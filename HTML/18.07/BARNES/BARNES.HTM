<HTML>   
     <HEAD>
<TITLE>July 2000/Implementation of Observer Pattern</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjul.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Implementation of Observer Pattern</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Paul Barnes</FONT></H3>

<BLOCKQUOTE>
<p>Many applications involve observers waiting for notification. Getting the logic right for both publishers and subscribers is something you don't want to have to do repeatedly.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p>The need to notify several objects of some event is a common theme in application development. So common, in fact, that it is discussed in <a href="#1">[1]</a> as the Observer Pattern, a.k.a. Publish-Subscribe. The basic problem is to provide a means for an object known as the Subject to notify other objects, known as Observers, when some event occurs so that they can take appropriate action.</p>
<p>Some schemes to implement this include having all observers register an event handler via a function pointer, or having observers poll or query the subject to determine if the event has taken place. These schemes have drawbacks, however. It is difficult to pass data from the subject to the observers without resorting to pointers to <B>void</B> or some similar mechanism. And the frequent polling by observers for some possibly infrequent event can incur significant overhead.</p>
<p>I present here a simple, object-oriented, Standard C++ implementation of the Observer Design Pattern. It allows the creation of any number of named publications that any number of Observers can subscribe to. It provides type safety (no void pointers) and has no polling. It also enforces other requirements, such as only a publication owner (creator) can publish that publication. This implementation can, and in fact has been, plugged into existing code relatively non-intrusively and with little effort.</p>
<p>The implementation consists of three classes, <B>Subject</B>, <B>Observer</B>, and <B>Publisher</B>. A <B>Subject</B> is an object that needs to notify observers when some event occurs. A <B>Subject</B> can create or discontinue a named publication and trigger a publication to be published to subscribers (<B>Observer</B>s.) An <B>Observer</B> is an object that needs to know when the event occurs and take some action. An <B>Observer</B> can subscribe and unsubscribe to a publication and receive updates when a subject triggers a publish event. The <B>Subject</B> and <B>Observer</B> must agree on the publication name in advance. The <B>Publisher</B> is a singleton object that manages all publications and acts as the intermediary between <B>Subject</B>s and <B>Observer</B>s. Client code need not, in fact should not, use or even know about the <B>Publisher</B>.</p>
<p>An extract of the <B>Subject</B> class is shown in <a href="fig1.htm">Figure 1</a>. A <B>Subject</B> can create, discontinue, or publish any number of named publications. Objects that need to provide notifications to observers should (preferably) inherit from <B>Subject</B>, but could just contain an instance of it. This <B>Subject</B> instance must remain in scope throughout the lifetime of the publication, because only the publication owner (creator) may publish a given publication. When a <B>Subject</B> is destroyed, all of his publications are discontinued.</p>
<p>An extract of the <B>Observer</B> class is shown in <a href="fig2.htm">Figure 2</a>. Client code that needs to receive updates should inherit from <B>Observer</B> and define the pure virtual <B>update</B> function. This function will be called by the <B>Publisher</B> object when a <B>Subject</B> triggers a publish operation. The <B>update</B> function takes the publication name as a parameter, which allows an <B>Observer</B> to subscribe to multiple publications and take different actions for each. It also takes a <B>Subject</B>* as an argument. This allows the <B>Observer</B> to obtain more information from the <B>Subject</B> in a type-safe manner. The concrete observer can safely cast (using <B>dynamic_cast</B>) the <B>Subject</B>* to its derived type and call any public functions of the derived <B>Subject</B>.</p>
<p>The <B>Observer</B> class remembers all publications it has subscribed to so that, if it is destroyed, it can unsubscribe from them in its destructor. This is necessary, of course, because the <B>Publisher</B> is maintaining a pointer to all subscribed <B>Observer</B>s, and this pointer will be invalidated when the <B>Observer</B> is destroyed. All this happens behind the scenes, with no intervention from the concrete observer.</p>
<p>The <B>Publisher</B> is the glue that ties it all together; it keeps track of all publications, their subscribers, and their owners. It will only allow the owner to publish any given publication. The <B>Publisher</B> is an instance of the Singleton design pattern <a href="#1">[1]</a> &#151; there is only one <B>Publisher</B> object. The <B>Publisher</B> class is illustrated in <a href="fig3.htm">Figure 3</a>.</p>
<p>The Publisher keeps a <B>std::map</B> of <B>std::string</B>'s to instances of struct <B>PubMapVal</B>. A <B>PubMapVal</B> object has a <B>Subject</B>* (the publication owner) and an <B>Observer</B>Set* (a <B>std::set</B> of <B>Observer</B>*'s.) This set contains a pointer to each subscribed observer.</p>
<p>In the intended use of these classes, client code would never interact directly with the <B>Publisher</B>. All publications are created, discontinued, and published via an instance of a <B>Subject</B>. All subscribes and unsubscribes are initiated with a concrete observer. This could be enforced more heavily by making all methods of <B>Publisher</B> private and declaring <B>Subject</B> and <B>Observer</B> friends of <B>Publisher</B>, but I did not like that approach.</p>

<H4><FONT COLOR="#000080">Tying It Together</FONT></H4>

<p>When a <B>Subject</B> calls <B>Subject::createPublication</B>, the call is forwarded to <B>Publisher::createPublication</B>. The <B>Subject</B> also passes its <B>this</B> pointer, which the <B>Publisher</B> records as the publication owner. When an <B>Observer</B> calls <B>Observer::subscribe</B>, the base <B>Observer</B> class forwards this call to the publisher along with its <B>this</B> pointer, which the <B>Publisher</B> adds to the set of all observers for that named publication. When a <B>Subject</B> calls <B>Subject::publish</B>, the call is forwarded to <B>Publisher::publish</B> along with the <B>Subject</B>'s <B>this</B> pointer. The <B>Publisher</B> ensures that the <B>Subject</B> owns the publication and then calls the <B>update</B> function of each subscriber, passing the <B>Observer</B>s the string publication name and a pointer to the subject who initiated the update.</p>
<p>Type safety and publication integrity are enforced in several ways. Only a <B>Subject</B> (or an object that creates a <B>Subject</B>) can create, discontinue, or publish a publication since a <B>Subject</B>* is a required parameter in <B>Subject</B>-related <B>Publisher</B> methods. Further, the <B>Publisher</B> will throw an exception if the <B>Subject</B> attempting to publish or discontinue a publication is not the publication owner. Similarly, only a concrete <B>Observer</B> can subscribe or unsubscribe to a publication since an <B>Observer</B>* must be passed to the corresponding <B>Publisher</B> methods. If a concrete observer needs more information from the <B>Subject</B> in its update method, it can safely cast the <B>Subject</B> to the appropriate derived type and call methods of the derived subject. If the observer subscribes to multiple publications, it can take different actions based on which publication is being published.</p>
<p>Note that a <B>Subject</B> could inherit from both class <B>Subject</B> and class <B>Observer</B> and then subscribe to its own publication.</p>
<p>Client code might look like the example in <a href="fig4.htm">Figure 4</a>.</p>

<H4><FONT COLOR="#000080">Data Structures and Time Complexity</FONT></H4>

<p>I chose a <B>std::set</B> for the <B>Publisher</B>'s <B>Observer</B> collection and the <B>Observer</B>'s collection of subscribed publications as a compromise in efficiency. The set allows logarithmic-time unsubscribes but makes subscribes also logarithmic, while a <B>std::list</B> would provide constant-time subscribes but linear-time unsubscribes. If, in your application, many <B>Observer</B>s subscribe to a publication but rarely unsubscribe (and are not destroyed), then a list might be more appropriate. Note that with a list, however, you must take care to avoid an <B>Observer</B> subscribing to a single list multiple times (and thus having its update method called more than once for a single publish operation). With the set implementation, a second attempt to subscribe to the same publication has no effect, since a set must have unique items.</p>

<H4><FONT COLOR="#000080">Conclusion</FONT></H4>

<p>In this article, I have presented an easy-to-use, type-safe, and object-oriented implementation of the <B>Observer</B> design pattern. It is very flexible, allowing any number of named publications, each with any number of subscribers. A subscriber can subscribe to multiple publications and take the appropriate action for each in its update function. A subject can even subscribe to its own publication if it inherits from both <B>Subject</B> and <B>Observer</B>.</p>
<p>Plugging this into an existing application is relatively simple. The class that needs to publish should inherit from <B>Subject</B> and have the appropriate calls to <B>createPublication</B> and <B>publish</B> inserted. The classes that need to receive these publications must inherit from <B>Observer</B>, define the <B>update</B> function, and call <B>subscribe</B> with the known publication name. Client code need not worry about unsubscribing or discontinuing publications when an observer or subject is destroyed &#151; this happens automatically. Nevertheless, subjects and observers can discontinue or unsubscribe from publications if need be.</p>

<H4><FONT COLOR="#000080">Reference</FONT></H4>
<p><a name="1"></a>[1]  Gamma, Helm, Johnson, and Vlissides. <I>Design Patterns</I> (Addison-Wesley, 1995). </p>

<p><i><B>Paul Barnes</B> has a B.S. and M.S. in Applied Mathematics from the University of Tulsa. He currently works as a developer with StatSoft in Tulsa. Paul can be reached at <B>pbarnes@statsoft.com</B>.</i></p>

<h4><a href="../../../source/2000/jul00/barnes.zip">Get Article Source Code</a></h4>

</blockquote></body></html>
