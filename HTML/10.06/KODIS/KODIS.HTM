


<HTML>
<HEAD>

<TITLE>June 1992/Using Variable-Length Argument Lists in C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Using Variable-Length Argument Lists in C<A name="0113_0086"><A name="0113_0086"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0113_0000"><A name="0113_0000">John Kodis</font></h3><hr><blockquote><P>
<P><i><A name="0113_0000"><A name="0113_0000">John Kodis has developed a wide variety of computer applications and has programmed in nearly all of the major languages which have come into fashion throughout the past decade. He is currently using C to develop supercomputer fileserver systems while</i></P><P>
C has always had the ability to operate on functions with a variable number of arguments, although this option hasn't been commonly used because the method for accessing the optional parameters wasn't documented until recently. For example, the first edition of Kernighan and Ritchie's <I>The C Programming Language</I>, one of the standard references on the language, makes no mention of the operation. The method to access the optional parameters used a certain amount of machine-dependent code. Such functions could not be written as portably as other C code. So, most programmers saw functions accepting a variable number of arguments only as part of the C runtime library in the <I>printf, scanf</I>, and related functions. But user-defined functions that accept variable arguments can benefit the programmer also.<P>
According to the ANSI C standard, the ellipsis (...) provides a controlled way to circumvent the type-checking of function calls against function prototypes. The compiler will not report a call to the same function with a different length argument list as an error. The <I>stdarg.h</I> header file supplied with ANSI-compliant C compilers includes macros that let you access the optional arguments in a variable-length parameter list in a portable manner. These macros are <I>va_start</I>, used to set up variable argument list processing, <I>va_arg</I>, which retrieves the next argument from the argument list, and <I>va_end</I>, which performs any cleanup necessary before leaving the function. <I>stdarg.h</I> also provides a type, <I>va_list</I>, with which the three argument-list macros keep track of the position of the next argument in the list.<P>
<h4><FONT COLOR="#000080"><A name="0113_0087">A Sample Implementation<A name="0113_0087"></FONT></h4></P>
To show how a simple routine would be written using the <I>stdarg.h</I> macros to access a variable number of parameters, the program in <A href="list1.htm">Listing 1</a>
implements a function called <I>maxn</I>. The <I>maxn</I> function takes one mandatory argument &#151; the count of optional arguments. The optional arguments follow. <I>maxn</I> searches through the number of optional arguments specified by the first integer argument, determines the largest, then returns this value to the calling function. <A href="list2.htm">Listing 2</a>
shows examples of valid calls. As shown in <A href="list1.htm">Listing 1</a>,
 the ellipsis after <I>n</I> tells the compiler that <I>n</I> may be followed by any number of unnamed arguments of any type.<P>
Unfortunately, in such a declaration the compiler has no way to check the types of the optional parameters. Even though the <I>maxn</I> function is clearly intended to handle only integer arguments, a compiler will readily process a statement such as<P>
<pre>/* an erroneous call */
maxn(2, 3.14159, acos(-1.0));</pre>
or even<P>
<pre>/* equally erroneous */
maxn(3, NULL, "This is a
string", '!');</pre>
since only the first parameter's type can be checked. The programmer must verify the validity of the other parameters. Even so, this declaration is an improvement over the obsolete form in the original K&amp;R parameter definition style<P>
<pre>int maxn (n)</pre>
which doesn't even allow type-checking the first parameter.<P>
The <I>maxn</I> function body declares a variable named <I>argp</I> (for argument pointer) with a type of <I>va_list</I>. <I>stdarg.h</I> defines <I>va_list</I> as a type for use with the other variable-length argument-list macros. A variable of this type must be declared and supplied as the first parameter to all of the argument-list access macros.<P>
The next line in <I>maxn</I> uses the <I>va_start</I> macro to initialize the argument pointer <I>argp</I>. <I>va_start</I> is called with two parameters: the name of the <I>va_list</I> variable (<I>argp</I>, in this example), and the name of the function's last named argument. One implication of this scheme is that a function that accepts a variable number of arguments must have at least one named parameter. The compiler will not accept attempts to write a function such as<P>
<pre>int func0(...) { ... }</pre>
which is just as well since there is no named argument to use with the <I>va_start</I> macro or to use in determining the number of parameters that follow.<P>
After initializing the <I>argp</I> variable, <I>maxn</I> fetches each of the <I>n</I> arguments, using the macro calls to <I>va_arg</I>. The <I>va_arg</I> macro accepts two parameters: the name of the argument list pointer (as always) and the type of the parameter to be retrieved from the argument list. <I>va_arg</I> returns the value of the next argument being passed to the function and updates the <I>va_list</I> variable so that the next <I>va_arg</I> macro call will retrieve the following argument. Supplying <I>va_arg</I> with the type of the argument to be retrieved serves two purposes. First, it allows casting the <I>va_arg</I> macro to the type of the argument being fetched. Second, it tells the <I>va_arg</I> macro by how much the <I>va_list</I> variable must be adjusted to point to the next argument. The <I>va_arg</I> macro can be a bit confusing since it can return a different type each time that it is called. However, as long as there is agreement between the type specified in the macro call, the type of the variable receiving the value, and the parameter passed in the argument list, no problems will result.<P>
Each call of the <I>va_arg</I> macro must update the value of the <I>va_list</I> variable so that this latter is set up to retrieve the next argument from the function's argument list. Occasionally, some unexpected results can occur. For example, some programmers define a <I>max</I> macro that looks something like<P>
<pre>#define max(a, b) ( (a)&gt;(b) ?
   (a) : (b) )</pre>
Now suppose the body of the <I>while </I>loop in the <I>maxn</I> function is changed from<P>
<pre>val = va_arg(argp, int);
if (val &gt; max_val)
   max_val = val;</pre>
to incorporate the <I>max</I> definition<P>
<pre>max_val = max( max_val, va_arg(argp, int) );</pre>
Depending on the compiler, the <I>va_arg</I> macro may be called twice whenever a new maximum value is encountered. Using the local variable <I>val</I> to receive the value of the current argument prevents this potential for excess calls to the <I>va_arg</I> macro.<P>
After the <I>while</I> loop terminates, a call to the <I>va_end</I> macro will perform whatever cleanup is required after argument processing is complete. This call can come anywhere between the end of argument processing and the return of the function. Finally, the <I>maxn</I> function returns the value of <I>max_val</I> as its result.<P>
<h4><FONT COLOR="#000080"><A name="0113_0088">Implementation Details<A name="0113_0088"></FONT></h4></P>
While the details of the argument-list access macros will vary somewhat from one CPU type to another and even from one compiler to another, some common threads run through all implementations. To make this particular discussion more concrete, I'll assume a CPU architecture in which parameters are passed by pushing them onto a stack in memory, and that the stack on this machine grows from high-memory addresses toward low-memory addresses. This description fits the CPUs on the Motorola 68000 series of microprocessors, the DEC VAX computers, the Intel 8088, 8086, through the Intel 80486 microprocessors, as well as most other CPUs. I'll assume further that all parameters on this machine are aligned on a four-byte boundary. While such an alignment narrows the field a bit, some type of alignment is a fairly common requirement.<P>
When a C compiler encounters a call to a function, it evalutes the expressions that make up the function's argument list. It writes the resulting values to the stack in such a way that when the called function is entered, the left-most argument in the caller's parameter list is located nearest the top of the stack. Since the C standard states that the order in which a function's parameters are evaluated is unspecified, programs that count on a compiler's behavior in this area are flawed. As a practical matter, however, most compilers for the type of machine under discussion here will generate code that evaluates arguments and pushes parameter values on the stack starting with the rightmost parameter and proceeding to the left. Just don't count on it. This set of operations generates the correct parameter list order while allowing values to be pushed on the stack immediately after being calculated.<P>
As an example, the statement<P>
<pre>printf("Five=%d. \n", 5)</pre>
will generate code to push the value 5 onto the stack, to push the address of the character string "<I>Five=%d. \n</I>" onto the stack, and to call the <I>printf</I> function. On entering <I>printf</I>, the stack will resemble the diagram in <A href="fig1.htm">Figure 1</a>.
<P>
Because the left-most parameters are pushed onto the stack last, they will always be located a fixed distance from the address that the stack pointer points to on entry to the function. You can therefore locate the left-most arguments in the same way as if the called function had a fixed number of parameters. In the case of <I>printf</I>, the left-most argument is a format string that is scanned to determine the number and type of arguments that follow. Furthermore, the address of the last required parameter can be used to set up the <I>va_list</I> variable so that the subsequent <I>va_arg</I> macro calls can step through the argument list starting with the first of the optional parameters.<P>
Typically, the <I>va_start</I> macro sets the <I>va_list</I> argument to the next location beyond the address of the last required argument by adding the argument's size to its own location and adjusting the sum to account for any alignment requirements. In the example above, the first parameter (<I>0x1234</I>) is located eight bytes above the location pointed to by the stack pointer on entering the called routine. Adding the size of this parameter to its address obtains the address of the next parameter (<I>5</I>) at <I>SP+12</I>.<P>
This pattern is continued within the called routine. Each call to the <I>va_arg</I> macro retrieves the argument pointed to by the <I>va_list</I> variable, casts it into proper form for assignment to a variable of the specified type, and adjusts the <I>va_list</I> variable to allow the next macro call to repeat this pattern. For successful repetitions, you must correctly specify the type of the variable to be retrieved in the <I>va_arg</I> macro call. The <I>va_arg</I> macro applies the <I>sizeof</I> operator to this type specification to determine the amount to increment the <I>va_list</I> variable. Responsibility for getting the type correct lies entirely with the programmer; the compiler cannot perform any kind of validation on the type of parameter being fetched.<P>
Finally, after all of the parameters in the argument list have been retrieved, the <I>va_end</I> macro is called to perform any cleanup that might be required. On most systems, no cleanup is required, so the macro does nothing but evaluate to <I>((void)0)</I>. However, the standard states that you must call <I>va_end</I> after all parameters have been retrieved but before the function returns. To be safe, always include the <I>va_end</I> macro as the standard requires, even if an application seems to run correctly without it. The code you write today may some day be ported to a machine that requires you to clean up the stack.<P>
<h4><FONT COLOR="#000080"><A name="0113_0089">The <B><I>printf</I></B> Functions<A name="0113_0089"></FONT></h4></P>
The C runtime library has always provided a variety of formatted input and output routines for variable-length argument lists, the most basic of which are the <I>scanf</I> and <I>printf</I> functions. These two functions access the <I>stdin</I> and <I>stdout</I> files, which are normally associated with the keyboard and terminal. The <I>fscanf</I> and <I>fprintf</I> functions provide formatted input and output from or to a file. These functions are the same as <I>scanf</I> and <I>printf</I>, except for a file pointer as an additional leading argument. For formatted data transfers from or to character strings in memory, the <I>sscanf</I> and <I>sprintf</I> functions are available. They are similar to the <I>fscanf</I> and <I>fprintf</I> functions, except that instead of accepting a file pointer, the <I>sscanf/sprintf</I> functions accept a pointer to a character string. This string plays the role of data source or sink that the file fulfills in the <I>fscanf/fprintf</I> routines.<P>
Recently, three more formatted I/O functions have been added to this lineup. These are <I>vprintf</I>, for output to the standard output file; <I>vfprintf</I>, for output to other files; and <I>vsprintf</I>, for output to character strings in memory. The only difference between this <I>v</I> series of <I>scanf</I> and <I>printf</I> functions and their earlier counterparts is that where the <I>printf</I> functions expect a variable-length list of parameters to be formatted, the <I>v</I> series of functions expects a <I>va_list</I> pointer. For example, the function prototype for the <I>sprintf</I> function looks something like<P>
<pre>int sprintf(char *str, const char *fmt, ...);</pre>
while the function prototype for the corresponding <I>v</I> function will be something like<P>
<pre>int vsprintf(char *str, const char *fmt, void *args);</pre>
Whereas the <I>sprintf</I> function is passed (in order) a pointer to the destination string, a pointer to the format-specification string, and a variable number of arguments, the <I>vsprintf</I> function takes a pointer to the destination string, a pointer to the format-specification string, and a pointer to an argument list. This last pointer is simply the <I>va_list</I> type variable that the <I>va_start</I> macro initialized.<P>
These functions are useful for developing other functions that provide customized versions of the services that the <I>printf</I> family of functions provides. One application of this type of routine is in graphics. The Turbo C graphics library provides a routine called <I>outtextxy</I> used to write a string of characters to the terminal when in graphics mode. While the function itself is sufficient to write a simple character constant, more frequently the string requires some formatting. This involves allocating buffer space, formatting the string, and finally calling <I>outtextxy</I> to write the formatted string to the display. It would be much easier if a function accepted the <I>x</I> and <I>y</I> coordinates for the output, a <I>printf</I>-style format specification string, and the corresponding argument list, and would output the string to the screen as desired. The <I>gprintf</I> (for "graphics <I>printf</I>") function in <A href="list3.htm">Listing 3</a>
does exactly that.<P>
The <I>va_start</I> macro sets the <I>va_list</I> variable <I>args</I> to point to the start of the variable portion of <I>gprintfs</I> argument list. <I>args</I> is then passed to the <I>vsprintf</I> function to perform the requested formatting, and the <I>outtextxy</I> routine is called to write the formatted string to the display. The <I>va_end</I> macro is called to tidy up, and the length of the formatted string is returned. The <I>main</I> routine initializes the graphics routines, calls the <I>gprintf</I> function to display the driver and mode numbers at coordinates (100, 200), and waits for a keystroke before shutting the graphics system down and exiting.<P>
You can use this same technique for many other purposes. For example, an application may need an emergency exit routine that generates a formatted explanation of what caused the emergency, and then shuts the application down in a controlled fashion.<P>
Another possibility is to augment the standard <I>printf</I> processing routines by scanning the format list and performing additional processing when a specific character pattern is recognized in the input. For example, programmers accustomed to FORTRAN bemoan the lack of a repetition specifier in format lists. They're used to being able to write something like<P>
<pre>write(*, '(3i)') i, j, k</pre>
to write three integers out, instead of the C equivalent<P>
<pre>printf("%i%i%i\n", i, j, k);</pre>
While repeating a format specifier three times is hardly a problem, it can become inconvenient when the number of variables grows. One way to alleviate this <I>printf</I> restriction is to write a <I>printf</I> preprocessor function that accepts repeat counts in format lists.<P>
The <I>rprintf</I> function in <A href="list4.htm">Listing 4</a>
does just that. Calling the <I>rprintf</I> function with a format list of <I>"%3r(%i )"</I> performs the same function as the two statements above. <I>rprintf</I> prints out three integers without requiring that the integer format specifier <I>%i</I> be repeated three times. <I>rprintf</I> scans the format string for occurrences of the <I>%r</I> format specification. On encountering a <I>%r</I> repeat specifier, the format specifier enclosed in parenthesis is expanded into repeated occurrences. Everything else in the string is passed through as is. The resulting format string is then passed to the <I>vprintf</I> function, along with a pointer to the original argument list. <I>vprintf</I> then performs its usual job of formatting and printing.<P>
Other, more application-specific enhancements can also be easily added to the <I>printf</I> family of functions using the approach used for repeat specifiers. For example, a financial application might need to display numbers in accounting style: prefaced by a dollar sign, with two digits after the decimal point, and the minus sign after the number rather than before it. In other application areas, it could prove helpful to be able to conveniently include time and date information in an easy-to-read format in a <I>printf</I> statement. The <I>vprintf</I> family of functions is just the ticket for any situation where formatted output must be processed in a slightly non-standard manner.<P>

<h4><a href="../../../source/1992/jun92/kodis.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
