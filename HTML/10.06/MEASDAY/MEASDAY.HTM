


<HTML>
<HEAD>

<TITLE>June 1992/C Packages</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">C Packages<A name="011B_008A"><A name="011B_008A"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="011B_0000"><A name="011B_0000">Charles Measday</font></h3><hr><blockquote><P>
<P><i><A name="011B_0000"><A name="011B_0000">Charles Measday is a programmer/analyst at Integral Systems,<I></I> <I></I>Inc. (Lanham, MD), which builds satellite ground systems for<I></I> <I></I>NASA, NOAA, and the Air Force. He has been a professional<I></I> <I></I>programmer for about 10 years, developing satellite image<I></I> <I></I>processing systems in VAX/VMS FORTRAN, automated test<I></I> <I></I>equipment for satellite components in PL/M-286, and, currently,<I></I> <I></I>satellite control center software in C under UNIX. He can be<I></I> <I></I>reached at 1100 West Street, Laurel MD 20707. (301) 497-2563.</i></P><P>
I recently was involved in a large software project where, as part of their quality assurance program, the main contractor established a set of standards for file and function names. The standards boiled down to two basic rules: (i) each function must have a three-character prefix that identifies the subsystem of which it is a part, and (ii) the name of a source file should match the name of the function within. The standards document, while acknowledging the common C practice of grouping related functions in a single file, encouraged programmers to store only one function per file. There are some very good reasons, however, for placing more than a single C function in one source file.<P>
<h4><FONT COLOR="#000080"><A name="011B_008B">Creating Packages<A name="011B_008B"></FONT></h4></P>
Encapsulation and data hiding are important techniques for decreasing the coupling between a program's modules. The weaker the coupling between two modules, the less changes to one will affect the other. These techniques are exemplified in Ada, which hides the implementation of a capability in a <I>package</I>, thus shielding its clients from changes made to the implementation. An Ada package consists of two parts: a <I>package specification</I>, whose declarations constitute the public interface to the package, and a <I>package body</I>, which hides the package's actual implementation.<P>
A C source file is analogous to an Ada package body. Static, non-local variables (i.e., those not declared in the scope of a function) in a C source file resemble variables declared in the body of an Ada package. Client modules have no knowledge of such variables and no access to them, except through declared procedures. Static functions in a C source file are like Ada procedures that are defined in the package body, but not in the package specification. Client modules cannot call these procedures.<P>
<A href="list1.htm">Listing 1</a>
shows an Ada package that manages a symbol table. The table is implemented as a simple list of name/value pairs. An internal variable, <I>SYMBOL_LIST</I>, points to the list. The representation of the list is not important. It could be a fixed-size array, a dynamically-allocated array, a linear linked list, a binary tree, a hash table, or even a skip list. <I>SYM_ADD</I> is a procedure that adds a symbol to the symbol table; <I>SYM_DELETE</I> deletes a symbol from the table. <I>SYM_LOOKUP</I> is a function that returns the value assigned to a symbol. All three functions call an internal function, <I>SYM_LOCATE</I>, which locates a symbol in the list and returns a pointer to the symbol's list node. <I>SYM_UTIL_DEBUG</I> is a global debug switch that a program can set so that the <I>SYM_UTIL</I> functions output debug information.<P>
<A href="list2.htm">Listing 2</a>
contains a comparable C "package," stored in a single source file. The <I>symbol_list</I> pointer and the <I>sym_locate</I> function are declared <I>static</I>, making them unknown outside the file. The remaining functions and the global <I>debug</I> flag are all accessible to the public.<P>
Clients (users) of the symbol table package (in either language) cannot reference the <I>symbol_list</I> variable, have no knowledge of the structure of list nodes, and cannot call the internal procedure, <I>sym_locate</I>. These restrictions are not just a matter of a design methodology &#151; they are enforced by the compiler. Breaking the C functions into separate files would force you to make the <I>static</I> variables global, the structure of list nodes visible throughout a program, and the <I>sym_locate</I> function callable from anywhere in the program. While you might trust people's good intentions and ignore the potential for malicious access to these hidden variables and functions, programs that access them out of necessity would be impacted by any change to the symbol table's implementation.<P>
The large software project mentioned earlier was a satellite control center. It included an event-logging system that illustrates a particularly effective use of the C package concept. An application program can access the event-logging facility only through two routines, <I>evt_init</I> and <I>evt_send</I>, found in the file <I>evt_util.c.</I><P>
<I>evt_init</I> initializes the interface to the event logger. The fact that <I>evt_init</I> loads event-message information from three database files and establishes a network connection to the event logger is immaterial to the application program. <I>evt_init</I> could just as well open a disk file for the event log, and the text of the event messages could be hard-coded in a string array.<P>
The details of how <I>evt_send</I> looks up the text of an event message, formats the message arguments, and writes the event packet out to the network are also of no consequence to the application program. You could completely revamp the internal implementation of the event-logging utilities without affecting any of the applications software. Though the applications would have to be relinked with the updated library, recompilation would be unnecessary.<P>
Our data-services library took the opposite approach. This library, which manages network connections to multiple data servers, stores each of its functions in a different source file. Although the functions' calling sequences shield client applications from implementation details to a certain extent, the internal data structures are global. The lack of a function that built an I/O selection mask for the managed connections forced application programs themselves to scan the library's list of connected servers. This kludge forced the application to depend heavily on the internals of the data services library. In this case, a new function, <I>ds_mask</I>, was added to eliminate the need for the kludge. However, tracking down and eliminating such kludges can be a major maintenance headache.<P>
<h4><FONT COLOR="#000080"><A name="011B_008C">Some Caveats<A name="011B_008C"></FONT></h4></P>
It is possible to close a package up too tightly. For example, as the project progressed, we found that certain applications needed to switch to a different event logger (on another computer) in mid-stream. Doing so required the application program to close the network connection to the current event logger and to open a connection to the new event logger. Hidden inside the events package, the file descriptor for the event logger connection is inaccessible to application programs. Adding a new function, <I>evt_reconnect</I>, easily solved the problem. Software changes may not, for organizational or configuration reasons, always be an available option.<P>
Another word to the wise: don't hide what shouldn't be hidden. The <B>UNIX</B> hashing functions, <I>hsearch(3)</I>, for example, manage a single hash table. While the details of the hash table are commendably hidden from the calling program, the calling program cannot use multiple tables simultaneously. The program must destroy one table before creating another. Rather than storing the hash table within the package, <I>hcreate</I> would be better off returning an opaque, <I>void</I> * pointer to each hash table it creates. This handle could then be passed to <I>hsearch</I> for adding and recalling entries from that particular table. Different hash tables would have different handles and could coexist peacefully.<P>
<h4><FONT COLOR="#000080"><A name="011B_008D">Packages As OOP?<A name="011B_008D"></FONT></h4></P>
C packages can be viewed as a primitive form of object-oriented programming. (Ken Pugh alluded to this in his "Questions &amp; Answers" column, <I>CUJ</I>, February 1991.) In the object-oriented approach, a program is composed of <I>objects</I>. An object consists of <I>instance variables</I>, which represent the state of the object, and <I>methods</I>, which are functions that modify or query the object's state. Objects communicate via <I>messages</I>. A message specifies a method that the receiving object is to execute, and arguments, if any, for the method.<P>
In C, the static, non-local variables are instance variables and the functions are the methods. Calling a function is logically equivalent to sending a message to a method. <A href="fig1.htm">Figure 1</a>
illustrates this object-oriented view of the symbol-table package. You could consider the global <I>debug</I> switch, not shown in the figure, as a class variable (i.e., a variable common to all instances of a particular object type, or class).<P>
<h4><FONT COLOR="#000080"><A name="011B_008E">Conclusion<A name="011B_008E"></FONT></h4></P>
C itself supports good software design principles. Rather than being encouraged to put separate functions in separate files, the C programmer should be encouraged to encapsulate functionality and data in C function packages.<P>

<h4><a href="../../../source/1992/jun92/measday.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
