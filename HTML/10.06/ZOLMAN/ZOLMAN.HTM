


<HTML>
<HEAD>

<TITLE>June 1992/Illustrated C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Illustrated C<A name="012D_0096"><A name="012D_0096"></font></h2><P>
<h3 align="center"><A name="012D_0000"><A name="012D_0000">A Portable Menu Compiler, Part 4</h3><P>
<h3 align="center"><font color="#800000">Leor Zolman</font></h3><hr><blockquote><P>
<P><i><A name="012D_0000"><A name="012D_0000">Leor Zolman has been involved with microcomputer programming for 15 years. He is the author of BDS C, the first C compiler<I></I> <I></I>targeted exclusively for personal computers. Leor's first book, Illustrated Co, is now available from R&amp;D Publications, Inc. Leor and his<I></I> <I></I>family live in Lawrence, KS.</i></P><P>
This month we continue to dissect <I>rmenu</I>, the runtime interpreter for the CMENU system. We'll be looking primarily at the code that handles the full-screen user interface.<P>
<h4><FONT COLOR="#000080"><A name="012D_0097">Command Processing<A name="012D_0097"></FONT></h4></P>
Most of <I>rmenu's</I> user interface code appears in <I>rmenu2.c</I> (<A href="list1.htm">Listing 1</a>)
, divided between the <I>sub_menu</I> and <I>get_cmd</I> functions. The <I>get_cmd</I> function accepts keystroke commands and maps them onto a standard <I>K_</I> code (as defined in the <I>rcmenu.h</I> header file, May 1992, <A href="list1.htm">Listing 1</a>)
. <I>sub_menu</I> acts upon those command codes. Some additional user interface code appears in the <I>do_cmnd</I> function (next installment) when a prompt is required after an item's execution, but before control is returned to the menu navigation functions.<P>
<h4><FONT COLOR="#000080"><A name="012D_0098">Loading a Menu File<A name="012D_0098"></FONT></h4></P>
The <I>ld_menu</I> function (<A href="list2.htm">Listing 2</a>,
 line 98) reads an <I>.mnc</I> file in from disk, allocating memory as necessary to hold the menu data and determines the precise way each menu item shall be positioned on the screen. All this is performed during one pass through the disk file.<P>
The first thing <I>ld_menu</I> does is initialize a convenience pointer named <I>Levp</I> (line 111) to simplify access to the <I>LMenus</I> structure representing the current nesting level. All operations performed by this instance of <I>ld_menu</I> will be confined to the current nesting level. There is no reason to require the repetitive evaluation of a base expression such as<P>
<pre>LMenus[nestlev]</pre>
when it can be evaluated once and assigned to a pointer. All the other pointers defined at the top of <I>ld_menu</I> serve a similar purpose later in the function.<P>
After the input file has been opened successfully, <I>ld_menu</I> is ready to read in the data. First, the integer value telling the number of menus present in the file is read from the beginning of the file (lines 123-124). For portability reasons, the <I>sizeof</I> operator is used to determine the size of an integer variable.<P>
The main loop (lines 127-209) executes once for each menu in the file. If the memory for each new menu's index position in the <I>LMenus</I> array has already been allocated, then the <I>M2p</I> pointer is simply assigned to point to that memory. If not, lines 132-138 perform the necessary memory allocation, and initialize the memory tracking variables <I>max_menus</I> (in the <I>LMenus</I> structure) and <I>most_items</I> (in the <I>Menus</I> structure for the new menu). These two variables track, respectively, the maximum number of menus loaded into a nesting level and the maximum number of items loaded into a particular menu. They retain their values as menus and items come and go dynamically.<P>
When menu memory allocation issues have been settled, the <I>MENU</I> header structure for the current menu is loaded in lines 142-143. The menu item placement strategy is then computed.<P>
<h4><FONT COLOR="#000080"><A name="012D_0099">Laying It All Out<A name="012D_0099"></FONT></h4></P>
The algorithm to calculate item positioning is complex, because of the number of variables involved. These variables include:<P>
1) screen dimensions currently specified by symbolic constants, (but could as easily be specified by a set of variables &#151; see the exercises for some ideas along this line);<P>
2) explicit <I>columns</I> and <I>spacing</I> instructions appearing in the menu specification file;<P>
3) the number of items in the menu;<P>
4) an arbitrary default heuristic for arranging the items in the absence of explicit <I>columns</I> or <I>spacing</I> specifications.<P>
The <I>placement</I> function starts the process by examining the general characteristics of the entire menu and adjusting the values of the <I>columns</I> and <I>spacing</I> variables accordingly. Because <I>cmenu</I> provides the length of the menu's widest line of item text (in the <I>MENU</I> element named, appropriately, <I>widest</I>), <I>placement</I> has all the information it needs in the <I>MENU</I> header and does not need to examine the individual items to establish the overall placement strategy.<P>
The <I>MENU</I> elements <I>placement</I> examines are: <I>spacing, columns, nitems</I>, and <I>widest</I>. Because the first three of these elements are examined repeatedly in <I>placement</I>, I've assigned their values to namesake local variables (lines 224-226) to make the code easier to follow.<P>
The first step of the placement algorithm is to fill in any missing values for <I>spacing</I> and <I>columns</I>. There is one case when neither are specified, one case when only <I>spacing</I> is specified, and one case when only <I>columns</I> is specified. Each of the three cases is handled individually.<P>
When neither value is specified, the placement is based on the relationship between the number of items in the menu and the number of lines available on the screen for menu items. If the number of items is less than half the number of lines, we are free to use double spacing to fill up the screen, putting a blank line between each item line for enhanced readability.<P>
If the number of items is greater than half, but less than or equal to the number of rows available, then we examine the length of the longest item to see if it would fit in half a screen width. If so, then we go to a two column format to allow double spacing. If the longest item is too long for a two column format, we stick with one column and go to single spacing.<P>
If the number of items is greater than the number of rows, then single spacing is forced and the number of columns is set to whatever it takes to make room for all the items. If that means some of the item text might be truncated, well, too bad. You can always put additional information for any item into its <I>help</I> clause, which is guaranteed never to be truncated (since there is always a full line available for each item's <I>help</I> text).<P>
If only an explicit <I>columns</I> value is given, then lines 250-251 calculate the spacing appropriate for that number of columns (either single or double).<P>
If only an explicit <I>spacing</I> value is given, then lines 253-256 figure the best number of columns for that spacing value. No adjustment is made for items that might be truncated when double spacing is specified and more items exist than would fit in a single column. If the menu designer really wants double spacing, why should <I>rmenu</I> second-guess?<P>
After the <I>spacing</I> and <I>columns</I> values are filled in, one more step is needed to guard against the case where an impossible configuration was specified (such as a <I>column</I> value of one, with a hundred items following). If necessary, the code in lines 260-264 reduces the spacing and increases the number of columns (in that order) until a proper fit is achieved. Control then returns to <I>ld_menu</I>.<P>
Back in <I>ld_menu</I>, it is now time to read in the individual <I>ITEM</I> structures from the disk file. Armed with reasonable values for <I>spacing</I> and <I>columns</I>, the length of the uniform item fields is calculated and stored in the variable named <I>field_len</I> (line 149). This helps optimize screen refreshing speed. If the longest actual item text is shorter than the available space for each item, there is never any need to write into the region between the end of the item and the start of the next item to the right of it (or the end of the screen, if we're dealing with only one column).<P>
Each pass through the loop in lines 155-208 reads in one menu item. Again, an incremental memory allocation strategy is employed. The code to perform the memory allocation is similar to that used to obtain memory for the <I>MENU</I> structures (lines 133-137), except for the names involved (and one less initialization).<P>
The <I>ITEM</I> structure itself is loaded in line 167. Then, the item text is truncated to fit the available display field length.<P>
The next section of code is a bit tricky. I thought it would be useful if menu items that select other menus were clearly marked as such. The description text for those items wouldn't need to state that the selection is a menu. The way I chose to implement this feature was to have <I>rmenu</I> insert the text "<I>(MENU)</I>" at the end of each line of item text that identifies a submenu (local or external). Additionally, all such identifiers are inserted at the same column position relative to the start of the item text. Thus, screen items keep an orderly appearance.<P>
Where there isn't enough room left in an item's text description buffer for the six characters of additional text, no action is taken. Nothing inherent to the display algorithm will distinguish that particular item as a submenu selection (although the menu designer is certainly free to place such descriptive text in a help line for the item.)<P>
The bulky <I>if</I> expression in lines 172-174 checks if the current item specifies a submenu, and if there is enough room for the additional text. If so, lines 175-184 insert the appropriate number of spaces after the end of the item text, then append the "(<I>MENU</I>)" text after the spaces. Note the assignment of the horizontal position to the variable <I>limit</I> in lines 178-179. The expression<P>
<pre>M2p -&gt; field_len - 7</pre>
represents the furthest to the right that the menu identifier could go to keep the combined text length within the established field width. It may not look good all the way to the right, however, if all the description texts are short. The <I>limit</I> value, therefore, is calculated as the minimum of the expression above and the length of the widest item plus two (to leave some breathing room). Care also must be taken not to write past the end of the <I>char</I> array that holds the description text; a condition to test for such an overflow is part of the loop that inserts the space characters into the text (line 181). I warned you this would be tricky.<P>
The final calculation required for each item is to establish:<P>
1) its text description's screen coordinates, and<P>
2) the number of spaces needed to pad its text out to the uniform field length.<P>
All these values are then stored in the <I>coords</I> array position for the item. The screen coordinates are calculated in lines 186-202 based on the spacing (single or double), the number of physical screen rows devoted to item descriptions (<I>MAX_IROWS</I>), the physical number of columns on the screen (<I>SCREEN_COLS</I>), and the coordinates of the top-left corner of the item description block (<I>HOME_Y, HOME_X</I>).<P>
The calculation of the item text's horizontal position <I>xpos</I> (lines 191-202) merits some clarification. This value is computed differently depending on whether the items are being displayed in a single column or in multiple columns. For a single column, the horizontal position is centered on the screen (lines 196-197); otherwise, the text is left-justified within each column (lines 200-201). The "magic numbers" in line 197 result in a fairly consistent, attractive centered layout on an 80-column screen.<P>
The number of spaces needed to pad out the text is calculated by the expression in lines 206-207. The set of above calculations is complex, but it is only performed once. After that, the resulting values are all stored directly in the <I>coords</I> data structure for rapid access during the screen refresh process.<P>
<h4><FONT COLOR="#000080"><A name="012D_009A">Real-Time Menu Processing<A name="012D_009A"></FONT></h4></P>
After all the preliminary steps have been completed, the <I>sub_menu</I> function (this month's <A href="list1.htm">Listing 1</a>)
 is finally given the chance to run a menu for the user.<P>
There are some state variables that <I>sub_menu</I> maintains:<P>
<I>cur_item</I> holds the index value of the currently highlighted menu item. It is initialized to zero for the first item in the menu. The index value of an item is always one less than the reference number displayed on the screen for that item. C programs like to count from zero, but most people prefer enumeration to begin with one.<P>
<I>sel_val</I> represents the latest direct numeric item selection value entered by the user via the digit keys. It is directly set by the <I>get_cmd</I> function whenever the user enters a numeric selection value, indicated by a return value of <I>K_DIRECT</I> from <I>get_cmd</I> calls.<P>
To display the menu on the user's screen, <I>sub_menu</I> calls the <I>draw_menu</I> function in <I>rmenu2.c</I> (<A href="list1.htm">Listing 1</a>,
 line 173).<P>
<I>draw_menu</I> begins by centering the menu title text on screen line <I>TITLE_ROW</I> (lines 190-191). This represents our first glimpse of a Curses display sequence. The <I>move</I> function positions the logical cursor to the specified row and column, and <I>addstr</I> inserts a given text string at the current cursor position. The text does not immediately appear on the screen, however, because the program has not yet called the <I>refresh</I> function.<P>
The Curses library supports multiple windows. When the library is first initialized via a call to the <I>init_win</I> function, one default window corresponding to the regular terminal screen is automatically opened. Most of the more common functions in the Curses library have two variations: one always acts upon the "default window," and one takes an additional parameter specifying a particular window on which to operate. Because we will always be dealing with the default window for this application, the shorter forms are used whenever available. (Actually, the shorter forms are implemented as macro definitions that expand to call the long form functions. They are not separate functions themselves. For the purpose of writing programs, however, they may be treated as shorter function calls.)<P>
<h4><FONT COLOR="#000080"><A name="012D_009B">Drawing the Menu and Its Items<A name="012D_009B"></FONT></h4></P>
The loop in lines 193-195 calls the <I>draw_item</I> function (lines 212-276) to write each individual item to the default window. The currently selected item is written with instructions to use reverse video and display any optional associated help text in the help line area of the screen. All other items are written in normal video mode with help text suppressed.<P>
After all items have been written, the prompt line is constructed on row <I>PROMPT_ROW</I>. It is constructed because it takes on one of two different appearances, depending upon the current value of the <I>escape</I> flag in the current menu's header. This flag tells whether the user is permitted to use the <I>!</I> command to invoke a command processor (shell) directly from within the current menu. If shell escapes are allowed, then the fragment of text that documents the option is included in the prompt string; if not, that text is not included.<P>
The last thing <I>draw_menu</I> does is call <I>refresh</I> to cause Curses to update the screen with all the changes.<P>
The <I>draw_item</I> function begins by moving the logical cursor to the location stored in the <I>coords</I> structure for the current item (line 229) and writing the item number there using the Curses function <I>printw</I> (the item number is always written in normal video mode). If the <I>vid_mode</I> parameter specifies to use reverse video, then the Curses function <I>standout</I> is called to switch screen writes into the standout video mode. The precise effect of calling <I>standout</I> may vary from system to system and terminal to terminal (at least in the UNIX versions), because the sequences used are terminal dependent. On most terminals, however, you can expect <I>standout</I> to enter reverse video mode.<P>
The item text is then written to the logical screen (line 235), along with the appropriate number of spaces needed to fill out the total length of the item field. If standout mode was requested, then the <I>standend</I> function is called to return to normal video mode.<P>
If the <I>dohelp</I> parameter was specified (i.e., has a nonzero value), and the current item has help text associated with it, then that help text is displayed in standout mode (lines 247-268). If the help text is not too long, then some extra blank padding is added at both ends of the line to improve readability in standout mode. If there is no help text, then the help area is cleared (lines 271-272).<P>
<h4><FONT COLOR="#000080"><A name="012D_009C">Back to <B><I>sub_menu</I><A name="012D_009C"></B></FONT></h4></P>
Upon return from the <I>draw_menu</I> call, <I>sub_menu</I> constructs the new default incremental path via a call to the <I>make_path</I> function and stores the returned result in the <I>newpath</I> string. (I'll describe <I>make_path</I> more fully in a later section.)<P>
The main user interface loop (lines 40-169) takes up the rest of the <I>sub_menu</I> function. <I>get_cmd</I> is called at the top of the loop to read a keyboard command from the user. The return value from <I>get_cmd</I> indicates the nature of that command. All commands except direct item selection (by number) are entirely defined by the value of the command code returned. For direct item selections, the return value of <I>K_DIRECT</I> indicates that such a selection has been made. The number of the selected item is stored in the <I>sel_val</I> variable.<P>
All the simple highlight bar movement commands are processed in lines 44-86. The up-arrow and down-arrow commands (and the space bar command, which is equivalent to down-arrow) are the easiest to process. The currently highlighted item is redrawn in normal video, the new item is selected by either incrementing or decrementing the <I>cur_item</I> variable (with wrap-around), and the new current item is redrawn in standout mode. Processing the direct item addressing command is just as easy (lines 121-128), except a test is thrown in that skips the redraw operations if the item selected is already the current item.<P>
The left-arrow and right-arrow keys are trickier, because the index number of the new item must be calculated based on the physical arrangement of items on the screen. For example, when the right-arrow key is pressed, there may or may not be an item in the column to the right (in fact, there may not even be a column to the right).<P>
Lines 64-68 and 78-83 compute the next item index in response to a right-arrow and left-arrow command, respectively. To achieve this feat, the algorithm considers the total number rows in the item display area <I>(MAX_IROWS)</I>, the current spacing value, the total number of items in the menu, and the index value of the current item. In trying to get these few lines of code to work correctly, I experienced almost as much frustration as I did with all the rest of the CMENU-related design problems combined. I finally solved this by calculating the maximum number of items that can fit into a single column (a value I called the "factor"), and testing for overflow by adding or subtracting that factor from the current item's index value.<P>
When moving to the right, the new index is computed by adding the factor to the current item index. Either the resulting index is within the range of menu items (the case when an item to the right exists) or it is out of range (then the index corresponding to the item on the same row in the first column is calculated by computing the modulus of the original index and the factor).<P>
When moving to the left, starting anywhere other than in the first column, the new item is simply in the column to the left. When starting in the first column, however, a loop is executed to find the index of the item in the right most column of the same row.<P>
When <I>get_cmd</I> returns <I>KEY_RUN</I>, then the action associated with the current item is executed. If the action code value is <I>ACT_EXIT</I>, <I>sub_menu</I> is finished and returns with a value of <I>OK</I> to indicate no problem.<P>
Any other type of action is passed to <I>do_item</I> for processing. <I>do_item</I> is discussed in a later section. For the time being, note that a fatal error might be encountered during the <I>do_item</I> call. <I>do_item</I> indicates a fatal error condition by returning a value of <I>EXITALL</I>, causing <I>sub_menu</I> to immediately return to its caller with <I>EXITALL</I> as its return value.<P>
If the <I>do_item</I> call went smoothly, lines 98-116 determine the next menu item to be highlighted, according to the options specified in the menu source. The menu is then rewritten and control returns to the top of the main command loop.<P>
Lines 130-152 process the shell escape command. If shell escapes are currently disabled, the <I>put_msg</I> function is called to display an error message and wait for the user to press a key to return to normal menu processing.<P>
If shell escapes are enabled, then there are two possible methods of dealing with the request, controlled by the symbolic constant <I>SHELL_PROMPT</I>.<P>
If <I>SHELL_PROMPT</I> is true, then a special prompt string (<I>SH_PROMPT_STR</I>) is displayed, again employing the <I>put_msg</I> function to show the message and wait for a keystroke. If the user presses the <B>ESC</B> key in response to this prompt, then the shell escape request is aborted. If any other key is pressed, the shell escape is performed. If <I>SHELL_PROMPT</I> is false, no prompt string is displayed, and the shell escape is performed immediately. This may be thought of as expert mode, when there is no danger of confusing the user if the shell escape command key is pressed accidentally.<P>
Lines 144-146 manage the invocation of a subordinate shell. A pair of functions, <I>pre_shell</I> and <I>post_shell</I>, together handle certain housekeeping tasks attendant to launching a subordinate command interpreter from within the Curses environment. The <I>system</I> call that actually launches the shell is sandwiched in between these two functions.<P>
The last four cases in <I>sub_menu</I> (lines 154-166) handle various forms of the exit command, display the program version number, or make a rude noise when an unrecognized key is pressed.<P>
<h4><FONT COLOR="#000080"><A name="012D_009D">Keystroke Processing<A name="012D_009D"></FONT></h4></P>
At the lowest level of the user command processing loop, <I>get_cmd</I> reads user keystrokes (lines 279-386). <I>get_cmd</I> translates raw keystrokes into a set of standard command symbols and returns those command symbols. For most commands this involves a simple one-to-one mapping of keys to symbols.<P>
<I>get_cmd</I> also performs another somewhat trickier task. It processes any direct menu item numbers entered by the user, and manages the contents of the item number echo area at the far right portion of the prompt line where digits are echoed during direct item number entry.<P>
Two parameters are passed to <I>get_cmd: nitems</I> tells how many items there are in the current menu, and <I>curr</I> is the index of the currently highlighted item.<P>
<I>get_cmd</I> maintains a static Boolean variable named <I>digits</I> that tells if a string of digits (presumably representing a direct item number) are currently being entered. Since each keystroke is an individual command, the entry of a multiple digit item number must necessarily span several calls to <I>get_cmd</I>.<P>
The first thing <I>get_cmd</I> does is display the item number of the currently highlighted item in the echo area (lines 301-302). The item number is one greater than the item's index value, because item numbering begins with 1 from the user's point of view. Any characters left on the echo area from a previous call are cleared away (lines 303-305). The cursor remains at the character position immediately to the right of the item number just displayed, to give the user a sense of continuity when entering a multiple digit item number.<P>
The loop in lines 308-385 processes a keystroke. It runs only once, except in the special case when either the ESC key or an illegal digit is pressed (see below).<P>
A keystroke is fetched via the <I>getch</I> function in line 310, and the <I>digits</I> flag is cleared if the key is not a decimal digit. Lines 315-354 then handle all the direct command mappings.<P>
Lines 356-383 process the digit keys. Once a digit key is recognized, does the decimal value formed by the concatenation of this new key onto the decimal total of previous contiguous keystrokes yield a new item number within legal range for the current menu? The conditional test in lines 361-362 asks this question. If the answer is yes, then the integer pointed to by <I>sel_val</I> is set to the value of the new item number and <I>get_cmd</I> returns <I>K_DIRECT</I> to indicate a new item has been directly selected. If the answer to the above question is no, then the digit is still construed as legal if it alone represents a legal item number. Line 369 checks for that possibility. If true, then the echo area is cleared and the new item number is displayed there; again the selection value is assigned through the <I>sel_val</I> pointer and <I>get_cmd</I> returns the value <I>K_DIRECT</I>.<P>
Any digit that fails both of the above criteria for legality generates a warning bell (line 382) and is otherwise ignored.<P>
<I>get_cmd</I> interprets the ESC key as a special command meaning "clear the digit echo area." If this command were not available, aborting a direct item number entry sequence could get confusing because of the cumulative handling of digit strings. For example, consider a menu containing thirty items, and a user mistakenly presses the digit 1 when meaning to select item 2. If the next keystroke is the digit 2, item twelve would be selected. If 2 is pressed again, item 2 would be selected (because there is no item 122). The ESC key could have cleared the numeric selection after the initial digit 1 keystroke, and let the user press 2 to select item 2.<P>
In my next installment of this series, we'll see how <I>rmenu</I> executes actions and how the machine-dependent portions of the program are encapsulated (might as well throw in an object-oriented buzzword; everybody else does!)<P>

<h4><a href="../../../source/1992/jun92/zolman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
