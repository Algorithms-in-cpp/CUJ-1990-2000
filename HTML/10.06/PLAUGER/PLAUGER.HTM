


<HTML>
<HEAD>

<TITLE>June 1992/Standard C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Standard C<A name="0125_008E"><A name="0125_008E"></font></h2><P>
<h3 align="center"><A name="0125_0000"><A name="0125_0000">Storage Allocation Functions</h3><P>
<h3 align="center"><font color="#800000">P.J. Plauger</font></h3><hr><blockquote><P>
<P><i><A name="0125_0000"><A name="0125_0000">P.J. Plauger is senior editor of The C Users Journal. He is secretary of the ANSI C standards committee, X3J11, and convenor of the ISO C standards committee, WG14. His latest book is The Standard C Library, published by Prentice-Hall. You can reach him care of The C Users Journal or via Internet at pjp@plauger.uunet.uu. net.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0125_008F">Introduction<A name="0125_008F"></FONT></h4></P>
Few functions are as much fun to tinker with as the storage allocation functions that come with the Standard C library. I can't begin to count all the variations of <I>malloc</I> and friends that have crossed my desk as editor. I see several reasons for this phenomenon:<P>
<UL><li>They form a compact subset that can be replaced as a unit.</li>
<li>They can almost always profit from the addition of debugging hooks.</li>
<li>They can often be made more efficient for any given pattern of usage.</li></UL>
Unfortunately, these functions are also easy to get wrong:<P>
<UL><li>They involve several tricky algorithms that are notoriously error prone.</li>
<li>They interact with computer architectures in various nonobvious ways.</li>
<li>They need to be as efficient as possible.</li></UL>
If you're ever tempted to tinker in this arena, you may as well start from a firm foundation. This column describes the storage management functions in detail. It also presents an implementation that works on a broad class of architectures. The code also seems to be fairly free of bugs.<P>
<h4><FONT COLOR="#000080"><A name="0125_0090">Kinds of Storage<A name="0125_0090"></FONT></h4></P>
The data objects in a Standard C program occupy three kinds of storage:<P>
<UL><li>The program allocates <I>static storage </I>and stores initial values in it prior to program startup. If you specify no initial value for (part or all of) a data object, the program initializes each of its scalar components to zero. Such a data object continues in existence until program termination.</li>
<li>The program allocates <I>dynamic storage</I> upon each entry to a block. If you specify no initial value for a data object, its initial content is indeterminate. Such a data object continues in existence until execution of the block terminates.</li>
<li>The program allocates <I>allocated storage</I> only when you call one of the functions <I>calloc, malloc, or realloc.</I> It initializes such a data object to an array of zero characters only if you call <I>calloc</I>. Otherwise, its initial content is indeterminate. Such a data object continues in existence until you call <I>free</I> with its address as the argument or else until program termination.</li></UL>
The functions that manipulate allocated storage are the storage allocation functions declared in <I>&lt;stdlib.h&gt;</I>.<P>
Static storage remains stable during program execution. Dynamic storage follows a last-in/first-out discipline. It can be implemented on a stack. Often, dynamic storage shares the call stack with function-call and return information. Allocated storage follows no such tidy discipline. The program can intermix the allocation and freeing of such data objects in arbitrary order. Hence, the Standard C library must maintain a separate pool of storage called a <I>heap</I> to satisfy requests for controlled storage.<P>
In some implementations, the call stack and the heap contend for a limited amount of storage. Allocate enough storage with <I>malloc</I> and you may limit the depth to which you can call functions later in the program. Or you may simply run out of space on the heap. In any event, it is simply good hygiene to allocate only what storage you need and to free it as soon as you're done with it.<P>
Be aware that allocated storage involves certain overheads. Accompanying each allocated data object is enough information for <I>free</I> to determine the size of the region being freed. Allocate 1,000 one-character data objects and you can easily consume four to eight times as much storage on the heap. The heap is also subject to fragmentation. Allocating and freeing data objects on the heap in arbitrary order inevitably leaves unusable holes between some of the allocated data objects. That too lowers the usable size of the heap.<P>
Don't overreact to this knowledge. Gather related data into a structure and allocate it all at once. That minimizes heap overhead, to be sure, but it is also good programming style. Do <I>not</I> gather unrelated data just to save heap overhead. Similarly, allocate data objects with similar lifetimes all at once, then free them at about the same time. That minimizes heap fragmentation, but it too is good style. Do <I>not</I> advance or defer unrelated heap operations just to minimize fragmentation. The storage-allocation functions are an important aid to programming flexibility. Use them as they are intended to be used.<P>
<h4><FONT COLOR="#000080"><A name="0125_0091">What the C Standard Says<A name="0125_0091"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="0125_0092">7.10.3 Memory management functions<A name="0125_0092"></FONT></h4></P>
The order and contiguity of storage allocated by successive calls to the <I>calloc, molloc,</I> and <I>realloc</I> functions is unspecified. The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly freed or reallocated). Each such allocation shall yield a pointer to an object disjoint from any other object. The pointer returned points to the start (lowest byte address) of the allocated space. If the space cannot be allocated, a null pointer is returned. If the size of the space requested is zero, the behavior is implementation-defined; the value returned shall be either a null pointer or a unique pointer. The value of a pointer that refers to freed space is indeterminate.<P>
<h4><FONT COLOR="#000080"><A name="0125_0093">7.10.3.1 The <B><I>calloc </I></B>function<A name="0125_0093"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="0125_0094">Synopsis<A name="0125_0094"></FONT></h4></P>
<pre>#include &lt;stdlib.h&gt;
void *calloc(size_t nmemb, size_t size);</pre>
<h4><FONT COLOR="#000080"><A name="0125_0095">Description<A name="0125_0095"></FONT></h4></P>
The <I>calloc</I> function allocates space for an array of <I>nmemb</I> objects, each of whose size is <I>size</I>. The space is initialized to all bits zero.127<P>
<h4><FONT COLOR="#000080"><A name="0125_0096">Returns<A name="0125_0096"></FONT></h4></P>
The <I>calloc</I> function returns either a null pointer or a pointer to the allocated space.<P>
<h4><FONT COLOR="#000080"><A name="0125_0097">7.10.3.2 The <B><I>free</I></B> function<A name="0125_0097"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="0125_0098">Synopsis<A name="0125_0098"></FONT></h4></P>
<pre>#include &lt;stdlib.h&gt;
void free(void *ptr);</pre>
<h4><FONT COLOR="#000080"><A name="0125_0099">Description<A name="0125_0099"></FONT></h4></P>
The <I>free</I> function causes the space pointed to by <I>ptr</I> to be deallocated, that is, made available for further allocation. If <I>ptr</I> is a null pointer, no action occurs. Otherwise, if the argument does not match a pointer earlier returned by the <I>calloc, malloc, </I>or <I>realloc</I> function, or if the space has been deallocated by a call to <I>free</I> or <I>realloc</I>, the behavior is undefined.<P>
<h4><FONT COLOR="#000080"><A name="0125_009A">Returns<A name="0125_009A"></FONT></h4></P>
The <I>free</I> function returns no value.<P>
<h4><FONT COLOR="#000080"><A name="0125_009B">7.10.3.3 The <B><I>malloc</I></B> function<A name="0125_009B"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="0125_009C">Synopsis<A name="0125_009C"></FONT></h4></P>
<pre>#include &lt;stdlib.h&gt;
void *malloc(size_t size);</pre>
<h4><FONT COLOR="#000080"><A name="0125_009D">Description<A name="0125_009D"></FONT></h4></P>
The <I>malloc</I> function allocates space for an object whose size is specified by <I>size</I> and whose value is indeterminate.<P>
<h4><FONT COLOR="#000080"><A name="0125_009E">Returns<A name="0125_009E"></FONT></h4></P>
The <I>malloc</I> function returns either a null pointer or a pointer to the allocated space.<P>
<h4><FONT COLOR="#000080"><A name="0125_009F">7.10.3.4 The <B><I>realloc</I></B> function<A name="0125_009F"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="0125_00A0">Synopsis<A name="0125_00A0"></FONT></h4></P>
<pre>#include &lt;stdlib.h&gt;
void *realloc(void *ptr, size_t size);</pre>
<h4><FONT COLOR="#000080"><A name="0125_00A1">Description<A name="0125_00A1"></FONT></h4></P>
The <I>realloc</I> function changes the size of the object pointed to by <I>ptr</I> to the size specified by <I>size</I>. The contents of the object shall be unchanged up to the lesser of the new and old sizes. If the new size is larger, the value of the newly allocated portion of the object is indeterminate. If <I>ptr</I> is a null pointer, the <I>realloc</I> function behaves like the <I>malloc</I> function for the specified size. Otherwise, if <I>ptr</I> does not match a pointer earlier returned by the <I>calloc, malloc, </I>or <I>realloc</I> function, or if the space has been deallocated by a call to the <I>free</I> or <I>realloc</I> function, the behavior is undefined. If the space cannot be allocated, the object pointed to by <I>ptr</I> is unchanged. If <I>size</I> is <I>zero</I> and <I>ptr</I> is not a null pointer, the object it points to is freed.<P>
<h4><FONT COLOR="#000080"><A name="0125_00A2">Returns<A name="0125_00A2"></FONT></h4></P>
The <I>realloc</I> function returns either a null pointer or a pointer to the possibly moved allocated space.<P>
Footnote<P>
127. Note that this need not be the same as the representation of floating-point zero or a null pointer constant.<P>
<h4><FONT COLOR="#000080"><A name="0125_00A3">Using the Functions<A name="0125_00A3"></FONT></h4></P>
<I>calloc</I> &#151; Use this function to allocate an array data object and store zeros in all of the characters that constitute the data object. You can assume that the size of any character type is 1, but otherwise you should use the operator <I>sizeof</I> to determine the second argument. Do <I>not</I> specify a second argument whose value is zero.<P>
For maximum portability, don't assume that any floating-point values thus become zero or that any pointers become null pointers. Probably they are, but you can't count on it. Nor should you assume that the product of the two arguments is all that matters. An implementation can select a storage alignment for the allocated data object based on the size specified by the second argument. Thus, you should allocate:<P>
<UL><li>an array of <I>N int</I> as <I>calloc(N, sizeof (int))</I></li>
<li>a data object of type <I>struct x</I> as <I>calloc(1, sizeof (struct x))</I></li></UL>
<I>free</I> &#151; Use this function to deallocate storage you allocated earlier in the execution of the program by calling <I>calloc, malloc,</I> or <I>realloc</I>. You can safely call <I>free</I> with a null pointer. (The function does nothing in this case.) Otherwise, the argument to <I>free</I><I> must</I> be the value <I>p</I> returned by one of the three functions listed above. Don't call <I>free((char *)p + N)</I> to free all but the first <I>N</I> allocated characters &#151; call <I>realloc(p, N)</I> instead. Once you call <I>free (p)</I> don't access the value currently stored in <I>p</I> in <I>any</I> expression &#151; some computer architectures may treat such an access as a fatal error.<P>
You are not obliged to free storage that you allocate. A good discipline, however, is to free all allocated storage as soon as possible. Freed storage can be reallocated, making better use of a limited resource. Moreover, some implementations can report storage allocated at program termination. That helps you locate places where you unintentionally fail to free storage.<P>
<I>malloc</I> &#151; See the discussion of <I>calloc</I>, above. Use <I>malloc</I> to allocate a data object that you intend to initialize yourself. If the data object contains only integers and you want them all set to zero, call <I>calloc</I> instead. The same considerations apply for the argument to <I>malloc</I> as for the second argument to <I>calloc.</I><P>
<I>realloc</I> &#151; The common use for this function is to make a previously allocated data object larger or smaller. If you make it larger, the values stored in the added portion are undefined. If you make it smaller, the values stored in the retained portion remain unchanged. In either case, however, the function may alter where the data object is stored. As with <I>free</I>, described above, you shouldn't access the argument value in <I>any</I> expression once <I>realloc</I> returns. Replace the call <I>realloc(NULL, size)</I> with <I>malloc(size)</I>. The same considerations apply for the second argument to <I>realloc</I> as for the second argument to <I>calloc</I>, described above.<P>
<h4><FONT COLOR="#000080"><A name="0125_00A4">Implementing the Functions<A name="0125_00A4"></FONT></h4></P>
Several functions cooperate to allocate and free storage during program execution. You can implement these functions many ways. I chose to maintain a pool of available storage (the "heap") as a singly-linked list. The list elements remain in sort by their addresses in storage. A static pointer points to the start of the list &#151; the element with the lowest address.<P>
<A href="list1.htm">Listing 1</a>
shows the file <I>xalloc.h</I>. It is an internal header that is included by all of the storage allocation functions. It defines several macros and types. A list element, for example, has type <I>_Cell.</I> At least it begins with such a data object. The member <I>_Size</I> gives the useful size in bytes of the entire element, which is typically much larger than a <I>_Cell</I> data object. The member <I>_Next</I> points to the next element of the available storage list.<P>
An allocated element still begins with the member <I>_Size</I>. That information may be needed later if the program elects to free the allocated element. The program does not see this size information, however. The allocation functions return a pointer to the usable area beyond the member <I>_Size</I>. The macro <I>CELL_OFF</I> gives the offset in bytes of the usable area from the start of the allocated element.<P>
Many computer architectures care about storage boundaries. Some require that certain types of data objects begin at a storage address that is some multiple of bytes. Typical multiples are two, four, or eight bytes. Other computer architectures do not require such alignment, but execute faster when manipulating data objects that are properly aligned. The macros defined in <I>&lt;stdarg.h&gt;</I> typically must correct for holes left by the alignment of argument data objects.<P>
The storage allocation functions also fret about storage boundaries. They assume that a worst-case storage boundary exists. Any data object aligned on such a boundary is thus suitably aligned. The internal header <I>&lt;yvals.h&gt;</I> defines the macro <I>_MEMBND</I> to specify this worst-case storage boundary. For a boundary of 2<I>N</I>, the macro has the value 2<I>N</I>-1. On an Intel 80X86 computer, for example, the macro can be zero (no constraints). You should probably make it at least 1 (two-byte boundaries). For such a computer with 32-bit memory, you might want to make it 3 (four-byte boundaries).<P>
Much of the ugly logic in the storage allocation functions results from this attempt to parametrize the worst-case storage boundary. The macro <I>CELL_OFF</I> assumes that a list element begins on a worst-case storage boundary. It determines the start of the usable area as the next such boundary beyond the space set aside for the member <I>_Size</I>. Similarly, the macro <I>SIZE_CELL</I> yields the smallest permissible value of <I>_Size</I> for a list element. The list element must be large enough to hold a <I>_Cell</I> data object. It must also end on a worst-case storage boundary.<P>
The remainder of <I>xalloc.h</I> is best explained along with the function <I>malloc</I>. <A href="list2.htm">Listing 2</a>
shows the file <I>malloc.c.</I><I> </I>The function <I>malloc</I> endeavors to allocate a data object of <I>size</I> bytes. To do so, it looks for an element on the list of available storage that has a usable area at least this large. If it finds one, it splits off any excess large enough to make an additional list element. It returns a pointer to the usable area.<P>
The internal function <I>findmem</I>, defined in <I>malloc.c</I> scans the list of available storage. It retains two static pointers in the data object <I>_Aldata</I> of type <I>_Altab</I>, defined in <I>xstdio.h</I>:<P>
<UL><li><I>_Head</I> points to the start of the list. If the list is empty, it contains a null pointer.</li>
<li><I>_Plast</I> is the <I>address</I> of the pointer to the next list element to consider. It can point to <I>_Aladata._Head</I> or to the <I>_Next</I> of an available list element. Or it can be a null pointer.</li></UL>
Whenever possible, <I>findmem</I> begins its scan where it left off on a previous call. That strategy reduces fragmentation at the start of a list by distributing usage over the entire list.<I>malloc</I> itself and the function <I>free</I> cooperate in maintaining these two pointers.<P>
If <I>findmem</I> cannot find a suitable element on the available list, it endeavors to obtain more storage. (Initially the heap is empty, so the first request takes this path.) It calls the function <I>_Getmem</I>, declared in <I>xalloc.h</I> to do so. That primitive function must return a pointer to a storage area of at least the requested size, aligned on the worst-case storage boundary. If it cannot, it returns a null pointer.<P>
The macro <I>SIZE_BLOCK</I>, defined in <I>xalloc.h</I>, specifies the smallest preferred list-element size. I have set it to 512, but you may want to change it. <I>findmem</I> first requests the larger of the required size and <I>SIZE_BLOCK</I>. If that fails, it halves the requested size repeatedly until the request is granted or a request of exactly the required size cannot be honored. This strategy favors larger element sizes but takes what it can get. If the request is granted, <I>findmem</I> makes the new storage look like a previously allocated element. It calls <I>free</I> to add the storage to the available list. The next iteration of the scan loop should discover this storage and use it.<P>
The function <I>_Getmem</I> depends strongly on the execution environment. You must tailor this primitive extensively for each operating system. For completeness, I show here a version of <I>_Getmem</I> that runs under UNIX.<P>
<A href="list3.htm">Listing 3</a>
shows the file <I>xgetmem.c.</I> As with the earlier UNIX primitives I've presented, it assumes the existence of a C-callable system service with its name altered to a reserved form. <I>_Sbrk</I> performs the UNIX <I>sbrk</I> system service, which allocates a block of storage. Note that <I>_Sbrk</I> expects an <I>int</I> argument. Hence <I>_Getmem</I> must ensure that a very large request is not misinterpreted.<P>
<A href="list4.htm">Listing 4</a>
shows the file <I>calloc.c.</I> It calls <I>malloc</I> to allocate storage, then sets its individual characters to zero. A more cautious version would check that the product of the two arguments is of a reasonable size.<P>
<A href="list5.htm">Listing 5</a>
shows the file <I>free.c.</I> It frees storage earlier allocated by <I>malloc</I> or <I>realloc</I>. Two common programming errors cause trouble for <I>free</I>:<P>
<UL><li>Invalid stores alter the value of the <I>_Size</I> member.</li>
<li>A program calls <I>free</I> with an invalid pointer. Either the data object was never allocated or it has already been freed.</li></UL>
Probably no amount of checking is enough to keep ill-formed programs from sabotaging <I>free</I>. This version makes just one or two cursory checks. If the <I>_Size</I> member is not a multiple of the worst-case storage boundary, it has been altered or was never allocated. If the element to be freed overlaps an existing element on the available list, it has been freed twice. Both errors cause <I>free</I> to return without freeing the designated storage. A more helpful version might report a signal or generate a diagnostic. At the very least, is might store a nonzero value in <I>errno</I>, defined in <I>&lt;errno. h&gt;</I>.<P>
Most of the work of <I>free</I> involves finding the appropriate place to insert the freed element in the list of available storage. If the freed element is adjacent to one or two existing list elements, the adjacent elements are combined. That minimizes fragmentation of the list.<P>
Note that <I>free</I> alters the scan pointer <I>_Aldato._Plast</I>. That is necessary because the stored pointer may be to a list element now merged with another. I chose to have the scan resume just after the freed element. That's an easy address to determine here. This approach also spreads the use of storage more uniformly across the list. And it postpones as long as possible recycling freed storage (a questionable kindness to buggy programs). On the other hand, it lowers performance whenever the heap grows by calling <I>_Getmem</I>. Here is an area that can occupy a designer for a long time.<P>
<A href="list6.htm">Listing 6</a>
shows the file <I>realloc.c.</I> The function <I>realloc</I> tries to allocate a larger storage area if that is necessary. It also tries to trim the existing storage area if that proves to be worthwhile.<P>
This version doesn't try quite as hard as it could. If a larger storage area is required, the function insists on allocating a new area before freeing the existing area. That eliminates any worries about preserving data stored in the usable area during the shuffle. But it precludes one possibility &#151; the larger area may be available only after the existing area is freed. Here is yet another place where an ambitious implementor can make improvements.<P>
<I>This article is excerpted from P.J. Plauger, </I>The Standard C Library,<I> (Englewood Cliffs, N.J.: Prentice-Hall, 1992)</I>.<P>

<h4><a href="../../../source/1992/jun92/plauger.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
