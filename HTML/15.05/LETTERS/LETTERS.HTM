






<HTML>
     
     <HEAD>


          
          <TITLE>May 1997/We Have Mail</TITLE>
     </HEAD>
     
     <BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
          
          <H2><A href="../tocmay.htm"><IMG src="../../toc.gif" ALT="Back to TOC" WIDTH="54" HEIGHT="54"></A>
          <FONT COLOR="#FF0000">Departments</FONT></H2>
          
          <HR>
          
          <H2 ALIGN="center"><FONT COLOR="#800000">We Have Mail</FONT></H2>
          
          <BLOCKQUOTE>
               
               <P> Letters to the editor may be sent via email to
                    cujed@rdpub.com, or via the postal service to Letters to the
                    Editor, C/C++ Users Journal, 1601 W. 23rd St., Ste 200,
                    Lawrence, KS 66046-2700.</P></BLOCKQUOTE>
          <HR>
          <BLOCKQUOTE>
               
               <p> Dear Editor, </p>
               
               <p> I've been wondering why arrays in C
                    are not lvalues and I couldn't find a good reason. </p>
               
               <p> Unfortunately, the earliest edition
                    of K&amp;R that I have dates to 1985, when various changes
                    had already taken place in the language. Section 14.3 states
                    that when an array type appears in an expression, it is
                    converted to a pointer to its first element. It says that's
                    the reason why an array cannot be an lvalue. </p>
               
               <p> However, it seems to me that
                    sometimes the pointer could be converted back to an array,
                    e.g.:</p>

<PRE>
void cpy021( int (*m)[10])
{
#ifdef __STDC__
 memcpy(m+1, m+0, sizeof m[1]);
#else
 m[1] = m[0]; /* naive :) */
#endif
}
</PRE>
               
               <p>The best rationale I could come up with is that that feature
                    had been banned because it cannot be always granted. Today,
                    having been exposed to C++, that sort of concern is
                    irrelevant. But, if I remember well, language orthogonality
                    and consistency were being given a somewhat higher priority
                    at the time.</p>
               
               <p> I know you can remember much farther
                    than I, and I'd be delighted to know your opinion about
                    that. </p>
               
               <p> Regards and best compliments for
                    September's STL-bomb!
                    <BR> Alessandro Vesely
                    <BR> MC6192@mclink.it </p>
               
               <p><I> Arrays are not lvalues because of
                    a fundamental design decision that Dennis Ritchie made in
                    the earliest days of C. He wanted practically any reference
                    to the array a to be equivalent to &amp;a[0]. That way, the
                    subscript operator a[i] can be defined as entirely
                    equivalent to *(a + i) &#151; giving the same (sensible)
                    behavior to p[i] where p is a pointer. With 20-20 hindsight,
                    we can now see that this equivalence was not strictly
                    required to support most of the convenient notation of C.
                    But we now have generations of C programmers who are more or
                    less inured to this equivalence.</I> </p>
               
               <p><I> Strictly speaking, there's still
                    room in C &#151; syntactically and semantically &#151; to introduce
                    arrays as first-class citizens. I suggested as much at one
                    meeting of X3J11 and got shouted down. However adventuresome
                    the C++ standards committee may be, the C folks were and
                    remain much more conservative. I have to agree that such a
                    change at this date would dramatically increase confusion in
                    an already confusing  area. &#151; pjp</I></p>
               <HR>
               
               <p> Dear PJP: </p>
               
               <p> First, does CUJ have or have any
                    plans for a CD-ROM of back issues like your sister mag WDJ
                    just produced? </p>
               
               <p> Second, why in C/C++ is there not a
                    way to represent binary numbers? (I believe you can only do
                    decimal, octal, and hex.) I was really quite flabbergasted
                    when I discovered this. After all, binary is the root of our
                    machines. </p>
               
               <p> Now, I understand that a 64-bit
                    number in binary would be a little unwieldy, but you can use
                    0xFF instead of 0x000000FF, so I imagine a similar shortcut
                    would be possible. </p>
               
               <p> Where I wanted to use this was in bit
                    twiddling. It's not too difficult to mentally convert
                    something that is only one bit, but when using a mask that
                    involves many bits, one needs a calculator to get the hex
                    equivalent. Or you have to OR a bunch of single-bit values
                    together. It just seems that code would be more readable if
                    you could see the bit representation directly. </p>
               
               <p> Thanks for the great magazine.
                    <BR> Tom Brown
                    <BR> ROCS, Inc.
                    <BR> tbrown@rocsinc.com </p>
               
               <p><I> The CD-ROM is already available.
                    Look for an ad in this issue, or check out our Web site at
                    www.cuj.com.</I> </p>
               
               <p><I> I believe that binary constants
                    have been proposed as an addition to C9X, the revision of
                    Standard C now under way. But I don't know the current
                    status of that proposal. &#151; pjp</I></p>
               <HR>
               
               <p> Editor, </p>
               
               <p> In the October 1996 issue of The
                    C/C++ Users Journal, in the article, "A Class Hierarchy for
                    Random Number Generation" the sidebar (p. 52) on Linear
                    Congruential Generators (LCG) leads the user to believe that
                    Multiplicative LCGs can have a generation cycle of m-1. In
                    fact they can only have a max generation cycle of m/4 if Zo
                    is odd and a equals 8k+1 for some k. (See Fundamentals of
                    Performance Modeling, by Michael K. Molloy, Ph.D, p. 88.)
                    </p>
               
               <p> Richard Crutchfield
                    <BR> crutchfr@earthlink.net </p>
               <HR>
               
               <p> CUJ, </p>
               
               <p> I have being involved in software
                    development and design for one year now and I have basically
                    learned C and C++ at the same time. I just started reading
                    CUJ and find it extremely interesting and useful. </p>
               
               <p> In the October 1996 issue, there is a
                    very good article in the form of an interview with Mr.
                    Bjarne Stroustrup called "C++: The Making of a Standard."
                    I have been using C++ to implement real-time embedded
                    systems and I have found some resistance. I am told that C++
                    adds too much overhead and that C could be a better choice.
                    It is now clear to me that C++ is a better choice than C in
                    any case since it provides all  the advantages of OOP and,
                    if you don't want to use these nice features, you won't
                    incur any time and/or space overhead. </p>
               
               <p> The problem with that is that I don't
                    really know what is the overhead incurred when it comes to
                    overloading functions, overloading operators, using
                    inheritance, and dynamic binding. Are there any good books
                    and/or articles that describe how the compilers generally
                    implement these OOP features and what is the overhead
                    incurred, so I can decide when it is appropriate to use
                    OOP-specific features in time and/or  space critical
                    applications? </p>
               
               <p> Thank you very much. </p>
               
               <p> Alain Bouvier
                    <BR> abouvier@comstream.com </p>
               
               <p><I> The best source I know, offhand,
                    is probably the series of articles by Dan Saks in these
                    pages. Try the CD-ROM containing back issues. You'll have to
                    scan quite a bit, I'm afraid. You can also profit
                    considerably from the style tips in the books by Scott
                    Meyers. And you should take a look at the Web site for the
                    Embedded C++ Technical Committee, www.caravan.net/ec2plus.
                    &#151; pjp </I></p>
               <HR>
               
               <p>Dear Mr. Plauger, </p>
               
               <p> I read with interest the excellent
                    article by Martin D. Carroll and Margaret A. Ellis entitled
                    "Obstacles to Inheritability in C++" in the August 1996
                    issue of CUJ. I have had to tackle some of these issues
                    myself when designing class libaries that I intend to be
                    used by other people. </p>
               
               <p> Although I agree with most of the
                    advice given in the article, I have difficulty with the
                    implication that a class-library designer should predict the
                    ways a user might want to derive from the classes in the
                    library. In my experience, the incredibly wide range of
                    things users want to do with a library makes this exercise
                    generally difficult and often impossible, unless one happens
                    to be clairvoyant. </p>
               
               <p> I very much prefer a philosophy of
                    defining during the design phase how the classes in a
                    library are intended to be derived from. Good documentation
                    for a class library should then include very detailed
                    information on how to derive from its classes, if this is
                    intended. </p>
               
               <p> As the above implies, this does not
                    only apply to inheritance, but to class library usage in
                    general. I believe that (merely human) class-library
                    designers cannot be expected to anticipate the (often
                    boneheaded) things a user might might want to do with their
                    libraries. The intended usage of a library should be well
                    defined and documented. Any usage outside those parameters
                    should not be supported. </p>
               
               <p> Thank you for an informative and
                    thought-provoking article.
                    <BR> regards,
                    <BR> Igor Siemienowicz
                    <BR> igor@adacel.com.au igorsiem@ozemail.com.au </p>
               
               <p> <I>Dennis Ritchie once observed that
                    language design is essentially a bottom-up process. The best
                    designers can envision a multitude of ways the language will
                    be used and will instinctively make the tradeoffs that
                    maximize usability. Class-library design lies midway between
                    language design and more conventional programming. Thus, it
                    does indeed require a touch of clairvoyance to do well.
                    Providing clear definitions, as you describe, is a good
                    discipline that minimizes the need for clairvoyance,
                    however. &#151; pjp</I> </p>
               <HR>
               
               <p> Dear CUJ, </p>
               
               <p> Regarding the letter from Chuck
                    Patterson in the November 1996 "We Have Mail:" Amen
                    Brother... </p>
               
               <p> Now finish your response by helping
                    us make that specialization choice. </p>
               
               <p> I spent 28 years in the practice of
                    consulting engineering to the broadcast industy, only to
                    have that field die during the late 1980s. Since I had used
                    minicomputers in my practice for most of those years, I was
                    able to change professions into networking, communications,
                    and writing some programs. </p>
               
               <p> I realize that my request is beyond
                    reason but had to ask anyway. </p>
               
               <p> Sincerely
                    <BR> Robert L. Miers, PE
                    <BR> Chandler, AZ 85225 </p>
               <HR>
               
               <p> Editor:
                    <BR> In regard to the letter from Virgilio Valasco Jr. in
                    the November 1996 issue, please note that primitive types,
                    such as int, do not have constructors and destructors
                    associated with them. Such methods exist only for
                    user-defined types. The syntax he notes:</p>

<PRE>
int x(5);
</PRE>
               
               <p>is called C++ style initialization, whereas:</p>

<PRE>
int x = 5;
</PRE>
               
               <p>is called C-style initialization. You correctly noted that
                    both styles must be supported for the sake of templates. For
                    example, in the classic swap routine:</p>

<PRE>
template &lt;class T&gt;
void swap(T&amp; x, T&amp; y)
{
T temp(x);
x = y;
y = temp;
}
</PRE>
               
               <p>the declaration of temp should use C++-style initialization
                    in case the constructor for class T has been declared
                    explicit, in which case the line would not compile. If T is
                    a primitive type, then the code must still compile.
                    <BR> Eric Nagler
                    <BR> 76711.521@compuserve.com</p>
               
               <p><I> The scalar types must also behave
                    as if they have destructors too, lest certain templates not
                    compile. As a pragmatic soul, the distinction is irrelevant
                    to me whether these are really constructors and destructors,
                    or just happen to look like them. &#151; pjp</I> </p>
               <HR>
               
               <p> Dear Mr. Plauger: </p>
               
               <p> Do you foresee the C++ file streams
                    classes ever supporting shared files, particularly the
                    locking and unlocking of byte ranges? If not, do we ever
                    stand the chance of being able to derive classes from
                    Standard C++ library classes with some reasonable access to
                    the implementation of those classes? For instance, the
                    filebuf class has as a private member a FILE pointer, which
                    in turn contains the operating-system  dependent file handle
                    that serves as the argument to most operating system's
                    locking and unlocking calls; protected access to these
                    details would allow developers to build upon the rich
                    feature set of the C/C++ libraries rather than starting new
                    classes from scratch. </p>
               
               <p> Thanks in advance for any insights.
                    <BR> Mark Reichert
                    <BR> reicher1@gate.net </p>
               
               <p><I>The draft C++ Standard doesn't
                    address file locking, nor does the C Standard. The latter,
                    however, has a clearer tie to the Posix Standard, which does
                    specify how to lock files. Private members are not part of
                    the visible interface mandated by the draft C++ Standard. So
                    the short answer is that C++ will probably not have a
                    standard-conforming, portable way to write code that locks
                    files. At least not in the near future. &#151; pjp</I> </p>
               <HR>
               
               <p> Dear Editor, </p>
               
               <p> I am a new C++ programmer, and I am
                    writing a security program that needs to know the current
                    time. I know I can get it out of the header file &lt;time.h&gt;,
                    but when I try to put it on the screen, it gives me a
                    hexadecimal number. What am I doing wrong? </p>
               
               <p> Thanks,
                    <BR> N. Musurca
                    <BR> slicknick9@aol.com </p>
               
               <p><I> You need to convert the time and
                    date you get by calling time() to a printable string. Try
                    printing ctime(time()) instead. &#151; pjp</I> </p></BLOCKQUOTE>
     </BODY>
</HTML>
