<HTML>   
     <HEAD>
<TITLE>August 2000/Converting VCL Components to Windows Resources</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Windows</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Converting VCL Components to Windows Resources</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Luigi Bianchi</FONT></H3>

<BLOCKQUOTE>
<p>Borland C++Builder has its own version of resource files, but they can be translated to more conventional .RC files.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<p>Creating dialog boxes for GUI applications is one of the most common repetitive tasks in Windows development. Many class libraries, such as MFC (Microsoft Foundation Classes), reduce this burden on Windows developers. IDEs (Integrated Development Environments) can speed up this process even more by providing automatic code generation.</p>
<p>BCB (Borland C++Builder), a development environment, utilizes both ideas. It provides both a class library, VCL (Visual Component Library), and an IDE that automatically generates code to incorporate the components within a Windows application. However, such code generation requires strict cooperation between the IDE and VCL. As a result, VCL resource files have a format that cannot be used in non-VCL applications.</p>
<p>In this article, I describe a utility that I have written to convert VCL resource files into plain Windows resource script (<B>.RC</B>) files. The utility also automatically generates some of the code needed to initialize these converted components with default settings. Although turning a VCL application into a non-VCL application is not automatic, this tool greatly simplifies the task, with potentially large savings in application size. The tool also opens up new possibilities in application development, such as using BCB as a prototyping tool and shipping the final product as a non-VCL application.</p>

<H4><FONT COLOR="#000080">Background on GUI Resources</FONT></H4>

<p>A <I>resource</I>, in general GUI terms, is a data set that describes a component's variable parts, such as its size, position, color, etc. It should not be confused with the component's class definition or the code that instantiates such a component. A <I>Windows</I> resource, according to MSDN (Microsoft Developer Network), has the following definition:</p>

<BLOCKQUOTE>
<p>A resource is binary data that you can add to the executable file of a Win32-based application. A resource can be either standard or defined. The data in a standard resource describes an icon, cursor, menu, dialog box, bitmap, enhanced metafile, font, accelerator table, message-table entry, string-table entry, or version information. An application-defined resource, also called a custom resource, contains any data required by a specific application.</p>
</BLOCKQUOTE>

<p>Standard resource data is defined at the OS (operating system) level; the OS provides several APIs to manipulate the data. Custom resource data, instead, is defined by the module that uses it. The module must provide, or have access to, some functions to handle the custom resource.</p>
<p>Most Windows development tools come with a resource editor and a resource compiler. The resource editor allows you to visually design a dialog box and store its parameters in a script file (with the extension <B>.RC</B>, shown in <a href="fig1.htm">Figure 1</a>). The resource compiler translates the script into a binary file (a <B>.RES</B> file) that can be linked into the executable. The Win32 SDK and the most commonly used class libraries (MFC, OWL, etc.) are expected to work in this way.</p>

<H4><FONT COLOR="#000080">The Problem with VCL Resources</FONT></H4>

<p>Instead of creating a resource script file, BCB Resource Editor generates a binary file (with the extension <B>.DFM</B>) that only VCL can understand. Moreover, all the resources, even the standard ones, are stored as if they were custom, so you can't rely on direct OS support or resource de-compilers. Custom resource data generated by BCB Resource Editor is a copy of a <B>.DFM</B> file. VCL guarantees translation of these resources into OS calls, at the cost of extra code linked to the module. This was done to add functionality, such as automatic initialization of the controls to accelerate the GUI development process.</p>
<p>In addition to this inconvenience, some low-level API programming has been hidden in what Borland calls component "properties," in order to further simplify the design of the user interface. From Borland's documentation:</p>

<BLOCKQUOTE>
<p>Properties are the most visible parts of components. The application developer can see and manipulate them at design time and get immediate feedback as the components react in the Form designer. A property can be of any type.</p>
</BLOCKQUOTE>

<p>This raises the question of how to design a dialog box using BCB for a non-VCL application. Borland's answer is to use Resource Workshop, a separate tool that generates a standard resource script file. I tried to use it, but I discovered that Resource Workshop does not allow the use of a lot of the newer controls, such as <B>ListView</B>s, <B>TreeNode</B>s, <B>MonthCalendar</B>s, <B>TrackBar</B>s, etc. (Not surprisingly, the date that appears in the About Box is 1994, which explains a lot of things.) BCB <I>is</I> able to compile MFC, OWL, and WinApi code because there is a resource compiler for script files, but a visual <B>.RC</B> file generator is missing.</p>
<p>Exploring a <B>.DFM</B> file convinced me that the file could be translated into a standard resource script file. So, I created an extendable <B>.DFM</B>-to-<B>.RC</B> file converter that translates a VCL <B>TForm</B> into a standard Windows <B>DIALOGBOX</B> resource. Because a <B>.DFM</B> file contains more data than can be included in an <B>.RC</B> file, I use some of this extra data to automatically generate code to initialize the dialog box. Thus, I have more benefits than I could have using an updated version of Resource Workshop.</p>

<H4><FONT COLOR="#000080">Exploring VCL Components</FONT></H4>

<p>I began my development of the conversion process by using a resource editor to create a simple <B>Dialog Box</B> with a Push Button, a Static Text Field, and a Combo Box. This produced the script file shown in <a href="fig1.htm">Figure 1</a>. Without entering into <B>.RC</B> file details (for which wide documentation exists), I simply provide <a href="fig1.htm">Figure 1</a>, which shows a <B>DIALOG</B> resource described by a row that defines its <B>nameID</B> (<B>IDD_DIALOG1</B>), position (0, 0), and size (240, 120). The row is followed by statements that relate to the dialog styles, caption text, and font. Finally, a list of three statements describes each control that populates the <B>DialogBox</B>. These statements describe <B>nameID</B>, family, window style, position, size, and, eventually, extended style. The <B>nameID</B> is either a unique name or a unique 16-bit unsigned integer value that identifies the dialog box or the control.</p>
<p>After creating this resource file, I created a <B>TForm</B> with BCB that contained the same controls as the <B>Dialog Box</B> in order to obtain a <B>.DFM</B> file. Naturally, after gaining an understanding of about 99.9 percent of the binary file format, I discovered a VCL function, <B>ObjectResourceToText</B>, that converts the binary resource file into an equivalent, more readable text file. From here on, when I talk about a <B>.DFM</B> file, I will be referring to the equivalent text file, unless otherwise indicated.</p>
<p>In BCB, all the Palette icons that can be dragged onto a Form are called components and derive from the VCL <B>TComponent</B> class. They can be both visual and non-visual. The visual components are quite similar to SDK controls, while the non-visual components are, for example, Common Dialogs, Timers, Database Tables, and so on. These non-visual components don't have an equivalent representation in an <B>.RC</B> file. Note that <B>TForm</B> and <B>TMenu</B> also inherit from a <B>TComponent</B>.</p>
<p>When you start to design a new Form, the IDE creates three files with the same name, but with different extensions: <B>.DFM</B>, <B>.CPP</B>, and <B>.HPP</B>. These three files contain all the information about that form: definitions, declarations, resources, and implementation. When you then drag a component onto that Form, the IDE inserts the declaration of a pointer to the component into the private members of the Form and a section into the <B>.DFM</B> with the component's description and some of its properties. To reduce the size of a <B>.DFM</B> file, only those properties whose value differs from the default are stored. If you modify the component's name, the IDE reflects the change in the three files to keep them aligned.</p>
<p>Even using the text representation of the <B>.DFM</B> file, you still must deal with some binary data (for example, bitmaps) or other data that VCL uses internally during Form initialization.</p>
<p>A component can be included within another component (e.g., a Form is a component and includes all the other components). Also, non-visual components are included in the Form onto which they have been dragged.</p>
<p>In the text version of the resource files, every component description starts with the keyword <B>object</B> and terminates with the keyword <B>end</B>. <a href="fig2.htm">Figure 2</a> shows the text version of a <B>.DFM</B> file generated for a <B>TForm</B> with the three controls described above. Similar to an <B>.RC</B> file, this file starts with a general description of the <B>TForm</B> and follows with a list of components.</p>
<p>One of those components is a <B>TComboBox</B>, which starts with a list of properties (Left, Top, etc.), each followed by an equal sign and a value. Within the source files, a pointer, <B>ComboBox1</B>, refers to this <B>TComboBox</B>. The IDE creates the declaration for <B>TComboBox</B> and initializes the pointer <B>ComboBox1</B> with its address, keeping things synchronized among the three files associated with the form. Unlike <B>.RC</B> files, you don't need a <B>nameID</B> to identify this combo box, because you have access to it through the pointer variable; this pointer is a data member of <B>TForm</B>.</p>
<p>Properties in a <B>.DFM</B> file can be integers, strings, and lists. To complicate things, strings can represent Boolean values (as in the <B>Sorted</B> property), something that looks like an <B>enum</B> (as in the <B>Style</B> property), or something that appears to represent text (as in the <B>Items.Strings</B> case). Finally, this <B>.DFM</B> file shows four default property values (<B>'I'</B>, <B>'Love'</B>, <B>'Chick'</B>, and <B>'Corea'</B>) for which there is no equivalent in an <B>.RC</B> file. These extra parameters are used by a magic VCL function that fills the Combo Box at run time with the four items defined at design time. From the resource information only, this function knows which strings must be inserted into the <B>ComboBox1</B> instance of the <B>TComboBox</B> class. The programmer does not need to write any code to accomplish this initialization.</p>

<H4><FONT COLOR="#000080">Conversion Classes</FONT></H4>

<p>Because the information stored in an <B>.RC</B> file is a subset of the information in a <B>.DFM</B> file, it should be possible to convert a <B>.DFM</B> file into an <B>.RC</B> file. This process involves several tasks: the substitution of variable names with <B>nameID</B>s, the conversion of the control metrics to account for different strategies between <B>.DFM</B> and <B>.RC</B> files, and the rearrangement of the controls' creation order to preserve the same tab-order navigation. In addition, the conversion process should create some code to initialize the controls and to set additional properties (which can be accessed only through API calls) without requiring users to manually write code. By generating this code, the conversion process preserves the added benefit of VCL components over ordinary Windows controls.</p>
<p>To perform these tasks, I created a hierarchy of classes, whose base class is <B>pVCLComponent</B> (<a href="list1.htm">Listing 1</a>). Its purpose is to read and keep track of the VCL components stored in a <B>.DFM</B> file. All the other classes descend from <B>pVCLComponent</B>. The first one, <B>pResComponent</B>, automatically generates a unique <B>nameID</B> for every control. Note that there are some components, such as <B>CommonDialog</B>, that do not have a <B>nameID</B> and have no representation in an <B>.RC</B> file.</p>
<p>Two classes are derived from <B>pResComponent</B>: <B>pVisualObject</B> and <B>pMenuBase</B>. The former relates to objects that are windows, so it has a size, a style, etc. The latter relates to menus. <B>pDialogBox</B> and <B>pVisualControl</B> are derived from <B>pVisualObject</B>. All the controls, such as <B>pRadioButton</B>, <B>pEdit</B>, <B>pComboBox</B>, etc., inherit from <B>pVisualControl</B>, while an intermediate class, <B>pCommCtrl</B> is used for the common control. More than 50 components are defined.</p>

<H4><FONT COLOR="#000080">The DfmConvert Function</FONT></H4>

<p>.DFM</B>-to-<B>.RC</B> conversion is implemented in the <B>DfmConvert</B> function (<a href="list2.htm">Listing 2</a>). This function receives the name of the <B>.DFM</B> file to convert, two integers for generating the <B>nameID</B>s of the <B>Dialog Box</B> and the controls, and two floating-point values required to resize the form. After all the necessary filenames have been set and the text version of the <B>.DFM</B> file has been generated and opened, <B>DfmConvert</B> creates a <B>pDialogBox</B> object and retrieves the required <B>TForm</B> properties, through the <B>Parse</B> function, which is a public member of <B>pVCLComponent</B>. The <B>Parse</B> function is the most important one; I'll come back to it later.</p>
<p>Next, the pointer to <B>pDialogBox</B> is added to a list of <B>pVCLComponent</B> pointers called <B>obj_list</B>. The <B>RecurseFile</B> function completes the task of retrieving the properties of all the other components. It continues to read the file, and whenever a new component is found, <B>RecurseFile</B> reads the component's name and type and passes them to <B>GetVCLComponent</B>. If the type is defined in the class hierarchy whose ancestor is <B>pVCLComponent</B>, an object of that type is created, and its pointer is returned; otherwise, a <B>NULL</B> value is returned. Next, program control returns to <B>RecurseFile</B>, which, if the component type has not been recognized, skips to the next one. Otherwise, <B>RecurseFile</B> inserts the component's pointer into <B>obj_list</B>, calls the <B>Parse</B> function to retrieve all the required properties of that specific object, and then recursively calls itself. This process stops when it reaches the end of the file.</p>
<p>At this point, all the information has been retrieved and preprocessed. Next, two more lists are created: one for the Menus and another for the Visual Controls. This extra step is performed because both component categories require some extra processing. The <B>.RC</B> file, for example, requires that controls be sorted in a particular order to properly handle the tab-key order. Therefore, two sort functions are required: the first for the tab-order arrangement and the second to avoid hiding one control beneath another &#151; controls must be sorted according to the "level" they occupy on the screen (see <a href="list2.htm">Listing 2</a>).</p>
<p>When all the components have been processed, it is relatively simple to convert them to resources. <B>DfmConvert</B> calls function <B>WriteRcRh</B> once for each element of the Menu list and the Visual Control list and once for the Dialog Box, to write the necessary entries into <B>.RC</B> and <B>.RH</B> files. <B>WriteRcRh</B> is declared virtual in <B>pResComponent</B>, so you can adapt its behavior by deriving a new class for the hierarchy and overriding the function in the derived class.</p>

<H4><FONT COLOR="#000080">Special Processing</FONT></H4>

<p>Some controls, such as images, require that items be added to the resource script file in different locations. For these controls, it is not possible to simply append some text at the end of the script file. For this reason, <B>DfmConvert</B> cannot store items directly into a file, but needs to prearrange the text in memory. To do this, <B>DfmConvert</B> uses a <B>StrList</B> object (<a href="list3.htm">Listing 3</a>), which is a class that derives from a <B>list&lt;string&gt;</B> and adds a few new member functions. The public member function <B>Insert_A_Before_B</B>, for example, first looks for occurrence of the string <B>B</B> in the list and then inserts the string <B>A</B> before it. Another member function, <B>WriteFile</B>, stores all the strings in the list into a file.</p>
<p>Similar to writing resource script files, code files are automatically written by overriding the virtual function <B>WriteCppHpp</B>. The override provided by <B>pDialogBox</B> creates a <B>Dialog Box</B> procedure that contains only the famous <B>switch(uMsg)</B> statement and adds some of the unique comments defined in <B>pvisualcomponent.h</B> (not shown &#151; provided in the online archive). All other components add the correct code at the desired position by calling <B>StrList</B>'s <B>Insert_A_After_B</B> function and passing one of these comments as the <B>B</B> string.</p>
<p>The <B>pResComponent</B> member function</p>

<pre>
sl_It
HandleMessage(StrList&amp; sl, const string&amp; msg, const string&amp; 
   code)
</pre>

<p>automatically inserts code into the <B>case &lt;MSG&gt;</B> clauses of message handlers, where <B>MSG</B> is a Windows message such as <B>WM_PAINT</B>, <B>WM_INITIDIALOG</B>, etc. If a <B>case &lt;MSG&gt;</B> statement does not already exist for that specific message, <B>HandleMessage</B> inserts it into the procedure's <B>switch(uMsg)</B> scope using the <B>Insert_A_After_B</B> function.</p>
<p>For a more detailed description of this mechanism, refer to the full source code listings (available at <B>www.cuj.com/code</B>).</p>

<H4><FONT COLOR="#000080">The Parse Function</FONT></H4>

<p>Now that I have demonstrated this utility's overall operation, I want to show how the <B>Parse</B> function works. This function retrieves the values associated with some of the component's properties and eventually processes them. Of course, a general approach, valid for all the derived classes, is required. The <B>Parse</B> function should read through the <B>.DFM file</B> and when it encounters the name of a property, store its value somewhere. For this purpose, I use STL <B>map</B>s to associate a property name string, which will be the key, with a pointer to a variable of a specific type (see <a href="list3.htm">Listing 3</a>).</p>
<p><B>pVCLComponent</B> declares four maps: one for Boolean values (<B>BoolMap bm</B>), one for integers (<B>IntMap im</B>), one for general text information that needs interpretation (<B>StringMap sm_info</B>), and one for quoted text (<B>StringMap sm_text</B>). In derived classes' constructors, I use the <B>LookForXXXX</B> member functions to create an association between the property name string and the pointer to the variable that will contain its value.</p>
<p>For example, the <B>int</B> version of the function</p>

<pre>
void pVCLComponent::LookForInt(
   const char *prop,
   int *dest,
   int def_val)
{  *dest = def_val;
   im.insert(make_pair(prop, dest));
}
</pre>

<p>first copies the value of <B>def_val</B>, an optional default value, into the variable pointed to by <B>dest</B> and then binds the pointer to that <B>int</B> to the string <B>"prop"</B>.</p>
<p>Whenever the <B>Parse</B> function (<a href="list4.htm">Listing 4</a>) encounters a property, it searches all the maps for the property's occurrence, using the property's name as a key. If <B>Parse</B> finds the property entry in a map, then it copies the property value read from the <B>.DFM</B> file into the associated variable. If <B>Parse</B> does not find the property entry in any of the maps, then it calls the virtual function <B>ParseMore</B>. This function can be overridden by derived classes to read more complex properties, such as arrays or binary data.</p>
<p>This lookup process is performed for every encountered property. Finally, when a component description is terminated, another virtual function, <B>OnParseEnd</B>, is called. This function gives derived classes the opportunity to perform some special processing that might be necessary before calling <B>WriteXXXX</B>. Such processing cannot be carried out until all the properties are read, because it requires knowledge of the complete set of properties.</p>

<H4><FONT COLOR="#000080">A Pleasant Surprise</FONT></H4>

<p>Because <B>.DFM</B> files are stored as unmodified custom resources within an executable, it is possible to extract them from programs and then apply the whole process of resource conversion and code generation. Because BCB and Delphi use the same resource format, you can also use this tool to convert a Delphi Form. For example I've extracted a Delphi freeware program's resources and converted them into a C program skeleton, reconstructing quite quickly the user interface. You'll find this utility in the full source code listings.</p>

<H4><FONT COLOR="#000080">The Results</FONT></H4>

<p><a href="fig3.htm">Figure 3</a> shows a form I built with VCL and then, with the help of this tool, converted to Windows controls. After converting the form, I wrote about 20 lines of code to initialize the <B>Common Controls</B> and the <B>Rich Edit</B> box, and to define a <B>WinMain</B> function that creates a <B>Dialog Box</B> with the resources and the generated window procedure. I added no other lines of code. Then, I built the non-VCL program with BCB, using the same compiler options. The results of the converted version appear in <a href="fig4.htm">Figure 4</a>. Even with some small differences, you can verify that the VCL form and the "standard Windows" version look very similar and a lot of controls are initialized.</p>
<p>Next, I compared the size of the two executables, both linked statically and with no debug information. While the file size of the original VCL application was more than 700 KB, the file size for the API version was only 64 KB (About an order of magnitude difference!). Also the differences in build times were impressive: 11.37 versus 4.95 seconds on my notebook.</p>

<H4><FONT COLOR="#000080">Conclusion</FONT></H4>

<p>This tool has some limitations. You may need to extend it to handle the situations that I haven't take into account. But I must confess, I didn't know where to stop in writing this article; there are many other features I didn't mention, in order to save space.</p>
<p>There are some Windows controls this tool does not support, and others it supports only partially. But because I see a lot of benefits in using this approach, especially for small applications, I invite you to contact me via email for an updated version of this tool or to contribute improvements. I will continue to use and update this tool. I'm also working on a version that generates code compatible with OWLNext, a freeware upgrade to Borland OWL.</p>
<p>The conversion of VCL events, which are also properties, into Windows messages remains to be explored.</p>
<p>Even with some limitations, I've really changed the way in which I actually work. There are several situations in which I don't need all the power of VCL, but just some BCB RAD facilities to generate a small executable or DLL. In my example, I've avoided writing many (hundreds) of lines of code, which were automatically generated by this utility; reduced the executable size to one-tenth; and cut the build time by more than two.</p>

<p><i><B>Luigi Bianchi</B> lives in Rome and has a degree in Electronic Engineering from the University of Rome "La Sapienza." He is a freelance consultant and a researcher at the University of Rome "Tor Vergata," where he is involved in a Brain Computer Interface project and real-time processing of Biological data for disabled people. He has been working in C++ under Windows since 1994. He can be reached at <B>theboss@luigibianchi.com</B>.</i></p>

<h4><a href="../../../source/2000/aug00/bianchi.zip">Get Article Source Code</a></h4>


</blockquote></body></html>
