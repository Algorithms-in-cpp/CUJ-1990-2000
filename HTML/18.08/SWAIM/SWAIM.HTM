<HTML>   
     <HEAD>
<TITLE>August 2000/A Simple Linear Regression Class</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">A Simple Linear Regression Class</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">David C. Swaim II</FONT></H3>

<BLOCKQUOTE>
<p>Even an operation as simple as linear least squares can benefit from encapsulation in a class.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<p>I began my computer career years ago while I was a student studying physics in college. One of the earliest things I used a computer for was statistical analysis of experimental data. Because of this I developed an interest in numerical analysis. As fate would have it, I eventually transitioned from a physicist writing programs to a programmer working on engineering and scientific applications. During that transition my programming language of preference mutated through Basic and Pascal to C and finally C++. I still find some numerical methods useful in my work and have translated many an algorithm to C and C++. A numerical tool I frequently use is one to fit data to a linear or straight line curve.</p>

<H4><FONT COLOR="#000080">Linear Regression</FONT></H4>

<p>Linear regression analysis, sometimes called the method of least squares, involves fitting a best-fit straight line to a set of data points. Scientist and engineers are often faced with having to make this type of analysis on experimentally gathered data. The analysis consists of determining the coefficients <I>a</I> and <I>b</I> in the equation <I>y = a + bx,</I> where <I>y</I> is the dependent variable and <I>x</I> is the independent variable. The coefficient <I>a</I> is the value of <I>y</I> when <I>x</I> is zero and is called the <I>y</I> intercept. The coefficient <I>b</I> is the slope of the line or the amount <I>y</I> changes when there is a given change in <I>x</I>. The slope, sometimes called the gradient, determines the angle of the line when it is plotted on a graph.</p>
<p>It is also nice to know how well the set of data fits the equation. There are several statistical coefficients for determining the "goodness" of the fit. These are the standard error of the estimate, the correlation coefficient, and the coefficient of determination. Of these the main one is the correlation coefficient, which is the square root of the coefficient of determination. It is sometimes referred to as the linear correlation coefficient. This coefficient has a value of one if the data is a perfect fit. If the data is perfectly random (no fit) the coefficient has a value of zero.</p>
<p>Due to experimental fluctuations you will never get zero or one, but some fraction in between. Given any correlation coefficient there is always a statistical chance that totally random data could give the same coefficient. Tables have been developed for determining this probability based on the number of data points used in the regression analysis. Reference 2 has such a table. For the purposes of this article it is sufficient to know two things:</p>

<UL><LI>   The higher the correlation coefficient the more certain you can be that the curve fits the data.
<LI>   The more data points in your analysis the more certain you can be that the curve fits the data even with a lower correlation coefficient.</UL>

<p>For example, if an analysis using ten data points resulted in a correlation coefficient of 0.765 there is only a 0.01 (or one per cent) probability that this could have occurred from purely random data. If 100 data points were used in the analysis there is only a 0.001 (or 0.1 per cent) probability that purely random data could result in a correlation coefficient greater than only 0.327 (Reference 2). The moral to this story is that you should gather as much data as you can for the analysis.</p>
<p>The standard error of the estimate comes into play when you use the coefficients (<I>a</I> and <I>b</I>) to estimate a future point on the curve. There is a 68 per cent probability that the real value is between the value estimated by the regression analysis plus the standard error and the estimated value minus the standard error. So if the regression analysis predicts a <I>y</I> value of 55 and the standard error of the estimate is 0.55 there is a 68 per cent chance that the actual value is between 55.55 and 54.45. There is a 99 per cent probability that the real value lies within 2.58 times the standard error of the estimated value.</p>

<H4><FONT COLOR="#000080">A C++ Class</FONT></H4>

<p>As a "born again" object-oriented programmer, I have noticed that the published references on numerical programming, even though some of them are using C++, tend to treat numerical analysis strictly as a set of algorithms. Most of the code I have seen consists of sets of simple functions which do the analysis or part of it. Typically an entire program is devoted to just a single linear regression analysis on one set of data. When I was converting my old programs to C++ I approached my linear regression code in an object-oriented way. Of course this meant encapsulating the regression analysis into a C++ class. The linear regression class that resulted from my efforts turned out to be very simple.</p>
<p>The code in <B>linreg.h</B>, shown in <a href="list1.htm">Listing 1</a>, contains the definition of my linear-regression analysis class. There are two classes defined in this header file. The first is a very simple class to define a two-dimensional point on a plane. This class, <B>Point2D</B>, is self contained in the header file. There are more robust implementations of point classes (this one is extremely simple) but <B>Point2D</B> has enough functionality to serve the <B>LinearRegression</B> class. All I really wanted in this case was a class to group my <I>x</I> and <I>y</I> values into a logical pair.</p>
<p>The main linear-regression class, <B>LinearRegression</B>, is the second one defined in <a href="list1.htm">Listing 1</a>. This class accepts data points and calculates the coefficients for the straight line. All calculated coefficients, including the error and correllation coefficients, are available from member "get" functions. In addition, I overloaded the insertion operator to print the coefficients to a standard C++ output stream. I chose not save the individual data points in the class to keep it as simple as possible. All I keep up with are the sums needed to do the regression calculation. The calling function can keep up with the individual data points if it needs to.</p>
<p>The code in <B>linreg.cpp</B>, shown in <a href="list2.htm">Listing 2</a>, is the implementation code for the <B>LinearRegression</B> class. I provided constructors for creating a <B>LinearRegression</B> instance using an array of <B>Point2D</B> data or a pair of arrays of <I>x</I> values and <I>y</I> values. The <B>Point2D</B> constructor doubles as the default constructor. You can use the <B>havedata</B> member function to determine if there is enough data in the instance to calculate the coefficients. You need at least three points for the math to work (considerably more for the statistics to be significant). The <B>addXY</B> and <B>addPoint</B> member functions are used to add individual data points to the <B>LinearRegression</B>.</p>
<p>The <B>Calculate</B> member function actually calculates the coefficients. This function is a protected utility function. It is called by <B>addXY</B> each time a data point is added. The <B>addPoint</B> function simply calls <B>addXY</B>. The constructors also use <B>addXY</B> to load data so that all the data will go through <B>addXY</B>. This insures that the coefficients remain updated no matter how the data points enter the object.</p>
<p>You can get the coefficients from the <B>LinearRegression</B> at any time using the "get" functions. One of the reasons to do curve fitting is so you can estimate the values of points you have not measured. The <B>LinearRegression</B> class provides the <B>estimateY</B> member function for this operation.</p>
<p>A simple test program utilizing the <B>LinearRegression</B> class is in <B>lrtest.cpp</B>, shown in <a href="list3.htm">Listing 3</a>. It illustrates all three methods of instantiation of the class using the same data. The program is extremely simple. The only critical information that the program must provide to the first two objects, in addition to the arrays, is the number of points represented in the arrays. If you don't know how many points you will be loading ahead of time the best method is to create an empty instance and fill it one point at a time using <B>addXY</B> or <B>addPoint</B>. The object will keep up with the number of points it represents.</p>

<H4><FONT COLOR="#000080">LinearRegression as a Base Class</FONT></H4>

<p>Sometimes you run across situations where the data fits a curve that is still simple but not linear. An example of this is nuclear decay, which follows an exponential decay curve. For data analysis you need a regression analysis that uses the equation <B>y = a * exp(b * x)</B>. You can convert this equation to a linear one by taking the logarithm of both sides to obtain <B>ln(y) = ln(a) + b * x</B>, where <B>ln</B> is the natural logarithm. The new equation is now linear (the logarithm of <B>y</B> varies linearly with <B>x</B>).</p>
<p>Using inheritance it is easy to create an <B>ExponentialRegression</B> class using the <B>LinearRegression</B> class as the base class. The code in <B>expreg.h</B>, <a href="list4.htm">Listing 4</a>, illustrates how this may be done. The only member functions I had to override in this class were the the <B>addXY</B> data entry function, the <B>getA</B> function and the <B>estimateY</B> function. Note that the <B>addXY</B> function makes the appropriate modification to the data to make it linear and passes it on to the <B>addXY</B> function in the base class. The main point here is that the child class must modify the data going in to match the linear form of the equation and it must modify the data coming out through the "get" functions so they are correct for the equation being modeled. The constructors for the derived class can be duplicates of the base class constructors or they could just invoke the base-class constructors. Because of this I did not include the implementation file for the derived class.</p>
<p>I did some preparation in the <B>LinearRegression</B> class to make it work better as a base class. Since I might want to refer to the derived class objects using base class pointers I made some of the base class functions virtual. This insures, for example, that the correct <B>addXY</B> member function will be executed. Remember, all data added to the class must go through the <B>LinearRegression::addXY</B> member function to insure the coefficients stay updated at all times.</p>
<p><B>Decay.cpp</B>, shown in <a href="list5.htm">Listing 5</a>, illustrates the use of the <B>ExponentialRegression</B> class. Like the test program in <B>lrtest.cpp</B>, <a href="list3.htm">Listing 3</a>, the program is short and very simple. Again I demonstrated more than one instance of the class. This time I used two different sets of data. The object of this program is to determine the decay constant so you can determine what isotope is producing the radioactivity. In this case <B>b</B> is the decay constant. Once <B>b</B> is determined it is just a matter of looking it up in physical tables to determine the isotope responsible. As you can see the <B>ExponentialRegression</B> class is just as easy to use as the <B>LinearRegression</B> class.</p>

<H4><FONT COLOR="#000080">Conclusion</FONT></H4>

<p>My main motivation for building these classes was to have an object-oriented set of regression-analysis tools. I was pleased to discover how easy it was to make the <B>LinearRegression</B> class and to derive other classes using the <B>LinearRegression</B> class as the base class. These simple classes have been very useful numerical-analysis tools for me. They are so simple that I have used them as illustrations in some of the object-oriented programming classes I teach. They make very good examples of C++ reuse at work.</p>

<H4><FONT COLOR="#000080">References</FONT></H4>

<p>1.  William H. Press, et. al. <I>Numerical Recipes in C</I> (Cambridge University Press, 1992).</p>
<p>2.  Hugh D. Young. <I>Statistical Treatment of Experimental Data</I> (McGraw-Hill, 1962).</p>
<p>3.  Milton Smith. <I>A Simplified Guide to Statistics, 4th ed.,</I> (Holt Rinehart and Winston, 1970).</p>
<p>4.  Ramond Annino and Richard Driver. <I>Scientific and Engineering Applications with Personal Computers</I> (John Wiley &amp; Sons, 1986).</p>
<p>5.  Lon Pool, et. al. <I>Some Common BASIC Programs</I> (Osborne/McGraw-Hill 1980).</p>

<p><i><B>David C. Swaim II</B> has a B.S. degree in Physics, a professional degree in Mechanical Engineering, a Masters degee in Physics, and a Ph.D. in Applied Physics. He is a senior information systems analyst for Southern Company Services in Atlanta, Georgia and also a member of the adjunct faculty at Gwinnett Technical Institute in Lawrenceville, Georgia, where he teaches C++ and object-oriented programming. His email address is <B>David@Swaim.com</B>.</i></p>

<h4><a href="../../../source/2000/aug00/swaim.zip">Get Article Source Code</a></h4>

</blockquote></body></html>
