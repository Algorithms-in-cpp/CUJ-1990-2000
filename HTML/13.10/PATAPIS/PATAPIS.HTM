

<HTML>
<HEAD>

<TITLE>October 1995/Design Patterns, Elements of Reusable Object-Oriented Software</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Book Reviews</FONT></H2>

<hr><h2 align="center"><font color="#800000">Design Patterns, Elements of Reusable Object-Oriented Software<A name="016F_00D6"><A name="016F_00D6"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="016F_0000"><A name="016F_0000">reviewed by George Patapis</font></h3><hr><blockquote><P>
<P><i><A name="016F_0000"><A name="016F_0000">George Patapis has been developing software for over ten years, initially as a hobby and now for  Telecommunications companies. He graduated with an Honors Degree in Computer Science from Macquarie University, Sydney, Australia in 1991. His areas of expertise and interest are Distributed Systems, Network Management, QAS, and Object-Oriented Software Engineering.</i></P><P>
I first heard about the term "Patterns," as used in software development, at a seminar given by Grady Booch back at Object World 1993. Ever since then I wanted to learn more about patterns but it wasn't until the release of this book that I had a chance to fully appreciate the concept and gain a better understanding of it.<P>
The authors identify this as a book of "design patterns that describe simple and elegant solutions to specific problems in object-oriented software design." If you have ever wondered how you can use OO to create programs that are more resilient to change, more modular, and more pleasing to the eye, then this book could be for you.<P>
<h4><FONT COLOR="#000080"><A name="016F_00D7">Book Contents<A name="016F_00D7"></FONT></h4></P>
The first chapter of this book is an introduction to design patterns. Rather than provide an abstract definition for patterns, I let the patterns' overall form speak for itself: a pattern is identified by its name, the problem it tackles, the solution it offers, and the consequences of applying the pattern. The book uses a common structure to describe each pattern, composed of the following headings: Pattern Name and Classification, Intent, Also Known As, Motivation, Applicability, Structure, Participants, Collaborations, Consequences, Implementation, Sample Code, and Known Uses and Related Patterns. To depict the object and class relationships, the authors use Rumbaugh's OMT style notation. (A summary of OMT notation appears in a separate section of the book; a reference also appears on the back cover.)<P>
The first chapter also contains a catalog of the patterns, a section on how design patterns solve design problems, and tips on selecting and using a pattern.<P>
The second chapter is a case study, built around the design of a document editor. The case study covers several of the cataloged patterns. Encountering fleshed-out examples so quickly is a bit like being thrown into the deep end and learning how to swim &#151; which I didn't mind in the least. This case study also helps introduce the rest of the design pattern examples, the vast majority of which seem to have stemmed out of GUI development. It's no surprise that so many of these patterns originated in GUIs, considering how much effort the industry has poured into producing applications that are GUI-independent, or GUI frameworks that are platform-independent. Whatever their origin, the patterns can be applied to other software segments; I felt a bit let down that the GUI bias robbed attention from other areas, such as Telecommunications applications. Maybe it's time we start creating and documenting some of those too!<P>
Chapter three onwards comprise a more elaborate version of the Design Pattern Catalog. This catalog consists of three main groups of patterns, organized according to function. They are summarized as follows:<P>
<UL><li>Creational Patterns &#151; deal with the instantiation of objects</li>
<li>Structural Patterns &#151; deal with the composition of classes and objects</li>
<li>Behavioral Patterns &#151; deal with how classes and objects interwork</li></UL>
The book makes a further distinction between patterns that apply to classes which are static and primarily use inheritance to establish relationships, and patterns that apply to objects which are more dynamic and can establish relationships dynamically (at run time). Most patterns fall into the latter category.<P>
Since all following chapters except the last go through each pattern, I present a quick run-down on them and use the examples where convenient.<P>
<h4><FONT COLOR="#000080"><A name="016F_00D8">Creational Patterns<A name="016F_00D8"></FONT></h4></P>
The Creational Patterns include the following:<P>
Abstract Factory. Think of a GUI Toolkit that needs to support multiple look-and-feel standards. Abstract the widgets needed and hide the concrete widget classes from the client. Each collection of a concrete widget class then supports a specific look-and-feel standard but the user of the Toolkit always accesses it through the same common interface.<P>
Builder. Consider a program that parses Rich Text Files (RTF) and must save them in many different formats (e.g. ASCII Text, TeX Text). The Builder pattern separates the mechanics of parsing (reading) the RTF, from the algorithms of creating and building new representations (ASCII, TeX).<P>
Factory Method. Define an interface for the creation of an object but let subclasses decide which class to instantiate.<P>
Prototype. Specify the kinds of objects to create by using a prototypical instance, and create new objects by copying this prototype.<P>
Singleton. For systems that contain a class that can have exactly one instance (e.g. a printer spooler), make that class responsible for keeping track of its sole instance.<P>
<h4><FONT COLOR="#000080"><A name="016F_00D9">Structural Patterns<A name="016F_00D9"></FONT></h4></P>
Adapter. If a class's interface is not exactly what a client expects, use either inheritance or object composition with the old class interface to provide a new interface that meets client expectations.<P>
Bridge: Decouple an abstraction from its implementation. This allows the two class hierarchies to vary independently.<P>
Composite. Compose objects into tree structures to represent part-whole hierarchies. Clients use individual objects and compositions of objects in exactly the same manner.<P>
Decorator. Suppose you have a user interface toolkit and you wish to make a scrolling feature available to your components, rather than subclassing and making it available to all classes. To implement the Decorater pattern extend functionality by encapsulating this feature in a new object called <I>decorator</I> to provide the new functionality when required.<P>
Facade. If you break a large system up into subsystems, provide one class that becomes the interface to a subsystem, thus hiding all internal complexity. This object becomes the facade!<P>
Flyweight. The Flyweight pattern specifies a way of reusing objects, to save space by separating the state-dependent and state-independent parts of an object.<P>
Proxy. Suppose you have a document editor and within it, resource-hungry bitmapped images may be included. You do not want to instantiate such objects unnecessarily because of resource considerations (it may take several seconds for each image to appear when you bring up a document). Use a placeholder, or <I>proxy</I> object which will instantiate and make the image available if and when required.<P>
<h4><FONT COLOR="#000080"><A name="016F_00DA">Behavioral Patterns<A name="016F_00DA"></FONT></h4></P>
Chain Of Responsibility. This pattern is used to decouple sender and receiver objects. A message arrives and gets passed from object to object until it reaches the object meant to handle it.<P>
Command. Encapsulate requests to objects as an object in their own right. This pattern is useful for building history lists of operations, enabling, for example, undo facilities in applications.<P>
Interpreter. This looks to me like a an OO way of doing what lex and yacc do.<P>
Iterator. This is a well-known approach to traversing elements of an aggregate object (list, queue etc.) without exposing its underlying implementation mechanisms.<P>
Mediator. If you need a lot of objects in your system to implement the system's behavior, then a mediator object can act as a "one stop shop" for all the objects. All the objects go through the mediator rather than having to know about and interact with all their peer objects. The mediator pattern thus reduces coupling.<P>
Memento. This pattern provides a way to save an object's state information.<P>
Observer. Suppose you have a GUI that is representing some of your database data with multiple views, such as a spreadsheet view, a pie chart view, and a bar chart view. Each view is an observer of the data, which is the subject. The observers register to the subject that they would like to be notified of any changes to it. When one observer changes the data, the subject then notifies the other interested observers.<P>
State. Represent the different states of an object as objects in their own right. Provide one interface to the outside world but allow each state object to implement its relevant behavior.<P>
Strategy. Encapsulate algorithms into a class, all sharing the same interface. Let clients pick the algorithm to use.<P>
Template. Allow subclasses to implement parts of an algorithm in an operation.<P>
Visitor. If you have a large object structure and different kinds of operations must be applied to the parts of this structure, encapsulate these operations in Visitor objects which execute the operations for each object member of the structure.<P>
Chapter 6 concludes the book with some history on patterns and on the process which lead to the writing of the book.<P>
<h4><FONT COLOR="#000080"><A name="016F_00DB">What Patterns Mean<A name="016F_00DB"></FONT></h4></P>
In order of increasing complexity, here is where I place patterns in relation to other software constructs: algorithms, idioms, design patterns, frameworks. In fact, this book often references idioms as presented in James Coplien's book, <I>Advanced C++ Programming Styles and Idioms</I> <a href="#1">[1]</a> (makes me want to go back and also read James's book!).<P>
My favorite patterns include singleton, facade, observer, and state. They are not particularly complex but I have had need of them on many occasions. They appear simple to implement and cross many application domain boundaries.<P>
<h4><FONT COLOR="#000080"><A name="016F_00DC">Audience, Uses For Book<A name="016F_00DC"></FONT></h4></P>
This book is for the experienced developer. You'll want plenty of exposure to software design and architecture before tackling this book, and the more C++ you know, the better! I always learn more from studying examples; this book accompanies each pattern with sample code, and most of it is in C++ (and not the elementary stuff). A bit of Smalltalk appears here and there as well.<P>
The authors derive all patterns from real-world applications. After reading this book you cannot help feeling more knowledgable and appreciative of Object Oriented Design.<P>
This is not a very long book, approximately 400 pages, unfortunately. I say unfortunately because the Software Engineering field needs more such documented patterns on which future developers can build. This book makes a good start but I hope to see many more volumes added.<P>
I find the book well organized, and after reading it the first time through I can now use it as a valuable reference. (The front cover shows a summary of the patterns together with their page number in the book.)<P>
I do not do justice to the patterns with my very quick reference as presented earlier. I hope though, that my brief reference will entice you to read this book and add it to your collection. Even if you find only one useful pattern it can save you hours of effort and cover the cost of buying the book.<P>
<h4>Reference</FONT></h4></P>
<a name="1"></a>[1]     James Coplien. <I>Advanced C</I>++ <I>Programming Styles and Idioms</I> (Addison-Wesley, 1991).<P>
Title:        <I>Design Patterns, Elements of Reusable Object-Oriented Software</I><br>
Authors:    Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.<br>
Publisher:  Addison-Wesley<br>
Price:       $39.76<br>
Pages:       416<br>
ISBN:        0-201-63361-2<P>
</BLOCKQUOTE>
</BODY>
</HTML>
