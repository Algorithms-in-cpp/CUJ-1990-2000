

<HTML>
<HEAD>

<TITLE>October 1995/Image Processing in C, Part 14: Warping and Morphing</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Image Processing in C, Part 14: Warping and Morphing<A name="0154_00D2"><A name="0154_00D2"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0154_0000"><A name="0154_0000">Dwayne Phillips</font></h3><hr><blockquote><P>
<P><i><A name="0154_0000"><A name="0154_0000">Dwayne Phillips works as a computer and electronics  engineer with the U.S. Department of Defense. He has a PhD in Electrical and Computer Engineering from Louisiana State University. His interests include computer vision, artificial intelligence, software engineering, and programming languages.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0154_00D3">Introduction to the Series of Articles<A name="0154_00D3"></FONT></h4></P>
This is the 14th in a series of articles on the C Image Processing System (CIPS) that performs image-processing operations on grayscale images. Previous articles in the series discussed reading, writing, displaying, and printing images (TIFF format), histograms, edge detection, spatial frequency filtering, sundry image operations, image segmentation, working with shapes, and geometric operations (see sidebar for an index). This article extends the discussion of geometric operations and delves into warping and morphing (Hollywood &#151; here we come).<P>
Image warping is a technique that Hollywood discovered in the 1980's. The result is the magic we see every day in commercials, music videos, and movies. Warping (and its cousin morphing) "melts" old cars into new ones and can turn a car into a tiger.<P>
<h4><FONT COLOR="#000080"><A name="0154_00D4">Image Warping<A name="0154_00D4"></FONT></h4></P>
Image warping is a technique that bends and distorts objects in images. Remember when we used to press a flat piece of silly putty on a newspaper to copy the image to the silly putty? Grabbing and pulling the silly putty distorted the appearance of the image. We could bend and stretch the silly putty until the objects in the image took on weird and wonderful shapes. Image warping does the same for digitized images.<P>
Image warping actually began as early as the 1960's with early space probes. Pictures of the moon produced by the "cameras" on the probes were distorted &#151; straight lines appeared bent and the objects were out of proportion. Image processors at the Jet Propulsion Laboratory <a href="#1">[1]</a> transformed these square images into pie shapes, which had straight lines where straight lines belonged.<P>
The basic idea behind warping is to transform a quadrilateral to a rectangle <a href="#2">[2]</a>. A quadrilateral is a four-cornered region bounded by straight lines (a rectangle is a special case of a quadrilateral). Transforming a quadrilateral to a rectangle warps the objects inside the quadrilateral.<P>
<A href="fig1.htm">Figure 1</a>
shows a quadrilateral with a point P inside. Transforming a quadrilateral to a rectangle requires finding the coordinates of any point P inside the quadrilateral. This is possible given the coordinates of the four corners P1, P2, P3, and P4 and the fractions a and b along the edges. The key to finding P is a technique called bi-linear interpolation. In the previous installment to this series <a href="#3">[3]</a> a form of this technique, called <I>gray level bi-linear interpolation</I>, determined the gray level of a pixel between other pixels. <I>Spatial</I> bi-linear interpolation works in a similar fashion to find the location of a pixel between other pixels.<P>
(Note: This article deals with shapes divided into four parts. As a convention, I number the parts 1, 2, 3, and 4, where part 1 is in the upper left-hand corner, and 2 through 4 are found by proceeding clockwise.)<P>
Equations (1) through (7) (see box, <a href="sidebar1.htm">"Spatial Bi-linear Interpolation"</a>) show how bi-linear interpolation determines the coordinates of point P. If mathematical derivation is not for you, skip down to the results in equations (6) and (7). The source code shown later will implement these equations. These equations interpolate along the top and bottom of the quadrilateral and then along the sides. In the equations, a and b are fractions (0 &lt; a &lt; 1, 0 &lt; b &lt; 1).<P>
Equation (1) finds point Q by interpolating between points P1 and P2 using a. Equation (2) finds point R by interpolating between points P3 and P4 using a. Equation (3) finds point P by interpolating between Q and R using b. Equation (4) is the result of substituting the values of Q and R from equations (1) and (2) into equation (3). Equation (5) gathers all the terms from (4).<P>
Equations (6) and (7) are the final answers. Equation (6) shows how to find the x-coordinate of any point P given the x-coordinates of the quadrilateral's four corners and the fractions a and b. Equation (7) does the same for the y-coordinate. The subroutines described below implement equations (6) and (7). Notice the ab term in the equations. This term introduces non-linearities (curves) into the results.<P>
<h4><FONT COLOR="#000080"><A name="0154_00D5">Two Ways to Warp<A name="0154_00D5"></FONT></h4></P>
In this article I implement two kinds of warping. The first is control point warping illustrated in <A href="fig2.htm">Figure 2</a>.
 Take a square section of an image (such as a <I>ROWSxCOLS</I> array) and divide it into four smaller squares 1, 2, 3, and 4. Pick a control point anywhere inside the square section. This control point divides the square section into four quadrilaterals as shown in the top part of <A href="fig2.htm">Figure 2</a>.
 Equations (6) and (7) will transform these four quadrilaterals back into the four squares as shown in the bottom part of <A href="fig2.htm">Figure 2</a>.
 This will warp the objects in the image. The control point effectively dictates the kind of warping that is done.<P>
<A href="list1.htm">Listing 1</a>
shows how CIPS implements control point warping. Function <I>warp</I> controls the process and calls functions <I>warp_loop</I> and <I>bi_warp_loop</I>. Inputs to <I>warp</I> include the usual file names, image arrays, and line and element coordinates. Inputs specific to warp are the x and y control points and the <I>bilinear</I> parameter. The control points control the warping, and <I>bilinear</I> specifies whether to call function <I>warp_loop</I>, or <I>bi_warp_loop</I>. Both functions perform spatial bi-linear interpolation, but <I>bi_warp_loop</I> throws in an extra <I>gray level</I> bi-linear interpolation step to produce a higher quality image. If <I>bilinear == 0</I>, warp calls <I>warp_loop</I>, otherwise it calls <I>bi_warp_loop</I>.<P>
<I>warp</I> operates on the four quarters of the <I>ROWSxCOLS</I> image section, one quarter at a time. At each quarter, <I>warp</I> sets (<I>x1, y1</I>) through (<I>x4, y4</I>) to the corner coordinates of the quadrilateral formed by the control point, then sets the <I>extra_x</I> and <I>extra_y</I> variables to the upper left-hand corner of the small square associated with that quadrilateral. Setting these variables provides all the information needed to implement equations (6) and (7). <I>warp</I> calls <I>warp_loop</I> for quick warping or <I>bi_warp_loop</I> to use gray-level bi-linear interpolation for a better (albeit slower to complete) image.<P>
<h4><FONT COLOR="#000080"><A name="0154_00D6">Function <B><I>warp_loop</I><A name="0154_00D6"></B></FONT></h4></P>
<I>warp_loop</I> implements equations (6) and (7) to transform a small quadrilateral to a small square. To do so, it sets up the coefficients for the equations &#151; the variables <I>xa, xb</I>, and <I>xab</I> correspond to a, b, and ab from equation (6), and <I>ya, yb, yab</I> correspond to a, b, ab from equation (7). The loops that iterate over <I>i</I> and <I>j</I> calculate the coordinates of the pixels in the input image that will be copied to the output image (<I>x_out</I> and <I>y_out</I>). If <I>x_out</I> or <I>y_out</I> lie outside the <I>ROWSxCOLS</I> array, <I>output_image</I> is set to a <I>FILL</I> value. Otherwise, the <I>output_image</I> pixel is set to the proper pixel from <I>the_image</I>.<P>
<h4><FONT COLOR="#000080"><A name="0154_00D7"><I>bi_warp_loop</I><B> and Friends<A name="0154_00D7"></B></FONT></h4></P>
<I>bi_warp_loop</I> performs the same operations as <I>warp_loop</I>; however, <I>bi_warp_loop</I> uses floating-point math and calls the <I>bilinear_interpolate</I> subroutine to set the final output pixel value. Thus, <I>bi_warp_loop</I> produces better results than <I>warp_loop</I>. It also takes more time. I recommend using <I>warp_loop</I> for quick experiments and <I>bi_warp_loop</I> for presentation results.<P>
<I>bilinear_interpolate</I> appears as the final routine in <A href="list1.htm">Listing 1</a>.
 I presented this routine in "Geometric Operations" <a href="#3">[3]</a> and I repeat the code here for those who may have missed that article.<P>
The top image in <A href="photo1.htm">Photograph 1</a>
shows some results of control point warping. The<P>
upper left quarter is the input image (a <I>ROWSxCOLS</I> array). The other three quarters show the result of picking a control point inside the <I>ROWSxCOLS</I> array. Repetitive warping can give an object almost any shape you want (windows the shape of circles, triangles, etc.).<P>
<h4><FONT COLOR="#000080"><A name="0154_00D8">Object Warping<A name="0154_00D8"></FONT></h4></P>
A second form of warping is what I call object warping. Instead of picking a control point inside the <I>ROWSxCOLS</I> array, the user picks the four corners of a quadrilateral as shown in <A href="fig3.htm">Figure 3</a>.
 Object warping transforms this quadrilateral to a <I>ROWSxCOLS</I> square. The four corners of the quadrilateral can be almost anywhere inside or outside the square. In some ways, object warping is more versatile than control point warping, because control point warping did not support quadrilaterals whose corners were outside the square.<P>
<A href="list2.htm">Listing 2</a>
shows how CIPS implements object warping. Function <I>object_warp</I> is very similiar to <I>warp</I>; it controls the process and calls either <I>full_warp_loop</I> or <I>bi_full_warp_loop. object_warp'</I>s inputs are nearly the same as <I>warp'</I>s except <I>object_warp</I> receives the four corners of the quadrilateral (x1, y1 through x4, y4) instead of the control points. The <I>bilinear</I> parameter controls whether <I>object_warp</I> calls <I>full_warp_loop</I> (no gray level bilinear interpolation) or <I>bi_full_warp_loop</I> (gray level bilinear interpolation and floating-point math).<P>
<I>full_warp_loop</I> and <I>bi_full_warp_loop</I> perform the same function as their cousins <I>warp_loop</I> and <I>bi_warp_loop</I>, but the <I>full_warp_loop</I> routines loop over an entire <I>ROWSxCOLS</I> array; the <I>warp_loop</I> routines only go through one quarter of the <I>ROWSxCOLS</I> array.<P>
Again, I recommend <I>full_warp_loop</I> for experiments and <I>bi_full_warp_loop</I> for presentation results.<P>
The bottom image in <A href="photo1.htm">Photograph 1</a>
shows some results of object warping. The upper left quarter shows the input image with the three other quarters showing results. The results are quite similar to those for control point warping. Note, however, that each result in the bottom image contains <I>FILL</I> values shifted in from outside the <I>ROWSxCOLS</I> square when the starting quadrilateral had corners outside the square.<P>
<A href="photo2.htm">Photograph 2</a>
shows what you can get by applying warping to a complete image. This image results from control point warping over several <I>ROWSxCOLS</I> arrays in the house's image file.<P>
This photo ought to spark your imagination. I'd say this was a house in the middle of a very bad earthquake. If we made a series of house images, with the control points moving from right to left, we could produce a motion picture that made the house ripple, like it was made of Jell-O. All we would need was a computer fast enough to generate 10,000 images and a motion picture camera. That's how they do it in Hollywood.<P>
<h4><FONT COLOR="#000080"><A name="0154_00D9">Morphing<A name="0154_00D9"></FONT></h4></P>
<I>Morphing</I> is the term most people use today to describe the melting of one object into another. Michael Jackson "morphed" to a panther; A car "morphed" to a tiger. The Mighty Morphin' Power Rangers . . . well that's another story.<P>
Morphing occurs as a sequence of images &#151; not a single image. A car becomes a tiger by showing a sequence of intermediate images. The transition appears magical when there are dozens of images shown every second in a film sequence.<P>
Morphing can be done as an extension to warping. Suppose we wanted to morph a dark circle to a bright triangle. The first step is to produce two sequences of images. One sequence warps the dark circle to a dark triangle. The second sequence warps the light triangle to a light circle (<A href="fig4.htm">Figure 4a</a>)
.<P>
The second step is to blend these two sequences into a third sequence. The third sequence is a weighted average of the first two; however, before blending to produce the third sequence we must first <I>reverse</I> one of the previous sequences (<A href="fig4.htm">Figure 4b</a>)
. The third, blended sequence handles the transition from one gray level to the next. If we placed one image of the third sequence in each frame of a motion picture film, we would have a smooth morphing.<P>
<A href="photo3.htm">Photograph 3</a>
illustrates the process. The objective here is to morph a window to a door. The far left frame of the middle row shows the original window. The far right of the middle row shows the final door.<P>
The top row of <A href="photo3.htm">Photograph 3</a>
shows how the window warps up to the size and shape of the door, in two steps. I use object warping and with each step pick a quadrilateral smaller than the <I>ROWSxCOLS</I> array. The output of each step is an enlarged window.<P>
The bottom row of <A href="photo3.htm">photograph 3</a>
shows how the door warps down to the size and shape of the window. Just as I expand the window in two steps, I shrink the door in two corresponding steps, by picking a quadrilateral larger than the <I>ROWSxCOLS</I> array. The output of each step is a smaller door. (However, you must read this bottom sequence from right to left, as I've reversed it here in preparation for blending.)<P>
The three frames in the center of the middle row show the result of a weighted average. (An average is the result of adding two images together and dividing by two. A weighted average is the result of adding an image to itself several times, adding this result to another image, and dividing by &lt;number of additions&gt; + 1.)<P>
The frame closest to the original window results from averaging two shots of the leftmost window from the top row and one shot of the the leftmost door from the bottom row. The frame at dead center is the average of one shot of the middle window and one shot of the middle door. The frame closest to the final door results from averaging two shots of the rightmost door and one shot of the rightmost window.<P>
The sequence of frames in the middle row morph the window to the door. Of course, it would look much nicer had I used a sequence of 3,000 warps and averages instead of three. The procedure is the same, but the more steps between the start and the end, the better the effect.<P>
<h4><FONT COLOR="#000080"><A name="0154_00DA">Applying Warping and Morphing<A name="0154_00DA"></FONT></h4></P>
One application of warping is simple "shearing" of images. Shearing is what you get when push on one side of a flimsy rectangular frame, such as an unbraced scaffold. The top and bottom remain parallel to the ground, while the sides (as well as all verticals) become slanted. In a more severe form of shearing, all four sides become slanted, turning a rectangle into a diamond-like shape (in geometry-speak, a parallelogram). A related article <a href="#4">[4]</a> showed how to shear images to make them appear as pages of a turning book. Object warping and bi-linear interpolation can do the same thing without producing jagged lines.<P>
I make extensive use of MS-DOS batch files with CIPS. Since CIPS includes a number of stand-alone programs, it's easy to write batch programs to produce shearing, as well as the morphing sequence shown in <A href="photo3.htm">Photograph 3</a>.
 This month's code disk includes the batch file that produced <A href="photo3.htm">Photograph 3</a>.
 After studying how it works you should be able to produce neat effects of your own.<P>
This month's code disk also contains source code for a stand-alone warp utility. This utility collects command-line arguments and calls the routines described in the preceding article. You can also use it in a batch program.<P>
The professional morphing seen in the movies is hand-tuned by artists, and the sequences are not as straightforward as discussed above. For one thing, artists will take the sequences and manipulate individual pixels so they look just right. They also adjust the weighted averages using more complicated algorithms. In short, the principle is the same, but the professional images reflect the tender loving care put into them. This is a field that calls for tinkering and experimentation.<P>
<h4><FONT COLOR="#000080"><A name="0154_00DB">Summary<A name="0154_00DB"></FONT></h4></P>
This article discussed image warping and morphing. Warping bends or objects in images. Morphing is an extension of warping that melts one object into another, by simultaenously altering shapes and gray levels. Warping is an old technique with its roots in the space program of the 1960's. The ever-increasing power and decreasing price of computers brought these techniques to Hollywood. They are fun. Experiment with them and you can turn brick houses into Jell-O.<P>
<h4>References</FONT></h4></P>
<a name="1"></a>[1] Kenneth R. Castleman. <I>Digital Image Processing</I> (Prentice-Hall, 1979).<P>
<a name="2"></a>[2] Christopher Watkins, Alberto Sadun, Stephen Marenka. <I>Modern Image Processing</I> (Academic Press, 1993).<P>
<a name="3"></a>[3] Dwayne Phillips. "Image Processing, Part 13: Geometric Operations," <I>C/C</I>++ <I>Users Journal</I>, August: 1995, p. 23.<P>
<a name="4"></a>[4] Christopher Dean. "Bitmap Image Transformations," <I>The C Users Journal</I>, December: 1993, pp. 49-70.<P>

<h4><a href="../../../source/1995/oct95/phillips.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
