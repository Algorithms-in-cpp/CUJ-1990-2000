


<HTML>
<HEAD>

<TITLE>September 1990/A Flexible dprintf Function</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">A Flexible dprintf Function<A name="01FB_0115"><A name="01FB_0115"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="01FB_0000"><A name="01FB_0000">Arkin Asaf</font></h3><hr><blockquote><P>
<P><i><A name="01FB_0000"><A name="01FB_0000">Arkin Asaf has eight years of programming experience, the last two exclusive to the C language. He gets his kicks from writing small but useful utilities, and can be reached at 47 Berri St., Herzlya, Israel 46456.</i></P><P>
<h4><FONT COLOR="#000080"><A name="01FB_0116">About <B><I>dprintff</I><A name="01FB_0116"></B></FONT></h4></P>
Many applications could benefit from a specialized version of <I>printf</I>. Unfortunately, <I>printf</I> is too large and complex to re-invent, and it's often easier to get the source to a complex 3-D graphics library than to the pedestrian functions in a compiler's standard library.</FONT></FONT></FONT></FONT><P>
This article presents source code to <I>dprintf</I>, a clone of the <I>printf</I> function. With minute effort you can modify and adapt <I>dprintf</I> to suit your needs. You will find <I>dprintf</I> is mostly portable and expandable: it easily extends to accommodate newly devised formats; it can print to almost all output destinations, and it follows the ANSI standard.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="01FB_0117">Defining <B><I>dprint</I><A name="01FB_0117"></B></FONT></h4></P>
<I>dprintf</I> parallels <I>printf</I> in calling convention and operation except that it uses a pointer to a function as its first parameter. This pointer designates a function, resembling <I>putchar(),</I> which performs all output. Specifying the output function gives <I>dprintf</I> unlimited choice of output destinations. The pointer's definition and function prototypes are:</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>typedef   int (*dprintf_fp)(int);
int    dprintf(dprintf_fp Func,
            const char *Format, ...);
int   vdprintf(dprintf_fp Func,
            const char *Format, va_list Args);</pre>
<h4><FONT COLOR="#000080"><A name="01FB_0118">Variations On <B><I>dprintf</I><A name="01FB_0118"></B></FONT></h4></P>
Like most <I>printf</I> implementations, <I>dprintf</I> accepts a variable length argument list and passes a pointer to this list, along with pointers to the output function and format string to a subordinate function, in this case to <I>vdprintf</I>. Having so little to do, <I>dprintf</I> tends to be rather small &#151; as short as four statements long.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Since <I>vdprintf</I> accepts fixed arguments and is quite long, I advise that <I>dprintf</I> absorb all non-standard arguments, setting them for <I>vdprintf</I>'<I>s</I> convenience. For example, you could create a function <I>aprintf</I> which allocates a memory block in which to store output by revising <I>dprintf</I> as in <A href="list1.htm">Listing 1</a>.
 Note that <I>vdprintf</I> remains unchanged.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>vdprintf</I> cannot be insulated from all changes: new formats will require changes to <I>vdprintf</I>. You can easily create relatively portable versions of <I>dprintf</I> that support binary and Roman numerals, file and path names, and printer control codes. At a minimum, you must modify <I>vdprintf</I> to create a % pointer format, since this format varies considerably between system architectures.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="01FB_0119">The Workings Of <B><I>vdprintf</I><A name="01FB_0119"></B></FONT></h4></P>
This section and the following two describe the internal working of <I>vdprintf</I> (<A href="list2.htm">Listing 2</a>)
 in a stepwise manner.</FONT></FONT><P>
<I>vdprintf</I> outputs characters using a programmer-supplied function designated by a pointer. This function returns<I> EOF</I> upon output error. Rather than passing a pointer and return value through three levels of functions, a <I>static</I> pointer (<I>Out-Func) </I>and <I>longjmp</I> buffer (<I>dputc_buf</I> &#151; for quick return) are defined. Consequently, <I>vdprintf's</I> first actions involve assigning <I>OutFunc</I> a pointer and initializing <I>dputc_buf</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
With that done, the printing process begins: <I>vdprintf</I> scans the format string a character at a time, interpreting <I>%</I> specifications and echoing all other characters to the output.</FONT></FONT></FONT></FONT><P>
Following the <I>%</I> format sign come the flags - zero or more from a set of five: -, +, space, <I>0</I> and <I>#</I>. Successive flags are parsed from the format string one by one. <I>strchr()</I> matches each potential flag against <I>FlagsList</I>, returning either <I>NULL</I> (not a flag) or a pointer to the flag in <I>FlagsList</I>. Simple pointer substraction and bit shifting then produce a bit mask, which <I>OR</I>s onto <I>Flags</I>. Later on <I>vdprintf</I> will <I>AND Flags</I> with <I>Mask</I> macros to establish whether or not certain flags have been mentioned.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
With all flags read, <I>vdprintf</I> gathers the width and precision parameters. Widths are processed first (zero assumed, if absent), either as a numeric (deduced from digits in the format string) or an <I>int</I>, and if an asterisk replaces the numerals an argument is consumed from the arguments list. Leading zeros are considered a flag. Since the precision is separated by a period, it may begin with zero but otherwise is read similarly. Note that not specifying the precision value (zero assumed by default) differs from omitting the precision and period altogether (minus one assumed). For example, <I>"%5.s"</I> implies a zero-length string, whereas <I>"%5s"</I> implies a string of five or more characters.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Before the format letter comes the argument size: default, <I>short</I> (type <I>h</I>), <I>long </I>(<I>l</I>), or <I>long double (L)</I>. The <I>long</I> size applies only to integers, the <I>long double</I> size to floating points. Default may be <I>int, double</I> or any specialized type, such as <I>char</I> for the <I>%c</I> format. The <I>short</I> type serves only to maintain some compatibility with <I>scanf ()</I>, <I>short</I> arguments being automatically promoted to <I>int</I> and <I>float</I> arguments to <I>double</I> by the compiler. In effect, the <I>L</I> specifier is meaningless.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Finally, <I>vdprintf</I> reads the format letter, which determines how to generate the output. Most formats are provided by auxiliary functions in order to keep <I>vdprintf</I> short. If an output error or incorrect format specification is encountered at any point, <I>vdprintf</I> returns <I>EOF</I>; if all goes well, <I>vdprintf</I> returns the number of characters successfully printed.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="01FB_011A"><I>vdprintf's</I><B> Auxiliary Functions<A name="01FB_011A"></B></FONT></h4></P>
Five auxiliary functions assist <I>vdprintf: PrintDecimal, PrintRadix, PrintFloat, ToInteger</I> and <I>Print</I>. The first three transform <I>long ints, long unsigneds, </I>and <I>long doubles</I>, respectively, into printable strings of digits. <I>ToInteger</I> also transforms and <I>Print</I> does the actual printing.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>PrintDecimal</I> (<I>%d</I> or <I>%i</I> formats) produces signed decimals. It dissociates the received <I>long int</I> into prefix and value, the prefix holding the sign. Once <I>ToInteger</I> stringizes the value, <I>Print</I> outputs both the prefix and the value.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>PrintRadix </I>yields <I>long unsigned</I> decimals (<I>%u</I> format), octals (<I>%0</I>), hexadecimals (<I>%x</I> or <I>%X</I>) and pointers (<I>%p</I>). Since these values are always positive, the prefix, obtained in the variant format (# flag present), denotes the value's type: nothing for decimals, <I>0</I> for octals and <I>0x</I> for hexadecimals. (Note that hexadecimal letters are in the same case as the format letter.)</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
As presented in <A href="list2.htm">Listing 2</a>,
 <I>vdprintf's PrintRadix</I> utters eight-digit hexadecimal (upper case letters) pointers, which <I>@ </I>prefixes in the variant format. Various system architectures impose different pointer representation, both in memory and in writing. It may be essential that you modify not only <I>PrintRadix</I>, but also <I>vdprintf's </I>switch construct, which assumes pointers remain intact, cast to <I>long unsigneds</I>. Not all systems guarantee this.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Before printing, numeric values must be converted into characters. <I>ToInteger</I> turns <I>long unsigneds</I> into <I>NULL</I>-terminated strings of digits in a given radix. A numeral must have no less than <I>precision</I> number of digits; if necessary, zeros precede the value. <I>ToInteger</I> stores the string in a <I>malloc</I>'ed memory block. Its address returns by reference &#151; through formal parameter <I>char </I><I>**Buffer</I>. The string's length returns by value (terminating <I>NULL</I> excluded.)</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>Print</I> completes the auxiliary functions, printing the prefix and value in accordance with <I>Flags</I>. Normally, spaces are inserted before the prefix, right-justifying it and the value within their field (the width parameter sets the field). The <I>0</I> flag states that zeros come between the prefix and value to fill the field whole. The - flag appends spaces at the end, left-justifying the prefix and value. Regardless of the style used, no more than <I>Maximum</I> number of characters are printed (ignoring negative maximums). Finally, <I>OutCnt</I> increments by the total number of characters printed.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="01FB_011B">Outputting Floating Point<A name="01FB_011B"></FONT></h4></P>
<I>PrintFloat</I> starts with the prefix: negative values have a - prefix; positive values have either nothing (default), a space (space flag present) or a + prefix (plus flag present, space flag present or not).</FONT></FONT><P>
At the far right of the representation, all formats but <I>%f</I> require an exponent. The exponent results from dividing and multiplying the floating point number by ten until the resulting value is between zero and one. Divisions add to the exponent count; multiplication subtract. The <I>%g</I> format forces <I>vdprintf</I> to choose between the standard <I>(%f)</I> and engineering <I>(%e)</I> formats, whichever is shorter. If the exponent lies between <I>-3</I> and <I>precision</I> (inclusive), standard format governs (the exponent is cleared after it has been deducted from the precision). Otherwise, <I>vdprintf</I> selects engineering. Either way, the precision loses one digit off its end.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
In the algorithm's trickiest manipulation <I>vdprintf</I> must split a floating point number into integer and fractional parts. The integer rounding is accomplished by casting the floating point to <I>int</I> and then back to <I>float</I>. Twice an integer is created. The second time, the part of the fraction to be printed is moved left of the decimal point, and again cast to <I>int</I> and back. We now have the integer and fraction parts stringized.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The integer part prints first. In the <I>%g</I> format, trailing zeros are removed from the fraction. In some cases (e.g., zero precision) there may be no fraction. If the fraction follows or the # flag appears, a period follows the integer. Unrelated, the exponent follows. An <I>e</I> (in the same case as the format letter) precedes the exponent, which always contains a sign and at least two digits.</FONT></FONT></FONT></FONT><P>
During the process a <I>long double</I> was cast to <I>long</I><I> </I><I>int</I> and back. On some systems, long floating numbers may fail to convert properly, if at all (they may even raise an exception). A simple but imperfect solution uses the <I>floor</I> function to obtain the integer part of a floating point. This fix also requires changes to parts of <I>PrintFloat</I>. (See <A href="list3.htm">Listing 3</a>)
. This solution is imperfect because <I>floor</I> acts only on <I>doubles</I>, not <I>long </I><I>doubles</I>. Depending on your system and your demands on it, either version of <I>PrintFloat</I> should work.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>

<h4><a href="../../../source/1990/sep90/asaf.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
