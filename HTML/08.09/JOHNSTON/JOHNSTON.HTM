


<HTML>
<HEAD>

<TITLE>September 1990/Using An RPC Protocol To Create A Basic File Server</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Communications</FONT></H2>

<hr><h2 align="center"><font color="#800000">Using An RPC Protocol To Create A Basic File Server<A name="01F1_0111"><A name="01F1_0111"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="01F1_0000"><A name="01F1_0000">Richard Johnston</font></h3><hr><blockquote><P>
<P><i><A name="01F1_0000"><A name="01F1_0000">Richard Johnston is product development manager for Stony-Brook Technologies&#151;a network systems integrator and reseller.<I></I> <I></I>He has worked in the computer communications industry for ten<I></I> <I></I>years and has a B.S. in computer science from SUNY Brockport.<I></I> <I></I>He can be reached at (516) 567-6060.</i></P><P>
<h4><FONT COLOR="#000080"><A name="01F1_0112">The Client-Server Model<A name="01F1_0112"></FONT></h4></P>
Remote Procedure Call (RPC) protocols support network activities by supplying a mechanism to perform local functions on a remote system. An RPC protocol is designed to deliver the parameters from a local system function and return the response back to the originator. The local application is ignorant of whether the function executed directly on the local system or was shared with the remote.<P>
The application in this system is referred to as the <I>client</I>. A dedicated process on the remote system, called the <I>server</I>, performs the function and returns the results. Thus, RPC is a system built upon the <I>Client-Server Model</I>. A client-server system is depicted in <A href="fig1.htm">Figure 1</a>.
 Multiple processes can be clients and can make requests for services on the server. Typical client-server systems can be found in network file systems, distributed database systems, electric-mail systems, and even simple applications such as printer spoolers and terminal servers.<P>
<h4><FONT COLOR="#000080"><A name="01F1_0113">The Basic File System<A name="01F1_0113"></FONT></h4></P>
As an example of RPC design, this article will show how to implement an RPC protocol for remote file access. This basic file system (BFS) protocol was developed to emulate the network file systems that are available with LANs but the BFS is specifically designed to operate on a wide area network (WAN). X.25 was selected for the underlying communications medium since it provides most of the services normally found at the transport level (OSI Layer 4) &#151; reliable, in-order delivery with buffer segmentation and support for multiple destinations and sources. Although X.25 was selected, the BFS is not limited to this communications medium, and with modifications to the communications interfaces could be ported to other types of networks.<P>
The BFS is designed to allow multiple client systems to communicate with multiple server systems. A single file server system network would appear as if it was a star topology &#151; the file server in the middle with client systems at the end-points (see <A href="fig2.htm">Figure 2</a>)
. A network with several file servers and client systems would logically appear as a highly meshed network (all of the client systems could have a connection to every file server). The use of X.25 provides a much simpler network topology as shown in <A href="fig3.htm">Figure 3</a>.
<P>
<h4><FONT COLOR="#000080"><A name="01F1_0114">Client System Components<A name="01F1_0114"></FONT></h4></P>
The BFS client system is comprised of two components: the application interface (APL) and the client monitor (CMON). The APL is linked to user-written programs that will use remote files. The CMON operates as an independent process and is responsible for the associated intra-system routing and X.25 communications.<P>
The APL implements a group of routines called the <I>r</I>-functions (<A href="list1.htm">Listing 1</a>)
. These routines parallel the <I>f</I>-functions of the UNIX Streams interface (e.g. <I>fopen</I>, <I>fclose</I>, etc.). The parameters of the <I>r</I>-functions are the same as the <I>f</I>-functions except for three differences: the <I>rfopen</I> returns a pointer to an <I>RFILE</I> structure instead of a pointer to a <I>FILE</I> structure; the other routines use the <I>RFILE</I> pointer for the <I>rstream</I> parameter; and the <I>rfopen</I> filename parameter specifies both the name of a file server system and the name of the file on the file server.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The filename parameter follows the same format as UUCP file references: <I>&lt;server-name&gt;!&lt;file-name&gt;</I>. The server-name is a logical reference to the desired file server system and is mapped to an X.25 call address by the CMON.</FONT></FONT><P>
The CMON performs a routing/multiplexing function between the local applications and the networked file servers. When a file is requested the CMON will open an X.25 virtual circuit to the server monitor on the remote file server. Requests from the applications, for specific file servers, are multiplexed onto the appropriate virtual circuit. Likewise, responses from the file servers are routed to the original application. The RPC protocol contains both a client and server identifier which identifies the current session. The CMON performs only a minor translation of the routing information within the RPC protocol header and otherwise does not play an active role in the file access processing.<P>
<h4><FONT COLOR="#000080"><A name="01F1_0115">Server System Components<A name="01F1_0115"></FONT></h4></P>
The server system has a single component, the <I>server monitor</I> (SMON) which is responsible for processing requests from the client systems and executing the <I>r</I>-function operations on the local file system. The SMON decodes the RPC message, formats the proper <I>f</I>-function parameters, and then calls the local <I>f</I>-function routine. Any resulting status (or <I>errno</I> value) is returned as the RPC response message. For read operations, the data will follow the response; for write operations, the data follows the request message.</FONT></FONT><P>
The SMON is also responsible for the X.25 communications interface. Unlike the CMON which "calls" file ser- vers, the SMON "listens" for client systems attempting to establish an X.25 virtual circuit. The SMON must have a unique "listen" request pending for each client system for which it is configured to process requests. <A href="list2.htm">Listing 2</a>
and <A href="list3.htm">Listing 3</a>
contain sample client and server configuration files.<P>
<h4><FONT COLOR="#000080"><A name="01F1_0116">The BFS RPC Protocol<A name="01F1_0116"></FONT></h4></P>
The BFS RPC protocol is a custom protocol designed to support the r-functions and is not a general purpose RPC protocol. The RPC protocol uses a common message structure for all commands and responses. <A href="list4.htm">Listing 4</a>
contains the declarations of the common message format and the command and response specific portions. The protocol is a synchronous transaction-oriented protocol &#151; a command is sent to the server and the application waits for the response prior to initiating another transaction.<P>
Several implied operations are embedded within the protocol. The <I>RPC_FOPEN_CMD</I> message header is transmitted with the Server Session Identifier (SSID) set to -<I>1</I>, indicating to the server that a server session should be allocated. The server sends the allocated SSID in the <I>RPC_FOPEN_RSP</I> if the <I>fopen</I> function succeeded. A failure implies that no session is needed. Another implied operation occurs on the <I>RPC_FCLOSE_CMD</I>. When a server completes an <I>fclose</I> operation the session is deallocated unconditionally. The life expectancy for a client-server session is equal to the time that a remote file is open.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Each RPC command and response is transmitted in its own X.25 packet. Thus the server or client can wait for any packet and assume it to be an RPC message with a valid header. Data for read and write operations is transmitted as a separate packet (or packets depending on the size of the data field). The client or server will perform an isolated read or write to the virtual circuit to receive the data.<P>
The application programs, client monitor, and server monitor are tied together via the BFS's data structures (see <A href="list5.htm">Listing 5</a>)
. Each of the three entities is 'attached' by exchanging process/file <I>ids</I>, RPC session <I>ids</I>, or X.25 circuit/line <I>ids</I> with the next entity in the processing chain.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="01F1_0117">The Client Application<A name="01F1_0117"></FONT></h4></P>
The client application has two functional components: the user supplied program and the <I>r</I>-functions application interface (API). The <I>r</I>-functions application interface is a library of routines which support access to files on remote file servers. The application program can utilize the <I>r</I>-functions just as the <I>f</I>-functions <I>fopen</I>, <I>fclose</I>, <I>fread</I>, <I>fwrite</I> and <I>feof</I> would be used. The <I>r</I>-functions are <I>rfopen</I>, <I>rfclose</I>, <I>rfread</I>, <I>rfwrite</I>, and <I>rfeof</I>. With some exceptions, the parameters to the <I>r</I>-functions are the same as those for the <I>f</I>-functions. Specifically, the <I>rfopen</I> filename parameter's format is different &#151; it uses the UUCP-like format: <I>&lt;server-name&gt;!&lt;file-name&gt;</I>. The result of an <I>rfopen</I> call is a pointer to an <I>RFILE</I> structure. This is a control structure for opened remote files (it should not be directly accessed by the user program). The <I>RFILE</I> pointer is passed to the other routines as an <I>rstream</I> pointer (instead of the <I>stream</I> pointer that the <I>f</I>-functions use).</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="01F1_0118">Error Response<A name="01F1_0118"></FONT></h4></P>
While the individual routines operate like their local counterparts, the user should be aware that the status and <I>errno</I> results do not correspond to local file system conditions &#151; they refer to the remote file system conditions. This is important if an <I>rfopen</I> error indicates that the file does not exist. This behavior may confuse the first-time user who is attempting to access a file on the local system &#151; the file must exist in the proper directory of the remote file system.</FONT></FONT></FONT></FONT><P>
Even though brief, the <I>r</I>-functions supply an integral part of the three layers of functionality in the <I>bfs_apl</I> code (see <A href="list6.htm">Listing 6</a>)
. The <I>r</I>-functions routines validate the incoming parameters for the internal routines.</FONT></FONT><P>
The next (<I>arpc</I>) layer implements the application's RPC session protocol. The <I>arpc_fopen</I> routine requests that a file be opened on a remote server and the <I>arpc-fclose</I> routine requests that the file be closed. These two routines initiate and terminate the RPC session between an application and a file server. The <I>arpc_read</I> and <I>arpc_write</I> routines are responsible for transferring data between the application's buffers and the <I>fifos</I> to the client monitor.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>afifo</I> management routines perform the actual transfer of commands, responses, and user data. For each process these routines open a unique <I>fifo</I> (named <I>pipe</I>) for reading responses and incoming data flow. The a<I>fifo</I> routines also write outgoing commands and data to the system global <I>fifo</I> for the client monitor. The <I>afifos </I>are opened and closed based on a link count. The link count represent the current number of open <I>RFILE</I>s.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
A link count of zero indicates that the <I>fifo</I>s are not opened and that the <I>afifo_open</I> routine is executed. Close operations decrement the link count and close the <I>afifo</I>s when the count becomes zero.</FONT></FONT></FONT></FONT></FONT></FONT><P>
A sample application program is shown in <A href="list7.htm">Listing 7</a>.
 The program is simple but the power to access files from a remote system can be significant when used in distributed applications. The reader should note that the program will operate in the same manner as if the calls were all <I>f</I>-functions referencing files on the local system.<P>
<h4><FONT COLOR="#000080"><A name="01F1_0119">The Client Monitor<A name="01F1_0119"></FONT></h4></P>
A client system can have many applications interacting with many file servers. The client monitor (CMON) facilitates the orderly routing of data between the file server systems and the client system. The CMON is launched during system startup and executes as a background task. During initialization it creates the global client monitor <I>fifo</I> and opens the X.25 communications ports. The CMON has three processing layers: the <I>fifo</I> management layer, the session routing layer, and the X.25 communications interface (see <A href="list8.htm">Listing 8</a>)
.</FONT></FONT></FONT></FONT><P>
The CMON's three layers communicate with each other via references to the internal control block tables: <I>fifo</I> control blocks (<I>c_fcb</I>), session control blocks (<I>c_scb</I>), and line control blocks (<I>c_lcb</I>). Each table contains indexes to the next higher or lower level in the processing chain. The <I>c_fcb</I> and <I>c_lcb</I> contain link counts for determining if a <I>fifo</I> or line is active and will execute the open and close functions automatically.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Data from applications is received by the <I>fifo</I> management routine (<I>cfifo_read</I>). The main processing loop assumes that an RPC command will be received first and locates the session in the <I>c_scb</I> table via the process and file identifiers (<I>pid</I> and <I>fid</I>) in the RPC header. Note that the client session identifier (<I>csid</I>) is an index into the <I>c_scb</I> table. The server session identifier (<I>ssid</I>) is a similar index. A client-server session is identified by matching <I>csid</I> and <I>ssid</I> pairs.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
To route the RPC command/data to the server system, the CMON uses the line identifier (<I>lid</I>) from the <I>c_scb</I> entry as an index into the <I>c_lcb</I> table. The <I>c_lcb</I> entry contains the X.25 port number and circuit number (<I>cid</I>) that is allocated for connecting to the server. If the link count is zero then the client is not connected to the server and an X.25 <I>Call Request/Confirm Operation</I> is performed, allocating a <I>cid</I>. The entries in the <I>c_lcb</I> contain the appropriate X.25 information for making the call to the server.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Responses from the server are processed in reverse. The <I>cid/lid</I> is known by the incoming X.25 event and the session is located in the <I>c_scb</I> via the <I>csid</I> contained in the RPC response header. The CMON then uses the <I>csid</I> to index into the <I>c_scb</I> and extracts the <I>pid/fid</I> representing the local applications file reference. This <I>pid</I> is used to find the application's <I>c_fcb</I> entry for the write <I>fifo</I>. The response is adjusted and sent on the correct <I>fifo</I>. Whether the RPC operation succeeds is an issue only to routing and communications layers - not to the CMON.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The CMON uses and contains specific support for the Eicon Technologies' X.25 Toolkit and HSI/PC communication controller. For example, the CMON will allocate an X.25 buffer (on-board memory) and will read or write the data from the X.25 communications interface directly into the fifo, saving a copy operation and reducing local system operating requirements.<P>
The CMON operates in a synchronous processing loop (it is single transaction oriented). The CMON will receive a command from an application and will transmit the command to the server. It will then wait for a response (this could take some time), and send the response back to the application. The CMON will ignore (temporarily) any other pending requests from other applications. Although the CMON's tables and the RPC protocol structure will support asynchronous processing (i.e. multiple commands/responses), the synchronous design of the CMON demonstrates the type of multiplexing that is necessary to support a client-server system.<P>
<h4><FONT COLOR="#000080"><A name="01F1_011A">The Server System<A name="01F1_011A"></FONT></h4></P>
The server system contains the server monitor (SMON). This background task is launched at system startup and during initialization opens the X.25 communications port and posts a <I>listen</I> request for each Client System configured. (A 'listen' request is the X.25 toolkit's counterpart to the <I>call</I> request function. A listen request completes when a call request with matching parameters is received.) The SMON has a line control block table <I>(</I><I>s_lcb</I><I>)</I> for keeping track of the client system circuits and a session control block table (<I>s_scb</I>) for keeping track of the client-server sessions and file system access.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The SMON doesn't depend on any applications above it, and as a result is not noticeable in a system. The SMON has three layers of functionality: the X.25 interface, the RPC protocol layer, and the file system interface (see <A href="list9.htm">Listing 9</a>
for source code). The SMON continuously waits for either a completion of any listen request (i.e., new client systems making contact) or received data (i.e., RPC commands from client systems). The SMON will accept any connection request from a client system and will maintain the X.25 circuit until it is cleared by the client. Data received in the main processing loop is interpreted as an RPC command and is passed to the <I>srpc</I> routines.<P>
The <I>srpc</I> routines are the mates of the <I>arpc</I> routines. These routines process the decoded RPC header and perform specific RPC functions. The SMON follows the CMON design where a <I>RPC_FOPEN_CMD</I> initiates a new RPC session and the <I>RPC_FCLOSE_RSP</I> closes the session. The <I>srpc</I> routines identify the sessions by extracting the <I>csid</I> and <I>ssid</I> from the RPC header. On <I>RPC_FOPEN_CMD</I> commands the <I>ssid</I> is -<I>1</I> and is replaced with the allocated session identifier (e.g. the <I>s_scb</I> index) within the <I>RPC_FOPEN_RSP</I> response message.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="01F1_011B">Future Directions<A name="01F1_011B"></FONT></h4></P>
These enhancements are critical if the BFS is to be a file access method:<P>
<UL><li>Adapt the application/client monitor interface to use the standard<I> f</I>-functions and add the client monitor to the kernal processing.</FONT></FONT></li>
<li>Increase the error detection and recovery of the overall system &#151; specifically network failure recovery and internal error recovery.</li>
<li>Routines to parallel other functions such as <I>fprintf</I>, <I>fscanf</I>, <I>fputs</I>, and <I>fgets</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></li>
<li>Enhance the BFS to support both local and wide area networks, possibly including a simple asynchronous version to connect directly to MS-DOS-based PCs.</li></UL>
<h4><FONT COLOR="#000080"><A name="01F1_011C">Conclusion<A name="01F1_011C"></FONT></h4></P>
The future of RPC protocols is expanding as the fourth-wave of computing emerges. Network-based applications or "Groupware" products will enhance the productivity of the computing community, increase the types of applications available, change how existing applications operate, and allow users to economically upgrade computing power where it is needed. The power of RPC protocols is not limited to software gurus or manufacturers &#151; it is now being delivered to the users themselves. Products such as Netwise's RPC Tool will allow individual programmers to develop custom client-server applications that execute on UNIX, MS-DOS, and other operating systems.<P>
<h4>References</FONT></h4></P>
Anderson, Bart &amp; Costales, Bryon &amp; Henderson, Harry. <I>UNIX Communications</I>, Indiana, Howard W. Sams &amp; Company, 1987.<P>
Fritz, T. E. &amp; Hefnet, J. E. &amp; Raleigh. "A Network of Computers Running the Unix System," <I>AT&amp;T Bell Laboratories Technical Journal</I> Vol. 63, No. 8, October 1984, reprinted in <I>AT&amp;T Unix System Readings and Applications, </I>Vol. II, New Jesey, Prentice-Hall, 1987.<P>
Stallings, William. <I>Handbook of Computer Communications Standards, </I>Volume 1, "The Open Systems Interconnection (OSI) Model and OSI-Related Standards." New York, Macmillan, 1987.<P>
Stevens, W. Richard. <I>Unix Network Programming</I>, Prentice-Hall Software Series, New Jersey, Prentice-Hall, 1990.<P>
Tanenbaum, Andrew S. <I>Computer Networks</I>, Second Edition, New Jersey, Prentice-Hall, 1988.<P>

<h4>Sidebar: <A HREF="sidebar1.htm">Network Standards</A></h4>
<h4>Sidebar: <A HREF="sidebar2.htm">OSI Reference Model Layer Functions</A></h4>

<h4><a href="../../../source/1990/sep90/johnston.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY></HTML>
