<HTML>
<HEAD>

<TITLE>January 1990/Fitting Curves To Data</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>
<hr><h2 align="center"><font color="#800000">Fitting Curves To Data<A name="0024_000A"><A name="0024_000A"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0024_0000"><A name="0024_0000">Michael Brannigan</font></h3><hr><blockquote><P>
<P><i><A name="0024_0000"><A name="0024_0000">Micheal Brannigan is President of Information and Graphic System, IGS, 15 Normandy Court, Atlanta, GA 30324 (404) 231-9582. IGS is involved in consulting and writing software in computer graphics, computational mathematics, and data base design. He is presently writing a book on computer graphics algorithms. He is also the author of The C Math Library EMCL, part of which are the routines set out here.</i></P><P>
Fitting curves to data ranks as one of the most fundamental needs in engineering, science, and business. Curve fitting is known as regression in statistical applications and nearly every statistical package, business graphics package, math library, and even spreadsheet software can produce some kind of curve from given data. Unfortunately the process and underlying computational mathematics is not sufficiently understood even by the software firms producing the programs. It is not difficult, for example, to input data for a linear regression routine to a well known statistical package (which I shall not name) used on micros and mainframes for which the output is incorrect.<P>
Constructing a functional approximation to data (the formal act known as curve fitting) involves three steps: choosing a suitable curve, analyzing the statistical error in the data, and setting up and solving the required equations. Choosing a suitable curve is a mixture of artistic sensibility and a knowledge of the data and where it comes from. Analyzing statistical error can be something of a guessing game and requires some thought. Setting up and solving the equations is computationally the most interesting. It is here that many programs fail because they use computationally unstable methods, but more of that later.<P>
The number of methods for data fitting is legion and we suggest some in this article. However, we give only one method in full and consider only 2-D data. Anyone interested in other specific data fitting techniques may contact the author.<P>
<h4><FONT COLOR="#000080"><A name="0024_000B">Problem<A name="0024_000B"></FONT></h4></P>
Given data points <I>(x</I><I><SUB>i</I></SUB><I>,y</I><I><SUB>i</I></SUB><I>)i=1,...,n</I> we suppose there exists a relation</FONT></FONT><P>
<pre>        y<SUB>i</SUB> = F(x<SUB>i</SUB>) + e<SUB>i,</SUB> i = 1,...,n</pre>
where <I>F(x)</I> is an unknown underlying function and <I>ei</I> represents the unknown errors in the measurements <I>y</I><I><SUB>i</I></SUB>. The problem is to find a good approximation <I>f(x)</I> to <I>F(x)</I>. We thus need a function <I>f</I> to work with and some idea, however minimal, of the errors.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0024_000C">How To Choose <B><I>f</I><A name="0024_000C"></B></FONT></h4></P>
<I>f</I> will have variable parameters whose correct values (the values that solve the approximation problem) are found by solving a system of equations, each data point defining one equation. We call the function <I>f</I> linear or non-linear if it is linear or non-linear in its parameters.</FONT></FONT></FONT></FONT><P>
Consider some of the general principles involved in choosing a suitable function <I>f</I>. We must have more data points than parameters, otherwise <I>f</I> will fit the data exactly and we will not model the errors. Unless absolutely necessary, don't use a non-linear <I>f</I>; solving systems of non-linear equations uniquely is, except for special cases, nearly impossible. In most cases polynomials are not a good choice; they are wiggly curves and nearly always wiggle in the wrong places.</FONT></FONT></FONT></FONT><P>
The best option in most cases is to use piecewise polynomials. The example we give is a piecewise cubic polynomial such that the first derivatives are continuous everywhere.<P>
(You can, of course, use cubic splines if you want second derivatives to be continuous, but in most cases the example set out here is superior for a general purpose curve fitting routine. If you want the full cubic spline, please use the B-spline formulation, no other, otherwise you get unstable systems of equations resulting in incorrect solutions. Using the B-spline formulation for spline approximation, you need only change the routine <I>coeff_cubic()</I> <A href="list1.htm"> (Listing 1) </A> in the program given in this article. The system of equations is solved by the same routines.)</FONT></FONT><P>
Once <I>f</I> has been chosen and applied to each data point, we obtain a system of linear equations to solve, where the number of equations will be greater than the number of unknowns. Such a system is called an overdetermined system and no exact solution exists &#151; one that is exactly what we want. However, overdetermined systems have an infinite number of inexact (approximate) solutions; we will seek an approximation that minimizes some particular error measure. (Mathematicians call these error measures "norms". Thus the problem of curve fitting becomes an optimization problem.)</FONT></FONT><P>
Of the infinite possible norms three should be considered for any curve fitting package: the L1-norm, the L2-norm (least squares norm), and the minimax (Chebyshev) norm (These norms are defined later in this article.). Fortunately good algorithms exist for solving overdetermined systems of linear equations in all three norms. For the L1-norm and the minimax norm, you use a variation of the simplex method of linear programming; for the L2-norm you use a QR decomposition of the matrix in preference to the computationally unstable method of solving the normal equations. (We cannot give all the program code here as space is limited but for more guidance the reader can contact the author.)<P>
Of many possible combinations the following solution is a good general-purpose option.<P>
<h4><FONT COLOR="#000080"><A name="0024_000D">Solution<A name="0024_000D"></FONT></h4></P>
We have data points <I>(x</I><I><SUB>i</I></SUB><I>,y</I><I><SUB>i</I></SUB><I>)i=1,...,n.</I> Let each <I>x</I><I><SUB>i</I></SUB> belong to some interval <I>[a,b]</I>. Specify <I>k</I> points <I>Xj j=1,...k</I>, on the X-axis, we call these points knots. These knots are such that</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>          a = X<I><SUB>1</I></SUB> &lt; X<I><SUB>2</I></SUB> &lt; … &lt; X<I><SUB>k</I></SUB> = b</FONT></FONT></FONT></FONT></FONT></FONT></pre>
We can now define our function as follows: for each <I>x</I> in the interval <I>[Xj,Xj+1]</I> define the cubic polynomial</FONT></FONT></FONT></FONT><P>
<pre>y = [(d<SUP>3</SUP> - 3dp<SUP>2</SUP>(x) + 2p<SUP>3</SUP>(x))Yj
    + (dp(x)q<SUP>2</SUP>(x))Yj' + (3d - 2p(x))p<SUP>2</SUP>(x)Yj+1
    + dp<SUP>2</SUP>(x)q(x)Yj+1']/d<SUP>3</SUP></pre>
where<P>
<pre>    d = Xj+1 - Xj
    p(x) = x - Xj
    q(x) = Xj+1 - x</pre>
Thus <I>y</I> is a cubic polynomial with the linear parameters <I>Yj, Yj+1,Yj',Yj+1'</I>, which are the values and first derivatives at the knots <I>Xj</I> and <I>Xj+1</I> respectively.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
For each data point we obtain one linear equation so we can set up <I>n</I> linear equations in the <I>2k</I> unknowns <I>Y</I><I><SUB>1</I></SUB><I>,Y</I><I><SUB>1</I></SUB><I>',..Y, k,Y k'</I>. In matrix form this can be written as</FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>               AY = b</pre>
where <I>A</I> is a block diagonal matrix, <I>Y</I> is the vector of unknowns, and <I>b</I> is the vector of <I>y</I> values. Because <I>A</I> is block-diagonal, for very large data sets optimal use should be made of the structured sparsity.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
With the same knots we could also define cubic B-splines and then fit a cubic spline to the data. We would again arrive at an overdetermined system of linear equations with a matrix of coefficients having block-diagonal structure. In fact the equations we have set out above form a cubic spline with each knot <I>Xj</I> a double knot.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0024_000E">Choosing A Norm<A name="0024_000E"></FONT></h4></P>
For each possible solution <I>Y</I> we have errors <I>s</I><I><SUB>i</I></SUB><I> i=1,...,n</I> such that</FONT></FONT></FONT></FONT><P>
<pre>               AY - b = s</pre>
where <I>s</I> is the vector of <I>s</I><I><SUB>i</I></SUB> values.</FONT></FONT></FONT></FONT><P>
The L1-norm is defined to be<P>
<pre>               <FONT FACE="Symbol" SIZE=3>åabs(s<I><SUB>i</I></SUB>)</FONT></FONT></FONT></FONT>
               <I>i</I></pre>
The L2-norm or least squares norm is<P>
<pre>               (<FONT FACE="Symbol" SIZE=3>ås<I><SUB>i</I></SUB><SUP>2</SUP>)<SUP>1/2</SUP></FONT></FONT></FONT></FONT></FONT>
                <I>i</I></pre>
And the minimax or Chebyshev norm is<P>
<pre>          max(abs(s<I><SUB>i</I></SUB>) :i=1,...,n)</FONT></FONT></pre>
We solve the overdetermined system of equations by finding that vector <I>Y</I> which minimizes one of these norms. The choice of norm depends on the unknown errors <I>e</I><I><SUB>i</I></SUB> and we hope that the choice of norm will give errors <I>s</I><I><SUB>i</I></SUB> that will mirror these unknown errors. The general rule is: choose the L1-norm if the <I>e</I><I><SUB>i</I></SUB> are scattered (belong to a long tailed distribution); choose the L2-norm if the <I>e</I><I><SUB>i</I></SUB> are normally distributed; choose the minimax norm if the <I>e</I><I><SUB>i</I></SUB> are very small or belong to a uniform distribution. Research has indicated that data sets have errors nearer to the L1-norm than the L2-norm. (Errors in data are never normally distributed, neither as they are nor in the limit. This assumption of normally distributed errors is common in most packages, the user should question this assumption very carefully.) So when you don't know how the errors are distributed, use the L1-norm. The minimax norm is rarely used for fitting curves to experimental data. However, always use the minimax norm if you want to fit a function to another function, for example fitting a Fourier series to a complicated function where you know the values exactly.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Whichever norm you choose, the computer solution of the equations is not straightforward. You must choose an algorithm that is computationally stable. (A computationally unstable algorithm is one that is mathematically correct but when fed into a computer, produces wrong answers. For example solving linear equations without pivoting, or solving quadratic equations from the well-known formula. So get some professional help in choosing the algorithm.)<P>
<h4><FONT COLOR="#000080"><A name="0024_000F">Program<A name="0024_000F"></FONT></h4></P>
After you have spent some time analyzing your particular data fitting problem, decided upon a suitable function to approximate the data, and also decided upon the norm to use for the errors in the data, you must program the result. Unless your application requires special functions, then the approximating function set out above is a good general purpose function. The programming for this function or any other has the same form. The system of equations is set up with one equation for each data point, and then the system is solved with the required norm. For the function described here the programming is just as straightforward.<P>
The main routine is <I>Hermite()</I>, named after the mathematician who defined these piecewise polynomials. The routine first gives the user the choice (by setting the variable <I>flag</I>) of either setting the <I>k</I> knots <I>lambda[]</I> on input or using the routine <I>app_knots()</I> to compute the knots. In most cases the user will never just use the routine once but compute a first approximation then alter the position of the knots for a second approximation. For a first approximation set <I>flag</I> to <I>true</I> and use <I>app_knots()</I> to compute the knots automatically. Then look at the result and choose new knots. A more sophisticated method automatically chooses the number of knots <I>k</I> and their position.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Once the knots are defined the routine allocates space for the matrix <I>A</I> of size <I>nx2k</I>. After making sure all elements of the matrix are zero, the routine calls <I>coeff_cubic()</I> to set up the coefficients of the matrix.</FONT></FONT></FONT></FONT></FONT></FONT><P>
Now the program solves the overdetermined system in the appropriate norm. The variable <I>norm</I> is set by the user to indicate which norm to use. (We do not give here the three routines that solve the overdetermined system of equations as they require lots of space, but the reader can find the algorithms in most computational mathematics textbooks.) The routine <I>L1_approx()</I> uses the Ll-norm, the routine <I>CH_lsq()</I> uses the least squares norm, and the routine <I>Cheby()</I> uses the minimax norm. With the solution from the appropriate routine, the function now fits the data.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Some words on the other routines. First, the routine <I>app_knots()</I> will compute <I>k</I> knots <I>lambda[j]</I> so that in each interval (<I>lambda[j], lambda[j+1]</I>) there are approximately the same number of <I>x</I> values. This is a good starting point for our Hermite approximation and for any spline approximation that needs knots. The routine <I>coeff_cubic()</I> is merely a direct translation of the formulae. This routine uses <I>interval()</I>, which finds to which knot interval each <I>x</I> value belongs. <I>coeff_cubic()</I> also uses the macro <I>SUB()</I> to move around the matrix (this is my preferred method for dealing with matrices passed as parameters). Finally there is the routine <I>app_cubic()</I>. This routine uses the results from <I>Hermite()</I> to compute the piecewise polynomial for any value of <I>x</I>. Thus <I>app_cubic()</I> completes the curve fitting problem.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0024_0010">Example<A name="0024_0010"></FONT></h4></P>
An example (using data from actual measurements of the horizontal angular displacement of an elbow flexion against time) will show how the pieces fit together. There are 142 measured points and these measurements are quite accurate (the experimenters knew the kind of instruments they were using&#151;see the paper by Pezzack, et al). In this instance a close fit to the data points is required. In all the figures the dark circles are the knots and the crosses are the data points.<P>
The solution is in <A href="fig1.htm">Figure 1</a>.
 <A href="fig2.htm">Figure 2</a>
shows the result when the L2-norm is used. <A href="fig3.htm">Figure 3</a>
shows the result when the minimax norm is used. As would be expected with such "clean" data, the answers are all quite good, the best being <A href="fig1.htm">Figure 1</a>.
<P>
To illustrate the behavior in the presence of noise, add some significant errors to the same data points. Using the same curve approximation method, then <A href="fig4.htm">Figure 4</a>,
 <A href="fig5.htm">Figure 5</a>,
 and <A href="fig6.htm">Figure 6</a>
show the result when using the L1- norm, L2-norm, and minimax norm respectively. As theory suggests, the Ll-norm gives definitely superior results. This example is a straightforward application of the method set out here &#151; well, nearly! You may be asking the six thousand dollar question, "How do I choose the knots?" The answer is not straightforward and contemporary research has different answers.<P>
As you can see from the figures, the number and position of the knots changes for each example. The goal is to choose the number of knots and their position so as to give the best fit possible for the norm chosen&#151;easy to say but not easy to compute. All the knots in each figure have been chosen according to an information theoretic criterion, plus a little experience on the placement of knots. The idea behind this method is to attempt to extract the maximum amount of information from the data points until only error remains. To do this we need a computable value for the amount of information contained in the errors <I>s</I><I><SUB>i</I></SUB>; we suggest using the Akaike Information Criterion. The routine changes the number of knots and their position until there is no more information in the errors. For those readers who wsh to go further into this problem, see the papers by Brannigan for a full mathematical treatment of this method, the information theoretic criterion, and an extension to multivariate data.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0024_0011">Bibliography<A name="0024_0011"></FONT></h4></P>
Pezzak, J.C. et al. "An Assessment of Derivatives Determining Techniques Used for Motion Analysis," <I>J. Biomechanics,</I> 10 (1977).<P>
Brannigan, M. "An Adaptive Piecewise Polynomial Curve Fitting Procedure for Data Analysis," <I>Commun. Statist.</I> A10(18), (1981).<P>
Brannigan, M. "Multivariate Data Modelling by Metric Approximants," <I>Comp. Stats. &amp; Data Analysis</I> 2, (1985).<P>

<h4><a href="../../../source/1990/jan90/branniga.zip">Get Article Source Code</a></h4>
</BLOCKQUOTE>
</BODY>
</HTML>
