

<HTML>
<HEAD>

<TITLE>April 1993/Code Capsules</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocapr.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Code Capsules<A name="00F2_006A"><A name="00F2_006A"></font></h2><P>
<h3 align="center"><A name="00F2_0000"><A name="00F2_0000">Sorting with qsort</h3><P>
<h3 align="center"><font color="#800000">Chuck Allison</font></h3><hr><blockquote><P>
<P><i><A name="00F2_0000"><A name="00F2_0000">Chuck Allison is a software architect for the Family History Department of the Church of Jesus Christ of Latter Day Saints Church Headquarters in Salt Lake City. He has a B.S. and M.S. in mathematics, has been programming since 1975, and has been teaching and developing in C since 1984. His current interest is object-oriented technology and education. He is a member of X3J16, the ANSI C++ Standards Committee. Chuck can be reached on the Internet at allison@decus.org, or at (801)240-4510.</i></P><P>
If you've been programming for very long you've probably noticed that many of your programs spend a noticeable amount of time ordering data elements. In his classic work "Sorting and Searching" (<I>The Art of Computer Programming</I>, Vol. III, Addison-Wesley, 1973), Don Knuth reports that the average program spends over 25% of its time sorting. Sorting is useful for grouping related items, eliminating duplicates, comparing or merging related sets, and helping searches. You'll certainly want to use an efficient algorithm for such a frequent activity.<P>
This article describes the use of <I>qsort</I>, the sort function supplied with the standard C library. In most compilers, <I>qsort</I> is an implementation of the Quicksoft algorithm, which is, on average, the most efficient of all general-purpose sorts. (However, an implementation is not required to use the Quicksort algorithm &#151; it just needs to sort arrays according to the specifications illustrated below) .<I>qsort</I> is general purpose because you can use it to sort an array of elements of any type, with simple or compound sort keys. It only requires that any two elements can be compared and that the array is in memory .<I>qsort</I> modifies the array by swapping elements so that they come out in ascending order.<P>
The program in <A href="list1.htm">Listing 1</a>
shows how to use <I>qsort</I> to sort an array of integers. <I>qsort</I> (declared in <I>&lt;stdlib.h&gt;</I>) takes four arguments: the array to sort, the number of elements in the array, the size of each element in bytes, and a user-supplied compare function. A compare function, <I>f</I>, must have the prototype <I>int f(const void *p1, const void *p2)</I>. (Using <I>void</I> *allows pointers to any type). <I>qsort</I> repeatedly calls the compare function, passing it pointers to two array elements. The compare function must behave like <I>strcmp</I>, i.e., it must return a negative number if the value that <I>p1</I> represents precedes that of <I>p2</I>, 0 if the values are equal, and a positive number otherwise. In this example <I>icomp</I> does this by returning the difference of the two integers being compared. Note that the incoming pointers must be cast to the appropriate type (<I>int</I> * in this case) in order to reference the values to compare.<P>
<A href="list2.htm">Listing 2</a>
shows how to sort an array of strings (i.e., an array of pointers to <I>char</I>) in descending order. You simply supply <I>qsort</I> with a compare function that reverses the order of the sort by negating its return value. Since <I>some_strings[]</I> is an array of <I>char </I>*, <I>qsort</I> passes pointers to <I>char</I> * (i.e., <I>char</I> **) to the compare function <I>scomp. scomp</I> dereferences once and passes the pointers to <I>char</I> to <I>strcmp</I>. Don't overlook the fact that it is the pointers that <I>qsort</I> reorders, and not the strings themselves.<P>
The program in <A href="list3.htm">Listing 3</a>
sorts an array of structures in two different ways: first by name (last, then first), and then by age. Most of the time it is faster to swap pointers than structures. (Structures tend to be bigger than pointers.) When this is the case, it will be more efficient to pass <I>qsort</I> an array of pointers to structures instead of an array of actual structures. This of course requires another level of indirection in the compare functions (see <A href="list4.htm">Listing 4</a>)
.<P>
<h4><FONT COLOR="#000080"><A name="00F2_006B">How Generic Sorting Works<A name="00F2_006B"></FONT></h4></P>
<I>qsort</I> is able to sort any array because you supply it with all it needs to know to do the job: where the elements are, how many, how big each one is, and how to compare them. To illustrate the technique, I'll take the simplest of comparison-sort algorithms, selection sort, and make it generic. Selection sort makes <I>n</I>--1 passes on an array of <I>n</I> elements. In the first pass, it compares the first element to the rest and swaps it with any that precede it in value (so after the first pass, the smallest element is now the first). It repeats the process with the second element, and so on until the array is in ascending order (see <A href="list5.htm">Listing 5</a>)
.<P>
To make this process generic, I'll parameterize the four items mentioned above, just like <I>qsort</I> (I'll call it <I>ssort</I> &#151; see <A href="list6.htm">Listing 6</a>)
. The statements<P>
<pre>char *p1 = (char *) array + i*size;
char *p2 = (char *) array + j*size;</pre>
determine pointers to the <I>i</I>th and <I>j</I>th array elements. These addresses are then passed to the user-supplied compare function. If the elements are out of order, <I>ssort</I> puts them in order by swapping their associated blocks of storage. <A href="list7.htm">Listing 7</a>
shows that usage of <I>ssort</I> is identical to <I>qsort</I>.<P>
<h4><FONT COLOR="#000080"><A name="00F2_006C">Indexes<A name="00F2_006C"></FONT></h4></P>
Sometimes you want to access data in a certain order without actually disturbing its contents. This is especially important if you need multiple orderings repeatedly in the same program &#151; you don't want to have to sort more than once for each ordering. This is the motivation for keeping indexes. If you don't mind having the data array global, indexes are easy with <I>qsort</I>. <A href="list8.htm">Listing 8</a>
shows how to construct an index for an array of integers. <I>idx</I> is the index array (sometimes called a permutation vector) for <I>some_ints</I>. After initializing it to the "identity" permutation (i.e., <I>idx[i] = i</I>), call <I>qsort</I> to sort <I>idx</I>, not <I>some_ints</I>. You use <I>idx</I> as an indirection device to access <I>some_ints</I> in ascending order, although <I>some_ints</I> itself hasn't changed. Note that <I>some_ints</I> must be global because the compare function needs access to it.<P>
Indexes have many uses. <A href="list9.htm">Listing 9</a>
shows how to extract only unique elements from an array non-destructively. This program can easily be modified to print a listing of the unique tokens in a text file. The program in <A href="list10.htm">Listing 10</a>
populates an array with the alphanumeric tokens read from standard input. It then prints only unique tokens in ascending order, while the original array still contains all the tokens in their original order (see <A href="fig1.htm">Figure 1</a>)
. This is quite a feat for such a short program. Although this lazy technique is not worthy of a serious parser (since it picks up tokens that start with a numeral, or that appear in strings or comments) you may find a use for it. I also cheated a little by using ranges in the scansets. The format descriptor <I>%*[^A-Za-z0-9]</I> instructs <I>scanf</I> to ignore any contiguous sequence of non-alphanumeric characters, while <I>%[A-Za-z0-9]</I> matches any such sequence (for an explanation of scansets, see "Code Capsules: Text Processing I", <I>CUJ</I>, October 1992). But scanset ranges are not guaranteed to be portable in ANSI C, although many popular compilers support them. If yours does not, replace <I>A-Za-z0-9</I> with all 62 alphanumeric characters spelled out.<P>
There is of course a lot more to sorting. I have only considered internal sorting (i.e., when you are sorting an array confined to memory). Some other sorting techniques perform more efficiently than <I>qsort</I> by using the characteristics of the data to optimize the process (e.g., radix sort, which only works on integral types). Like Quicksort, <I>qsort</I> is not a stable sort. This means that elements with equal keys may lose their relative ordering after sorting (e.g., if you sort the data in <A href="list3.htm">Listing 3</a>
by last name only, Edsel Ford may precede or follow Henry Ford &#151; their relative ordering is indeterminate). If you are interested in external sorting or want to explore the innards of many different sorting algorithms, see Knuth's book cited in the beginning of this article. (Next month's column will also discuss external sorting.) In this column I have tried to illustrate how much mileage you can squeeze out of a single, well-designed sort function.<P>

<h4><a href="../../../source/1993/apr93/allison.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
