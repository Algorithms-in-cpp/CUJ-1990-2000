





<HTML>
     
     <HEAD>

<TITLE>February 1998/We Have Mail</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<H2><A href="../tocfeb.htm"><IMG src="../../toc.gif" ALT="Back to TOC" WIDTH="54" HEIGHT="54"></A>
<FONT COLOR="#FF0000">Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">We Have Mail</FONT></H2>
<hr><blockquote>
<p><i>Letters to the editor may be sent via email to cujed@mfi.com, or via the
postal service to Letters to the Editor, C/C++ Users Journal, 1601 W. 23rd St.,
Ste 200, Lawrence, KS 66046-2700.</i><p><hr>
Dear P.J. Plauger,<p>
I know you are busy but I wanted an opinion of someone whose views on C++ I
respect. Two functions that behave similarly:</p>

<pre>
void foo(int *myVal);
void foo2(int &amp; myVal);
</pre>
<p>The user writes:</p>

<pre>
foo(&amp;anInt);
foo2(anInt);
</pre>
<p>To my way of thinking, foo1 is clearer to the reader of the code and by inference,
better. The fact that you are passing by reference is unambiguous. It seems to
me the pass by reference syntax of foo2 is a mistake in the C++ design. What
are your feelings?<p>
Have you discussed this in a previous issue of C/C++ Users Journal? If so point
me in the right direction. I have decided that I must have the CD of previous
issues. This magazine has become indispensable! I am looking forward to the
rest of the Locales series. Keep up the good work.</p>
<p>Andre R. Oughton<br>
PictureTel Corporation<br>
aoughton@pictel.com</p>
<p><i>I too prefer the overtness of passing an explicit pointer rather than a
reference. Nevertheless, there are times when references are really necessary.
For example, you cannot declare a sensible assigning operator, such as
operator+=, unless you can make the left operand a reference to the object to
be altered. Const references also let the implementor of a function optimize
the passing of large objects. &#151; pjp</i></p><hr>
<p>Dear CUJ,<p>
Pointers and references. Enjoy.<p>
The difference between a pointer and a reference is like duck and glass.<p>
A duck quacks like a duck and flies like a duck. Therefore, it is a duck.<p>
Glass quacks like a duck and does not fly. Therefore, it is not a duck.<p>
Think of a thick glass pen fully surrounding zero or more ducks. Fly all they
want but cannot quack the glass.<p>
Now, a duck outside the glass may not get in, but can fly from pen to pen to
pen.<p>
Please ship all ducks in pens.</p>
<p>Denton E. Karle</p>
<p><i>It's a little scary to think someone has to go this far to get a grip on
pointers and references. But for the sake of those whose brains really work
this way, I'm inclined to correct a few misconceptions buried in all your
prose:</p>
<UL><LI>C++ makes it almost impossible to construct an empty pen ("zero or more
        ducks"). This helps us avoid a commonly encountered problem in C: the dreaded
        Dangling Duck.</LI>
    <LI>Maybe ducks can fly from pen to pen, but they can never land on one. Ducks
        complain that the pens aren't real objects. Whenever they try to land on one it
        just evaporates &#151; a mirage, apparently.</LI>
    <LI>Is the pen really filled with ducks? We're not supposed to know that, even
        though we can sometimes see them through the glass. The truth is, implementors
        aren't required to fill their pens with dereferenced ducks (and if you've ever
        met a dereferenced duck, you'll never tangle with another one). They might use
        turkeys, geese, whatever will make their pens act like mirages of other
        objects.</LI>
</UL>
<p>I hope this clears things up a little. I feel better, I think. &#151;
mb</i></p><hr>
<p>Dear Editor:<p>
C/C++ Users Journal is an excellent magazine. However, many nowaday developers
use tools &#151; either Visual C++, or Borland C++ Builder, or some other visual
IDEs. So if you can include the Visual C/C++ Development column in your
magazine (say, talking about C++ Builder components), it would be much better.
Best wishes to your magazine. Thanks.<p>
Regards,</p>
<p>Richard Zhu<br>
OHS System, HR&amp;OGC<br>
rzhu@ford.com</p>
<p><i>Your suggestion has some merit, but it conflicts with CUJ's goal of being
as vendor and platform neutral as possible. We aim to provide content balanced
between universal, timeless information (e.g., the importance of information
hiding) and specific, timely information. In the latter category, for example,
we've run articles on ISAPI, a Microsoft-specific API. And we won't avoid
vendor- or platform-specific articles in the future if we judge them too
important to pass up. But a vendor-specific column would just be going too
far.<p>
We know that no single article can be useful to all readers. But we hope that
if an article isn't immediately useful to all, it will at least be interesting
and instructive to most. A column on Visual C++ would be unquestionably useful
to a select portion of our readership, and boring to all the rest. The gnarly
details of navigating an IDE, or trying to get a Wizard to do what you want,
have little to do with programming in general, and they quickly go out of
date.<p>
On the other hand, I think there are a lot of interesting topics having to do
with developing software in a visual environment, which remain largely
untapped. How to leverage visual components in performing regression tests is
one that immediately springs to mind. Very brief articles &#151; one-pagers or less
&#151; with tips on how to work around quirks of specific visual environments would
also be most welcome. So if anyone reading this has some ideas for articles,
please visit our website (www.cuj.com) and get a copy of our Author
Guidelines.<p>
Thanks for writing.<p>
&#151; mb</i></p><hr>
<p>Dear CUJ,<p>
In response to the letter by John Gammel, published in CUJ, December 1997, on
DOS extenders:<p>
The DOS/4GW extender provided with Watcom is not the professional version. It
is a subset of the commercial product provided by Tenberry and thus has some
limitations, including a 32 MB memory limitation. This limitation should not be
present in DOS/4GW Professional.<p>
As for Virtual Memory Management on Windows 95, NT, or any other multitasking
OS, one of the aspects of memory management is avoiding resource starvation.
Running a memory-intensive process such as the one you describe will cause
numerous page faults (accesses to virtual memory) simply because the memory
manager places an upper bound on the amount of memory available to a single
process. To ensure that your process receives the maximum resource utilization,
consider relaxing any ceiling constraints on the memory manager (if such
options are available), or running on a single-user OS.<p>
Best of luck!</p>
<p>Eli Ofenstein<br>
ejo@vsurf.net</p>
<hr>
Dear CUJ,<p>
You published a letter by John Gammel in December 1997 about only accessing
physical memory (128 Mb of it). I didn't look at the program, but things to try
are:</p>
<p>1) disable swapping (this is an option)<p>
2) look at the algorithm</p>
<p>There are algorithms that are friendlier to virtual memory. For example,
when processing arrays such as:</p>

<pre>
double array[BIG][BIG];
</pre>
<p>there is a big difference if you start doing:</p>

<pre>
for(i = 0; i &lt; BIG; i++)
    for(j = 0; j &lt; BIG; j++)
        process array[i][j]
</pre>
<p>against the same loop with the body:</p>

<pre>
process array[j][i]
</pre>
<p>The first example will (generally) process a page of VM at a time, the second will
process one entry on a page. (i.e. each entry may cause a swap).<p>
I agree with PJ, that if you're doing serious computing on an Intel platform,
you may be advised to do it on Linux or FreeBSD.<p>
Also, how much other stuff are you doing during this computation? If the system
is idle other than this program, almost all the physical RAM should be
dedicated to the program. (I wouldn't be surprised if it's not on MS operating
systems.)</p>
<p>Marty Leisner<br>
leisner@sdsp.mc.xerox.com</p>
<p><i>The essence of virtual-memory support is making a relatively small
physical memory look like a much larger one. The manager can achieve
significant improvements in performance if it guesses right about the pattern
of page accesses it must satisfy. The program itself can achieve significant
improvements if it avoids patterns known to be difficult to deal with. In
either case, you the programmer must rely on documentation, lore, and
experimentation to help both the manager and the program. I appreciate our
readers sharing some of that lore. &#151; pjp</i></p><hr>
<p>Dear PJP,<p>
In the January 1998 We Have Mail, Saul Rosenberg made a few comments concerning
my article, "Segmenting Large Database Transactions in C" (October, 1997). I
was incapacitated when the letter was received, but am now able to respond to a
few of his comments. To quote Mr. Rosenberg:<p>
"In the October 1897 edition, the article by Stan Milam on 'Segmenting Large
Database Transactions in C' was devoted to discussing Checkpoint / Restart, and
listed a sample implementation. The article contained some excellent points and
procedures but also reminded me somewhat of distributing plans for a V8
dragster without including brakes :-) A caution is necessary:<p>
"As written, the Restart function does not check if it is attempting to
restart a transaction that may have caused a previous abort/restart. Without
this necessary check, once the program encounters a transaction/situation that
is a hard, repeatable failure, the program will endlessly yo-yo, aborting and
restarting at the same point. This yo-yo wastes system resources, blocking
other programs from running. It can also mislead system observers who see
regular CPU usage into thinking that meaningful work is being performed while
in fact it is not.<p>
"The recommendation is to modify the Restart routine to write info to disk
each time a restart occurs. (This restart-point file parallels the checkpoint
file written by the Checkpoint routine.) The restart file contains a pushdown
array (or a circular array) of size N. Each time a Restart occurs, push down
the current record number (or transaction key or other unique value describing
the current position). If the last N restarts are at the same record number,
the Restart routine returns a code indicating a repeatable failure on that
record."<p>
Yes, checkpoint/restart can be a double-edged sword. If one is not careful
designing how a transaction is processed it can be a yo-yo, but I have never
encountered such a situation. The reason is that every environment in which I
have worked has used a sophisticated logging mechanism. When programs
abnormally terminate they are designed to log detailed messages, including all
relevant data and error messages returned from the database server. Before
restarting a program the cause is thoroughly investigated and resolved, thus
avoiding the yo-yo syndrome. To put it another way, when your favorite C/C++
compiler gives error messages, do you simply start the compiler again and hope
for better results, or do you resolve the problems with the code, then invoke
the compiler?<p>
For the reasons already stated, I do not believe any other modifications are
necessary. However, if Mr. Rosenberg has some special situation where he feels
this is necessary, then why change the checkpoint package code? He could just
save the pushdown array in the save area when he checkpoints, then do the
checking when a program restart is detected. No changes to the checkpoint
function is required. If he really wants to change the package, he can download
the code and do what he wants with it (and have fun too) :-).<p>
Mr. Rosenberg also suggests the possibility of reducing block size to one when
a restart occurs, until the system is safely past the problem area. This would
allow the offending transaction to be isolated. I would like to reiterate,
however: if a detailed message is logged you already know exactly where the
problem occurred. Once investigated and resolved the program can be restarted
and sent on its merry way. However, if deemed necessary to do so, logic can be
implemented in the program to lower the checkpoint threshold when a program
restart is detected.<p>
I would like to thank Mr. Rosenberg for his comments. I have been using
checkpoint/restart mechanisms for over 10 years now and learned a lot about
using them. Checkpoint/restart is just one of the tools I have accumulated in
my toolbox, and detailed message logging is another. Used together they are
quite effective dealing with large transactions with updates numbering in the
millions. I had 3,000 words in which to describe checkpoint/restart, and I
tried to mention the most prominent caveats as best I could in that confining
space. My other C/SQL tools with message logging would easily fill another
article. I guess it is time to get started on it!</p>
<p>Stan Milam<br>
milam@metronet.com</p><hr>
<p>Dear CUJ and PJ:<p>
I experienced a strange thing. It was not detected when using Borland C++ 5.0
and CodeGuard, but it was detected by Visual C++ 5.0 (perhaps due to app
differences, since the Visual C++ app reads a lot more data). The problem was
that the VC apps using my persistent streaming scheme (ported from Borland and
modified to use only the STL) would exit the debugger with a single warning:</p>

<pre>
Detected memory leaks!
Dumping objects -&gt;
{25} normal block at 0x00FA0A30,
  33 bytes long.
Data: &lt; .         &gt;
  00 2E 00 CD CD CD CD CD CD ...
</pre>
<p>After tracking down all allocations of 33 bytes to the one at the given address, I
found the lines of code that were causing the problem. The call stack went
something like this:</p>

<pre>
// line 265:
operator new(unsigned int 33))
// line 25:
std::_Allocate(int 33, char * 0x0)
std::allocator&lt;char&gt;::allocate( ... )
std::basic_string&lt;char, ... &gt;::
  _Copy(unsigned int 1...)
std::basic_string&lt;char, ... &gt;::
  _Grow(unsigned int 1...)
::assign( ... )
::assign( ... )
std::basic_string&lt;char, ... &gt;( ... )
SpecInterface::SpecInterface( ... )
  [my code]
</pre>
<p>There were a large number of _malloc_dbg allocations of size 33. The one complained
about was the last one before breaking back into my code, at the marked lines
below.<p>
It seems to me that the reference counting scheme in the library might be bad,
and, in some circumstances, the reference-count might end up off by one. Why it
should occur here in the creation of a temporary object, I do not know. My fix
was to note that nowhere do I use the path parameter. So I commented it out.<p>
Next topic. Which is more readable, <A href="list1.htm">Listing 1</a>
or <A href="list2.htm">Listing 2</A>?<p>
I must confess that <A href="list1.htm">Listing 1</a>
is only a little easier to read. I'm sure you're
familiar with this code, PJ. It's about the worst example of readability I've
ever seen. I must read it character-by-character to understand it. If it were
pretty-printed, I could grok it by gestalt. Why is almost all library source
code so incredibly hard to read? Why are there no comments in library source
code? Do they strip them out before they ship the code?<p>
One other readability problem with Microsoft code is those dang warts, the
worst of which is the m_ (member variable) wart. If you can't tell the nature
of a variable from context, your code will cause you (and your clients)
problems.<p>
Borland code and Microsoft code are both messy-looking. If I were generating
code, I'd take the time once to make sure the code looks spotless,
professional, and highly readable. I'd use #pragmas to demarcate wizard/expert
code, instead of linty constructs such as:</p>

<pre>
//{{AFX_WIZARD_BEGIN
</pre>
<p>Better still, I'd reduce the reliance on such breakable things, and make the wizard
better able to collect unmarked information from the code. I've broken wizard
code many times by accident; now I use it only in an experimental project, and
copy the generated code to the project I really want to work on. I use my
editor's features to pretty-print it as I type.<p>
I had a Borland AppWizard app that Windows 95 would flag as a corrupt
executable. As a result, I no longer support both compilers, except in library
code. I find that running code through both compilers finds more stuff to clean
up. But I'm not too happy with either compiler.<p>
Sincerely,</p>
<p>Chris Ahlstrom<br>
major league software<br>
ahlstroc@compuserve.com</p>
<p><i>I'll take the blame for the storage leak. It is a known bug in the VC++
library that assigning a small string to a large one sometimes causes a storage
overwrite. We have been regrettably slow in getting the word out on this one,
and a patch to go with it.<p>
I'll take a little blame for the code you find hard to read. It is religiously
indented to show control structure, but pretty sparing in its use of white
space. The funny names are largely mandated by the C++ Standard, to avoid
collisions with macros you may define in the code you write. And yes, some
informative comments are removed, partly for contractual reasons. Having said
all that, however, I confess that Microsoft has already requested that I make
the library headers more readable in future. I hope to do so soon. &#151; pjp
</i></p></blockquote>
</body></html>
