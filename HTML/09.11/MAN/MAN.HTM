


<HTML>
<HEAD>

<TITLE>November 1991/A Multithreading Library In C For Subsumption Architecture</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Operating Systems</FONT></H2>

<hr><h2 align="center"><font color="#800000">A Multithreading Library In C For Subsumption Architecture<A name="0241_0131"><A name="0241_0131"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0241_0000"><A name="0241_0000">Richard F. Man</font></h3><hr><blockquote><P>
<P><i><A name="0241_0000"><A name="0241_0000">Richard F. Man is a compiler writer at<I></I> <I></I>DEC, a part time "gradual" student at Tufts<I></I> <I></I>University, and father of Ariane Man-Willrich: the cutest baby girl in the world. If<I></I> <I></I>you are interested in this project or subsumption architecture in general, write to him at<I></I> <I></I>P.O. Box 6, North Chelmsford, MA 01863.</i></P><P>
Subsumption architecture, created at the MIT Mobile Robot Lab by Professor Rodney Brooks as a control system for autonomous robots, decomposes the control program in terms of task-achieving layers. Starting from the lowest layer, the robot's capabilities are increased by additions of higher and higher layers of competence, with each higher level subsuming and incorporating capabilities of the lower layers by modifying lower layers' behavior. The resulting control system provides more robustness, buildability, testability, and adaptability than traditional systems.<P>
A major characteristic of a subsumption architecture implementation is the ability to write concurrent asynchronous executing modules with certain communication capabilities. Since autonomous robots have their own embedded processors and C has many advantages in programming embedded systems, I decided to augment C with a subsumption architecture library. In this library, the multithreading executive provides the ability to write concurrent executing modules and the message manager implements the communication mechanisms.<P>
This subsumption language contains features similar to MIT's first generation FSM-based subsumption language, plus some features from the Behavior Language. I hope to add more Behavior Language features as time goes on. Most of these functions are written in standard C, with some target hardware specific functions in assembly. All target-specific functions are isolated into their own modules and can be replaced easily when switching environments.<P>
Although the library was created for the purpose of writing subsumption architecture-based robot control software, it may also be used to write simulation software that runs on PCs or workstations. To date, I have tested the library in PC DOS and Sun 3 UNIX environments, and on a Motorola MC68HC11 EVB evaluation board with 16K of RAM. (My own mobile robot project, which uses the HC11 EVB as the main controller, is mentioned briefly at the end of this article.)<P>
<h4><FONT COLOR="#000080"><A name="0241_0132">Overview Of The Multithreading Executive<A name="0241_0132"></FONT></h4></P>
With the multithreading library, a single program may contain multiple executing threads, each being an execution instantiation of a function in the program. The executive's scheduler, operating independently of the host OS scheduler, controls which thread to run at a given time.<P>
<A href="fig1.htm">Figure 1</a>
lists the executive functions included in the library; <A href="fig2.htm">Figure 2</a>,
 the message manager functions. (Because the code has been commented and is provided in the listings, I will not give a detailed explanation of each of the functions; instead, I will outline the way the system works.)<P>
The function <I>ExecInit()</I> initializes the system. A program must call it before it calls any other functions in this library.<P>
<I>ExecCreateThread()</I> creates the context for a thread but does not execute it. A program calls this function with the address of a thread function, its required stack size, and two pointersized initial arguments. <I>ExecCreateThread()</I> may be called anytime, including in another concurrently running thread as well as multiple times within the same thread function. (Such thread functions should obey the usual rules of reentrancy, e.g., by using automatic variables instead of global variables.) The first argument to this function specifies the thread type: this will be used when more features are incorporated from the Behavior Language.<P>
After a user program creates all the initial threads, it must call the function <I>ExecStart()</I> to start the scheduler. Once started, the scheduler never returns control to the original caller but will pass control to runnable threads in a round-robin manner.<P>
This executive supports only the cooperative style of multitasking &#151; that is, a thread only gives up control back to the executive when it explicitly calls a particular library function. Although in theory not as suitable as preemptive multitasking for real time programming, the use of subsumption architecture makes this mostly a non-issue. (Both of Brooks's subsumption languages use cooperative multitasking as well.)<P>
A thread typically executes some initialization code and then calls the <I>MsgGetMsg()</I> function to get a message. <I>MsgGetMsg()</I> immediately calls the thread-switching function <I>ExecSwitch()</I>, which gives execution control to the next runnable thread. After receiving control, a thread should call <I>MsgGetMsg()</I> again within a "reasonable" time to ensure that other threads have a chance to run. Thus the call to <I>MsgGetMsg()</I> is usually done in a non-terminating while loop. If a thread function ever returns, its resources are reclaimed and it will not be executed again.<P>
As an example, consider the following program that creates two threads:<P>
<pre>void thread(void)
   {
   MsgWatchTimer (0);
   while (MsgGetMsg())
      printf("I am alive, thread %d\n", ExecGetThreadID());
   }

int main()
   {
   ExecInit();
   ExecCreateThread (NORMAL_PROC,
           thread, 10000, 0, 0);
   ExecCreateThread (NORMAL_PROC,
            thread, 10000, 0, 0);
   ExecStart ();
   }</pre>
When run, the program prints the following output:<P>
<pre>I am alive, thread 0
I am alive, thread 1
I am alive, thread 0
I am alive, thread 1
I am alive, thread 0
(etc...)</pre>
There are three types of messages: timer, port, and semaphore. A thread notifies the message manager of what types of messages it wants to receive by using the <I>MsgWatchTimer(), MsgWatchPort(), or MsgWatchSemaphore()</I> functions. All of these functions return a unique message identifier. When a message arrives, the message manager places the receiving thread at the end of a queue of runnable threads and stores the message identifier in the queue entry; it then calls the scheduler function <I>ExecSwitch</I>. Upon receiving control, the scheduler takes the first thread off the runnable queue thread and gives control to it. From a thread's point of view, it calls the <I>MsgGetMsg()</I> function and the library function returns with a message identifier.<P>
This event-driven style of cooperative multitasking is similar to those used by other cooperative multitasking OSs such as MS Windows v3.0 and the Apple MacIntosh Multi-Finder. I have thus chosen the name <I>MsgGetMsg()</I> deliberately to be close to the names of the corresponding functions in these OSs.<P>
The simplest message to watch for is the timer message. To do this, a thread calls the function <I>MsgWatchTimer()</I> with the time delay factor. The thread will then be runnable after the specified time has elapsed since it was last run. In this implementation, the unit for time delay factor is proportional to the number of threads currently watching for timer messages. (I may change the time delay factor to a constant time unit later, to match the corresponding concept in Brooks's languages.)<P>
Threads communicate through a "port" message. A port variable can be any C variable, although it is best to use a local variable for re-entrancy reasons. To allow other threads to identify a port variable, a thread must associate a unique identifier with it. Port variables serve as the input/output "register" interface of a thread, and their corresponding identifiers serve as their "name" interface. An ASCII string serves as a good unique identifier for a port variable (or a semaphore, see below). For efficiency reasons, a program must convert the string to a unique index value and use it in place of the ASCII string. (This library contains the function <I>StringToAtom()</I> for this purpose. It returns the same unique index value for two ASCII strings if and only if they are identical.)<P>
A program informs the message manager of the binding between a port variable and a port identifier by using the <I>MsgWatchPort ()</I> or <I>MsgOpenPort ()</I> function. All other message manager functions only use port identifiers.<P>
A port variable may be unidirectional or bidirectional. A thread sets a port variable for reading by calling the function <I>MsgWatchPort ()</I> with a port identifier and the address of its corresponding port variable. When another thread indirectly writes to that port variable, the message manager notes the arrival of this message to this thread and takes the appropriate action.<P>
A thread sets a port for writing by calling the function <I>MsgConnectPorts ()</I> with an output port identifier and an input port identifier (the destination port) in another thread. Multiple input port variables (up to a system-defined limit) may be connected to a single output port. When using <I>MsgConnectPorts ()</I>, no actual output port variable is required. Alternatively, a thread can set a port for writing by calling the function <I>MsgOpenPort ()</I> with a port identifier and the address of a port variable. Here, it is assumed that other threads will connect their input port variable(s) to this output port. A lower layer of competence uses the <I>MsgOpenPort ()</I> function to provide feedback values for the higher layers.<P>
A thread writes to a port by calling the function <I>MsgWritePort ()</I> with the output port identifier and the value it is writing. This function updates the value of the output variable (if it was registered via <I>MsgOpenPort ()</I>) and finds all threads with input port variables connected to this output port (by <I>MsgConnectPorts ()</I>). It then updates these input port registers and places the threads on the runnable queue.<P>
A thread calls <I>MsgSuppressPorts ()</I> with an output port identifier and the identifier of an output port (usually in another thread) to be suppressed. The semantic of this function is that whenever the thread writes to the output port (the first argument to the <I>MsgSuppressPorts ()</I> function) via <I>MsgWritePort()</I>, all the input ports attached to the suppressed port (the second argument) will receive this value for a system-defined period. Any other writes during this period is ignored and will not get passed to the attached ports.<P>
A thread calls <I>MsgInhibitPorts()</I> with an output port identifier and the identifier of an input port to be inhibited. Whenever the thread writes to the output port with <I>MsgWritePort()</I>, the inhibited input port will receive this value (for a system-defined period) instead of from the output port that it may be connected to.<P>
A thread also may read the current value of any output port variable by calling <I>MsgPeekPort()</I> with the port identifier of an output port variable.<P>
Note that the system does not care if you specify the same port identifier (i.e., same ASCII string) for two different port variables. The result is undefined. <I>MsgConnectPorts()</I> may also be called anywhere, including in functions that are lexically far from the threads whose variables are involved in the call. However, since this practice obscures the interface between the threads, it is not recommended. As a programming style, I use ASCII strings in the form of either <I>thread_function_name.in.digit</I> (e.g., <I>alphaPos.in.2)</I> , or <I>thread_function_name.out.digit</I>, where "in" and "out" signify an input or output register respectively.<P>
A thread may wait for a semaphore by calling the function <I>MsgWatchSemaphore()</I> with a unique identifier. The second argument to the function specifies whether the thread is watching for the clearing of or the setting of the semaphore. A semaphore is set and cleared via the functions <I>MsgSetSemaphore() and MsgClearSemaphore()</I> respectively.<P>
<h4><FONT COLOR="#000080"><A name="0241_0133">Implementation Of The Multithreading Executive<A name="0241_0133"></FONT></h4></P>
There is almost enough machinery in standard C to write all the functions in the multithreading executive. The standard library functions <I>setjmp() </I>and <I>longjmp(),</I> which implement non-local <I>gotos</I>, are enough to implement the thread-switching function <I>ExecSwitch()</I>. These functions work in the following ways: when <I>setjmp()</I> is called with a <I>jump buffer</I>, it returns immediately with the value <I>0</I>. Later, if the function <I>longjmp()</I> is called with that same jump buffer, then execution returns to where the <I>setjmp()</I> is called; this time as if <I>setjmp()</I> returns with the second argument to <I>longjmp()</I> as its value. If the second argument of <I>longjmp()</I> is <I>0</I>, then <I>setjmp()</I> returns a value of <I>1</I>.<P>
The internal function <I>ExecSwitch()</I> first checks for possible stack overflow, then records the current thread's execution context via a call to <I>setjmp()</I>. It then calls another internal function, <I>execRunNewThread()</I>, which takes the first thread off the runnable queue and switches back to that thread via a call to <I>longjmp()</I>. The execution continues in this new thread as if its call to <I>setjmp()</I> inside <I>ExecSwitch()</I> has just returned again with a message identifier. <I>ExecSwitch()</I> then returns to <I>MsgGetMsg()</I> which in turn returns the message identifier to the thread that calls it.<P>
One concern with these functions is that <I>setjmp()</I> and <I>longjmp()</I> do not address the issue of setting up the initial stack pointer for each thread. In theory, <I>longjmp()</I> should not be called if the function that originally calls <I>setjmp()</I> has already exited since the stack context may no longer be valid. Some C-and C++-based multithreading executives deliberately ignore this constraint so that the stack space for all the threads is allocated on the stack of the running program. This technique, however, makes thread stack allocation tricky and obscure. Under this scheme a program may be forced to create all the possible threads at once, because the alternative of allowing a program to create a thread anytime is difficult to implement.<P>
I chose a different approach to allocate thread stack space. The <I>ExecCreateThread()</I> function allocates stack space for a thread dynamically via the standard C function <I>calloc()</I> and stores the address of the returned value in the thread's context. When calling a thread function for the first time, the scheduler function <I>ExecSwitch()</I> changes the stack pointer so that the new thread will use the correct stack pointer. This is only done at the initial call to a thread since normal thread-switching uses the functions <I>setjmp()</I> and <I>longjmp()</I> to save and restore execution context, including the stack pointer.<P>
Since there is no portable way of changing stack pointers in C, it is done using a small assembly routine. I wrote a prototype C routine that does everything except modify the stack pointer, then compiled it to assembly. I then modified the assembly file to handle stack switching for a particular machine environment. This compile/modify technique makes it relatively easy to port this part of the system to different environments.<P>
I did encounter one problem with this approach. The library in the HC11 cross compiler that I am using assumes that if a stack address is lower in value than a heap address, then the heap must have overrun the stack. This would be true in normal cases since the heap is allocated upwards from the bottom of a free data segment and the stack is allocated downward from the top of the same data segment. It is not true here because the "stack" is really another heap item, so I had to write a very simple-minded linear stack allocator to circumvent this problem.<P>
<h4><FONT COLOR="#000080"><A name="0241_0134">About The Listings<A name="0241_0134"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
contains the multithreading executive. <A href="list2.htm">Listing 2</a>
(sans the servo interface code) is the control software for a simple six-legged walking robot.<P>
The <A href="list2.htm">Listing 2</a>
code is based on the description of a simple walking algorithm for Genghis in <a href="#ref4">[4]</a>. Notice that there is no routine that is consciously doing any walking &#151; the closest it comes is that the highest layer function, <I>TripodGait()</I>, alternately raises its legs in a tripod gait.<P>
This code is intended to control the movement of a six-legged "ladybug" robot (for which the hardware is being built by Donald Doughty). The robot's brain is an MC68HC11 EVB, chosen because it contains many features that are useful for embedded work, such as a serial and parallel interface, some A/D converters, and several timers on one chip. The EVB emulates all the features of the CPU while providing a ROM monitor, 16K of user RAM space and an RS-232 port. The monitor and the RS-232 port allow programs to be developed on the host, typically on an IBM PC, and executed on the EVB. The EVB interfaces 12 Futuba servos &#151; two per leg &#151; through a custom-designed interface board. One servo moves the leg back and forth and the other moves it up and down. (As of this writing, the hardware for the project, which is part of my master's thesis, is not yet finished and the code is incomplete; if you are interested in the project, you may contact me at the address given in my bio.)<P>
<h4><FONT COLOR="#000080"><A name="0241_0135">Bibliography<A name="0241_0135"></FONT></h4></P>
<a name="ref1">[1]</a>     "Achieving Artificial Intelligence Through Building Robots," Rodney A. Brooks, MIT AI Memo 899, May 1986.<P>
<a name="ref2">[2]</a>     "A Robust Layered Control System For a Mobile Robot," Rodney A. Brooks, MIT AI Memo 864, September 1985.<P>
<a name="ref3">[3]</a>     "The Behavior Language; User's Guide," Rodney A. Brooks, MIT AI Memo 1227, April 1990.<P>
<a name="ref4">[4]</a>     "A Robot That Walks; Emergent Behaviors from a Carefully Evolved Network," MIT AI Memo 1091, February 1989.<P>
Listings &#151; All code in this listing copyright (c) by Richard F. Man 1991. All rights reserved.<P>
<h4>Sidebar: <A href="sidebar1.htm">"Subsumption Architecture: Moving Robots In The Real World"</A>

<h4><a href="../../../source/1991/nov91/man.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
