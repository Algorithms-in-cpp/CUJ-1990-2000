<HTML>   
     <HEAD>
<TITLE>June 1999/Implementing a Request Distribution Server with DCOM and ATL</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Implementing a Request Distribution Server with DCOM and ATL</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">James J. Fan</FONT></H3>

<BLOCKQUOTE>
<p>You can do the darndest things with DCOM, including load balancing with a relatively simple daemon.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<h4><FONT COLOR="#000080">Introduction</FONT></H4>

<p>A request distribution server is a server that distributes client requests across clustered machines, so that user access time will be shorter while the cost of providing large-scale service remains low. In this article, I present a simple request distribution server, LoadBal. It balances the creation of DCOM (Distributed Component Object Model) objects on a cluster of up to eight Windows NT machines. LoadBal is installed on a master NT machine, and when it receives a request to create a DCOM object, it creates the object on a slave machine based on a round-robin algorithm. LoadBal is implemented as a DCOM server; it is developed using ATL (Active Template Library); and it runs as an NT service.</p>

<h4><FONT COLOR="#000080">Some Background on DCOM and ATL</FONT></H4>

<p>DCOM is the Microsoft model of distributing objects over a network. A DCOM server can create object instances of multiple object classes. A DCOM object can support multiple interfaces, each representing a different view or behavior of the object. An interface consists of a set of functionally related methods. A DCOM client uses DCOM objects by requesting that an object be activated on the server; the client is passed back an interface to that object. Once the client obtains the interface, it can access the interface as if the server object resides within the client's address space. This is done through a piece of code called a proxy; it exists in the client address space. A similar piece of code called a stub resides in the server address space. When the client invokes a method of the interface, it invokes the method on the proxy. The proxy passes the invocation to the stub code on the server via RPC (Remote Procedure Calls). The server itself may or may not be on the same machine as the client. The stub on the server unmarshals the request, and invokes the method on the server object.</p>
<p>A DCOM server can be implemented as an EXE, a DLL, or an NT service. An NT service is conceptually similar to a Unix daemon. The Service Control Manager starts, stops, and controls services <a href="#1">[1]</a>. The reason for implementing LoadBal as an NT service is the need to retain some common state information even if no instance of the server object has been instantiated. An NT service can fulfill this need because it remains in the address space even if no instance of the server object has been instantiated.</p>
<p>A DCOM server can be easily implemented as an NT service using ATL. ATL is a template library that is designed for writing DCOM servers. Using ATL significantly simplifies the daunting task of developing DCOM servers, without greatly increase code size. ATL 2.1 comes as part of Visual C++ 5.0, and an identical version called ATL 2.0 is available on Microsoft's web site for users of previous versions of Visual C++ <a href="#2">[2]</a>.</p>

<h4><FONT COLOR="#000080">The Objmill Class</FONT></H4>

<p>The main class responsible for creating DCOM objects in round-robin fashion is called <B>Objmill</B>. The definition appears in <A HREF="fig1.htm">Figure 1</A>.  This source code was generated by the ATL COM AppWizard. This source code is provided in its entirety on the CUJ ftp site, but I also provide documentation on the ftp site that explains how to use the ATL wizards to create the project and source files. (See p. 3 for instructions on accessing the ftp site.)</p>
<p><B>ObjMill</B> contains one primary method: <B>CreateObject</B>. This function takes two parameters. The first is a string describing the type of the requested object. <B>CreateObject</B> creates the requested DCOM object on a machine based on a round-robin algorithm, and returns a pointer to the interface of the requested object.</p>
<p>In DCOM, there are two ways to identify the type of an object class, CLSID and ProgID. A CLSID is a GUID (Globally Unique Identifier), which is a unique 128-bit number. Here's an example of a CLSID:</p>

<pre>
{0xF503FAD1,0x7FFC,0x11D2,
   {0xAD,0xD5,0x00,0xC0,
    0x4F,0xD0,0xCD,0x29}
}
</pre>

<p>A ProgID is a string that uniquely identifies the corresponding class. Here's an example of a ProgID:</p>

<pre>
ObjMill.ObjMill.1
</pre>

<p>A CLSID can be converted from a ProgID by calling <B>ProgIDFromCLSID</B>, or vice versa.</p>
<p>The first parameter to <B>CreateObject</B>, <B>szProgId</B>, is of type <B>BSTR</B>. <B>BSTR</B> is a string type provided by DCOM. It is implemented as an array of wide chars, plus a header that indicates the size of the string. Because the header part is hidden from the user and is used by DCOM, a <B>BSTR</B> can be viewed as an array of wide chars. However, a <B>BSTR</B> can be created only by calling <B>SysAllocString</B>, and it should be destroyed by <B>SysFreeString</B> after it has been used. ATL provides macros such as <B>USES_CONVERSION</B>, <B>T2OLE</B>, and <B>OLE2T</B> to ease the conversion to and from <B>BSTR</B>.</p>
<p>The last parameter to <B>CreateObject</B>, <B>ppRetObj</B>, is the address of a pointer to an <B>IUnknown</B> interface. An <B>IUnknown</B> is the basis of all other DCOM interfaces. The <B>IUnknown</B> interface contains the following functions: <B>QueryInterface</B>, <B>AddRef</B>, and <B>Release</B>. Because <B>CreateObject</B> doesn't know which interface of the requested object a user wants, it just hands back the generic <B>IUnknown</B> interface. The user can call the <B>QueryInterface</B> method on <B>IUnknown</B> to request a specific interface later on.</p>
<p>There are a couple of things in the signature of <B>CreateObject</B> that bear some explanation &#151; they're not pure C++. <B>STDMETHOD</B> is a COM macro that wraps the method declaration. The comment <B>/*[in]*/</B> in the parameter list indicates that <B>szProgId</B> is an <B>[in]</B> parameter, a parameter that passes data from the client to the server. (<B>[in]</B> and <B>[out]</B> are constructs defined in DCOM's Interface Definition Language, a.k.a. IDL. IDL can be used to define interfaces independently of programming languages.) The <B>/*[out]*/</B> comment in the parameter list indicates that <B>ppRetObj</B> is an <B>[out]</B> parameter, which means it is used to pass data from the server to the client. <B>[in]</B> parameters are allocated and freed by the client; <B>[out]</B> parameters are allocated by the server and freed by the client. The <B>[retval]</B> prefix indicates that <B>ppRetObj</B> is also the return value of the method.</p>

<h4><FONT COLOR="#000080">Other Members of Objmill</FONT></H4>

<p>Objmill</B> also has a few private data members. <B>m_MachinesNames</B> is a simple array of strings that holds the names of the machines in the cluster. The integer <B>m_nCount</B> keeps track of the number of machines in the cluster. <B>m_nCurrentMachine</B> keeps track of whose turn it is to create the next object. Because these three variables are shared among all instances of <B>ObjMill</B>, they need to be static. Note that since there may be many instances of <B>ObjMill</B> updating <B>m_nCurrentMachine</B> at the same time, access to this variable must be serialized. For this purpose, <B>Objmill</B> declares a static variable, <B>m_hMutex</B>, that is used as a handle to a mutex.</p>
<p>Mutexes are one kind of kernel object Win32 API provides for thread synchronization. To use a mutex, a program must first create it by calling <B>CreateMutex</B>. Like any other kernel object, a mutex has two states at any time: signaled or nonsignaled. Threads sleep while the mutex they are waiting for is nonsignaled. As soon as the object becomes signaled, the sleeping thread sees the flag, wakes up, and resumes execution <a href="#3">[3]</a>.</p>
<p><B>Objmill</B> also defines a couple auxiliary member functions, <B>Startup</B>, <B>Cleanup</B>, and <B>CreateObjectAt</B>. <B>Startup</B> reads in the list of machine names in the cluster from an <B>.INI</B> file, whose name is specified by a registry entry, and it sets the mutex handle. <B>Cleanup</B> closes the mutex handle. <B>CreateObjectAt</B> takes the ProgId of an object, and the name of the machine on which the object will be created. It first checks whether the machine name is empty. If so, it just uses the name of the machine on which it resides. Then <B>CreateObjectAt</B> converts the ProgId to CLSID by calling <B>CLSIDFromProgID</B>, and obtains the interface ID of <B>IUnknown</B>. Finally, <B>CreateObjectAt</B> creates the object on the machine specified, by calling <B>CoCreateInstanceEx</B>, and hands the reference to this object back to the caller.</p>
<p>The method <B>CreateObject</B> picks the machine name according to <B>m_nCurrentMachine</B>, calls <B>CreateObjectAt</B> to create the object, and advances <B>m_nCurrentMachine</B>. The call to advance <B>m_nCurrentMachine</B> is bracketed by calls to <B>WaitForSingleObject</B> and <B>ReleaseMutex</B>. This pair of API calls ensures that no two threads can update <B>m_nCurrentMachine</B> simultaneously. <B>WaitForSingleObject</B> puts the thread to sleep until <B>m_hMutex</B> is signaled. Once <B>m_hMutex</B> is signaled, the thread wakes up, and changes the mutex to the nonsignaled state. After <B>m_nCurrentMachine</B> is updated, <B>ReleaseMutex</B> puts <B>m_hMutex</B> back in the signaled state.</p>
<p>Because <B>ObjMill</B> is running as an NT service, it must use the Event Log to track any errors encountered. Unlike Unix, NT does not have the concept of a master console. Services cannot count on a console being available to receive output or error messages. However, NT does provide event logging capability. All applications can access the event log to record significant information, and the event log can be easily viewed from any machine on the network. Using the event log, however, requires that you develop a series of messages in advance and compile them using the message compiler, which can be a complex process <a href="#1">[1]</a>. Luckily, ATL provides a simple implementation of logging to event log as a method of the standard <B>CServiceModule</B> class.</p>

<h4><FONT COLOR="#000080">Running the Request Distribution Server</FONT></H4>

<p>In the online documentation, I show how to use the ATL wizard to create a project named LoadBal. LoadBal is a project that creates the load balance server (<B>Objmill</B>) as an NT service. The <B>_tWinMain</B> function for the project is in the file <B>LoadBal.cpp</B>, <A HREF="fig2.htm">Figure 2</A>. This function calls the <B>Objmill</B>'s <B>Startup</B> method to start the NT service, and it calls the <B>Cleanup</B> method after the service has ended.</p>

<h4><FONT COLOR="#000080">Creating a Sample DCOM Server</FONT></H4>

<p>Testing LoadBal will require creation of a sample DCOM server, <B>svrCompName</B>. This server has only one function, <B>GetCompName</B>, which returns the name of the computer on which the server resides. This will be a good test to see how evenly the load balance server distributes the requests.</p>
<p>Like the LoadBal project, creating the sample server involves creation of a new project space (called <B>svrCompName</B>), using the ATL COM AppWizard. Again, I provide detailed instructions for using the ATL wizard on the <I>CUJ</I> ftp site. There I show how to create a DCOM server of type "Executable (EXE)," and add a method called <B>Name</B>, with parameter <B>[out retval] BSTR* szComputerName</B>. <A HREF="fig3.htm">Figure 3</A> shows the implementation.</p>

<h4><FONT COLOR="#000080">Creating a Sample DCOM Client</FONT></H4>

<p>I've used MFC to create a simple test client. This client instantiates an <B>ObjMill</B> object, uses the <B>CreateObject</B> method on <B>ObjMill</B> to create a <B>CompName</B> object, and invokes the <B>Name</B> method on <B>CompName</B>. The client displays the name of the computer on which <B>CompName</B> resides in a message box.</p>
<p>The client must initialize the DCOM libraries by adding the initialization code shown in the <B>CSampleClient::InitInstance</B> function in the <B>SampleClient.cpp</B> file (<A HREF="fig4.htm">Figure 4</A>).</p>
<p>The last thing to implement is code to instantiate an <B>ObjMill</B> object and use it to create a <B>CompName</B> object. You'll need to include <B>LoadBal.h</B> and <B>svrCompName.h</B> in both <B>SampleClient.h</B> and <B>SampleDialog.h.</B> You'll also need to define the interface ID and CLSID of <B>ObjMill</B> and <B>CompName</B> in <B>SampleClientDlg.cpp.</B> These IDs can be copied from the <B>LoadBal_i.c</B> file and <B>svrCompName_i.c</B> file. Note: you need to change the server name to the name of the machine on which LoadBal is installed.</p>

<h4><FONT COLOR="#000080">Setting up Tests</FONT></H4>

<p>Setting up the tests involves setting up registry entries on the slave machines and the master machine, as well as on the client machine. I provide detailed instructions on the <I>CUJ</I> ftp site.</p>
<p>You'll start the request distribution service as someone in your domain other than the local system account, because the local system account cannot create objects on remote machines. Make sure that account belongs to the Administrator group on all slave machines.</p>
<p>When you run <B>SampleClient.exe</B> several times, you should see a different machine name listed in the message box every time.</p>

<h4><FONT COLOR="#000080">Limitations and Further Enhancements</FONT></H4>

<p>Limitation 1 &#151; maximum number of machines. LoadBal can distribute requests among a maximum of eight slave machines. This is because <B>Objmill</B> uses a simple array to contain the names of the machines in the cluster, and the array has a maximum size of eight. A programmer could remove this limitation by using a more sophisticated data structure, such as a <B>vector</B> as defined in Standard Template Library.</p>
<p>Limitation 2 &#151; unequal resource loads. LoadBal does a good job of balancing the creation of objects, but not all objects are created equal! Some objects take a lot more resources than others; some are more active than others; some objects have longer lives than others. The round-robin algorithm does not take into account any of these aspects. There are a couple of ways to take these aspects into consideration. For example, a separate thread can be constructed to periodically collect the loads of machines in the cluster, and distribute the creation of objects accordingly.</p>
<p>Limitation 3 &#151; overhead in the master machine. Because every DCOM object created requires the existence of an <B>ObjMill</B> object, there must be at least one instance of <B>ObjMill</B> for each client. This may impose a huge overhead for the master machine when the number of clients becomes large. For example, suppose there are 1,000 clients, each of which creates four objects, distributed over a cluster of eight machines. Then each machine will host approximately (1,000 x 4)/8 = 500 objects. However, the master machine will host 1,000 objects. If the master machine is also a slave machine, then it will host 1,500 objects. One solution is to have a separate powerful machine that hosts only <B>ObjMill</B>; another solution is to install <B>ObjMill</B> on very machine in the cluster, and designate groups of clients to create <B>ObjMill</B> on certain machines so that the number of <B>ObjMill</B> instances are distributed across all machines evenly. But then, "distributing across all machines evenly" is what LoadBal is for! This means you can use <B>ObjMill</B> itself to create <B>ObjMill</B>, so that the number of <B>ObjMill</B> instances are distributed evenly across the cluster, and the overhead for the master machine can be minimized. To be more specific, create an <B>ObjMill</B> from one machine, and use it to create an <B>ObjMill</B>. Destroy the first instance of <B>ObjMill</B>, and keep the second instance to create other objects.</p>
<p>Limitation 4 &#151; security compromise. I've used default DCOM security here for the sake of simplicity. This means that when LoadBal creates another object, the result object will be running under the same user as the user LoadBal is running under. This will create a problem if the client is running under a different user than the service. For example, if the service is running under John's account, then the object it creates will be running under John's account as well; but the client may be running under Jane's account. This problem comes from making the objects to be balanced accessible to everybody. The problem can be fixed by coding impersonation into LoadBal.</p>

<h4><FONT COLOR="#000080">Summary</FONT></H4>

<p>In this article I've presented a simple request distribution DCOM server running as an NT service. I provide a set of step-by-step instructions on how to create the request distribution server, using ATL, on the <I>CUJ</I> ftp site. While I've emphasized the simplicity of the server, it should be quite easy to modify and thus improve.</p>

<h4><FONT COLOR="#000080">References</FONT></H4>

<p><a name="1"></a>[1]  John T. Bell. "A Wrapper Class for NT Services," <I>C/C++ Users Journal,</I> August 1998, p. 35.</p>
<p><a name="2"></a>[2]  Richard Grimes. <I>Professional DCOM Programming</I> (Wrox Press, Inc), Chapter 3.</p>
<p><a name="3"></a>[3]  Jeff Richter. <I>Advanced Windows</I> (Microsoft Press), Chapter 10.</p>

<p><i>James Fan got his B. S. in Computer Sciences from the University of Texas at Austin. Currently he is working as a programmer analyst, developing DCOM components. He can be reached at <B>jjfan@email.com</B>.</i></p>

<h4><a href="../../../source/1999/jun99/fan.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY>
</HTML>
