<HTML>   
     <HEAD>
<TITLE>August 1999/We Have Mail</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">We Have Mail</FONT></H2>

<hr>

<BLOCKQUOTE>
<p><i>Letters to the editor may be sent via email to </I>cujed@mfi.com<I>, or via the postal service to Letters to the Editor, </I>C/C++ Users Journal<I>, 1601 W. 23rd St., Ste 200, Lawrence, KS 66046-2700.</i></p>

<hr>
<p>Dear <I>CUJ</I>,</p>
<p>Just a quick note to let you know about a typo in my article titled "A Wrapper Class for Dynamically Linked Plug-ins" (<I>CUJ,</I> May 1999). In the article introduction, I indicated that I was using the GNU GCC compiler v2.8.2 on Solaris. In fact, the most recent version of GCC is 2.8.1. Sorry for any confusion.</p>
<p>Eric Roe</p>
<p></p>
<p><i>Thanks. &#151; mb</i></p>

<hr>
<p>Dear Editor,</p>
<p>I enjoyed Daniel Wisehart's article on "Debugging Embedded Systems" (<I>CUJ,</I> June 1999). I found the techniques for debugging multithreaded applications particularly interesting. However, I found one error that probably deserves comment.</p>
<p>Mr. Wisehart seems to have confused his descriptions of the DATA and BSS memory sections. He places uninitialized global data in the DATA section, and initialized global data in the BSS sections. Actually, the reverse is true. The DATA section contains initialized data, which is copied from ROM into RAM by the C startup code. BSS merely reserves memory for data that will be initialized at runtime (i.e., uninitialized data). Most C startup routines will fill the contents of BSS with zeros.</p>
<p>I thought at first that this might be a typo, but the author refers to these sections incorrectly several times in the "Understanding Embedded Memory" section, and in Figure 1. He also refers to constant BSS data, which does not exist. I believe that older (<B>a.out</B>?) executable file formats put constant data, like the first few lines in Figure 1, in the TEXT section. Newer formats will designate a separate memory section for this data, such as RODATA or STRINGS.</p>
<p>All of this can make for serious brain pain for programmers who haven't had to deal with it, but it is nevertheless important to understand. I look forward to seeing more <I>CUJ</I> articles on programming "close to the hardware."</p>
<p>With best regards,</p>
<p>Michael Elwood<br>
<b>mkelwood@qsicorp.com</b></p>
<p></p>
<p><I>Dan Wisehart replies:</p>
<p>Dear Mr. Elwood,</p>
<p>Thank you for your kind remarks on my article and for catching my error.</p>
<p>It has been a long time since I looked up the definitions of DATA and BSS. As you noted, I transposed their usage. I believe that if you reverse them in the article, the article stands otherwise correct.</p>
<p>I appologize for my error and again thank you for your comments.</p>
<p>Regards,</p>
<p>Daniel Wisehart</p>
<p></p>
<p>It's my job to catch things like this and I missed it. I do know the difference between DATA and BSS. Mea culpa. &#151; pjp</i></p>

<hr>
<p>Hi,</p>
<p>I am a regular reader of you magazine, and a professional C++ developer. I enjoy Chuck Allison's "import.java.*" column very much &#151; it provides the right amount (and kind) of Java information that I need for my current level of interest in that language. I am writing to you because I have a strong disagreement with an opinion voiced in Chuck's column in the May 1999 issue.</p>
<p>In comparing C++ constructor/destructor semantics to the Java try/finally block, Chuck writes that "...Java doesn't have destructors, but it does have the <B>finally</B> clause, which is an even better solution..." I couldn't disagree more, and I bet most of your C++ readership will also disagree with such an odd statement.</p>
<p>C++ constructor/destructor semantics give a class author the opportunity to totally encapsulate resource allocation/release from the class user code. This greatly reduces the chance of errors due to class users forgetting (or misunderstanding) the implementation details of the resources being managed by the class. I have found it a fundamentally recurring theme in object-oriented programming that classes should control their own resources internally (especially under exceptional conditions), regardless of the programming language being used.</p>
<p>The fact that Java class user code must deal with the releasing of class resources during exceptions breaks encapsulation, almost forcing a Java class author to provide public access to initialize and restore resources that might otherwise be kept hidden from the users of the class. This causes exactly the kind of resource leaking maintenance code nightmares that programmers are consistently trying to avoid by defensive programming. The only advantage I see to the Java <B>finally</B> clause is that it gives the Java developer a chance to handle resource clean-up under exception handling, and it seems to me that it exists to solve the problems left over by the lack of destructors in Java, and not as a better solution, as Chuck implies in his column.</p>
<p>The sample source code accompanying the article even supports this &#151; Chuck's own class user code shows that a publically accessible "close" method must be used for no other reason than to handle file resource deallocation under exception processing!</p>
<p>I hope Chuck's column continues to provide important cross-language commentary in spite of my disagreement on this one particular point.</p>
<p>Sincerely,</p>
<p>Allen Broadman</p>
<p></p>
<p><I>Chuck Allison replies:</p>
<p>I must admit I spoke rather loosely. What I was actually thinking is that Java's </I><B>finally</B><I> is an improvement over C++ exception handling control syntax, and that it is convenient in some situations to just use </I><B>finally</B><I> instead of having to create a wrapper object whose destructor deallocates a resource. But I didn't mean to say that </I><B>finally</B><I> was a replacement for object-based resource management, let alone an improvement. I appreciate your sound and thoughtful feedback.</p>
<p>Chuck Allison (The Harmonious CodeSmith)<br>
Consulting Editor, C/C++ Users Journal<br>
</I><b>cda@freshsources.com</b></p>

<hr>
<p>Dear <I>CUJ,</I></p>
<p>Help! My C++ Bibles are totally out of date. What are some of the best ones published since C++ has been standardized?</p>
<p>Sharon Harvey<br>
Normandale Community College<br>
Bloomington, MN</p>
<p></p>
<p><I>It depends on what you look for in a "Bible." If you're looking for a book of Do's and Don'ts, get Scott Meyers' </I>Effective C++<I>, Second Edition. I'd recommend Chuck Allison's book, </I>C&amp;C++ Code Capsules<I>, for a practical treatment of key C++ features. Matt Austern's </I>Generic Programming and the STL<I> is definitely New Testament, and worth having if you're going to do anything with STL. Finally, Bjarne Stroustrup's </I>The C++ Programming Language<I>, Third Edition, is as formidable as most bibles in terms of sheer page count, and makes a good all-around reference. Hope this helps. &#151; mb.</i></p>

<hr>
<p>Hi Marc,</p>
<p>I just got the June <I>CUJ</I> and read Mr. Bavestrelli's article. I hope you wouldn't mind if I shared a few criticisms with you &#151; and him. I started reading the article with hope. I always considered assertions a powerful tool and I was expecting to find new and interesting things. I easlily passed over the slight inaccuracy right in the opening "certainly my favorite statement is <B>assert</B>." (<B>assert</B> is not a statement, it's a macro. But anyway that's food for language lawyers.)</p>
<p>All my hopes fell apart when I read the author's "favorite macro:"</p>

<pre>
#define SAFE(exp) (ASSERT(exp), (exp))
</pre>

<p>No matter how fond the author is about it, that's plain bad advice he's giving. Macros that double evaluate their argument are evil. To compound the problem, the macro evaluates the expression only once in release builds, yielding to subtly different behaviors. Read: incredibly hard to trace bugs, defeating the whole purpose of this "debugging" macro in the first place.</p>
<p>The proof is in the article itself. The author spends most of the article carefully explaining that you should use great care in exercising the macro. He tries to provide a useful aid in debugging, but the tool itself is at best fragile, comes with a pile of caveats, and relies on a lot of programmer discipline to be properly used. That's not a tool.</p>
<p>There are a few ways around it. It would have been impossible in spaceship-era C++ with templates, exceptions, and type inference to rely on such an abomination for getting decent debugging. The tools I like the most were written by Petru Marginean (<B>margineanp@mmanet.com</B>). I would certainly recommend you to follow up with him.</p>
<p>Reading the code, I also found some other problems. Basically I didn't like any of the macros, as the author relies heavily on them. In my humble opinion, macros in C++ should be at most thin layers that add preprocessor variables and a bit of syntactic sugar over function calls or <I>very</I> carefully-chosen constructs. Please allow me to explain my disagreements one by one:</p>
<p>1.  <B>ASSERT(v)</B> inexplicably uses the ancient MFC constant <B>THIS_FILE</B>, where <B>__FILE__</B> would have been much more portable and appropriate.</p>
<p>2.  <B>ASSERT_ONCE</B> uses a bracketed statement that can be terminated by its user with or without a semicolon, leading to confusing constructs. For instance, the following code fails mysteriously to compile:</p>

<pre>
if (something)
    ASSERT_ONCE(blah);
else
    statement
</pre>

<p>As Alan Perlis would have put it, "Syntactic sugar causes cancer of semicolon."</p>
<p>What about a static inline template function taking <B>__LINE__</B> as the template parameter and sporting a static variable inside?</p>
<p>3.  <B>ASSERT_LEN</B> does not work correctly for simple pointers. The problem is, it doesn't signal this at compile time. Ironically, only a few months ago Bobby Schimdt hashed to death the <B>lengthof</B> pseudo-keyword that measures the length of a fixed-size array in a typesafe manner.</p>
<p>4.  <B>ASSERT_ARRAYINDEX</B> relies on <B>ARRAYSIZE</B> which does not appear in the article. Given the macro aboundance, I guess <B>ARRAYSIZE</B> is nothing but the ill-recommended:</p>

<pre>
#define ARRAYSIZE(s) (sizeof(s) / sizeof(*s))
</pre>

<p>which again fails silently to work for dynamically-sized arrays. Again, <B>ARRAYSIZE</B> evaluates its argument twice. <I>[No it doesn't. It evaluates it zero times. &#151; pjp]</I></p>
<p>5.  Going to the implementation file, I found a fixed-size buffer used with <B>sprintf</B> in a very risky way. The buffer isn't even generously allocated &#151; 1,024 bytes for a long message containing a full path, an arbitrary long expression, and an arbitrary long appplication name. All this in a debugging library.</p>
<p>6.  The log filename is hardcoded, making the design unappealing for a library.</p>
<p>7.  The catch statement does not catch the dynamically allocated MFC exceptions (<B>CException</B> and derivees). Each time you'll have an exception in that code, a memory leak will occur. This, again, in a debug library.</p>
<p>For all these reasons, I would recommend <I>CUJ</I> readers not to use any of the macros in their actual form. Each and every of them is a vivid example on how badly macros can be misused. There are ways to do all what they (unsuccessfully) attempt to do and more, in a true C++, safe manner. The underlying code is also very brittle, especially for a debug library, and needs serious rework.</p>
<p>I hope this helps both the author and the magazine readers.</p>
<p>Best regards,</p>
<p>Andrei Alexandrescu</p>
<p></p>
<p><I>Giovanni Bavestrelli replies:</p>
<p>Dear Marc,</p>
<p>I knew it would happen some day, after the considerable very positive feedback I received, I got the first negative feedback to one of my articles (luckily, my third). Here is my answer to Andrei Alexandrescu's mail that you sent me:</p>
<p>Andrei Writes:</p>
<p>"Macros that double evaluate their argument are evil. To compound the problem, the macro evaluates the expression only once in release builds, yielding to subtly different behaviors. Read: incredibly hard to trace bugs, defeating the whole purpose of this &#145;debugging' macro in the first place."</p>
<p>Andrei is right (and I warned about this in my article) but does he think the same of the standard and acclaimed </I><B>assert</B><I> macro? He says, "I always considered assertions a powerful tool." But the Standard C library (or the MFC one for that matter) </I><B>assert</B><I> macro has the exact same problem he so adamantly condemns. The macro does not evaluate the expression in release builds, but evaluates it once in debugging builds, opening up the door to all the same incredibly hard to trace bugs Andrei talks about.</p>
<p>Actually, for the standard </I><B>assert</B><I> macro the problems are more common. Any side effect in a standard </I><B>assert</B><I> can give problems, whereas only side effects that are different between one evaluation and the next of the expression within </I><B>SAFE</B><I> can give problems (as I stated in the article). Anyway, the difference in number of debug/release evaluations (2-1=1, 1-0=1) between </I><B>assert</B><I> and </I><B>SAFE</B><I> is the same, but I think in general </I><B>assert</B><I> has helped to find more bugs than it created, and so will </I><B>SAFE</B><I> if used appropriatelly. That's why I dedicated most of the article to explaining how it works and warning about the potential problem of the double evaluation in debugging builds, trusting programmers would learn how to use it to their advantage, as they have done with </I><B>assert</B><I> for so many years. It seems to me that assertions, as well as most tools (not just with C++) do indeed "rely on a lot of programmer discipline to be properly used." Such is life.</p>
<p>That said, there is indeed a much better way to define </I><B>SAFE</B><I> using templates, that does not suffer from the double-evaluation problem but maintains its expressiveness and usefulness. (Thanks to Mark Lee for being the first to point it out to me.)</i></p>

<pre>
#ifdef _DEBUG
   template&lt;class T&gt;
   inline T __safe(T expr,
      LPCSTR file, int line,
      LPCSTR err)
   {
       if(!expr)
           GioAssertFailedLine(file,
              line, err, "SAFE");
       return expr;
   }
   #define SAFE(expr)  __safe(expr, __FILE__, __LINE__, #expr)
#else
       #define SAFE(expr) (expr)
#endif
</pre>

<p><I>Why did it escape me? I played a lot with references (</I><B>operator&amp;</B><I>) and </I><B>const</B><I> in my few template function attempts, if I well remember, but all led to some compiler errors and ambiguities (maybe because in those days I was using Visual C++ 4.2?), and I missed such a simple solution! I do deserve some criticism, indeed!</p>
<p>Regarding Andrei's seven points:</p>
<p>1.  My code was for MFC, as the title said, and in MFC </I><B>ASSERT</B><I> still uses </I><B>THIS_FILE</B><I> (see </I><B>AFX.H</B><I>, line 223, in MFC 6.0). In the article, I suggested a definition of </I><B>SAFE</B><I> for users of the Standard C library that uses </I><B>__FILE__</B><I> (page 38). My sample code will not compile outside MFC. (It uses </I><B>CTime</B><I>, </I><B>CString</B><I>, etc.) In MFC, </I><B>THIS_FILE</B><I> has its own advantages (mainly reduced code size, I think).</p>
<p>2.  Andrei is right, his suggested solution would be better. I slipped in this macro at the last moment, and I should have tested it more first. I plead guilty.</p>
<p>3.  I never considered this a problem because I knew it and never used </I><B>ASSERT_LEN</B><I> with simple pointers. But again, Andrei is right. And I must confess I missed Bobby Schimdt's article. (Sorry, Bobby.)</p>
<p>4  </I><B>ARRAYSIZE</B><I> was in my header file, is on the ftp site, was edited away, and I did notice but didn't mind. It is not my invention, I have seen it in too many places to mention. Though this does not mean it's a good macro, I imagine most programmers know about it (and maybe even admit they used it).</p>
<p>5.  I have quickly increased it to 4,096, before my boss finds out.</p>
<p>6.  I did not want to provide a library, but just humble ideas, with some code to help. Anybody who thought there were good ideas in the article (and some did), can use the method he wants to set the filename. The method to pick the file name is beside the point, in my opinion, and I kept it simple (fixed) because of this.</p>
<p>7.  Here I totally agree with Andrei. I should have used MFC's </I><B>TRY/CATCH</B><I> instead of </I><B>try/catch</B><I>.</p>
<p>Thanks to Andrei for his suggestions, ideas and criticism, and my renewed compliments to him for his April 1999 CUJ article. I thought it was excellent (and I told him), though I haven't had a chance to look for any bugs yet.</p>
<p>With Respect</p>
<p>Giovanni Bavestrelli</p>
<p>P.S. Mama, why did you let me write an article on macros in 1999?</p>
<p></p>
<p>Like Bavestrelli, I don't think his </I><B>SAFE</B><I> macro is as "evil" as Alexandrescu makes it out to be. And some people still understand macros better than templates, which is important in a debugging tool. But if the article and subsequent feedback has brought a safer implementation to light, so much the better. </I>&#151;<I> mb</I></p>

</BLOCKQUOTE>
</BODY>
</HTML>
