


<HTML>
<HEAD>

<TITLE>January 1991/Software Engineering in C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Book Reviews</FONT></H2>

<hr><h2 align="center"><font color="#800000">Software Engineering in C<A name="0041_0021"><A name="0041_0021"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0041_0000"><A name="0041_0000">Robert E. Cady</font></h3><hr><blockquote><P>
<P><i><A name="0041_0000"><A name="0041_0000">Bob Cady holds bachelor's degrees in Computer Science, Electronics Technology, and Business Management and has been programming for 13 years. He is president of a software company developing communications programs for DOS and Windows. He may be contacted at Tethys Software Co, 6651 E. Indian River Rd., Suite 138, Va Beach, VA 23464-3441.</i></P><P>
Despite the title, <I>Software Engineering in C</I> is not about software engineering. The authors describe it in the preface as a textbook for beginning and intermediate C programmers. It serves that purpose well and emphasizes good programming style.<P>
This fast-paced book is organized into 12 chapters and six appendices. Every chapter concludes with exercises that test understanding of the material covered. It does not assume any particular operating system, hardware, or compiler.<P>
Chapter one briefly introduces high-level programming languages and the history of C. Chapter two explains the fundamentals of C programming: the preprocessor, the <I>#include</I> and <I>#define</I> directives, and the edit/compile/link/execute cycle. It also covers C functions in general and <I>main()</I> and <I>printf()</I> in particular, reserved keywords, variable naming, expressions, and assignments. Chapter three is an extensive discussion of scalar data types, including pointers and <I>typedef</I>. Notable are the sections on implicit and explicit conversions, enumeration types, and the mixing of data types in expressions.<P>
Chapters four through 11 cover the real meat of C programming. The authors use flow charts and formal syntax charts. Unfortunately, they don't describe either of these types of charts, so if you aren't already familiar with them, they may be more confusing than helpful. Chapter four introduces control flow, and discusses conditional branching, looping, the switch statement, and <I>gotos</I>. It also includes a section on infinite loops. Chapter five, "Operators and Expressions," covers precedence of operators, relational operators, and logical operators, but only briefly explains bitwise operators.<P>
Chapter six contains some of the best discussions of arrays and pointers I have seen. It gives good examples of initializing arrays, passing them to functions, and pointer operations on them. It also effectively covers pointer arithmetic and using arrays of pointers. Chapter seven, one of the most valuable chapters in this book, discusses storage classes. This chapter clearly describes scope and duration of variables.<P>
Chapter eight, "Structures and Unions," is the next most valuable chapter. This chapter clearly explains how to set up and use <I>unions</I> and nested structures. Chapter nine is a rigorous look at functions, pointers to functions, recursion, and prototyping. However, the discussion on calling functions using pointers is shallow. Because this book is not intended for advanced users, I don't consider this a major deficiency.<P>
Chapter 10 adequately discusses the preprocessor, with a good comparison of macros and functions. Chapter 11 extensively discusses file input and output. It explains buffered and unbuffered I/O, differentiating between sequential and random access methods.<P>
Chapter 12 is the only chapter that deals with software engineering, and it barely scratches the surface of this important topic. It covers product specification, software design, project management, software production tools, debugging, testing, performance analysis, and documentation in only 30 pages. By way of example, it includes the functional specification and project plan for a C interpreter. The book includes source code for the interpreter in an appendix.<P>
Appendix A is a comprehensive overview of the ANSI C standard, including a listing of all functions in the runtime library. Appendix B contains the formal syntax charts for the C language. Appendix C is a list of numerical and translation limits. Appendix D lists the differences between K&amp;R and ANSI C. Appendix E is a list of reserved names. Appendix F is a listing of the source code for the C interpreter referred to in Chapter 12. The source code is also available on diskette. Appendix G is the obligatory listing of ASCII character codes (up to <I>Ox7f</I>). This book was copyrighted in 1988. There have been numerous changes to the ANSI standard since then, so you can't rely on it as your reference to the standard.<P>
This book is written in a clear, friendly, and easy-to-read style. The sections in each chapter contain enough examples to adequately reinforce the subject matter. Each chapter contains sidebars containing either bug alerts or notes on ANSI implementation. The bug alerts include the usual errors, such as using an assignment operator (=) when a test for equality (==) is intended, or vice versa. It also highlights more subtle errors. For example, the expression<P>
<pre>if ((a &lt; b) &amp;&amp; (c == d++))</pre>
is discussed. It is certainly possible that a programmer would intend that <I>d</I> be incremented only if <I>a</I> is less than <I>b</I>, but it seems more likely that <I>d</I> should always be incremented. There are quite a few of these helpful alerts throughout the book.<P>
<h4><FONT COLOR="#000080"><A name="0041_0022">Summary<A name="0041_0022"></FONT></h4></P>
Although the authors intended this book for beginning and intermediate C programmers, I don't think it is suitable for beginning programmers. It is a very fast-paced book that implicitly expects the reader to have a good understanding of some other high-level structured programming language, such as Pascal or COBOL. As an advanced C programmer, I have found this book to be most valuable as a reference. In fact, it has replaced five C books I used to keep on the shelf above my programming desk. The replaced books include <I>K&amp;R</I> (first edition), Plum's <I>Reliable Data Structures In C</I>, and two bookds titled <I>Advanced C.</I><P>
I like this book and use it a lot. I'm not programming 12 hours a day as I used to, so I rely heavily on a good reference, especially when working under a deadline at a client site. <I>Software Engineering in C</I> is that reference and I highly recommend it. If you are going to have just a couple of books on C, include this one on your list.<P>
<I>Software Engineering in C</I><br>
Peter A. Darnell and Philip E. Margolis<br>
Springer-Verlag<br>
$32.00, 612 pages<br>
ISBN 0-387-96574-2<P>
</BLOCKQUOTE>
</BODY>
</HTML>
