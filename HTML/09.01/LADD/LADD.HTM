


<HTML>
<HEAD>

<TITLE>January 1991/Portability Across MS-DOS C Compilers</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Portability</FONT></H2>

<hr><h2 align="center"><font color="#800000">Portability Across MS-DOS C Compilers<A name="0022_0007"><A name="0022_0007"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0022_0000"><A name="0022_0000">Scott Robert Ladd</font></h3><hr><blockquote><P>
<P><i><A name="0022_0000"><A name="0022_0000">Scott Robert Ladd is a full-time free-lance writer with over 15 years computer programming experience. Scott works mostly in C and C++ when he's not hiking and shooting photos with his wife and daughter. He can be contacted at 3652 County Road 730 Gunnison, CO 81230. (303) 641-4219.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0022_0008">How Portable Is Portable?<A name="0022_0008"></FONT></h4></P>
Programs written in C are often touted as being more portable than those written in other languages. To be very portable, a program should use only the C language as defined by ANSI. After all, the ANSI standard exists to promote portability.<P>
Most MS-DOS programs, though, use low-level facilities that are not part of the ANSI standard. Still, MS-DOS C compilers are remarkably similar. Language extensions, such as the <I>near</I> and <I>far</I> keywords, are universally accepted with only minor differences in meaning. It's the non-ANSI extensions such as directory searching and hardware port I/O that are different from compiler to compiler. Experience has taught me that these differences range from the minor to the major.<P>
Is portability among MS-DOS C compilers a mirage, then? No. When I publish C programs, they need to be as generic as possible. Presenting a program that will, say, compile only with Microsoft's QuickC will generate a torrent of letters from Borland and Zortech enthusiasts who want a version for their compiler. Necessity is the mother of invention. In this case, my invention was a header file that allows me to create programs that automatically adjust to the specifics of the C compiler being used. Using <I>portable.h</I>, I can write system-level programs that will compile using C compilers from Microsoft, Borland, Zortech, and WATCOM.<P>
<h4><FONT COLOR="#000080"><A name="0022_0009">The Header <B><I>portable.h</I><A name="0022_0009"></B></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
shows <I>portable.h</I>, a header file containing macros that ease porting C programs among MS-DOS compilers. The file consists almost exclusively of macro definitions that alias or replace compiler dependencies. There are four sections in <I>portable.h</I>, each concerned with a different aspect of portability.<P>
Every MS-DOS C compiler predefines a macro identifying itself. Microsoft C defines the <I>_MSC_VER</I> macros, beginning with v6.0. Microsoft QuickC v2.5 and later create the <I>_QC</I> macro. WATCOM C defines the <I>__WATCOMC__</I> macro. Borland's Turbo C and C++ define the <I>__TURBOC__</I> macro. Zortech C and C++ use the <I>__ZTC__</I> macros. You can use these macros in conditional preprocessor statements to select compiler-specific characteristics.<P>
The first macro definition conditionally creates a proper version of the <I>MK_FP</I> macro. You use this macro to create a far (32-bit) pointer from 16-bit segment and offset values. <I>MK_FP</I> is found in most compiler libraries, but Microsoft's C compilers do not define it. If <I>portable.h</I> does not find a <I>MK_FP</I> macro, it creates one.<P>
<h4><FONT COLOR="#000080"><A name="0022_000A">Searching Directories<A name="0022_000A"></FONT></h4></P>
The next section of the include file defines macros and types used in searching MS-DOS file directories. Working with directory search functions under MS-DOS can be frustrating. Each compiler vendor uses unique function and structure identifiers. Macros to the rescue! The MS-DOS file data structure has the same format for all of the compilers, even if the names of the structure and its members are different. I therefore created my own data structure, <I>DOSFileData</I>, that can be used in place of the structures peculiar to each compiler. The function macros that follow cast a pointer to a <I>DOSFileData</I> structure to the specific structure type supported by a specific compiler.<P>
How does a program work with the compiler-specific function names and parameter lists? The solution is to define macros that translate between compilers. The <I>FIND_FIRST</I> macro hides a compiler's implementation of the MS-DOS 0x4E (find first file) function. <I>FIND_NEXT</I> is an alias for the function call to the MS-DOS <I>0x4F</I> (find next file) function.<P>
<h4><FONT COLOR="#000080"><A name="0022_000B">Accessing I/O Ports<A name="0022_000B"></FONT></h4></P>
Aliases also help you perform I/O to ports. Bytes and words can be written to and read from the I/O ports in your PC. Access to I/O ports is required for video, serial, and other hardware-level programming tasks. The names for port I/O functions are consistent across most compilers &#151; only Borland uses unique names. So I created the macros <I>IN_PORT</I>, <I>IN_PORTW, OUT_PORT</I>, and <I>OUT_PORTW</I> as aliases for the actual function names.<P>
Borland's Turbo C and C++ support pseudoregister variables and inline interrupt calls. The assignment <I>_AX = 1</I> directly assigns 1 to the AX processor register. The <I>geninterrupt</I> function compiles to an inline <I>INT</I> instruction. Obviously, Borland's ability to directly load registers and call system BIOS and MS-DOS services is a performance booster. Other MS-DOS C compilers don't support these language extensions.<P>
That would normally preclude the use of pseudoregisters in "portable" programs. But again, macros can be used to solve the problem. In the last section of <I>portable.h</I>, a macro is defined for each pseudoregister variable when a non-Borland compiler is begin used. The pseudoregister is replaced by an assignment to a member of a <I>struct REGS</I> named <I>CPURegs</I><I>.</I> Calls to <I>geninterrupt</I> are replaced with calls to <I>int86</I>. I've successfully used these macros in several Turbo C-specific programs to allow the code to migrate to other C compilers.<P>
<h4><FONT COLOR="#000080"><A name="0022_000C">Conclusion<A name="0022_000C"></FONT></h4></P>
I've found <I>portable.h</I> to be useful both in presenting articles and doing consulting work. I can develop a generic program using one compiler and be able to use that program with another C compiler. I'm sure you'll find extensions that can cover other compiler inconsistencies. Have fun!<P>

<h4><a href="../../../source/1991/jan91/ladd.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
