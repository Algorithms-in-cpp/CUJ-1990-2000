



<HTML><HEAD>

<TITLE>April 1996/Image Processing in C, Part 16: Random Dot Stereograms/Listing 1</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h4>
<A name="HEADING1">Listing 1: pstereo program</A></h4>


<pre>

/********************************************
*
*filepstereo.c
*
*Functions:Thisfilecontains
*main
*zero_line
*initialize_pattern
*lengthen_pattern
*no_change
*shorten_pattern
*get_random_values
*random_substitution
*read_image_line
*write_image_line
*test_print_line
*
*Purpose:
*Thisfilecontainsaprogramthatwill
*makepixelbasedrandomdotstereograms.
*
*ExternalCalls:
*tiff.c-read_tiff_header
*rtiff.c-read_tiff_image
*wtiff.c-does_not_exist
*round_off_image_size
*create_allocate_tiff_file
*write_array_into_tiff_image
*
*Modifications:
*18March1995-created
*
********************************************/
#include"cips.h"
#defineKONSTANT2
#definePATTERN_START0
#definePATTERN_END255
#defineASCII_SIZE256
shortthe_image[ROWS][COLS];
voidshorten_pattern();
voidlengthen_pattern();
voidno_change();
voidget_random_values();
voidrandom_substitution();
voidread_image_line();
voidwrite_image_line();
voidzero_line();
voidinitialize_pattern();
main(argc,argv)
char*argv[];
intargc;
{
chardepth_file_name[MAX_NAME_LENGTH],
s_file_name[MAX_NAME_LENGTH],
pp_file_name[MAX_NAME_LENGTH],
response[MAX_NAME_LENGTH];
FILE*depth_file,
*processed_pattern_file,
*stereo_file;
intcurrent_width,
*depth_line,
i,
j,
index,
last_pixel,
length,
location,
max_width,
*pattern,
pattern_width,
pp_index,
*processed_pattern,
this_pixel,
width;
structtiff_header_structimage_header;
if(argc!=5){
printf(
"\nusage:pstereopattern-width"
"\ndepth-file-name"
"stereo-file-name"
"\nprocessed-pattern-file-name"
"\n");
exit(1);
}
strcpy(depth_file_name,argv[2]);
strcpy(s_file_name,argv[3]);
</pre>
<p><b><u>strcpy(pp_file_name,argv[4]);</u></b></p>

<pre>

if(does_not_exist(depth_file_name)){
printf("\nThedepthfile%sdoesnotexist",
depth_file_name);
exit(1);
}
read_tiff_header(depth_file_name,<br>&amp;image_header);
round_off_image_size(&amp;image_header,
&amp;length,&amp;width);
image_header.image_length=length*ROWS;
image_header.image_width=width*COLS;
create_allocate_tiff_file(pp_file_name,
&amp;image_header,
the_image);
create_allocate_tiff_file(s_file_name,
&amp;image_header,
the_image);
width=width*COLS;
pattern_width=atoi(argv[1]);
pattern=<br>malloc(KONSTANT*width*sizeof(int));
depth_line=<br>malloc(KONSTANT*width*sizeof(int));
processed_pattern=<br>malloc(KONSTANT*width*sizeof(int));
/****************************************
*
*Thisisthemajorloopoftheprogram.
*Itreadsonelineatatimefromthe
*depthfile,processesthatoneline,
*andwritestheresultingpatterntothe
*processedpatternfile.
*
*****************************************/
printf("\npstereo&gt;&gt;%drows",length*ROWS);
for(i=0;i&lt;length*ROWS;i++){
if(i%10==0)printf("%d",i);
read_image_line(the_image,depth_file_name,
i+1,depth_line,width);
zero_line(pattern,KONSTANT*width);
zero_line(processed_pattern,<br>KONSTANT*width);
initialize_pattern(pattern,
&amp;current_width,
&amp;max_width,
pattern_width,
&amp;index);
/**************************************
*
*Loopthroughthepixelsinthe
*depth_line.Calloneofthethree
*processingroutinesbasedonthe
*relationshipbetweenthelastpixel
*andthispixel.
*
**************************************/
last_pixel=depth_line[0];
pp_index=0;
for(j=0;j&lt;width;j++){
this_pixel=depth_line[j];
if(this_pixel&gt;last_pixel)
shorten_pattern(
(this_pixel-last_pixel),
pattern,&amp;index,&amp;current_width,
width);
if(this_pixel&lt;last_pixel)
lengthen_pattern(
(last_pixel-this_pixel),
pattern,&amp;index,&amp;current_width,
&amp;width,&amp;max_width);
/***********************************
*
*Performtheno_changeinevery
*pass.
*
***********************************/
</pre>
<p></p>

<pre>
no_change(pattern,processed_pattern,
pp_index,current_width,<br>&amp;index);
pp_index++;
if(index&gt;=current_width)
index=0;
last_pixel=depth_line[j];
}/*endsloopoverj*/
write_image_line(the_image,pp_file_name,<br>i+1,processed_pattern,<br>width);
random_substitution(processed_pattern,<br>width);
write_image_line(the_image,s_file_name,<br>i+1,processed_pattern,<br>width);
}/*endsthemajorloop*/
free(pattern);
free(depth_line);
free(processed_pattern);
return(111);
}/*endsmain*/
/*******************************************
*
*shorten_pattern(...
*
*Thisfuntionshortensthepatternby
*deletinganelementfromit.Forexample,
*iftheinputpatternisabcdefg,
*theoutputpatterncouldbeabcfg.
*
********************************************/
voidshorten_pattern(size,pattern,index,
current_width,width)
int*pattern;
intsize,*index,*current_width,width;
{
int*temp_pattern;
inti,new_index,new_width;
temp_pattern=<br>malloc(KONSTANT*width*sizeof(int));
for(i=0;i&lt;width;i++)
temp_pattern[i]=pattern[i];
zero_line(pattern,KONSTANT*width);
new_index=0;
new_width=*current_width-size;
/*****************************************
*
*Increasetheindexbytheamountwewant<br>*toshortenthepattern.Thencopythe<br>*temp_patternbacktothepattern<br>*skippingoverpartsofthepatternby<br>*theamountwewanttoshortenit.
*
*****************************************/
*index=(*index+size)%(*current_width);
for(new_index=0;new_index&lt;new_width;<br>new_index++){
pattern[new_index]=temp_pattern[*index];
*index=*index+1;
if(*index&gt;=*current_width)
*index=0;
}/*endsloopovernew_index*/
*current_width=new_width;
*index=0;
free(temp_pattern);
}/*endsshorten_pattern*/
/********************************************
*
*lengthen_pattern(...
*
*Thisfuntionlengthensthepatternby
*insertinganelement(s)intoit.For<br>*example,iftheinputpatternisabcdefg,
*theoutputpatterncouldbeabcdefgh.
*
********************************************/
voidlengthen_pattern(size,pattern,index,
current_width,width,<br>max_width)
</pre>
<p><b><u>int*pattern;</u></b></p>

<pre>
intsize,*index,*current_width,
*width,*max_width;
{
int*temp_pattern;
intcount,i,new_index,new_width;
temp_pattern=<br>malloc(KONSTANT*(*width)*sizeof(int));
for(i=0;i&lt;(*width);i++)
temp_pattern[i]=pattern[i];
zero_line(pattern,KONSTANT*(*width));
for(count=0,new_index=0;count&lt;size;
count++,new_index++){
pattern[new_index]=
count+*max_width+PATTERN_START;
}/*endsloopovercount*/
new_width=*current_width+size;
for(;new_index&lt;new_width;new_index++){
pattern[new_index]=temp_pattern[*index];
*index=*index+1;
if(*index&gt;=*current_width)
*index=0;
}/*endsloopovernew_index*/
*current_width=new_width;
*index=0;
*max_width=*max_width+size;
free(temp_pattern);
}/*endslengthen_pattern*/
/********************************************
*
*no_change(...
*
*Thisfunctionprocessesthepattern
*anddoesnotmakeanychangestoit.
*
********************************************/
voidno_change(pattern,processed_pattern,<br>pp_index,current_width,index)
int*pattern,*processed_pattern;
intpp_index,current_width,*index;
{
processed_pattern[pp_index]=
pattern[*index];
*index=*index+1;
if(*index&gt;=current_width)
*index=0;
}/*endsno_change*/
/*******************************************
*
*initialize_pattern(...
*
*Thisfunctioncreatesaninitialpattern
*thatisaswideasthepattern_width
*parameter.
*
********************************************/
voidinitialize_pattern(pattern,current_width,
max_width,<br>pattern_width,index)
intpattern[];
int*current_width,
*max_width,
*index,
pattern_width;
{
inti;
for(i=0;i&lt;pattern_width;i++)
pattern[i]=i+PATTERN_START;
*index=0;
*current_width=pattern_width;
*max_width=pattern_width;
}/*endsinitialize_pattern*/
/********************************************
*
*zero_line(...
</pre>
<p><b><u>*</u></b></p>

<pre>
*Thisfunctionfillsanintarraywith<br>*zeros.
*
********************************************/
voidzero_line(array,length)
int*array;
intlength;
{
inti;
for(i=0;i&lt;length;i++)
array[i]=0;
}/*endszero_line*/
/********************************************
*
*random_substitution(...
*
*Thisfunctiontakestheprocessed_pattern
*arrayandsubstitutesrandom0'sand1's
*foreachvalueinthearray.
*
********************************************/
voidrandom_substitution(processed_pattern,<br>width)
int*processed_pattern;
intwidth;
{
intsubstitution_values[GRAY_LEVELS+1];
inti,place;
get_random_values(substitution_values);
for(i=0;i&lt;(KONSTANT*width);i++){
place=processed_pattern[i];
processed_pattern[i]=
substitution_values[place];
}/*endsloopoveri*/
}/*endsrandom_substitution*/
/********************************************
*
*get_random_values(...
*
*Thisfunctionfillsarraywith1'sand<br>*0's.These1'sand0'scomefromarandom<br>*numbergenerator.Ifthenumberisodd,<br>*usea1,otherwiseusea0.
*
********************************************/
voidget_random_values(array)
intarray[];
{
inti,number;
/*Onlyusethe1'sand0's*/
for(i=0;i&lt;GRAY_LEVELS+1;i++){
number=rand();
number=number%2;
if(number==1)number=PATTERN_END;
array[i]=number;
}/*endsloopoveri*/
}/*endsget_random_values*/
/********************************************
*
*read_image_line(...
*
*Thisfunctionreadsalineofpixelsfrom
*aTIFFimagefile.
*
********************************************/
voidread_image_line(the_image,file_name,
line_number,array,width)
charfile_name[];
shortthe_image[ROWS][COLS];
int*array,line_number,width;
{
inti,il,ie,ll,le,
pixels_to_read,
reading_counter,
still_reading;
il=line_number;
ll=il+1;
ie=1;
le=ie+COLS;
</pre>
<p><b><u>if(width&lt;COLS)</u></b></p>

<pre>
le=ie+(width-1);
pixels_to_read=width;
reading_counter=0;
still_reading=1;
while(still_reading){
read_tiff_image(file_name,the_image,
il,ie,ll,le);
for(i=0;i&lt;(le-ie);i++)
array[i+(reading_counter*COLS)]=
the_image[0][i];
reading_counter++;
pixels_to_read=pixels_to_read-(le-ie);
if(pixels_to_read&lt;=1)
still_reading=0;
else{
ie=ie+COLS;
le=ie+COLS;
if(le&gt;width)
le=width;
}/*endselse*/
}/*endswhilestill_reading*/
}/*endsread_image_line*/
/********************************************
*
*write_image_line(...
*
*Thisfunctionwritesalineofpixelsto
*aTIFFimagefile.
*
********************************************/
voidwrite_image_line(the_image,file_name,
line_number,array,width)
charfile_name[];
shortthe_image[ROWS][COLS];
int*array,line_number,width;
{
inti,il,ie,ll,le,
pixels_to_write,
writing_counter,
still_writing;
il=line_number;
ll=il+1;
ie=1;
le=ie+COLS;
if(width&lt;COLS)
le=ie+(width-1);
pixels_to_write=width;
writing_counter=0;
still_writing=1;
while(still_writing){
for(i=0;i&lt;(le-ie);i++)
the_image[0][i]=
array[i+(writing_counter*COLS)];
writing_counter++;
write_array_into_tiff_image(file_name,<br>the_image,il,<br>ie,ll,le);
pixels_to_write=pixels_to_write-(le-ie);
if(pixels_to_write&lt;=1)
still_writing=0;
else{
ie=ie+COLS;
le=ie+COLS;
if(le&gt;width)
le=width;
}/*endselse*/
}/*endswhilestill_writing*/
}/*endswrite_image_line*/
/* End of File */
</pre>
</body></html>
