






<HTML>
     
     <HEAD>
          <TITLE>April 1996/The OSE Class Libraries</TITLE>
     </HEAD>
     
     <BODY BGCOLOR="#FFFFFF">
          
          <H2><A href="../tocapr.htm"><IMG src="../../toc.gif" ALT="Table of Contents" WIDTH="54" HEIGHT="54"></A>
          <FONT COLOR="#FF0000">Unix</FONT></H2>
          
          <HR>
          
          <H2 ALIGN="CENTER"><FONT COLOR="#800000">The OSE C++ Libraries</FONT></H2>
          
          <P><FONT COLOR="#800000"> </FONT> </P>
          
          <H3 ALIGN="CENTER"><FONT COLOR="#800000">George Patapis</FONT></H3>
          
          <P><FONT COLOR="#800000"> </FONT> </P>
          <BLOCKQUOTE>
               
               <p>In the best spirit of the UNIX
                    community, the Australian Overseas Telecommunications Centre
                    has made this C++ code available via FTP. A no-fee license
                    makes this library hard to resist.</p></BLOCKQUOTE>
          <HR>
          <BLOCKQUOTE>
               
               <h4><FONT COLOR="#000080">Introduction</FONT></H4>
               
               <p>Anyone who programs in C++ for a
                    living is likely to need a library or collection of
                    fundamental C++ classes to supplement what comes with their
                    compiler. My first library was OSE. I present here a review
                    of this library based on my own practical experiences with
                    it. This article is not a library shoot-out, but rather an
                    insight into the OSE library from someone who has been using
                     it since early 1992 for industrial strength projects. I
                    believe that it has a lot to offer and can save huge amounts
                    of time and money for any new C++ UNIX development groups.</p>
               </FONT>
               
               <h4><FONT COLOR="#000080">A Bit Of Background</FONT></H4>
               
               <p>OSE has its roots back in the early
                    nineties, at what was then the Australian Overseas
                    Telecommunications Centre (OTC). The main work was done by
                    Graham Dumpleton, grahamd@nms.otc.com.au, who now continues
                    to provide upgrades and support. The library was initially
                    created for internal use only, but a couple of years ago OTC
                    released it to the general public. No fees, and a license 
                    similar to the GNU license makes the OSE Library very
                    attractive. It has been used in real, large-scale
                    applications. UNIX, C++, and GNU-like resemblance are core
                    themes of this library.</p>
               </FONT>
               
               <h4><FONT COLOR="#000080">Functional Categories</FONT></H4>
                </FONT>
               
               <p>What follows is my own breakdown of
                    the major functional categories within OSE. My breakdown
                    doesnt quite follow what the OSE manual says, but then, I am
                    writing from the perspective of a user.</p>
               </FONT>
               
               <h4><FONT COLOR="#000080">Basic Classes</FONT></H4>
                </FONT>
               
               <p>OSE provides some of the basic classes
                    we all know and love. These are a bit low level, but still
                    very useful: Strings, Regular Expressions, Pairs, and
                    Triples.</p> </FONT>
               
               <p>The string class is my personal
                    favorite. It is one of the easiest to use and offers lots of
                    functionality. Using OTC_String, you can add strings
                    together, search strings, or even manipulate binary arrays.
                    OTC_String is implemented with extensive use of inlining so
                    as to not hamper performance. It also uses a delayed copy
                    mechanism, which means that when two users reference the 
                    same string, OSEallocates new memory only if a change is
                    made to the string by one of the users.</p>
               </FONT>
               
               <p>The regular expression classes provide
                    operations familiar to all sed/Perl users, which you can
                    call from within your code. Pairs and triples are constructs
                    that allow you to congregate pairs or triples of objects and
                    use them in a list or some other collection as a group.</p>
               </FONT>
               
               <h4><FONT COLOR="#000080">Collections</FONT></H4>
                </FONT>
               
               <p>These classes are straight out of
                    Computer Science 101 and include the following:</p>
               </FONT>
               <UL><LI> Lists </FONT></LI>
                    <LI> Doubly Linked Lists </FONT></LI>
                    <LI> Queues </FONT></LI>
                    <LI> Priority Queues </FONT></LI>
                    <LI> Stacks </FONT></LI>
                    <LI> Sets</FONT></LI>
                    <LI> Bags</FONT></LI>
                    <LI> Vectors </FONT></LI>
                    <LI> Maps (a.k.a. Dictionaries)
                         </FONT></LI>
                    <LI> Iterators, etc. </FONT></LI>
               </UL> </FONT>
               
               <p>These are all template classes, and
                    you can use them to hold either items or pointers to items,
                    which makes them quite flexible.</p>
               </FONT>
               
               <p>The most useful class has to be the
                    OTC_Map class. For those unfamiliar with maps (in some other
                    libraries they are called dictionary classes), maps hold a
                    collection of items that you can store and retrieve, based
                    on some key. For example, you can store a collection of
                    pointers to books by using the ISBN as the key. You can
                    retrieve a book object by querying the map with your ISBN as
                     the key. If you are using an object-oriented database such
                    as Objectstore, you can easily make this class persistant.
                    You may very quickly find yourself putting together an OO
                    database application with a minimum of effort.</p>
               </FONT>
               
               <h4><FONT COLOR="#000080">Error Handling &amp;
               Debugging</FONT></H4>
                </FONT>
               
               <p>To assist developers in handling
                    run-time errors OSEprovides a series of classes based on a
                    class called OTC_Logger. The OTC_Logger hierarchy allows
                    messages to be logged to a screen or file with different
                    levels of severity</p> </FONT>
               
               <p>For debugging, OSE provides a set of
                    classes centered around another class called OTC_Tracer.
                    These classes enable run-time tracing of code execution
                    (sure beats printf or #ifdef DEBUG). For example, you can
                    insert a Trace statement at the beginning of each member
                    functions code section. At run time you can follow the entry
                    and exit of your code through each member function. When its
                     time to deliver to your customer, you can compile the
                    debugging functions out of your final code, thus reducing
                    code size.</p> </FONT>
               
               <h4><FONT COLOR="#000080">UNIX Support</FONT></H4>
                </FONT>
               
               <p>One of the great features offered by
                    this library is abstraction of the UNIX programming
                    interface. OSE includes classes that provide the following
                    functionality:</p> </FONT>
               <UL><LI> User and group information
                         </FONT></LI>
                    <LI> File information (eg.
                         read/write properties, owner, etc.) </FONT></LI>
                    <LI> Pathname information </FONT></LI>
                    <LI> Interface to program arguments:
                         argc and argv </FONT></LI>
                    <LI> UNIX signal handling. </FONT></LI>
               </UL> </FONT>
               
               <p>This set of classes will aid those who
                    need to do UNIX system programming and require code
                    portability between many UNIX flavors.</p>
               </FONT>
               
               <h4><FONT COLOR="#000080">The OSE Build
               Environment</FONT></H4>
                </FONT>
               
               <p>In addition to the functionality
                    provided by the code, OSE has a great build environment. In
                    fact, I consider this one of the highlights of the library.
                    I know of some users who had a library to begin with but
                    adopted the OSE build mechanism because of its simplicity,
                    robustness, and elegance. It takes a bit of getting used to,
                    but those that have hung on to "makeit" have
                    reaped the benefits. Lest you think I am overstimulated over
                    what is probably just a clever makefile, let me describe
                    what is involved in a build environment.</p>
               </FONT>
               
               <p>A large software system will be
                    composed of many subsystems. Developers may need to compile
                    a single subsystem, multiple subsystems, or the whole
                    system. Programmers may need multiple compiler support, that
                    is, use of more than one compiler for their development.
                    They also may need to accommodate different versions fo the
                    same compiler. Programmers often need their application to 
                    be portable across many operating systems. Ideally, if you
                    are developing for, say, both SunOs and Linux, you would
                    like to effortlessly and transparently compile for either.
                    Programmers may also need to integrate libraries with
                    external tools, such as a database, or Purify (memory check
                    tool). On top of that, they might want to provide facilities
                    for testing each subsystem automatically. Obviously most
                    developers will have no intention of supporting the above
                    manually. What they need is a setup with tools that handle
                    all of the above in an automated fashion.</p>
               </FONT>
               
               <p>OSE offers makeit, which does all of
                    the above and more. makeit is essentially a highly automated
                    UNIX make facility implemented with a collection of
                    pre-defined GNU makefiles. It comes with a version of GNU
                    make for this reason. makeit comes with modules that already
                    provide much of the functionality UNIX developers were
                    accustomed to writing manually into their makefiles. It 
                    really shines on large complex projects.</p>
               </FONT>
               
               <h4><FONT COLOR="#000080">Strengths of OSE</FONT></H4>
                </FONT>
               
               <p>I list below the strengths that I have
                    found in this library in decreasing order of significance.</p>
               </FONT>
               <UL><LI> The makeit build environment.
                         Multiple compiler support and other third-party tool
                         support such as Purify make makeit hard to resist.
                         </FONT></LI>
                    <LI> Support for nearly every UNIX
                         platform and compiler. (The GNU of C++ libraries is how
                         I would describe it!) </FONT></LI>
                    <LI> Robust, many years of
                         enhancements, and a history of use in commercial
                         environments. This robustness and reliability are quite
                         important if your aim, like mine, is to develop real
                         applications and not just toy around with C++. </FONT></LI>
                    <LI> Support for OODBMSs, primarily
                         Objectstore. OSEs OODBMS support shields programmers
                         from the proprietary classes that come with Objectstore
                         (and any other DB for that matter) and allows them to
                         use the same familiar classes for both persistent and
                         transient data. This saves in learning time and
                         confusion. </FONT></LI>
                    <LI> Very good documentation,
                         including UNIX man pages, PostScript, and hypertext
                         online documentation. </FONT></LI>
                    <LI> No up-front costs or royalties.
                         </FONT></LI>
                    <LI> Relative ease of installation,
                         use, and upgrading. In particular, upgrades can be as
                         painless as switching an environment variable to the
                         new version number, as the library always ensures
                         backward compatibility with at least one older version.
                         </FONT></LI>
                    <LI> Support for shared libraries.
                         On large applications, shared libraries can save on
                         memory, and their use is pretty much mandatory these
                         days. </FONT></LI>
                    <LI> Comes with full source code.
                         </FONT></LI>
                    <LI> Code documentation utilities.
                         These allow the extraction of documentation from C++
                         header files. </FONT></LI>
                    <LI> Good performance (uses
                         reference counting, inlining, delayed copying
                         techniques in an effective manner). </FONT></LI>
                    <LI> Support for OSE exists through
                         the Internet. A mailing list dedicated to the OSE
                         library exists , and has subscribers from all over the
                         world. Professional support contracts can be obtained
                         for a fee. </FONT></LI>
               </UL> </FONT>
               
               <h4><FONT COLOR="#000080">Weaknesses</FONT></H4>
                </FONT>
               
               <p>No library can be perfect, but I can
                    honestly say I know of nothing major wrong with OSE. Two
                    areas, though, are worth alerting you to: templates and STL.</p>
               </FONT>
               
               <p><B> </B>I have found that using
                    templates can slow compilations down. The problem mainly
                    shows up on UNIX cfront-based C++ compilers (they convert
                    C++ to C and then they compile that). The cfront-based
                    compilers I have been using dont handle templates well.
                    Therefore, if you have the option, opt for a native C++
                    compiler. OSE makes extensive use of templates. However,
                    compilers are getting better in their handling of templates.
                    Also, the OSE documentation suggests some neat techniques to
                    get around some of the delays in compilation due to
                    templates.</p> </FONT>
               
               <p>STL seems to be the buzz library of
                    late. As it will eventually be the standard, and accompany
                    any C++ compiler worthy of its name, it might make someOSE
                    classes, in particular the collection classes, redundant.
                    Looking at the present situation, STL implementations are
                    still new, whereas OSE has proven itself in the field. I
                    also believe it is easier to use for the newcomer. Plus, OSE
                     provides many more facilities; therefore, I would say OSE
                    is a superset of STL.</p>
               </FONT>
               
               <h4><FONT COLOR="#000080">Theres More</FONT></H4>
                </FONT>
               
               <p>After Ive described all the above you
                    may be surprised to find out that there still is more
                    functionality left in this library that I have never gotten
                    around to exploring. I will just mention some of the
                    features briefly. OSEhas classes to interface to the TCL/TK
                    libraries. TCL/TK have become a very popular route to rapid
                    application development under X-Windows. OSE also includes a
                     collection of classes that allow you to simulate
                    multitasking (called co-operative multitasking). Finally,
                    OSE includes a series of classes for doing your own memory
                    management.</p> </FONT>
               
               <h4><FONT COLOR="#000080">Who Will Benefit</FONT></H4>
                </FONT>
               
               <p>The OSE Library is of most potential
                    benefit to those developers who are moving or are thinking
                    of moving from a C to a C++ UNIX development environment. On
                    a secondary note, developers already comfortable with C++
                    and who have already made their choice of libraries may find
                    useful features in OSE. (I hope that there are no C++
                    developers whose sole library is the more-than-often spartan
                     collection that accompanies the standard UNIX C++ compilers
                    of today!)</p> </FONT>
               
               <h4><FONT COLOR="#000080">Where to Get OSE</FONT></H4>
               
               <p>You can obtain OSE from a number of
                    anonymous ftp sites. Here are three:</p>
               </FONT>
<PRE>ftp://ftp.th-darmstadt.de/pub/programming/languages/C++/class-libraries/OSE
ftp://straylight.acs.ncsu.edu/pub/ose
ftp://csis.dit.csiro.au/pub/SEG/ose</PRE>
               
               <p>OSE has its own web page at:</p>
               </FONT>
               
<PRE>http://www.telstra.com.au/docs/ose/doc/ose~home.html</PRE>
               </FONT>
               
               <h4><FONT COLOR="#000080">Conclusion</FONT></H4>
               
               <p>I believe you should consider OSE as
                    one of your options when you are next deciding on a
                    general-purpose C++ library. An extensive Windows NT port is
                    in the works, which should open a whole new avenue of
                    portability for OSE users. OSE offers an excellent
                    springboard into the world of OO, C++, and software reuse
                    for UNIX programmers.</p>
               </FONT>
               
               <p><I>George Patapis has been developing
                    software for over ten years, initially as a hobby and now
                    for Telecommunications companies. He graduated with an
                    Honours Degree in Computer Science from Macquarie
                    University, Sydney, in 1991. His areas of expertise and
                    interest are Distributed Systems, Network Management, QAS,
                    and Object-Oriented Software Engineering. He can be reached 
                    at gpatapis@ozemail.com.au. </I></p></BLOCKQUOTE>
     </BODY>
</HTML>
