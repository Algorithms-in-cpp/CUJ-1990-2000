<HTML>
     
     <HEAD>
<TITLE>January 1999/Comparing C++ and Java: A Java SwitchBoard Implementation</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Java</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Comparing C++ and Java: A Java SwitchBoard Implementation</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">William L. Crowe</FONT></H3>

<BLOCKQUOTE>

<p>Writing a "switchboard" in Java is both enlightening and useful. Comparing it to a C++ version is also educational.</p>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<h4><FONT COLOR="#000080">Introduction</FONT></H4>

<p>In the June 1998 issue of <I>CUJ</I>, I presented an article, "Inter-Object Messaging Using a <B>SwitchBoard</B>," which demonstrated how to pass messages from one object (the sender) to another (the receiver) without the sender being compiler-dependent on the receiver. A typical example is that of an <B>ApplicationShell</B> that needs to send a <B>saveYourself</B> message to persistent object <B>PersonnelList</B>. Now, imagine ten other persistent objects, just like <B>PersonnelList</B>, that are also interested in the <B>saveYourself</B> message. Great benefits can be gained by reducing the compiler dependencies between the objects, as well as by the simplification of message registration and delivery. The C++ implementation in my previous article relied heavily on template classes to bind objects to the <B>SwitchBoard</B>, template functions to properly construct the template classes, and function overloading to determine which templates to instantiate.</p>
<p>When looking at Java, you might at first think that a <B>SwitchBoard</B> is unnecessary. After all, Java is interpreted, classes are loaded at run time, and Java has only one implementation file (no headers/source maintenance required). But since Java compiles each class into architectural neutral byte codes, these dependencies, albeit more manageable, still exist. If an object of class <B>A</B> contains a handle to an object of class <B>B</B> and class <B>B</B>'s interface changes, then class <B>A</B> must be recompiled, or it will throw a run-time exception.</p>
<p>In this article, I present a <B>SwitchBoard</B> implementation in Java. I also show how the Java implementation differs from the C++ implementation as a result of Java's lack of templates, of using a different memory-management paradigm, and of using some Java features not found in C++.</p>

<h4><FONT COLOR="#000080">The Java SwitchBoard</FONT></H4>

<p>The <B>SwitchBoard</B> object allows one object to send a message to another object, or objects, without the caller (sender) knowing the identification or location of the receiver. An object interested in receiving a message simply subscribes to the <B>SwitchBoard</B>, thus becoming a subscriber. Subscribers receive notification by way of messages passed through the <B>SwitchBoard</B>. Continuing the earlier example, the <B>PersonnelList</B> would subscribe to the <B>SwitchBoard</B> for the <B>saveYourself</B> message, and the <B>ApplicationShell</B> would post <B>saveYourself</B> when the persistent objects need to be saved. At that time, the <B>SwitchBoard</B> would dispatch the message to each subscriber of <B>saveYourself</B>.</p>
<p>The <B>SwitchBoard</B> class diagram for the Java implementation consists of two main classes, <B>SwitchBoard</B> and <B>SubscriberHookup</B>; an interface, <B>SwitchBoardListener</B>; and an adapter class, <B>SwitchBoardAdapter</B> (see <A HREF="fig1.htm">Figure 1</A>). The corresponding C++ class diagram is slightly different. The C++ implementation uses a template instead of an interface (see <A HREF="fig2.htm">Figure 2</A>). In both cases, the <B>SwitchBoard</B> class takes subscriptions, manages the list of subscribers, and provides a method for sending messages to the subscribers. The <B>SwitchBoard</B> follows a Singleton pattern, which insures that only one instance of itself exists per application. <B>SwitchBoard</B> enforces this by making the constructor private (or protected) and by providing only a static utility interface. Every method requiring access to the <B>SwitchBoard</B> singleton must retrieve a handle to it by calling the static <B>instance</B> method of the <B>SwitchBoard</B> class. <B>instance</B> checks to see if a <B>SwitchBoard</B> has already been instantiated, and if not, instantiates it. (The use of a utility interface also provides an easier access method than having to keep track of a handle to the <B>SwitchBoard</B>.) The biggest difference between the C++ implementation and the Java implementation is that Java does not support global variables; everything must be contained in a class. (This facilitates more object-oriented solutions.)</p>

<h4><FONT COLOR="#000080">How the SwitchBoard Works</FONT></H4>

<p>The code required to implement a rudimentary <B>SwitchBoard</B> in Java can be seen in <A HREF="list1.htm">Listing 1</A>, <B>SwitchBoard.java</B>.</p>
<p>Objects interested in subscribing to the <B>SwitchBoard</B> call the <B>SwitchBoard</B>'s <B>subscribeTo</B> method with a <B>SwitchBoardListener</B> argument; objects interested in canceling a subscription call <B>unsubscribeFrom</B>. In the C++ implementation, the hookup class, <B>SubscriberHookup</B>, automatically does the subscribing in its constructor and unsubscribing in its destructor. The Java <B>SubscriberHookup</B> class (<A HREF="list2.htm">Listing 2</A>, <B>SubscriberHookup.java</B>) doesn't do it this way, because Java is a garbage collected language.</p>
<p>Garbage collection has many advantages. It frees the Java programmer from having to deallocate memory; it reduces (but does not eliminate) the number of memory leaks; and it simplifies the code by reducing the need for most destructors. However, garbage collection does have disadvantages. For example, you cannot control when objects actually get destructed &#151; that is, when the destructor (<B>finalize</B> in Java) is called. In C++ applying the <B>delete</B> operator to an allocated <B>SubscriberHookup</B> results in its destructor being invoked. In our example, the hookup would unsubscribe to the <B>SwitchBoard</B>. However, Java cannot guarantee when garbage collection will occur unless it is explicitly invoked, which of course defeats its purpose. Therefore, the Java programmer must write code that explicitly unsubscribes from the <B>SwitchBoard</B>.</p>
<p>Also related to garbage collection, if an object subscribes to the <B>SwitchBoard</B>, it must unsubscribe to be destructed. As long as the <B>SwitchBoard</B>, or any object for that matter, holds a handle to the subscriber, the garbage collector considers that subscriber still in use. The garbage collector finalizes only those objects that are no longer referenced.</p>
<p><B>SwitchBoard</B>'s only other public methods are a set of overloaded <B>notify</B> functions. These functions send messages to subscribing objects. These <B>notify</B> methods are all declared <B>static</B>. Before they can perform their specified tasks, they must retrieve a handle to the <B>SwitchBoard</B>, via <B>instance</B>.</p>
<p>The <B>SwitchBoard</B> keeps track of the <B>SubscriberHookup</B>s in a <B>Hashtable</B> member. A <B>Hashtable</B>, a Java utility collection class, associates a key with a value. In this case, the value is a Java <B>Vector</B> object, which in turn contains all the <B>SubscriberHookup</B>s. Similar classes exist in the C++ STL (<B>map</B>, <B>vector</B>, etc.). A big difference between C++ and Java collection classes is type safety. Java collection classes store all objects as references to a base type <B>Object</B>. The developer must cast this <B>Object</B> into the appropriate type. C++, on the other hand, uses templates to accommodate the type of object being stored. No casting is required.</p>
<p>The <B>SwitchBoard</B> and <B>SubscriberHookup</B> classes work together to maintain who is whom and who is interested in what. The <B>SubscriberHookup</B> class, however, cannot contain a handle to the subscribing object's receiver method because the receiver's type is unknown at this time. (If the hookup did contain such a handle, it would force the subscribers to all be the same type.) Instead, the <B>SubscriberHookup</B> class holds a reference to a <B>SwitchBoardListener</B> <I>interface</I>, a class that implements the <B>SwitchBoardListener</B>. Interfaces in Java, like abstract classes in C++, can be used to define methods, or behavior, that a class must implement. Java also uses interfaces as a clever alternative to multiple inheritance, but that is another article.</p>
<p>The only information stored by a hookup is the name of the subscription, which is accessed when the <B>SwitchBoard</B>'s <B>notify</B> method is dispatching a message via method <B>getSubscription</B>. <B>SwitchBoard</B> calls <B>SubscriberHookup</B>'s <B>getSubscriber</B> method to get a handle to the subscribing <B>SwitchBoardListener</B> object. Since the <B>SubscriberHookup</B> class does not know about the subscriber class it must rely on the <B>SwitchBoardListener</B> interface.</p>

<h4><FONT COLOR="#000080">Using the SwitchBoard</FONT></H4>

<p>Using the Java <B>SwitchBoard</B> differs from using the C++ <B>SwitchBoard</B>. The C++ <B>SwitchBoard</B> takes advantage of template functions and template classes to automate the subscription, or binding of the callbacks. In Java, a <B>SwitchBoardListener</B> implementation (a class that implements the interface) must be passed as an argument to the unsubscribe/subscribe methods. <A HREF="tab1.htm">Table 1</A> shows a side-by-side comparison of C++ versus Java implementations to deliver a message from one object to another.</p>
<p>Possibly the strangest looking thing in <A HREF="tab1.htm">Table 1</A> is the use of the <B>SwitchBoardAdapter</B> class in the row marked "Subscribing to the <B>SwitchBoard</B>." The <B>SwitchBoardAdapter</B> implements the <B>SwitchBoardListener</B> interface. This adapter serves two purposes: the developer does not have to implement all the interface methods, just the ones of interest; and the callback can be implemented at the point where it is installed, by anonymous subclassing.</p>
<p>An anonymous class is a shorthand way of creating a helper class, an inner class (or "nested" class in C++) without an explicit name. The adapter class contains empty methods for each possible callback, just as the C++ template does; but unlike the case with C++ templates, the Java callback must be written by hand. Anonymous classes are one of the major advantages of Java. They are used extensively for callbacks when writing GUI code with the AWT (Abstract Window Toolkit). Java's anonymous classes are much more useful than their C++ counterparts, because Java's classes have access to the enclosing class even when they are declared in the body of a method. This is evident in the example where the anonymous <B>SwitchBoardAdapter</B> <B>deliver</B> method calls the containing class's <B>busy</B> method without a handle to the containing class. (For more on the difference between Java and C++ anonymous classes, see the <A HREF="sidebar.htm">sidebar</A>.)</p>
<p>Even with the flexibility of anonymous classes and interfaces, C++ provides a much safer and cleaner way of passing data through the <B>SwitchBoard</B>. In Java, specific data types are passed through the <B>SwitchBoard</B> cast to an <B>Object</B>, and the receiver must downcast the <B>Object</B> into the appropriate type (as in the <B>deliver</B> method). The Java <B>instanceof</B> operator insures the safety of the downcast. It is similar to using <B>typeid</B> or <B>dynamic_cast&lt;&gt;</B> in C++. C++, on the other hand, can use template methods to provide a type-safe object delivery mechanism or a new template <B>instance</B> for each type.</p>

<h4><FONT COLOR="#000080">A Busyness Example</FONT></H4>

<p>Many applications that do complex GUI processing can take advantage of a centralized-application busyness management center using the <B>SwitchBoard</B>. The busyness management center notifies all the GUI objects (application shell and dialogs) when to use the working or normal cursor, as well as updates and resets the status bar. By reference counting a "busyness" variable, each routine can independently control its busyness and not worry about prematurely ending the busy state of the application. Furthermore, objects can query the application to determine busyness and make decisions accordingly.</p>
<p>The example shown in <A HREF="list3.htm">Listing 3</A>, <B>Example.java</B> expands on the <B>PersonnelList</B> example by posting the <B>busy</B>/<B>notBusy</B> messages in the <B>PersonnelList.store</B> method, and by implementing an <B>ApplicationShell</B> class to demonstrate how to handle and coordinate these new messages.</p>
<p>Note that the <B>ApplicationShell</B> class instantiates both the <B>ApplicationShell</B> and the <B>PersonnelList</B> objects in its <B>main</B> method, but neither of the instantiated classes knows anything about the other. After the objects have been constructed, <B>main</B> calls the <B>ApplicationShell</B> <B>save</B> method. The <B>save</B> method simply posts the <B>busy</B> message, and then the <B>saveYourself</B> message, which calls the <B>PersonnelList.store</B> method. The <B>PersonnelList.store</B> method also posts the <B>busy</B>/<B>notBusy</B> messages, thus incrementing and decrementing the busyness reference count accordingly. Finally, the <B>save</B> method calls <B>ApplicationShell.refresh</B>, which posts its own <B>busy</B>/<B>notBusy</B> messages, and posts the last <B>notBusy</B> message. Several of the <B>busy</B> messages are posted with a status string to display in the status bar (in this example, <B>stdout</B>). The last <B>notBusy</B> message results in restoring the status bar to what it was before all the work started. Running the program displays the status information to standard out:</p>

<pre>
Ready.
Saving the application state...
 PersonnelList - saving...
 Saved.
 Refreshing...
Ready.
</pre>

<h4><FONT COLOR="#000080">Conclusion</FONT></H4>

<p>Java is fast becoming a widely used programming language, for some very good reasons. It is simple, portable, robust, object-oriented, GUI/Web enabled, distributed, threaded, and most importantly, it is just plain cool. Another reason for its growing popularity is the ease with which C++ programmers can make the transition to Java (without too many headaches, that is). It is definitely not just a toy!</p>
<p>As pointed out in this article, the same things can be accomplished in either Java or C++, but the solution differs based on which language you choose. For instance, a C++ solution will probably take advantage of several features that Java doesn't support, such as template classes, template functions, type safety, default parameters, etc. Likewise, the Java solution will most likely involve the use of interfaces and anonymous classes. At first, it might seem that Java needs to incorporate all these missing C++ features, but I'm not so sure incorporating all of them would be for the best. Today, Java is simple, yet powerful. The more features incorporated, the more complicated the language will become, and the more difficult it will be to use and understand.</p>
<p>If you are interested in learning more about Java from a C/C++ perspective, or if you are just looking for a good book on the subject, try <I>Java 1.2 and JavaScript for C and C++ Programmers</I> by Michael C. Daconta, et. al. While this article may only scratch the surface, this book covers it all. [Also check out Chuck Allison's new column, "import java.*", right here in this issue. &#151; mb] o</p>

<p><i>William L. Crowe is currently employed as a consultant for Sprint. He is a Software Architect who specializes in object-oriented design, GUI design, and large-scale distributed computing. He can be reached via email at <B>billcrowe@earthlink.net</B>.</i></p>


<h4><a href="../../../source/1999/jan99/crowe.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY>
</HTML>
