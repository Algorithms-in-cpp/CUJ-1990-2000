<HTML>
     
     <HEAD>
<TITLE>January 1999/A Java Object List Dialog</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Java</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">A Java Object List Dialog</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Steve Welstead</FONT></H3>

<BLOCKQUOTE>

<p>Java keeps getting better at handling those bread-and-butter windowing tasks that once required C or C++ under Windows.</p>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<h4><FONT COLOR="#000080">Introduction</FONT></H4>

<p>Java promises nothing less than the holy grail for those who develop code for multiple platforms. One set of object-oriented source code can provide cross-platform portability with a graphical user interface. What Java has delivered thus far, however, may fall somewhat short of this lofty goal. Byte-code interpreters run much slower than compiled code and some user interface components demonstrate sometimes quirky behavior. Nevertheless, Java is getting better and it presents intriguing possibilities, particularly for C++ programmers who will find many things familiar in this new language.</p>
<p>This article describes a Java implementation of a device that I find handy. I use it often for quickly setting up a user interface for small prototype application programs. The device is a list dialog that handles lists of data objects, each of which knows how to update its own value through a dialog that is specific for that data type. For example, the article defines object classes representing numeric <B>float</B> data, Boolean yes-no choices, and file names, each with its appropriate dialog. The idea easily extends to other data types, such as color choices. New input items can be added to the dialog simply by adding additional items to the list. This is particularly useful in Java, where the layout interface approach of the AWT (Abstract Window Toolkit) complicates the process of designing and modifying dialogs composed of many different components.</p>
<p>The code accompanying this article (available from <I>CUJ</I> online sources) implements a complete Java application, using a <B>Frame </B>window with a menu to call up the list dialog and its associated data-object dialogs. The code was developed using Borland's JBuilder Standard, version 2.0, using version 1.1.6 of the JDK (Java Development Kit). I have also tested the code with Asymetrix Supercede 2.0, which uses JDK 1.1. JDK 1.1, or later, is needed to obtain proper dialog behavior, as discussed below. Also, JDK 1.1 introduced significant changes in the AWT classes, with many of the old variable names and methods deprecated (though still retaining functionality).</p>
<p>The code in this article uses the new names wherever possible. For this reason, you need JDK 1.1 or later to compile and run the code listed here. The code uses only standard Java and AWT classes, with no classes from any other libraries or toolkits. Also, I do not make use of any of the "visual" development capabilities. You should be able to produce a working version of this code with a text editor and a copy of the JDK, version 1.1 or later.</p>
<p>The ideas in this article are similar to a C/C++ Windows implementation that I presented in the September 1995 issue of <I>C/C++ Users Journal,</I> in the article "Data Object List Dialog for Windows." That article also appears as a chapter in the book, <I>Windows NT Programming in Practice,</I> R&amp;D Books, 1997. The present article will point out similarities and differences between the Java approach and the C/C++ Windows implementation discussed in the earlier article.</p>

<h4><FONT COLOR="#000080">Dialog Classes</FONT></H4>

<p>Dialogs are a cornerstone of any good GUI (Graphical User Interface). If you know how to build dialogs for input and you can write graphics output to a window, you are well on your way to being able to build complete GUI applications. Incredibly, dialogs were one of the weakest aspects of early versions of the Java AWT. The problem was that these early AWT dialog classes lacked modal behavior.</p>
<p>From the user's point of view, modal behavior is not that big a deal. It simply means that no other windows or dialogs in the application can be accessed until the open modal dialog has been closed. However, from the programmer's point of view, modal behavior is more important. It means that program execution stops and waits while the modal dialog is open. If you have a line of code that displays and runs the modal dialog, then you can depend on the next line of code having available to it the latest user input from that dialog.</p>
<p>In earlier Java versions, program execution continued even while the "modal" dialog was open. This proved to be particularly disastrous for the application discussed in this article, which depends on dialogs delivering their data at very specific points in the code. Fortunately, modal dialog behavior was corrected in JDK 1.1.</p>
<p>The AWT provides a <B>Dialog</B> class, which produces a dialog window capable of taking input from the user. This basic class does not provide much functionality, other than defining message-capturing capability and, as of JDK 1.1, providing true modal behavior as an option. Class <B>Standard_dlg</B>, shown in <B>Standard_dlg.java</B> (<A HREF="list1.htm">Listing 1</A>), extends the <B>Dialog</B> class by providing some additional features that are useful for every dialog, such as <B>OK</B> and <B>Cancel</B> buttons with appropriately defined responses.</p>
<p>As of JDK 1.1, component actions such as pressing a button are handled by means of <B>ActionListener</B> classes. This is a somewhat more complicated approach than earlier versions, which handled actions directly with the <B>action</B> class method. The <B>Standard_dlg</B> class uses the methods <B>ok_response</B> and <B>cancel_response</B> to isolate the response actions to the <B>OK</B> and <B>Cancel</B> buttons. Separate <B>ActionListener</B> classes then call these methods. Note that the dialog itself is passed as an argument to each <B>ActionListener</B> class to enable access to these methods. C++ programmers will recognize the use of <B>this</B> as an argument, although here it represents an object rather than a pointer. In this way, descendant dialog classes do not need to redefine their own <B>ActionListener</B> classes. They need only override the <B>ok_response</B> and <B>cancel_response</B> methods.</p>
<p><B>ActionListener</B> classes together with their <B>ActionPerformed</B> methods play a role similar to callback functions in C/C++ for Windows and X-Windows. However, C/C++ callback functions typically need to be global or static functions. They cannot, for example, be member functions of C++ classes. Java has the advantage of allowing any object type as an argument in an <B>ActionListener</B> constructor. Using the dialog itself as an argument allows access to the dialog's own class methods as "callback functions."</p>
<p><A HREF="list2.htm">Listing 2</A>, <B>Textfield_dlg.java</B>, shows the code for the <B>Textfield_dlg</B> class, which adds an AWT <B>Textfield</B> control for input of text string data. A <B>Textfield</B> is an AWT object that allows the editing of a single line of text. The <B>String</B> variable <B>value_str</B> holds the text that this dialog controls. Descendant dialog classes use <B>value_str</B> to hold the display string corresponding to the data value that they control. A dialog should update the value under its control only when the user hits the <B>OK</B> button. If the user exits the dialog via the <B>Cancel</B> button, then the dialog should revert to the previously stored value.</p>
<p><B>Textfield_dlg </B>accomplishes this behavior by overriding the <B>ok_response</B> method to update <B>value_str</B> via <B>Textfield</B>'s <B>getText</B> method and overriding the <B>cancel_response</B> method to restore <B>value_str</B> to the display field (so that it, rather than the user-entered string, will be displayed the next time the dialog is opened) using <B>Textfield</B>'s <B>setText</B> method. Note that there is no need to define new <B>ActionListener</B> classes.</p>
<p><A HREF="list2.htm">Listing 2</A> also shows the code for the <B>Float_dlg</B> class, which extends <B>Textfield_dlg</B> to extract numeric float values from the input string. This dialog controls the <B>float</B> variable <B>value</B>. Java makes it very easy to display a numeric value as a <B>String</B>, using the <B>toString</B> method, and to extract a numeric value from a <B>String</B> representation, via the <B>valueOf</B> method. This raises the possibility of non-numeric exception errors due to inappropriate user input. I discuss the handling of these errors below.</p>
<p>The <B>Yes_no_radio_dlg</B> class (<A HREF="list3.htm">Listing 3</A>, <B>Yes_no_radio_dlg.java</B>) implements a two-choice <B>Checkbox</B> group as a radio-button control. Grouping the <B>Checkbox</B> controls in a <B>CheckboxGroup</B> implements standard radio-button behavior &#151; exactly one <B>Checkbox</B> can be selected at any one time. The control variable for this dialog is the Boolean variable <B>answer_is_yes</B>. The <B>ok_response</B> method retrieves the selected <B>Checkbox</B> and sets <B>answer_is_yes</B> to either <B>true</B> or <B>false</B>, depending on whether the <B>yes_box</B> or <B>no_box</B> has been selected. The <B>cancel_response</B> method restores <B>yes_box</B> and <B>no_box</B> to their previous states, regardless of the user's actions. </p>

<h4><FONT COLOR="#000080">Layouts vs. Resources</FONT></H4>

<p>The dialog code shown here introduces the concept of layout managers, one of the primary differences between the AWT and C/C++ Windows development. Windows developers are accustomed to working with resources to define the appearance of components such as dialogs. However, the cross-platform nature of Java requires a more adaptable approach. Layout managers automatically arrange the components of a user interface container (such as a window or dialog) according to a set of rules specific for that particular manager. There are a number of pre-defined layout managers, and you can also define your own custom versions.</p>
<p>Dialogs use the <B>BorderLayout</B> interface by default. We will also briefly encounter <B>FlowLayout</B> and <B>GridLayout</B> in this article. <B>BorderLayout</B> specifies five regions of the container: <B>North</B>, <B>South</B>, <B>East</B>, <B>West</B>, and <B>Center</B>. For example, <B>North</B> is a good place to position the dialog text label, while the <B>Center</B> region naturally accommodates input controls such as text fields and checkboxes.</p>
<p>To get a little more precision in the placement of components within these regions, it is useful to first define an AWT <B>Panel</B> object to contain the component or components. For example, a single <B>Panel</B> contains both the <B>OK</B> and <B>Cancel</B> buttons in the <B>South</B> region of the dialog. Panels use the <B>FlowLayout</B> manager as their default layout, which simply inserts new components from left to right, like a text editor. <B>GridLayout</B>, as the name implies, arranges components in a grid consisting of a specified number of rows and columns. The <B>Yes_no_radio_dlg</B> class uses a simple 2X1 grid to position its two <B>Checkbox</B> controls in a single column.</p>
<p>The visual Java development tools, such as JBuilder, Microsoft's Visual J++, and Symantec's Visual Caf&eacute;, all have some type of resource-oriented user interface design capability. While it may appear that you are using resources similar to those used by Windows, the output of these visual development tools is Java code, sometimes proprietary and not always portable to non-Windows platforms, based on some type of layout manager.</p>

<h4><FONT COLOR="#000080">Exception Handling</FONT></H4>

<p>The <B>Float_dlg</B> class provides an example of exception handling in Java. Because we are dealing with user input here, one of the things that can go wrong is that the user may try to enter non-numeric data in the input field. As it turns out, Java has excellent exception-handling capabilities that are very easy to implement. Even without specific exception-handling code, the program will not crash if the user enters invalid data. Java will note the exception in the console window, and the dialog will continue to display.</p>
<p>The problem is that once the user hits <B>OK</B>, the invalid data has made its way into the display field (although the <B>float</B> control field <B>value</B> remains uncorrupted) and will remain there unless we clear it out. We have no way of knowing that the data is not valid unless we handle the exception ourselves. Fortunately, as I mentioned, Java makes it very easy to do this.</p>
<p>Like C++, Java implements <B>try</B> blocks and <B>catch</B> blocks for handling exceptions. Simply enclose the call to <B>valueOf</B> inside a <B>try</B> block. Immediately following the <B>try</B> block, insert a <B>catch</B> block that includes code to recognize and handle the exception. In this case, the exception is <B>NumberFormatException</B>. (If you don't know the name of the exception, run the program without exception handling and Java will identify the exception in the console window when it occurs.) In response, the <B>catch</B> block simply prints the offending input text to the console window, and restores the previous <B>value_str</B> to the <B>Textfield</B>. (A more civilized application might inform the user via a message dialog rather than the console window.)</p>
<p>If the input data is valid, then the inherited <B>ok_response</B> will load the display string into <B>value_str</B>. In addition to checking for non-numeric input, you may also want to include allowable maximum and minimum values in the <B>Float_object</B> class and check for those as well. The ability to screen data at the point of user entry is one of the advantages of using dialogs for input.</p>

<h4><FONT COLOR="#000080">Data Objects</FONT></H4>

<p>The data object classes shown in <A HREF="list4.htm">Listing 4</A>, <B>Data_object.java</B>, tie data values to dialogs suitable for updating those values. So, for example, <B>Float_object</B> is a class that contains a <B>float</B> variable <B>value</B> and a method <B>get_new_value</B> that executes a <B>Float_dlg</B> dialog. These data object classes are derived from the abstract <B>Data_object</B> class, which does not handle any specific data type, and whose functionality is limited to building a display string from a description string and a value string.</p>
<p>Each of the derived data object classes contains a data-specific <B>get_new_value</B> method. In my C++ Windows implementation, <B>get_new_value</B> calls a stand-alone function which instantiates, executes, and deletes the appropriate dialog class. Java does not allow stand-alone functions. Rather, each function call must be a method belonging to an instantiated object class. So here the <B>get_new_value</B> method directly instantiates, executes, and disposes of the appropriate dialog object class.</p>
<p>Note that each dialog class requires a parent <B>Frame</B> object. Rather than tie the data object itself to a particular <B>Frame</B> object, which may not be known when the data object is created or may change during the application execution, I assign the <B>Frame</B> object parent as a parameter in the <B>get_new_value</B> method.</p>
<p>In addition to <B>Float_object</B>, I define two additional data-object types for the example of this article:</p>

<UL><LI><B>Boolean_object</B> controls a Boolean data value, with <B>get_new_value</B> calling <B>Yes_no_radio_dlg</B> to update this value.</LI>
    <LI><B>Filename_object</B> updates a <B>String</B> variable containing a file name. The <B>get_new_value</B> method for this class calls the built-in AWT class <B>FileDialog</B>, which implements the host platform's standard file browser.</LI></UL>

<p>You can add to these data object types with classes of your own. For example, you could use the <B>Textfield_dlg</B> class to define a <B>String</B> data object. In my C++ Windows implementation, I define a color object that uses the standard Windows <B>ChooseColor</B> dialog. The Java AWT does not have its own color chooser dialog class, however it is not difficult to find examples of such a dialog in the various Java information sources.</p>
<p>The final data-object class defined in <A HREF="list4.htm">Listing 4</A> is the general purpose <B>Multiple_data_object</B> class. It typecasts to each of the previously defined data-object classes, depending on which of several constructors is used. The advantage of using this class is that you don't need to know what the data type is when calling its <B>get_new_value</B> method. The <B>Multiple_data_object</B> <B>get_new_value</B> method uses the stored data type to index into a <B>switch</B> statement that calls the appropriate data-specific <B>get_new_value</B>. This is handy when manipulating lists of data objects of different types, which is exactly what the list dialog defined in the next section does.</p>

<h4><FONT COLOR="#000080">List Dialog</FONT></H4>

<p>The AWT <B>List</B> class is a control class that responds to user input for scrolling through and selecting items from an array of <B>String</B> objects. The <B>List_box_dlg</B> class (<A HREF="list5.htm">Listing 5</A>, <B>List_box_dlg.java</B>) inserts a <B>List</B> control into a <B>Standard_dlg</B> dialog. To facilitate handling arrays of objects more general than strings, I define the <B>Object_list</B> class, shown in <A HREF="list6.htm">Listing 6</A>, <B>Object_list.java</B>. In this article, I have need only for methods which add objects to the list <B>(add_item</B>) and return a specified object from the list (<B>at</B>). Space limitations preclude a more generally useful version which would also provide delete and insert functionality.</p>
<p><B>Object_list</B> is the mechanism by which lists of objects are introduced into the dialog. <B>List_box_dlg</B> loads the <B>String</B> representation of each item in the <B>Object_list</B> into the <B>List</B> control. The <B>List</B> class has some useful features, including the automatic addition of vertical and (as of JDK 1.1.6) horizontal scroll bars as needed. The <B>getSelectedIndex</B> method retrieves highlighted items selected with a single mouse click. Double-click selections, however, require a new <B>ActionListener</B>.</p>
<p>The <B>Data_list_dlg</B> extends the functionality of <B>List_box_dlg</B> by manipulating an array of objects of the class <B>Multiple_data_object</B>. The <B>get_item_string</B> method is overridden to return the string obtained from <B>get_dislay_str</B>, which shows a description and the latest value of the data object. I want <B>Data_list_dlg</B> to respond to a double-click action by calling the selected data object's <B>get_new_value</B> method, which will display a dialog for updating the data object's value. For this, I need to define a new <B>ActionListener</B> which captures the <B>List</B>'s double-click actions. After <B>get_new_value</B> has executed, <B>replaceItem</B> updates the display string in the list. The list dialog remains open until the user hits <B>OK</B> or <B>Cancel</B> so that other items in the list may be updated.</p>

<h4><FONT COLOR="#000080">Application Frame Example</FONT></H4>

<p>The example in this section shows how easy it is to use the data-list dialog as an application user interface. The application launches a <B>Frame</B> class window that includes a menu with two items, <B>File</B> and <B>Edit</B>. The <B>File</B> menu includes the <B>Exit</B> item, while the <B>Edit</B> menu has a single <B>Setup...</B> item that summons the list dialog. <A HREF="fig1.htm">Figure 1</A> shows the frame-window application, with the list dialog and an example of the yes-no radio dialog which has been opened for updating one of the list items. The frame window itself displays the index of the most recently selected list item and its contents. Doing this in a platform-independent way actually constitutes more code than is required for setting up the list dialog.</p>
<p><A HREF="list7.htm">Listing 7</A>, <B>App_Frame_with_dlg.java</B>, shows the code for the <B>App_Frame_with_dlg</B> class that implements this example. The list dialog interface is set up by first defining a new <B>Object_list</B> object and then adding new <B>Multiple_data_object</B> objects to it. Note that the constructor call for <B>Multiple_data_object</B> determines the data type and its initial value. You can introduce additional items merely by adding more items to the list. The dialog layout does not change, and no new controls need be defined. The <B>dispose</B> method releases all of the resources used by the frame and also destroys all windows owned by the frame, such as the dialogs that we have been using. Finally, <A HREF="list8.htm">Listing 8</A>, <B>dlg_app.java</B>, shows the small amount of code required to actually run <B>App_Frame_with_dlg</B> as an application.</p>

<h4><FONT COLOR="#000080">Summary</FONT></H4>

<p>This brief discussion has shown how to develop a few simple dialogs in Java and how to tie them together in a list dialog that provides a convenient device for user input of varied data types. Along the way, I have compared the Java development process with that of development in C/C++ for Windows. From a code point of view, for user interface development, Java and the AWT present an attractive alternative to C/C++ and the Windows API. As a bonus, you get multiple-platform portability. While early implementations of Java applications lack the sophistication of their Windows counterparts, improvements in Java continue to bring it closer to being a viable competitor to C/C++/Windows for GUI applications.</p>

<p><i>Steve Welstead is senior scientist with XonTech Incorporated in Huntsville, Alabama, and an adjunct associate professor of mathematics at the University of Alabama in Huntsville. He does all of his own C/C++ and Java programming for research investigations in image and signal processing. He has contributed three previous articles to <I>C/C++ Users Journal</I>. He has written one book that uses C/C++ code, and is currently completing <I>Fractal and Wavelet Image Compression Techniques</I>, to be published by SPIE Publications in the summer of 1999.</i></p>

<h4><a href="../../../source/1999/jan99/welstead.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY>
</HTML>
