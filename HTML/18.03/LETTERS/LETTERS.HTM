<HTML>   
     <HEAD>
<TITLE>March 2000/We Have Mail</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">We Have Mail</FONT></H2>

<HR>
<BLOCKQUOTE>
<p><I>Letters to the editor may be sent via email to </I>cujed@mfi.com<I>, or via the postal service to Letters to the Editor, </I>C/C++ Users Journal<I>, 1601 W. 23rd St., Ste 200, Lawrence, KS 66046-2700.</I></p>

<hr><p>Dear <I>CUJ,</I></p>
<p>I am employed as a programmer, concentrating on machine control applications. I cannot understand why every programmer that uses C++ for Windows has not switched to Borland C++ Builder. It is so superior to Visual C++ in speed of development, in true reuse of the framework, and ANSI support. Builder is like Visual Basic because it is truly visual development but it is C++. I am not a Microsoft basher, I am even a shareholder. Microsoft says if you want a nice front end, and RAD development environment, use VB to your GUI front end with a VC back end. I challenge you all to <I>try</I> Builder and do the whole job with one tool. I dare your magazine to do a true comparison of VC++ vs. Builder.</p>
<p>Michael Christopher<br>
Embedded Software Manager<br>
Ohio Electronic Engravers<br>
Dayton, Ohio, USA</p>
<p><I>I use C++ Builder in a lot of my own projects, and I agree with you in one respect: for people who don't know (and don't want to know) anything about Windows internals, C++ Builder is a lot easier to use than VC++ when creating simple GUI-based applications. However, I have used the GUI builder feature of C++ Builder only in very small projects. I cannot offer a comparison of, say, Borland's VCL (Visual Component Library) and Microsoft's MFC (Microsoft Foundation Classes). Such a comparison would be important if you were going to develop a GUI-based application of any appreciable size, and it would have to be carried out by someone who understood the requirements of the project.</I></p>
<p><I>Beyond that, of the three things you mention that make a compiler "superior" in your view (speed of development, reuse of the framework, and ANSI support) the only one we could say anything objective about would be compliance to the ANSI standard. The best we could do here would be to list the various features (e.g., member templates) supported or not by the two compilers. Even a list such as this would be of marginal utility, however. Consider, for instance, that the libraries supplied with a compiler can easily be just as important as the feature set supported, and evaluating the relative merits of two libraries is yet another can of worms.</I></p>
<p><I>There is no meaningful way to compare two products as complex as a compiler in a few thousand words. Compilers and libraries have to be evaluated in the context in which they'll be used. Any magazine article that leads you to believe otherwise is just not telling the truth. &#151; mb</I></p>

<hr><p>Editor,</p>
<p>Greetings! I just wanted to say that I really enjoyed the cover picture on December's graphics programming issue &#151; is it supposed to look like what I think it looks like?</p>

<p><I>No. &#151; mb</I></p>

<hr><p>Dear <I>CUJ,</I></p>
<p>I just had opportunity to read through the article on singleton creation in a multithreaded environment ("Singleton Creation the Thread-Safe Way," by Jonathan Ringle, <I>CUJ</I>, October 1999).</p>
<p>The author brings up some important considerations for multithreaded environment, and suggests a locking mechanism to avoid creating a second singleton object. I agree with his solution, but I feel he has added extra overhead without needing to. In his article, he describes using a flag as a "lock-hint." Rather than using another variable (the flag), the singleton itself can be used for this. Just as in the original version with the potential race condition, the <B>_instance</B> value can be checked, if it does not exist; then grab the lock, then test again for the value of <B>_instance</B> and create the singleton if needed. Again, the first thread to need the singleton will grab the mutex and create the object. If another thread tests for the object and fails, then it will contend for the mutex and by the time it gets the mutex, the object will exist and the second test will cause the thread to not try to create a new object. This solution accomplishes the same thing, but does not require yet another global object (the flag).</p>
<p>Keep up the good work, I throroughly enjoy reading through your publication.</p>
<p>Thomas Groleau<br>
Benson, Arizona</p>

<p><I>Thanks for the tip. &#151; mb</I></p>

<hr><p>Dear P. J.,</p>
<p>As someone with over 30 years in the business, I found your article in the <I>C/C++ Users Journal,</I> "Just Another Version of Algol," quite interesting.</p>
<p>You mentioned JOVIAL as standing for "Joe's Own VersIon of ALgol." This is slightly incorrect. JOVIAL's principal architect was Jules Schwartz, at the time, the principal scientist of Computer Sciences Corp. With some "pride of authorship" the language developed for the U.S. military was designated as "Jules' Own Version of the International Algorithmic Language."</p>
<p>Hope you find this revealing.</p>
<p>Regards,</p>
<p>John Carroll </p>

<hr><p>Dear <I>CUJ,</I></p>
<p>To avoid any loss of information transferring from one system to another, perhaps from IEC559/IEEE 754 to other systems using some other mantissa and exponent combination, (or even just sending to a file or paper and reading back in!), I seem to have discovered that one needs more than the <B>digits10</B> (== 15 for double) precision using:</p>

<pre>
cout &lt;&lt; setprecision
   (std::numeric_limits&lt;double&gt;::
       digits10)
</pre>

<p>than I expected. For example:</p>

<pre>
cout &lt;&lt; 1.0 +
   std::numeric_limits&lt;double&gt;::
      epsilon()
</pre>

<p>outputs just <B>1</B>, and not the <B>1.0000000000000002</B> that one wants to avoid losing that least significant bit.</p>
<p>Even adding an extra digit, as in:</p>

<pre>
cout &lt;&lt; setprecision
   (std::numeric_limits&lt;double&gt;::
       digits10 + 1)
</pre>

<p>doesn't always produce the terminal <B>2</B>, but</p>

<pre>
cout &lt;&lt; setprecision
   (std::numeric_limits&lt;double&gt;::
       digits10 + 2)
</pre>

<p>does seem to work as expected.</p>
<p>So floating-point constants like <B>pi</B> are best defined to at least this number of digits too.</p>
<p>This is not what I had naively expected from reading the somewhat cryptic definition of <B>digits10</B>.</p>
<p>This may seem an obscure point, but it is important to avoid loss of information to avoid getting slightly different results on different systems. Statistics assumes and works best on continuous input, so one cannot but improve matters by adding extra "noisy" bits or digits at the end.</p>
<p>Dr. Paul A. Bristow<br>
hetp Chromatography<br>
Wilmslow, Cheshire UK<br>
<B>pbristow@hetp.u-net.com</B></p>

<p><I>The problem is much harder than it at first appears. Guy Steele and others published papers a decade ago on how to read and write floating-point numbers without such surprising loss of precision. Java requires this behavior. Took Pete Becker a couple of weeks to get it right in our Java library, not to mention a lot of code. &#151; pjp</I></p>

<hr><p>Dear <I>CUJ,</I></p>
<p>There appears to be an error in one of the code snippets in Gary Powell's "Extending <B>&lt;limits&gt;</B> for Type Safety" (<I>CUJ,</I> December 1999). In the second block of code under the heading "Template Argument Deduction," I believe <B>min(value)</B> and <B>max(value)</B> ought to read <B>min(index)</B> and <B>max(index)</B>, respectively. Otherwise, the template is instantiated on the type of <B>value</B>, which is <B>int</B>, and the assertion will always succeed. The text below the code appears to be consistent with these changes, naming <B>index</B> as the variable that provides the template's type.</p>
<p>Also, I would like to comment that all of the examples shown fit into the same pattern of checking not just a bound on a variable's type, but whether or not a particular value can fit within that variable's range. A template like the following could simplify this even further:</p>

<pre>
template &lt;class TSource,
   class TVariable&gt;
inline bool
fits_in(TSource value,
   const TVariable &amp;) throw()
{
   return
     std::numeric_limits&lt;TVariable&gt;::
        min() &lt; value
     &amp;&amp; value &lt;=
     std::numeric_limits&lt;TVariable&gt;::
        max();
}
</pre>

<p>This would be used as follows:</p>

<pre>
int FooFunction(int value)
{
   short index;

   assert(fits_in(value, index));
   index = value;
   ...
}
</pre>

<p>Weston Markham</p>

<p><I>Gary Powell replies:</I></p>
<p><I>Dear Weston,</I></p>
<p><I>Thank you for the comments about the limits paper. The mistake was made after the galley proofs were sent to me. Fortunately most people will be able to make the correction from the next bit of code.</I></p>
<p><I>Your </I><B>fits_in</B><I> template is nice in that it encapsulates the whole test in one easy-to-read statement. I skipped making examples for the rest of the </I><B>limits&lt;&gt;</B><I> properties as being redundant, the point of the article that while </I><B>limits&lt;&gt;</B><I> is fine, one more layer of templates makes it even more useful.</I></p>
<p><I>Thanks again,</I></p>
<p><I>Gary Powell</I></p>

<p><I>I'll 'fess up &#151; the mistake was our doing. We truly regret the error. &#151; mb</I></p>

<hr><p>Dear <I>CUJ,</I></p>
<p>I read with interest the Editor's Forum in your December 1999 issue &#151; the commonality between Hardware Design and Software Design is coming back 'round again. A number of years ago my Ph.D. thesis was based on the creation of a "Circuit Specification Language" &#151; in effect a Hardware Description Language for VLSI Design. The object of this was to be able to create a design using a C/C++-style language and use this to realise the design across multiple VLSI implementation technologies. The inspiration of this work was partially based on the similarity between porting software programs across multiple platforms and porting hardware designs &#151; which the use of object orientation made easier. (For further information see <B>http://eleceng.ukc.ac.uk/~ltw/csl.pdf</B>.)</p>
<p>At that point I was using the advanced state of object-oriented software techniques as a means of helping manage a hardware-design problem. At the same time software technologies were using the advanced state of hardware design &#151; in terms of reusable components &#151; to solve a software crisis. A number of years later the issues surrounding reusable components in software are still unresolved &#151; and hardware technologists are still looking to solve their problems using software-development techniques.</p>
<p>The lessons to be learnt from this seem to be: nobody really has the final answer to the management of complexity &#151; there is still no silver bullet, and none expected on the horizon. As systems grow beyond what we have built before there will probably always be a delivery crisis &#151; showing up in the costs and timescales related to not really understanding how to build something like this. The process of understanding how to construct complex items in complex and rapidly changing environments will probably also always be slow &#151; despite the demands for it to be ever quicker based on customer expectations. It is worthwhile having a broad knowledge base available in an organisation &#151; rather than making sure that everyone has very specific skills ready to do their current role. There will always be someone in a different discipline to learn from &#151; who would also find it beneficial to learn from you. Not earth shattering relations in the modern world &#151; but worth reflecting on.</p>
<p>David Howard<br>
England<br>
waddy100@hotmail.com</p>

<p><I>&#151; Hear, hear. &#151; mb</I></p>

<hr><p>Dear <I>CUJ,</I></p>
<p>I noticed that in his article, "Debugging Component-Based Memory Leaks" in the January 2000 issue, that Ernesto Guisado uses a macro and inheritance to pass type information. It seemed to me that templates and run-time type information would be a better solution in this case. With this in mind, I wanted to try replacing the <B>OBJECT_LOGGER</B> macro with a template. I came up with:</p>

<pre>
template&lt;class object_t&gt;
class object_logger
   : public log_object {
public:
   object_logger()
      : log_object(sizeof(object_t),
           typeid(object_t).name())
        {}
};
</pre>

<p>Now, you can add logging to a class simply by adding an <B>object_logger</B> member, without any macros:</p>

<pre>
class my_gizmo {
   object_logger&lt;my_gizmo&gt;
      log_object_my_gizmo;
   // Whatever ...
};
</pre>

<p>If one has code that already uses the <B>OBJECT_LOGGER</B> macro, or one does not like coming up with one's own member names, you can redefine the <B>OBJECT_LOGGER</B> macro in terms of this template:</p>

<pre>
#define OBJECT_LOGGER(name) \
    object_logger&lt;##name##&gt; \
    __##name##_log_object_;
</pre>

<p>Sincerely,</p>
<p>Matt Seitz<br>
San Jose CA</p>

<p><I>Ernesto Guisado replies:</I></p>
<p><I>Hi,</I></p>
<p><I>Thanks for your comments.</I></p>
<p><I>Your code would definitely work, but there are reasons why I prefer my version. You use inheritance too. So it would be macro + inheritance against template + RTTI + inheritance. Although the use of macros is not particularly elegant, it solves the same problem as the template + RTTI combination. I didn't want to obscure the intent of the article by using too many or too advanced features of the language.</I></p>
<p><I>C++ was designed following the maxim, "You shouldn't pay for what you don't use." As a consequence, compilers like VC++ V5.0 implement RTTI (and exception handling) as an "optional" feature of the language that you have to explicitly enable. I didn't want to be in the position where I have to explain that you have to enable a specific compiler feature just to use my logger class.</I></p>
<p><I>Yes, "you can add logging to a class simply by adding an </I><B>object_logger</B><I> member, without any macros," but it's not simpler. If you had to explain your code to a C programmer (remember, it's </I>C/C++ Users Journal<I>), how many C++ features would you have to explain before he can understand the article? And my version?</I></p>
<p><I>Your macro example shows another reason why I decided to use a macro instead of templates. For an object that is not going to be used by any client code I didn't want to have to exclicitly name it. The variable is just an artifact I need. The name is totally irrelevant and I don't want to force anybody to choose it for me. On the other hand, if you finally wrapped your code in a macro like mine, the final equation would be &lt;macro + inheritance&gt; against &lt;macro + template + RTTI + inheritance&gt;.</I></p>
<p><I>As I said, your solution is perfectly valid, but in my opinion using features of the language not relevant to the point adds nothing but complexity.</I></p>
<p><I>Regards,</I></p>
<p><I>Ernesto</I></p>

<hr><p>Dear PJP,</p>
<p>Some historical trivia:</p>
<p>JOVIAL is an acronym for "Jules' Own Version of International Algorithmic Language." Jules is Jules Schwartz of Systems Development Corporation, which was here in Santa Monica CA. IAL was the (a?) progenitor of the various Algols.</p>
<p>Jules implemented the JOVIAL compiler at SDC, where it was used for many projects, and, as I recall, became a standard language for military software.</p>
<p>(I enjoy reading your column!)</p>
<p>Regards,</p>
<p>George Armerding<br>
<B>Armerding@alum.mit.edu</B></p>

<p><I>You were one of many who pointed out my memory lapse. Thanks for giving credit where it is due. &#151; pjp </I>o</p>

</blockquote></body></html>
