<HTML>
     
     <HEAD>
<TITLE>February 1999/LUP Matrix Decomposition Using Templates</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">LUP Matrix Decomposition Using Templates</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Mike Rumore</FONT></H3>

<BLOCKQUOTE>

<p>Solving linear equations is not for the amateur, or the faint of heart. Templates, and some good algorithms, can be a real help.</p>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<h4><FONT COLOR="#000080">Introduction</FONT></H4>

<p>Solving a set of linear equations is a very common problem in engineering. Two examples are the sets of equations that arise from analyzing an electrical circuit or from statics. In either case, the set of linear equations has the following form:</p>

<pre>
A<SUB>11</SUB>X<SUB>1</SUB> + A<SUB>12</SUB>X<SUB>2</SUB> +&#133;+ A<SUB>1N</SUB>X<SUB>N</SUB> = Y<SUB>1</SUB>
A<SUB>21</SUB>X<SUB>1</SUB> + A<SUB>22</SUB>X<SUB>2</SUB> +&#133;+ A<SUB>2N</SUB>X<SUB>N</SUB> = Y<SUB>2</SUB>
 .
 .
 .
A<SUB>N1</SUB>X<SUB>1</SUB> = A<SUB>N2</SUB>X<SUB>2</SUB> +&#133;+ A<SUB>NN</SUB>X<SUB>N</SUB> = Y<SUB>N</SUB>
</pre>

<p>where <I>A<SUB>ij</SUB></I> is the <I>i,j</I> element of an <I>NxN</I> matrix, and <I>X<SUB>i</SUB></I> and <I>Y<SUB>i</SUB></I> are vectors of <I>N</I> dimensions. In general, you know <I>A</I> and <I>Y</I>, and you have to solve for <I>X</I>.</p>
<p>There are several methods used to solve for the vector <I>X</I> in the previous of set of equations. This article describes an implementation of one of these methods, LUP decomposition. LUP decomposition is the method of choice for matrices that are dense (<I>A<SUB>ij</SUB></I> mostly non-zero) and for <I>N</I> less than a few hundred <a href="#1">[1]</a>. For matrices that are sparse (<I>A<SUB>ij</SUB></I> mostly zero) and for <I>N</I> greater than a few hundred, a set of techniques known as iterative methods is used to solve for <I>X</I> [<a href="#2">2</a>, <a href="#3">3</a>].</p>

<h4><FONT COLOR="#000080">The LUP Decomposition Algorithm</FONT></H4>

<p>The set of equations listed before can be rewritten more concisely using matrix notation as follows:</p>

<pre>
A*X = Y,
</pre>

<p>where <I>A</I> is an <I>NxN</I> matrix, and <I>X</I> and <I>Y</I> are vectors of <I>N</I> dimensions. Again, <I>A</I> and <I>Y</I> are known, and <I>X</I> must be determined.</p>
<p>The LUP decomposition method assumes that the matrix <I>A</I> can be rewritten as the product of two matrices,</p>

<pre>
A = L*U,
</pre>

<p>where the matrix <I>L</I> is assumed to be lower triangular (all <I>L<SUB>ij</SUB></I> above the main diagonal are zero) and the matrix <I>U</I> is assumed to be upper triangular (all <I>U<SUB>ij</SUB></I> below the main diagonal are zero). Substituting into the original equation we get:</p>

<pre>
A = L*U 
A*X = Y 
L*U*X = Y
</pre>

<p>Now suppose that <I>U*X = Z,</I> where <I>Z</I> is a new vector of <I>N</I> dimensions. Then we can rewrite the original problem <I>A*X = Y</I> as follows:</p>

<pre>
U*X = Z 
L*Z = Y
</pre>

<p>What has this gained us? It turns out that the two new sets of equations can be solved very efficiently, since <I>L</I> and <I>U</I> are triangular matrices. First we solve <I>L*Z = Y</I> for <I>Z</I> using forward substitution, then we solve <I>U*X = Z</I> for <I>X,</I> the original problem, using backward substitution [<a href="#4">4</a>].</p>
<p>There are two common factorizations for the <I>L</I> and <I>U</I> matrices, Crout's and Doolittle's. Crout's factorization results in a <I>U</I> matrix which has 1s along the main diagonal, and Doolittle's factorization results in an <I>L</I> matrix with ones along the the main diagonal. I have chosen to use Gaussian elimination with pivoting and scaling to generate a Doolittle factorization of the matrix <I>A</I> <a href="#4">[4]</a>. Since pivoting is required to maintain stability during Gaussian elimination, it is necessary to track how rows are switched. A permutation vector (the P in the name LUP) is generated by the LUP decomposition function to record the row switches.</p>

<h4><FONT COLOR="#000080">Implementation</FONT></H4>

<p>The LUP code is displayed in <A HREF="list1.htm">Listings 1</A>, <A HREF="list2.htm">2</A>, <A HREF="list3.htm">3</A>, <A HREF="list4.htm">4</A>, <A HREF="list5.htm">5</A>, and <A HREF="list6.htm">6</A>. It is based on the algorithms described in reference <a href="#4">[4]</a>. All the code was tested using the SUN Solaris 4.2 C++ compiler (without the use of <B>#pragma</B>s). All the code is also available from the <I>CUJ</I> ftp site (see p. 3 for downloading instructions).</p>
<p><A HREF="list1.htm">Listings 1</A> and <A HREF="list2.htm">2</A> display the headers of the vector and matrix classes used in the LUP code. The LUP code requires the <B>Matrix</B> class to have a constructor of the form <B>Matrix&lt;T&gt;(unsigned int number_of_rows, unsigned int number_of_columns)</B> and an access operator of the form <B>T &amp;operator()(unsigned int row, unsigned int col)</B>. Purists may argue that the correct method to access a matrix is with the form, <B>matrix[i][j]</B>, but I went with the simpler solution. The vector class must support a constructor of form <B>Vector&lt;T&gt;(unsigned int dimension)</B> and an access operator of the form <B>T &amp;operator[](unsigned int)</B>.</p>
<p><A HREF="list4.htm">Listings 4</A> and <A HREF="list5.htm">5</A> display the header and source file containing the LUP code. <A HREF="list5.htm">Listing 5</A> lists the following functions.</p>

<UL><LI><B>GaussianLUP_Pivot(Matrix&lt;T&gt; &amp;m, Vector&lt;int&gt; &amp;pv, T ep, T &amp;sign)</B> generates the LUP decomposition for the given matrix. It expects <B>m</B> to contain the original matrix and it returns <I>L</I> and <I>U</I> stored in <B>m</B>; that is, <B>m</B> is overwritten with <I>L</I> and <I>U.</I> <B>pv</B> is the permutation vector that tracks how rows were switched during Gaussian elimination. <B>ep</B> is the epsilon used to determine if a matrix is singular; and <B>sign</B> is used to calculate determinants. If epsilon (<B>ep</B>) is less than or equal to zero, then the template function <B>calcEpsilon</B> is called to calculate it.</LI>
    <LI><B>SolveUsingGaussianLUP_Pivot(Matrix&lt;T&gt; &amp;m, Vector&lt;T&gt; &amp;x, Vector&lt;T&gt; &amp;y, Vector&lt;int&gt; &amp;pv, T ep)</B> calculates and returns the solution vector <B>x</B> for a given matrix <B>m</B> and vector <B>y</B>. It expects <B>m</B> to contain the matrices <I>L</I> and <I>U,</I> <B>pv</B> to contain the permutation vector, and <B>ep</B> to equal the epsilon.</LI>
    <LI><B>GetInverseUsingGaussianLUP_Pivot(Matrix&lt;T&gt; &amp;m, Matrix&lt;T&gt; &amp;minv, Vector&lt;int&gt; &amp;pv, T ep)</B> calculates and returns the inverse of <B>m</B> in the matrix <B>minv</B>. It expects <B>m</B> to contain the matrices <I>L</I> and <I>U,</I> <B>pv</B> to contain the permutation vector and <B>ep</B> to equal the epsilon.</LI></UL>

<p><A HREF="list5.htm">Listing 5</A> displays a template function <B>calcEpsilon</B>, which calculates the smallest difference that is representable for a given data type. These values are used to determine if a matrix is singular. If the values are too small, then they can be scaled. On a Sun workstation the epsilon calculated for <B>float</B> and <B>double</B> match the values stored in header <B>float.h</B>, <B>FLT_EPSILON</B> and <B>DBL_EPSILON</B>, respectively.</p>

<h4><FONT COLOR="#000080">An Example</FONT></H4>

<p><A HREF="list6.htm">Listing 6</A> displays a sample program which calculates the LUP decomposition for a matrix, then uses the results to calculate the <I>X</I> vector for a given <I>Y</I> vector, and calculates the inverse matrix. The solution vector <I>X</I> and the inverse matrix are printed.</p>

<h4><FONT COLOR="#000080">Conclusion</FONT></H4>

<p>The original version of this code was written in Fortran 77 over ten years ago. Recently I rewrote the code for a numerical methods class that I teach at a local two-year college. Finally, I completely rewrote and updated the algorithm using C++. Since then its main use has been for least-squares fits and optimization.</p>

<h4><FONT COLOR="#000080">Acknowledgment</FONT></H4>

<p>I would like to thank K. B. Williams for his comments and review of the LUP code. His input is gratefully acknowledged.</p>

<h4><FONT COLOR="#000080">References</FONT></H4>

<p><a name="1"></a>[1]  William H. Press, Brian P. Flannery, Saul A. Teukolsky, and William T. Vetterling. <I>Numerical Methods: The Art of Scientific Computing</I> (Cambridge University Press, 1987).</p>
<p><a name="2"></a>[2]  Terrence J. Akai. <I>Applied Numerical Methods for Engineers</I> (John Wiley, 1994).</p>
<p><a name="3"></a>[3]  Lee W. Johnson and R. Dean Riess. <I>Numerical Methods</I> (Addison-Wesley, 1982).</p>
<p><a name="4"></a>[4]  David Kincaid and Ward Cheney. <I>Numerical Methods: Mathematics of Scientific Computing</I> (Brooks/Cole, 1991).</p>

<p><i>Mike Rumore has a Ph.D. in Nuclear Physics from the University of Colorado, Boulder. He has been working for Lucent Technologies (formerly AT&amp;T) Bell Labs for 11 years as a software engineer. He has been using C++ for over six years for tool generation. His current interests are data structures and numerical algorithms (linear inversion methods applied to radiation spectra).</i></p>


<h4><a href="../../../source/1999/feb99/rumore.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY>
</HTML>
