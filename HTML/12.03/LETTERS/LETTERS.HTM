

<HTML>
<HEAD>

<TITLE>March 1994/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="00B4_004E"><A name="00B4_004E"></font></h2><hr>
<BLOCKQUOTE>
<A name="00B4_0000"><A name="00B4_0000">Dear Mr. Plauger:<P>
There are a number of aspects of the current state of the art of software engineering that I find less than satisfactory. They are<P>
1)     Bug-infested tools<P>
2)     The dearth of productive engineering tools<P>
3)     The programming languages themselves.<P>
First of all, I have used Lattice C, Turbo C, and Microsoft and Borland C/C++ compilers. Our group chose the latter two for their third-party and Windows support. First I used Lattice C 3.1. It didn't do <I>float</I>s but <I>double</I>s seemed to work OK. Next I used Microsoft v5.0. It optimized code out of existence. Because of that we switched to Turbo C/C++. It refused to do assignments of floating point (<I>float</I> or <I>double</I>) literals in the range between 0 and 1!<P>
This problem only occurred when linking together 20-odd modules, In a three-module test program all worked fine. Due to project deadline pressure I was never able to whack away at the 20-odd modules to the point where the problem went away in order to determine its cause. I worked around it. This problem was also present in Borland C/C++ 3.0, but does not occur in version 3.1 with identical source code. I have seen two instances where Borland C/C++ 3.1 handled the following snippet where the function returns the value 1 by not taking the <I>if</I>:<P>
<pre>if ( func() )   // returns 1
   do_something(); // never executed</pre>
Changing this to the following worked, however:<P>
<pre>status = func();
if ( status )
   do_something()</pre>
My first gripe about the state of the art is that compiler vendors seem to concentrate on features like IDEs, 32-bit versions (64-bit next, no doubt), Windows support, etc., while basic functionality is not solid. Floating point seems especially difficult for these people. (You'd think that after ten years of writing C compilers...) I really don't know if Borland C/C++ v3.1 has floating point problems; I just haven't seen any problems so far. Now if Borland and Microsoft are the least-buggy products on the market, I'd hate to see the others. I would love to be able to trust the compiler, but that seems to be wishful thinking. At least we have debuggers to go roto-rooting in the generated assembly code.<P>
More and more vendors are charging for phone support. Now I get to <I>pay them</I> for reporting bugs in their products. Borland actually told me to call their 900 number to discuss a bug! No thanks! Along with the bug situation, I wish compiler error and warning messages were more accurate. In many cases I have to ask myself, "Now what does it <I>really</I> mean?" I use PC-LINT religiously. To the compiler vendor's credit, error and warning messages have been getting better in recent years.<P>
Now lets add C++ on top of this whole mess. I enjoyed your article, "Programming Language Guessing Games" in <I>Dr. Dobb's</I> (October 1993). I agree of course with your suggestion to "pick a subset of the [C++] language that minimizes surprises, learn it well, and don't stray from it." The problem is that the compiler vendor chooses to support everything that looks like it will make it through the ANSI committee. If they can't get some of these simple things solid (like the function return value example above) how can I trust them to do some of the complicated things you have described for C++? Even if I <I>do</I> restrict myself to a subset of the language, it could be that the other features induce bugs in the parts that I am using. The bottom line is that the majority of our time is spent on maintenance. Compiler bugs cost us. Secondly, the support tools available do not help me with software engineering (as opposed to hacking which I define as, "code it first without thought of design, document it later") as I would like. Diagrams are a neat idea, but then we have to translate the diagram into code by hand and translation is where errors creep in. Management might go for the time spent on diagramming if automatic code generators were available. Code generators for Windows screens and other user interfaces are generally available, but I haven't seen any for other parts of a program. A framework generator would be nice. Hardware engineers have schematic capture and printed-circuit-board layout tools including auto routers, but as software engineers, we do analogous things by hand. Also, I've yet to see a decent cross-reference generator after evaluating several. The ones with usable output are way too slow. I use GNU CTAGS, but wish it did more. I know of no general purpose, highly configurable cross-reference generator. We have written our own programs and editor macros to insert comment blocks for functions and modules and for extracting those into a Word document, but so much more could be done. I am beginning to write add-on tools for Codewright, a very extensible Windows programmer's editor. Thirdly, despite some ugly features of C, I like it a lot (more than Pascal, Modula-3, Eiffel, etc.). For example, C overloads the <I>static</I> and <I>void</I> keywords, allows functions to return pointers to automatic variables, and various other gotchas mentioned in Andrew Koenig's <I>C Traps and Pitfalls</I>. (Being able to execute an array of opcodes is a feature?) But for the sadist, C++ is a real treat. Now we have not two but three meanings of <I>static</I> and not two but four meanings of <I>void</I>!<P>
C and C++ violate many of the accepted guidelines of language design. Many things can be done several different ways, much of it behind the scenes. I shudder whenever I read one of your articles concerning C++, your latest in <I>The C User's Journal</I> on the Standard C++ library included (P.J. Plauger, "Standard C: Developing the Standard C++ Library," <I>CUJ,</I> October 1993). I know that I cannot avoid learning C++, but hopefully it will be replaced soon with something simpler. We need new paradigms and metaphors to handle advanced concepts. Languages will <I>have</I> to become more complicated, but they should be as simple as possible. I like the approach taken by Meyer in Eiffel of including an extensive set of libraries. The less I have to write myself, the more productive I am. Hopefully, libraries supplied with compilers are well thought-out and bug-free. I wish Borland C/C++ came with the library support that Eiffel or NextStep Objective-C does. A collection of third-party classes or libraries does not have the consistency that a single-sourced library does. I have only touched the surface of some current problems in the software industry. What I would like to know is:<P>
1)     Which in your experience are the least-buggy C/C++ compilers?<P>
2)     Do you know of a diagrammer w/code generator? What other engineering tools have you found to be helpful?<P>
3)     Do you know of any cross-reference generator that outputs a list of identifiers including the module name, line number, <I>and function</I> (if any) they were found in, <I>and that is fast?</I><P>
4)     What do you think of Modula-3, Eiffel, and IBM's Object REXX? Thank you in advance for your help. Thanks for your excellent articles. Please keep them coming.<P>
<I>BRUCEDICKEY@VAX.MICRON.COM</I><br>
Bruce Dickey<br>
Micron Semiconductor, Inc.<br>
2805 E. Columbia Rd., MS 892<br>
Boise, ID 83706<P>
<I>Whew! You raise a whole slew of issues. I agree with you almost across the board, except that I am a bit more sympathetic to the plight of all those compiler vendors out there scrabbling for market share in a turbulent industry. I guess that comes from selling compilers myself for ten years. Growing complexity seems always to offset gains in our ability to manage software development and reduce shipped bugs.</I><P>
<I>I don't know how to answer any of your questions at all well, but I invite other readers to chip in. My opinion of Modula-3 and Eiffel, for what it's worth, is fairly simple. Both offer interesting combinations of features, but neither has quite pulled off the synergy of C or C++. I don't know enough about REXX to comment. &#151; pjp</I><P>
Dear Editor,<P>
My compiler issues an error diagnostic on the call to <I>g</I> in the code fragment shown in <A href="list1.htm">Listing 1</a>,
 but no error on the call to <I>f</I> The error claims that there is a pointer mismatch in the argument. I am using Digital's DEC C compiler under OpenVMS on their new Alpha processor. When I contacted DEC's customer service, they explained that the ANSI standard allows conversion from a pointer to a qualified type to a pointer to a non-qualified type, but does not allow 'ignoring' the qualifier for a pointer to a pointer to a type. Their argument seemed somewhat niggling to me, so I wanted to appeal to a higher authority. How do you think a compiler should handle this code (shown in <A href="list1.htm">Listing 1</a>)
? Sincerely,<P>
Dick Hile<br>
T and B Computing, Inc.<br>
24 Frank Lloyd Wright Dr.<br>
P.O. Box 302 - Lobby A<br>
Ann Arbor, Michigan 48106-0302<P>
<I>DEC is correct. The distinction may appear niggling to you, but we meant to do it that way when we wrote the C Standard. &#151; pjp</I><P>
Dear Mr. Plauger,<P>
I would like to add my two cents' worth to Mr. Mike Musielski's comments (<I>CUJ</I>, October 1993) on the nature of C as a language. ("Is C a language?" was his opening question.) The short answer to that question is, no, C is not a language. Neither is any programming language. The programming-as-writing analogy is interesting, but like most analogies it is partly true and partly dangerous.<P>
A programming language is really a notation system: defined narrowly, conceived as a formal means of expression, and limited in its range of expressiveness, at least when compared with natural languages. No programming language is used as an end in itself (except of course by participants in Obfuscated C contests), whereas a natural language is used that way all the time by artists whose only goal it is to explore the language's poetic possibilities. This is the main reason why programs, no matter how short, cannot be compared to short stories or other forms of fiction.<P>
Nevertheless, there is a basis for the analogy. Like natural languages, programming languages do evolve and adapt themselves to new situations and conditions. And as they do, new vocabulary creeps in, functions begin to overlap, and things begin to get <I></I>&#151; well, messy. Even standards cannot clear up all ambiguities: there will always be more than one way to skin a cat. You can say "pass away" or "kick the bucket," just as you can use <I>strtol</I> or <I>atol</I>. Both elements in each pair approximate, but do not exactly map, the same idea. How are you to recognize when it is appropriate to use one and not the other? This is what Mr. Musielski wants to know.<P>
There are some useful texts out there. I suggest Mr. Musielski look at (again, if not for the first time) <I>The C Programming Language</I>, by Kernighan and Ritchie. Another book I have found useful on occasion is <I>C Lab Notes</I>, by Flanders and Holmes. This book has a nice feature in that each chapter has at its head a list of the tasks that are to be explored inside ("forward and reverse scrolling," "sending a message to another node," etc.). And, not least, <I>The C Users Journal</I> is itself very instructive in matters of language use. None of these texts is consciously "literary," but all take the implicit stance that a programming language is an idiom to be mastered. Mastering the language (your "material") is the goal of literary writing as well.<P>
I think what might be very beneficial to Mr. Musielski (and others, myself included) would be a kind of reverse dictionary: a list of common tasks along with the range of functions, procedures, tools, etc. that could be used to fulfill each task's requirement. Such a book could not possibly be exhaustive and the organizational problems would be daunting, but a good text like this might be useful enough to be a starting point. Of course, as writers learn from writing, programmers learn best from programming. There is still no effective substitute for trial and error&#151;many trials, many errors.<P>
Sincerely,<P>
Michael Nichols<br>
1725 York Avenue<br>
New York, New York 10128<P>
<I>Thanks for your insightful comments. &#151; pjp</I><P>
Editor:<P>
I found Robert Watson's "DMA Controller Programming, in C" (<I>CUJ</I>, November 1993) interesting, particularly of course the protected-mode details, but found his conclusion, "the technique is actually very easy to use" laughable, considering what he had just painstakingly documented. "Virtually impossible" is more like it. I agree with his further conclusion: that DMA is increasingly obsolete, since fast CPUs deal with dedicated card memory blocks more expeditiously (and of course the implication that such memory is relatively cheap in modern times <I></I>&#151; DMA was originally a cost as well as speed feature).<P>
I also think along the way he erroneously minimized the difficulties involved in getting hold of a DMA buffer in real mode ("in real mode, generating a DMA buffer is relatively easy"). I hope I'm missing something, but in my source where I tried to accomplish this there are three or four failed attempts commented-out, and I'm not at all happy with my current effort, shown in <A href="list2.htm">Listing 2</a>.
<P>
If anybody knows how to do this rationally, stop me before I code again! The crude strategy here is to keep getting buffers, and if they're no good &#151; won't do DMA because they cross a physical boundary &#151; retain the offending part of the buffer and keep trying; and then when we get a good one, free all the chunks accumulated along the way. This approach relies on totally unreliable assumptions about memory allocation, and really comes down to a "keep trying until you give up" approach.<P>
Operating systems in 80x86 land get to own low memory, where it is relatively easy to set-up a good DMA buffer. Programs, on the other hand, can be loaded at any address, and can't make any such arrangements except, as far as I can figure out, by using awflike the example.<P>
And incidentally, who owns the VDS (Virtual DMA Services) interface mentioned in the article? I have a vague idea how one goes about getting in touch with DPMI; is VDS one of these things that comes with DOS extenders and/or Windows or what?<P>
j.g. owen<br>
Software engineer<br>
31 Darby Drive<br>
South Huntington, NY 11746<br>
cis 71121,625<P>
To the Editor:<P>
Concerning the letter from Lawrence H. Hardy in the 11.12 issue of <I>CUJ</I>, page 136, asking for information about PCX graphics:<P>
And I thought <I>my</I> memory was going... Actually, this might instead be seen as an illustration of the need for a <I>CUJ</I> index &#151; depending on one's perspective of course. At any rate, whilst fumbling through a stack of old <I>Journals</I> seeking edification on a particular coding problem, I came across Vol. 9, No. 8 (August, 1991). Emblazoned across the cover was "PCX GRAPHICS DOCUMENTED!" And sure enough, there on page 89 was a decent discussion of the topic by one Ian Ashdown, complete with bibliography.<P>
I would also like to join Ian Somerton (p. 127) in expressing concern, if not alarm, at the exponential increase in C++ coverage of late. Perhaps someone on your staff misread it as C**?<P>
Sincerely,<P>
Scott Swanson<br>
Box 75<br>
Pendroy MT 59467<P>
<I>I am notorious within R&amp;D for my instant amnesia, once an issue goes out the door. You're right that an index to</I> CUJ <I>is indispensable, and the folks back in Kansas have anticipated your wish. As for C++ coverage, that happens to be an area of intense interest in our community at the moment. We haven't forgotten about C by any means, but the mix what we publish is strongly influenced by the mix of what's proposed to us in the way of articles. &#151; pjp</I><P>

<h4><a href="../../../source/1994/mar94/letters.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
