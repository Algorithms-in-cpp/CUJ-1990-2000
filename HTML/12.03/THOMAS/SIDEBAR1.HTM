<HTML><HEAD><TITLE>March 1994/Enhancing the UNIX Korn Shell Using Predictor Techniques/Sidebar</TITLE></HEAD><BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">Anatomy of a Command Shell</FONT></h3><hr>
<BLOCKQUOTE>
In most systems, user programs and system programs are executed by the command-language interpreter. In more sophisticated systems such as UNIX, there are no major distinctions between this interpreter and any other program &#151; so users can easily create their own shells.<P>
The shell actually executes a command by completing a <I>fork</I>, after which the child process executes an <I>execve</I> (load and execute) of the command. The parent process (the shell) does a <I>wait</I> and suspends its own execution until the child process finishes executing and performs an <I>exit</I>. In multi-tasking systems, such as UNIX, both the shell and the command it is processing can execute concurrently. Users can initiate concurrent execution by typing a command followed by an ampersand. The shell interprets this symbol as an indication not to perform the <I>wait</I>; instead the shell continues with the next step in its command input by prompting the user for the next command.<P>
This capability implies the existence of a fairly sophisticated interprocess communication system. As a bare minimum, a child process needs a method to signal its termination to the parent process (the shell), which is not necessarily polling for this signal.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
