

<HTML>
<HEAD>

<TITLE>March 1994/ROMLDR, an Embedded System Program Locator</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Real-Time/Embedded Systems</FONT></H2>

<hr><h2 align="center"><font color="#800000">ROMLDR, an Embedded System Program Locator<A name="0088_0037"><A name="0088_0037"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0088_0000"><A name="0088_0000">Charles B. Allison</font></h3><hr><blockquote><P>
<P><i><A name="0088_0000"><A name="0088_0000">Charles Allison has been working with microprocessor hardware and firmware in embedded systems since 1976. He has a Bachelor of<I></I> <I></I>Science degree in physics and a Master of Business Administration degree. Charles has a microprocessor consulting business, Allison<I></I> <I></I>Technical Services, where he has been developing embedded control and monitoring products for clients since 1984. Charles can be<I></I> <I></I>reached through CompuServe 71005,1502, his BBS/FAX line at (713)-777-4746 or his company, ATS, 8343 Carvel, Houston, TX 77036.</i></P><P>
MS-DOS software development tools such as C compilers and debuggers have become marvelously sophisticated and useful. They can also provide a cost-effective means for developing embedded systems. The purpose of this article is to introduce one of the aspects of using a high performance DOS-based C compiler for embedded systems, that of relocating code and data segments. I provide a program, <I>ROMLDR</I>, which can modify a program from the MS-DOS EXE format to a located binary file format.<P>
<I>ROMLDR</I>'s principle purpose is to adapt DOS-based C compiler output for use in EPROM-based embedded systems. Other uses include BIOS extensions, EPROM-based MS-DOS applications, and relocation of MS-DOS programs in PC memory, such as above the 640k MS-DOS memory limit. <I>ROMLDR</I> can also be used with EXE files generated by languages other than C.<P>
<I>ROMLDR</I> was written using Borland C 3.1. It should be possible to use either Borland Turbo C or Microsoft C to make the <I>ROMLDR</I> program and to use for embedded programs. I have tested <I>ROMLDR</I> only with the Borland C 3.1 compiler.<P>
<h4><FONT COLOR="#000080"><A name="0088_0038">Embedding DOS-Compiled Programs<A name="0088_0038"></FONT></h4></P>
To use DOS-compiled programs in EPROM-based embedded systems, you must provide several additional components, as well as resolve some unique programming issues. A number of the required components, such as the startup code, depend on the compiler, target hardware, and application. (See the sidebar <a href="sidebar1.htm">"Coding for Embedded Applications"</a> for a brief discussion on embedded code requirements.)<P>
Once you have attended to all these details, you can program, compile, and link the various program files into an MS-DOS EXE file. However, you can't just burn your EXE file into EPROM and go. You must explicitly perform a step that MS-DOS performs implicitly when it loads an EXE file.<P>
MS-DOS modifies programs with the EXE extent when it loads them into memory. This modification, often referred to as a fix up (also known as the <I>locate</I> function), consists of modifying the program's segment values for the actual memory address where it is to run. By performing fix ups, DOS can load an executable almost anywhere in real-mode memory. (DOS can load small programs with the COM extent anywhere and run them without modification.)<P>
DOS performs fix ups by adding the file's load-address segment value to all segment addresses stored in the code and data areas of the program.<P>
Unlike DOS programs, most embedded systems programs reside in and execute from EPROM. Embedded system locators must perform fix ups prior to placing the program in EPROM and must take into account that variables will be located in RAM, through their initialized values for startup are still in EPROM.<P>
<h4><FONT COLOR="#000080"><A name="0088_0039">Locating for Embedded Systems<A name="0088_0039"></FONT></h4></P>
Before I present my program in detail, I want to outline the major parts of the location process. I will first describe the structure of a DOS EXE file, and how that structure is reflected in my code. Next, I will describe the location process.<P>
<h4><FONT COLOR="#000080"><A name="0088_003A">EXE File Format<A name="0088_003A"></FONT></h4></P>
The EXE file consists of several sections, including a header, program code, data initialization values, and optional program debug information. Refer to structure <I>EXE_HDR</I> at the beginning of <A href="list1.htm">Listing 1</a>
for the layout and definitions of the various parameters. The header section consists of several parameters which define the size of the file and the size of the header. Following these parameters is a section of fix-up <I>far</I> pointers.<P>
Each of these pointers targets a location in the program code containing a segment address value that must be modified with the correct load address. These pointers are stored in standard 80x86 <I>segment:offset</I> format relative to the beginning of the code section. The pointers' segment values are derived from teh MAP file segment table by using the top four hexadecimal digits from the beginning address listed for each segment. (MAP files are generated by the compiler. MAP file segments consist of the top four hexadecimal digits of the beginning address.)<P>
There are <I>num_reloc</I> fix-up pointers in the header section. These pointers begin at the offset <I>off_reloc</I> from the beginning of the header. (Note that fix-up pointers may not be sorted by address as they occur in the EXE file.) Following the header is the program's code section. This section consists of one or more separate segments, the number and type of which depend on the program and its memory model. Following the code is the initialized data section. Then comes the uninitialized data section, and finally the stack.<P>
<h4><FONT COLOR="#000080"><A name="0088_003B">The Location Process<A name="0088_003B"></FONT></h4></P>
Once it has loaded a program into memory, the MS-DOS loader adds the code section's segment address to the segment value stored in each location requiring a fix up. The loader finds these locations by dereferencing each fix-up pointer in the header. MS-DOS sets the CPU's stack registers to <I>disp_stack_seg:sp</I> and calls the program at address <I>rel_cs_seg:ip</I>. (Note: For the sake of illustration, I use <I>disp_stack_seg, sp, rel_cs_seg</I>, and <I>ip</I> to represent values stored at specific offsets within the EXE header. By referring to fields of the same name in my <I>struct, EXE_HDR</I>, you can see where these values are stored in the header.) MS-DOS also provides some environment and header information to the loaded program through register contents.<P>
Most, but not quite all of the information necessary to generate rommable absolute binary files already exists in the EXE file. The rest of the information must come from the segment data in the compiler's MAP file and from configuration information provided by the user in a loader configuration file.<P>
<h4><FONT COLOR="#000080"><A name="0088_003C">Program Description<A name="0088_003C"></FONT></h4></P>
<I>ROMLDR</I> uses the linked EXE file and its MAP file to create a binary file that can be programmed into EPROMs.<P>
<I>Main</I> begins by allocating a <I>far</I> buffer to contain program segments. This buffer should be 0xl0000 bytes in length to ensure that any size code segment can be processed. (While testing from within the Borland IDE, I had to reduce the buffer's size significantly due to memory constraints.) A simple error routine, <I>term_error</I>, generates error messages for a variety of potential problems, and provides for program termination.<P>
After allocating a buffer, <I>ROMLDR</I> reads the configuration file (CFG) specified on the command line. This file contains the names for the EXE, MAP, and BIN output files, EPROM and RAM hexadecimal load addresses, and the class name of the first RAM segment. <A href="tab1.htm">Table 1</a>
shows the CFG file format. CFG file parameters must be located on separate lines and separated by spaces. On each line, <I>ROMLDR</I> ignores any characters occurring after the list of required parameters.<P>
<h4><FONT COLOR="#000080"><A name="0088_003D">Reading the MAP File<A name="0088_003D"></FONT></h4></P>
<I>ROMLDR</I> executes a <I>while</I> loop to read and process lines of text from the MAP file. (The MAP file used with <I>ROMLDR</I> should be the short version, which contains only the segment table.) <I>ROMLDR</I> extracts memory allocation class names, plus their starting and ending addresses, and stores them in an array of structures called <I>maptable. ROMLDR</I> performs a simple length check using configuration variable <I>class_loc</I> to determine if the current line contains segment information. <I>ROMLDR</I> expects the line to be in a fixed column format, with the class name occurring at offset <I>class_loc. ROMLDR</I> converts address values to long integers, and compares class names with <I>ram_class</I>, a configuration variable used to define the beginning of RAM. The beginning segment address is stored in <I>ramdata. ROMLDR</I> currently will process a maximum of 120 segments.<P>
<h4><FONT COLOR="#000080"><A name="0088_003E">Processing the Header<A name="0088_003E"></FONT></h4></P>
Once <I>ROMLDR</I> has acquired the MAP file, it reads the EXE header portion via function <I>gethdr</I>. This function first reads in 32 bytes of the header to determine the header's size and then loads the rest of the header. This function stores header information in an array named <I>header</I> which can contain a maximum of 10,000 bytes.<P>
<I>ROMLDR</I> then sorts the fix-up pointers into ascending address order. Function <I>sort_table</I> uses <I>qsort</I> to sort the pointers. Function <I>cmp_ptr</I>, supplied as an argument to <I>qsort</I>, compares values for <I>qsort</I> by converting pointers from <I>segment:offset</I> to long integer form.<P>
After sorting the pointers, <I>ROMLDR</I> performs fix ups on each segment, using a <I>for</I> loop to iterate through all segments. Function <I>read_segm</I> reads each segment from the EXE file and returns the segment size. If the segment length is non-zero, <I>ROMLDR</I> calls function <I>fix_segm</I> to run through any fix ups needed for the segment and then calls <I>write_segm</I> to output the processed segment to the BIN file. (A logical enhancement to <I>ROMLDR</I> would be to output the segments in a standard hex format, such as Intel hex format.)<P>
<h4><FONT COLOR="#000080"><A name="0088_003F">HOW <B><I>ROMLDR</I></B> Handles EPROM and RAM<A name="0088_003F"></FONT></h4></P>
EPROM segments require different modifications than RAM segments. <I>ROMLDR</I> treats all segments at or below the class named <I>ENDCODE</I> as EPROM and treats those above <I>ENDCODE</I> as RAM. The location process currently terminates on reaching the last segment, the STACK class. (The BIN file, however, needs only to contain code and data segments up to the last initialized data value.)<P>
The <I>ENDCODE</I> class name is special for another reason. ROM based systems typically must transfer initialized data from EPROM to RAM. Therefore, <I>ROMLDR</I> will modify all references to data segments to refer to the RAM locations and not to the initial values located in the EPROM. (The location for the initial values must be used in the startup code so that they can be transferred to RAM.) Segment <I>ENDCODE</I> is used for this purpose. I make the <I>ENDCODE</I> segment's length less than 16 bytes, locate it on a paragraph boundary, and ensure that the beginning data segment is also aligned by paragraph. As a result, the beginning ROM location for initialized data becomes <I>ENDCODE</I>+1. Since <I>ENDCODE'</I>s address is less than the beginning of the RAM segment, it will refer to the ROM address just below the initialized data values.<P>
<I>ROMLDR</I> modifies EPROM data by adding the configuration file's EPROM segment address, stored in <I>romsadr</I>, to the code's existing segment value. (A more sophisticated version of the program could offer the option of several user-defined addresses and the names of the classes that would reside in each.)<P>
<I>ROMLDR</I> modifies RAM segments by first subtracting out the value of the first RAM segment and then adding the configuration file's RAM segment location value. This method allows the RAM locations to begin at the configuration-defined starting value. The subtraction was not necessary for code segments since they began with a zero segment value.<P>
<h4><FONT COLOR="#000080"><A name="0088_0040">Example Code<A name="0088_0040"></FONT></h4></P>
<A href="list2.htm">Listing 2</a>
is <I>DEMO.C</I>, a typical "Hello World" program with some added items to provide examples of values for several segment classes. <A href="list3.htm">Listing 3</a>,
 <I>DEMO.MAP</I>, is the map file generated for <I>DEMO.C</I> using the example startup code in <A href="list4.htm">Listing 4</a>
instead of the standard Borland startup code. Note that the <I>_INIT_</I> segment contains some values which are addresses of library initialization routines that should be called in order of priority. The example startup code does not yet include this section or the interrupt vector initialization section. Examples of these can be found in your compiler's startup code. The sidebar <a href="sidebar2.htm">"Startup Code for Embedded Systems"</a> provides a discussion of startup code requirements.<P>
<h4><FONT COLOR="#000080"><A name="0088_0041"><I>ROMLDR</I><B> Versus Commercial Products<A name="0088_0041"></B></FONT></h4></P>
<I>ROMLDR</I> has several shortcomings when compared to commercial locator packages. When you use <I>ROMLDR</I> you must provide startup code for your application; commercial products usually provide the basic startup code required as well as code solutions for a variety of problems which must be overcome in various embedded configurations. <I>ROMLDR</I> does not provide debugging support, but commercial products usually provide some capabilities for the debugging of application programs. Finally, vendors of commercial locator packages often provide technical support; when you use a non-commercial package such as <I>ROMLDR</I> you must solve all problems on your own.<P>
<h4><FONT COLOR="#000080"><A name="0088_0042">Conclusions<A name="0088_0042"></FONT></h4></P>
While <I>ROMLDR</I> is intended primarily as a learning tool and an introduction to embedded systems, it can prove useful for some low-end applications. <I>ROMLDR</I> should be able to handle straightforward applications where there is one EPROM and one RAM memory space. It can easily be modified for more complex configurations, especially those which have specific fixed requirements.<P>
Embedded systems often monitor and control equipment other than normal computer peripherals. Embedded systems programmers must be extra cautious, since bugs in their programs can place property and lives at risk. In this situation, there is no substitute for understanding both the application and the tools. Understanding how <I>ROMLDR</I> works may give you insight into how more complex systems operate.<P>

<h4><a href="../../../source/1994/mar94/allison2.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
