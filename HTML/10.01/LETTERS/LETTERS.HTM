


<HTML>
<HEAD>

<TITLE>January 1992/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="0054_001A"><A name="0054_001A"></font></h2><hr>
<BLOCKQUOTE>
<A name="0054_0000"><A name="0054_0000">Dear Mr. Plauger,<P>
I am looking for a software publisher to market a program I have developed. I noticed that another person requested similar information (<I>CUJ</I>, September 1991, "We Have Mail", p. 132), but you did not provide a method individual developers could use to locate marketing agents.<P>
I have developed a program which is appears to be unique in the DOS/80x86 world. EP ("Evoked Potential") is a program which integrates data acquisition and process control. It was originally developed for the neuroscience community but appears to have wide applicability. Before I explain some of its features, let me briefly described what Evoked Potentials are.<P>
Evoked Potentials are EEG signals produced in response to a stimulus. A patient is fitted with a cap containing a number of electrodes to detect low levels of voltage (potentials) on specific parts of the scalp. Channels of analog electrical signals are monitored for activity while the patient is subjected to a stimulus. Typical stimuli include visual, somatosensory (ie: vibrations) and auditory (sounds). For example, a checker board may flip black and white squares on a screen, or a waveform generator produce waveforms at a certain frequency to make sounds. One of the most important aspects of collecting Evoked Potentials is that the data collected, usually consisting of recordings or averaged histograms, is synchronized with the stimulus. This synchronization needs to be accurate within a fraction of a millisecond.<P>
For instance, we may want to collect 100 trials consisting of one second samples of 16 channels of analog data at a rate of 1000 samples per second on each channel. A real-time display of the averaged histograms must be presented during the acquisition. The averaging process may at times reject certain trials due to artifacts in the data or other unusual circumstances.<P>
A researcher begins by first defining an experiment and a protocol. An experiment describes the placement of electrodes, the sample rate, and number of channels. A protocol describes the behavior of laboratory equipment such as waveform generators, other computers, and handcrafted stimulus producing equipment. EP uses a simple protocol language which allows the researcher to describe the sequence of events and contingent responses the computer should perform when various conditions occur (ie., a switch is pressed). A protocol can be defined, edited, compiled, and loaded during acquisition. This allows a person to start with a simple protocol then enhance and test it incrementally.<P>
The original purpose of EP was to acquire analog data and synchronously control arbitrary laboratory equipment. EP can be configured to acquire up to 256 channels of analog data at an aggregate rate of 200,000 samples per second. Nonproprietary data acquisition cards and other special equipment may be added to the system and accessed in the protocol. Single unit (neuron) spike recording capabilities will be available soon. We are also developing a clinical, turnkey version for use by technicians here at the Washington University Medical School in St. Louis.<P>
Each of these functions are generally available in one form or another in the market place. What is unique is the combination of capabilities in EP. Specifically, the ability to monitor and acquire many channels of data at high speeds while synchronously controlling external equipment from a MS DOS 80x86 computer is novel. Further, the speed of creating or changing a protocol allows rapid development of complex experiments, an important capability in research.<P>
Surprisingly, people outside of this small community have also expressed interest in EP. Due to EP's general design, it turns out to be possible to use it to control arbitrary equipment and EP may have application in factories and other environments needing to monitor and control complex machines (ie: robots). Several university laboratories on the east coast are considering incorporating it into their work. A group studying Positron Emission Tomography (PET) here at Washington University are considering its use in counting gamma ray emissions from bank pairs of a PET machine.<P>
I am a computer scientist, not a marketing person. I admit my ignorance in that area but I have a feeling that what I have may be useful in a broader range of applications. How do I go about finding people interested in marketing this program? It seems to be a relevant question to any programmer who feels they have produced a useful program. Is it consistent with the philosophy of the C Users Journal to raise such questions in these pages?<P>
Sincerely,<P>
Sheldon Hoffman<br>
917 Alanson Dr.<br>
St. Louis, MO. 63132<P>
<I>It's hard to give general advice about how to market computer software. More and more companies are learning the advantages, and logistics, of distributing software developed by others. These companies range in size from Microsoft down to very specialized niche marketers working a limited geographical area.</I><P>
<I>In your case, I'd say you have to do a lot of educating of potential customers </I>&#151;<I> at least outside the very limited application area you now inhabit. Your best bet may be to gain experience with your current crop of potential customers. My experience is that word of mouth does at least half the job of technical selling. So long as you don't sign away all rights to your product early on, you have a good chance of eventually connecting up with a marketeer you can trust.</I><P>
<I>Meanwhile, all I can do is give you some exposure here and wish you good luck. </I>&#151;<I> pjp</I><P>
Dear C Users Journal,<P>
I am writing in response to Belinda Aboshanab's letter, published in <I>The C Users Journal</I>, September 1991. In her letter she complains about Microsoft OuickC's requirement of additional royalty payments due to Bitstream for any commercial distribution of their fonts. She asked if Borland had the same policy.<P>
I am an avid fan of Borland's products. I currently own Borland's Turbo C++ 2.0 and Professional and Turbo Pascal for Windows. I am desperately trying to learn the Windows 3.0 API well enough to write some commercial grade software which I intend to distribute via shareware. I am extremely pleased with Borland's products and their technical support. I am approximately halfway through Charles Petzold's <I>Programming Windows Second Edition</I>. I have yet to encounter a programming example in the book that would not compile and run properly using Borland's C++ compiler.<P>
As for Ms. Aboshanab's question about royalty payments, I quote from Borland's No-nonsense License Statement: "Programs that you write and compile using Borland's language compilers, and that contain any portion of Borland code, may be used, given away or sold without additional license or fees, as long as all copies of these programs bear a valid copyright notice. By "copyright notice," we mean either your own copyright notice or the copyright notice which appears on the original diskette label on your Borland language compiler product. Borland's language compilers may include various support files that contain encoded hardware and font information used by the runtime library. You may use these proprietary Borland files with the programs you create with Borland language compilers for your own personal use. In addition, if the programs you write and compile using a Borland language compiler make use of these support files, you may distribute these support files in combination with these programs, provided that you do not use, give away, or sell the support files separately, and all copies of your programs bear a valid copyright notice."<P>
In my opinion Borland is the leader in reasonable license agreements. They even grant you permission to use their product on more than one machine, provided there can never be more than one copy in use at the same time. Borland also frequently offers special deals to computer magazine subscribers. Their Turbo C++ 2.0 Professional Compiler package includes a full ANSI-compatible C compiler, a C++ compiler which conforms to AT&amp;T's 2.0 specification, the Turbo Assembler, two Turbo Debuggers (one for DOS and one for Windows), and the Whitewater Resource Toolkit for creating Windows icons, bitmaps, etc. All this for a list price of $495. I have seen it offered for as low as $149. Since Ms. Aboshanab is a registered owner of Microsoft's QuickC, she may qualify for a discount on the purchase of Turbo C++ 2.0. It would certainly be worth her time to call Borland and ask about it.<P>
Now that I have thoroughly plugged Borland and Microsoft Windows, how about some articles on Windows programming techniques? Thank you for an excellent magazine.<P>
Leon G. Rollison<br>
116 Towne Creek Trail<br>
Anderson, SC 29621<P>
<I>Thanks for the clarification. We are always on the lookout for good articles on Windows programming. </I>&#151;<I> pip</I><P>
<I>You can also try the Windows/DOS Developer's Journal. For information, call Customer Service.</I>&#151;<I> rlw</I><P>
Hello (via e-mail),<P>
As a reader of <I>The C Users Journal</I> I have been looking forward to each new article in your series on the ANSI C standard (now covering the headers). I recall you commenting that you didn't see much use for the new syntax of the <I>sizeof</I> operator which allows you to determine the size of an expression. I wonder if you have any other solution to the following problem relating to that feature?<P>
Given:<P>
<pre>typedef struct dbe {
        struct  dbe *next;
        char    name [8] ;
        int     sequence ;
        char *  comment ;
      } DBEntry_t ;</pre>
and I want to code a comparison between a given string and the name field of a specific structure. Right now it looks something like this:<P>
<pre>DBEntry_t *   current ;
char *        some_string ;

strncmp( some_string, current-&gt;name, sizeof( current-&gt;name ) )</pre>
I can't think of any other way to get the size of the name field in the <I>DBEntry_t</I> structure. I'm not terribly pleased with this code because I have to declare a structure or structure pointer to be able to specify the field. This limits my ability to create a macro to provide this value. I'm also worried that the expression <I>current-&gt;name</I> would have type <I>char</I> * on some C compilers. But it seems like ANSI covered that.<P>
Do you know of any other way to specify a field of a structure to the <I>sizeof</I> operator without using the expression syntax? (Something like <I>DBEntry_t.name</I>?)<P>
Thank you for your attention,<P>
Sincerely,<P>
Philip D. Pokorny<br>
<I>philip@cel.cummins.com</I><P>
<I>Your code is fine </I>&#151;<I> I do that sort of thing all the time. It's a minor nuisance that you have to name an explicit pointer to a structure when you want to inquire about the size of one of its members, but C has worse limitations than that.</I><P>
<I>What I have branded as useless in the past is taking the </I>sizeof<I> an expression that yields only an rvalue. The expression you wrote is an array lvalue. That's just the sort of thing that </I>sizeof<I> should work on. Don't be distracted by the fact that an array lvalue almost invariably changes to a char * rvalue. For the </I>sizeof<I> operator and the </I>address-of<I> operator, the arrayness sticks around. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
In the September 1991 issue of <I>CUJ</I>, you give your e-mail address as <I>pjp@wsa.oz.</I> As I understand things, that's not quite correct &#151; your address should be given as <I>pjp@wsa.oz.au.</I> The form you gave was appropriate for the old ACSnet mail system, which was internal to Australia (although a lot of gateway sites knew how to reach it). The form with <I>.au</I> is a valid Internet address, with the <I>.AU</I> indicating that you are in Australia.<P>
In any case, I hope you are enjoying your stay in Australia. I'm an American myself, so I can appreciate the rather subtle sort of "culture shock" you've probably been experiencing.<P>
Sincerely,<P>
Eric Zurcher<br>
CSIRO Division of Entomology<br>
Canberra ACT 2601<br>
E-mail: <I>ericz@ento.csiro.au</I><P>
<I>I welcome corrections to my rendition of e-mail addresses. I am too senile ever to understand the intricacies of intertwined networks that snake around the world. I'm only grateful that they work sometimes. </I>&#151;<I> pjp</I><P>
Dear Sir:<P>
Three short answer questions for you.<P>
1) How can you pass data to a spawned process, and back again, either in C or 8086 assembler? I need to pass up to about 30 data items.<P>
2) Is there a magazine, with focus and coverage similar to <I>CUJ</I>, for 8086 assembler?<P>
3) How would you define the term "side effect"? I've seen the term frequently used, have some vague understanding of what it means (I think), but have never seen a formal definition.<P>
I like you magazine very much. I find it always interesting, if not immediately useful.<P>
Sincerely,<P>
John Beach<br>
1025 Medburst Rd.<br>
Columbus, OH 43220<P>
<I>I assume you're talking about MS-DOS. You could probably set aside an area in the parent process large enough to hold the data to be passed. Getting the pointer to the spawned process is not easy, however. To pass it as part of the command line, you really need to encode the pointer as hexadecimal text, or some such. If the overhead is tolerable, you're best off opening a temp file in the parent and having the child write data to it.</I><P>
<I>Other magazines besides CUJ show more assembly language than we do. Check out our sister publication, Windows/DOS Developer's Journal.</I><P>
<I>I define side effect as a change in the state of a file or the value stored in a data object. I think that's about as good a definition as any.</I><P>
<I>Glad you like the magazine. </I>&#151;<I> pjp</I><P>
</BLOCKQUOTE>
</BODY>
</HTML>
