


<HTML>
<HEAD>

<TITLE>January 1992/Illustrated C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Illustrated C<A name="004C_0015"><A name="004C_0015"></font></h2><P>
<h3 align="center"><A name="004C_0000"><A name="004C_0000">A Portable Menu Compiler</h3><P>
<h3 align="center"><font color="#800000">Leor Zolman</font></h3><hr><blockquote><P>
<P><i><A name="004C_0000"><A name="004C_0000">A long time ago, Leor Zolman wrote and distributed the BDS C Compiler for CP/M (what's that?). Following a several-year hiatus<I></I> <I></I>from computer-compulsiveness to learn some people skills, he got married, dragged his disbelieving wife to Kansas and joined the staff of<I></I> <I></I>R&amp;D Publications, Inc. Two years later his wife has almost forgiven him. You can reach him at <I>leor@rdpub.com</I> or<I></I> <I>uunet!bdsoft!rdpub!leor</I>.</i></P><P>
Here at R&amp;D Publications, we do most of our internal data processing on a single SCO XENIX/386 system running the latest available releases of the Informix database system for XENIX. At any time, there may be up to 30 users sharing the system. Many of those users run under the FACET/TERM software package to launch multiple login sessions on their individual serial terminals. Thus it is not unusual to see up to 50 logical users, and perhaps up to 150 system processes, active at any single point during the business day. Despite the load, the system response time experienced by our users is pretty darn good.<P>
And now for the punch line: our CPU is just an inexpensive 386/25 Taiwanese clone. Even with 12Mb of RAM, system units such as this one sell for about half the price of the 10Mb hard disk drive I purchased in 1980. My intention isn't to tout the cost-effectiveness of imported hardware; I just think it is remarkable how well a contemporary entry-level CPU can be made to perform. A system load such as ours could have brought even a minicomputer system to its knees not so long ago.<P>
One way we've managed to streamline our system is to eliminate as many CPU-intensive tasks as possible from the daily during-business-hours load. We did this partially through the design of a general-purpose sequential overnight job spooler. From among the set of tasks that used to be routinely run during the day, we looked for the worst bottlenecks. We then modified the shell scripts that control these programs to allow users to schedule the programs for overnight execution.<P>
The CMENU menu system I shall be describing in this series of columns was originally created as part of our effort to reduce the overall daily system load. In the end, CMENU also brought some welcome spinoffs: it significantly reduced the Technical Department's maintenance requirements, and enhanced the usability, speed, and efficiency of the menu system for our users.<P>
<h4><FONT COLOR="#000080"><A name="004C_0016">The 50-Percent Solution<A name="004C_0016"></FONT></h4></P>
R&amp;D's entire internal business management system revolves around menus. All the menus stem from two root menus we invoke from the system prompt. The first of these two menus contains all invoice processing and customer-related tasks. The second main menu handles our advertising subsystems and personal utilities (E-mail, calendar maintenance, business letter generation, etc.). Counting all the submenus and sub-sub-menus, there are roughly 300 distinct menu options in the system. Many of these are shell scripts that manage standardized parameter entry and invoke Informix report generators.<P>
Before CMENU, this entire menu system ran under Informix's own menu-processing scheme. Menu headers and their associated lists of menu items existed as database tables in a master/detail relationship. The mechanism supplied by Informix for creating and maintaining the menu system relied on a screen form built to work with Informix's general-purpose table query tool, Perform. This screen, unfortunately, allows only one menu selection to appear on the screen at a time, which made on-line searches for a particular item in the menu hierarchy a repetitive, time-consuming operation.<P>
Informix integrated their menu-maintenance programs into their new-generation SQL runtime module, but imposed the limitation that each database can contain only a single associated menu system. Since there were two distinct menu hierarchies which we used with our one major database, we had to create a dummy database just to support the existence of a second independent menu hierarchy. Each time a user invoked a menu, the menu program launched two system processes. The first was an SQL interpreter to run the user-interface portion of the menu, and the second was a back-end SQL engine that interfaced with the actual database. Then, in the cases where we had logically isolated some additional menu subsystems from the main menus (as when developing new subsystems or when we had not yet ported an existing application from our old Informix 3.3 system and the menus were still in the old format), any invocation of an external (non-integrated) submenu from the main menu system meant that<P>
<UL><li>all the processes from the main menu were still active,</li>
<li>a new set of processes was launched to handle the new menu, and</li>
<li>yet more processes came along when the user made a selection from the new menu!</li></UL>
Clearly, this was not an effective use of system resources.<P>
In contrast to the clumsy internal implementation and maintenance difficulties of Informix's menu system, the end-user interface portion of the Informix system is remarkably clean, intuitive, and generally user friendly. I chose largely to retain the look and feel of their user interface in designing CMENU as a replacement for their menu system. This choice allowed changeover at R&amp;D to take place with a minimum of retraining. After installation of the new CMENU system, a short e-mail message to all users outlining CMENU's few extensions to the Informix menu system's user interface sufficed for the entire retraining.<P>
<h4><FONT COLOR="#000080"><A name="004C_0017">The Best Of Both Worlds<A name="004C_0017"></FONT></h4></P>
To the end-user, CMENU-based menus appear roughly the same as their Informix-based predecessors. Internally, however, CMENU works quite differently. Rather than being built on top of a complex database package, CMENU is a standalone system using a pre-compilation scheme to make execution (interpretation) of menus as efficient as possible.<P>
The menu compiler module, named <I>cmenu</I>, compiles an ASCII-format menu specification file containing any number of "menu screen" specifications into an intermediate binary object format. The menu runner module, <I>rmenu</I>, loads the intermediate file(s) into RAM and executes the menu system as specified.<P>
The advantage of pre-compiled menu specifications is that most of the hard work of parsing the source code and compiling it into a form suitable for efficient runtime interpretation only happens once, at compilation time. When <I>rmenu</I> is invoked, it only has to display the text on the screen, interpret the user's keystrokes, process menu navigation commands, and submit the action commands associated with selected menu commands to the operating system for execution.<P>
To reduce the number of processes needing to be launched by the runtime menu system, <I>rmenu</I> employs a recursive data structure. Separate screens of a menu system may be compiled either together in one source file or separately in distinct physical source files. At runtime there is no need to spawn additional processes just to traverse up and down through the menu structure, even when that structure contains separately compiled menu files. A single process coordinates all the dynamic loading and menu navigation operations.<P>
Through a rich, powerful repertoire of options in the CMENU specification language, a high level of control over menu behavior is possible in response to the varying requirements of application programs and shell scripts. Some applications, for example, may require a prompt after their completion to allow users to read vital information left on the screen immediately before the application terminated. Other applications never leave any useful information on the screen and so do not require a prompt. Still other applications may sometimes require a prompt and sometimes not, based upon their exit status code. Any of these cases can be handled easily by CMENU (at least the UNIX version) through appropriate use of the specification language.<P>
<h4><FONT COLOR="#000080"><A name="004C_0018">Two Programs, Two Personalities<A name="004C_0018"></FONT></h4></P>
The <I>cmenu</I> and <I>rmenu</I> programs share a common intermediate menu object format and not much else. Each evolved in its own style of programming, necessarily distinct from the other due to the disparate natures of the two connected tasks.<P>
The menu compiler, <I>cmenu</I>, operates as an iterative state machine. It processes the source file text sequentially, and maintains all state information in global data shared by all the token-processing functions of the program.<P>
To understand why such a scheme is appropriate for the <I>cmenu</I> program, note that the CMENU specification language, like C itself, is not block-structured. In C, you define all functions at one top level and can't define functions within functions (although you can reference functions from within other functions). Other constructs in C, such as expressions, do have a recursive nature, but there are no such recursive expression structures in a CMENU specification. Thus, a sequential approach works well for parsing CMENU source code and also makes the program less complicated.<P>
On the other hand, the sort of simplicity inherent to <I>cmenu</I> wouldn't work for <I>rmenu</I> without severely limiting its power. At run time, menus must be callable from other menus, and, ideally, there should be no structural limitation on the depth to which menus nest. In practice, of course, memory may eventually run out.<P>
Several steps can be taken to increase the practical limit on the number of menus or total menu items a single logical menu system can contain. The first is to design a longitudinal menu tree structure, to take maximum advantage of the dynamic loading features of CMENU. The second is to compile the CMENU program using the huge memory model, so array-size limitations are eliminated. All my testing was performed with the CMENU programs compiled with the default "small" memory model, for efficiency.<P>
So, one way <I>rmenu</I> differs from <I>cmenu</I> is that <I>rmenu</I>'s menu processing functions support recursion. There is only one trivial case where <I>rmenu</I> would not employ recursion: when a complete menu system consists of only a single menu file, and that file contains only a solitary menu definition with no submenu references. In any other configuration, recursive calls will always occur.<P>
<h4><FONT COLOR="#000080"><A name="004C_0019">...And At Least Two Operating Systems<A name="004C_0019"></FONT></h4></P>
Another distinction between the two programs is platform-dependence. Both programs support C compilers of varying ANSI-compliance, but aside from that, <I>cmenu</I>'s code is pretty much system-independent. Since <I>cmenu</I> simply compiles a text file into a binary file, the issue of real-time user interface management (i.e., curses) does not arise.<P>
<I>rmenu</I>, however, must deal with the user's screen. Pandora's box immediately opens, because DOS and UNIX systems have completely different ideas of what the user's terminal is like. UNIX sees terminals as serial devices, while DOS sees them as direct memory-mapped devices (that is an oversimplification, but it'll suffice for present purposes).<P>
A standard utility library for managing the screen &#151; the curses library &#151; is available with most UNIX-like systems. The curses library represents enough of a standard that several PC-based implementations have even popped up. I selected a PC curses package that we distribute through our CUG library. The package is called, appropriately, "PC Curses" (CUG volume 298), and it was written by Jeff Dean (who, by the way, volunteered extensive assistance to me in checking out the CMENU package for bugs and portability issues. Thank you Jeff!).<P>
PC Curses allows the CMENU system to be compiled under DOS with very few conditionally compiled variations in the terminal-handling code. This is possible because Jeff's library uses the same standard function names as the UNIX versions of curses.<P>
There are some minor variations between the UNIX and DOS flavors of curses, and there are also other areas of the CMENU system that must be handled differently between UNIX/XENIX and DOS. The most irritating one involves the idea of "current working directory," or CWD, and how the CWD can change unexpectedly after submitting command strings to the respective operating system's command processors.<P>
Under UNIX, a subshell can never alter the parent shell's current working directory, period. There are subtle tricks for letting a child process have a say in setting the CWD of its parent, but ultimately the parent is always in control of its own CWD.<P>
Not so under DOS. Once you pass an unknown command string to the command processor under DOS, you can't know for sure where the CWD will be upon return. The current working directory and currently selected drive (two distinct global modes, as we'll see later) must be saved before making any system calls. Then, upon return from system calls, those settings must be restored.<P>
Finally, screen and terminal characteristics may vary from system to system. Features such as lines per screen, column width, and operation of certain keys are terminal-dependent. Under UNIX, for example, certain versions of curses support predefined cursor key codes and certain others do not. Under XENIX, at least one curses library function name is different than the equivalent curses function name on other UNIX-variants. CMENU's header files try to handle known variations such as this, to keep the program text as uncluttered with conditional compilation directives as possible.<P>
The CMENU system may be compiled interchangeably under either DOS or XENIX without requiring any changes to the code; just use the appropriate makefile for the target operating system. <A href="fig1.htm">Figure 1</a>
shows the makefile for DOS. This version works specifically with the Borland C++ <I>make</I> program, but can easily be adapted to other dialects of <I>make</I>. <A href="fig2.htm">Figure 2</a>
shows the UNIX/XENIX version of the makefile.<P>
Each makefile uses the C compiler's -<I>D</I> command line option to define the target operating system and cause the appropriate variations of system-dependent code to be compiled. Several lines at the top of the makefile may be customized as needed to configure CMENU properly for the desired target environment.<P>
There may be issues with UNIX-variants (other than XENIX) that I haven't foreseen. One area that I know must be changed for other UNIX systems is the way the makefile specifies the names of the curses library object files. It works as supplied on XENIX, but I can make no other guarantees.<P>
<h4><FONT COLOR="#000080"><A name="004C_001A">The CMENU language<A name="004C_001A"></FONT></h4></P>
<A href="fig3.htm">Figure 3</a>
shows a modified BNF description of CMENU's menu definition language. This section presents a detailed English description.<P>
A CMENU description file has one or more menu definitions. The first menu appearing in the file is always the main menu for that file, and need not have a name. Since additional menus appearing in the same file can only be accessed by name via the <I>lmenu</I> (local menu) option in the main menu, all such additional menus must be given unique names.<P>
Each menu definition begins with a menu clause, consisting of the keyword <I>menu</I>, an identifier (optional only for the main menu, required otherwise), and an optional colon. After the menu clause come any desired menu options, followed by the item definitions. The menu definition is complete when the <I>endmenu</I> keyword appears.<P>
A menu system may consist of any number of separate menu files (or compiled units). Traversal across compiled units at runtime is totally transparent from the user's point of view.<P>
Selecting and returning from an external menu (that is, a separately compiled unit) appears the same as selecting and returning from a local menu, since the user receives no indication that another compiled unit has just been dynamically loaded. Within a single menu definition, global menu options may be specified immediately after the opening <I>menu</I> clause, but before the first <I>item</I> has appeared. If such options appear in a menu, they control screen processing for the entire menu (but not for any submenus that might be invoked). The available menu options and their functions are:<P>
<B>path</B> &#151; Defines the default path for all action items in the menu<P>
<B>escape, noescape</B> &#151; Tells whether to allow shell escapes<P>
<B>spacing</B> &#151; Sets vertical spacing between items (single or double)<P>
<B>columns</B> &#151; Tells number of horizontal columns to be used (1 - 6)<P>
There is code supporting the compilation of a text alignment option, but there is currently no runtime support for this option. There didn't seem any real need for it. In case someone wants to add customized options to CMENU, I've left the code in as a template to provide a starting point for work on such extensions.<P>
After all desired menu options have been specified, the item definitions follow. Each item definition begins with an <I>item</I> clause, consisting of the keyword <I>item</I>, an optional item identifier, an optional colon, and an optional text string (the text string is optional only because the item text may alternatively be specified in its own <I>text</I> clause later in the item definition).<P>
Not all components of the <I>item</I> clause are always optional. If the clause does not include an item identifier but does include a text string, a colon between the <I>item</I> keyword and the text string is required. This keeps the text string from getting parsed as an item identifier. When both an identifier and item text are present, the colon may be omitted.<P>
The only strict requirement for each item definition, other than the item clause itself, is an <I>action</I> clause. The <I>action</I> clause must be one of the following:<P>
<B>action</B> &#151; Execute a system command, or set of commands<P>
<B>lmenu</B> &#151; Run a local menu (one in the active <I>.mnc</I> unit)<P>
<B>emenu</B> &#151; Run an externally compiled .<I>mnc</I> unit<P>
<B>exit</B> &#151; Return to the previous menu; if none, exit<P>
A menu does not require an <I>exit</I> action, since the user may directly exit a menu anytime via the <I>e</I> or <I>x</I> runtime keystroke commands. Sometimes, though, displaying the exit option on the screen with other menu items can be useful. I've included the <I>exit</I> action code to provide that capability.<P>
Before or after the action code, some item options may also appear. Many of these item options have default behaviors that apply in the absence of explicit directions. Such defaults are hard-wired at <I>rmenu</I> compile time by definitions in the <I>rmenu.h</I> header file. They may be chosen to suit the specific requirements of your user environment. Any item options stated explicitly in a CMENU specification always override the defaults. These are the available item options:<P>
<B>text</B> &#151; If the text isn't part of the item clause, a text clause must be provided.<P>
<B>help</B> &#151; A help message, appearing only when the highlight bar is on the associated option.<P>
<B>path</B> &#151; A full pathname overrides the default path; a relative pathname is appended onto the default path.<P>
<B>prompt, noprompt</B> &#151; Controls whether the system pauses for a keystroke following termination of an action item.<P>
<B>pause, nopause</B> &#151; Equivalent to prompt/noprompt above (I couldn't decide which terms were clearer, so I left them both in).<P>
<B>preclear, nopreclear</B> &#151; Controls whether an explicit screen clear occurs before execution of an action item.<P>
<B>nextitem</B> &#151; Tells where to send the highlight after the current item has been executed. Options are:<P>
<B>first</B> &#151; to the first item in the menu<P>
<B>last</B> &#151; to the last item in the menu<P>
<B>next</B> &#151; to the next item in sequence<P>
<B>&lt;ident&gt;</B> &#151; to the item with the given identifier<P>
If no <I>nextitem</I> clause is present, the default is for the highlight to remain on the item that was just run.<P>
The <I>path</I> string, if specified, causes a <I>cd</I> command to be pre-pended to the action string when running under a UNIX variant. If running under DOS, then both a <I>cd</I> and a drive selection operation are performed, to ensure that the named drive/directory is current before the associated action statement executes.<P>
Under UNIX, the <I>action</I> clause (with possibly pre-pended <I>cd</I> statement) is passed directly to a <I>system()</I> call. DOS does not support multiple commands on a single command line the way UNIX does, but some special processing supports compound statements under DOS. This code begins by scanning the action text for semicolons. If it finds any, then it breaks the action text into a set of individual subcommands as delimited by the semicolons. Each subcommand is then processed by an independent <I>system()</I> call. This allows several DOS commands to be chained together in a single <I>action</I> clause text string.<P>
Upon completion of all listed actions, the original drive and path are restored under DOS. Under UNIX, this isn't necessary, since a child shell cannot alter the parent's current directory.<P>
An item definition implicitly ends when either another item clause or an <I>endmenu</I> keyword is encountered.<P>
<h4><FONT COLOR="#000080"><A name="004C_001B">CMENU Language Minutiae<A name="004C_001B"></FONT></h4></P>
The preceding section sums up the high-level structure CMENU language. There remain only a few syntactic details to mention before moving on.<P>
Tokens in the CMENU language are delimited by one or more of the following: any whitespace (space, tab, or newline), ; (semicolon) or , (comma). <A href="fig4.htm">Figure 4</a>
and <A href="fig5.htm">Figure 5</a>
illustrate the format I use, but there is no reason (syntactically) that you couldn't create something to rival Don Libes's "Obfuscated C Code" winners if that is what you want to do.<P>
The parser considers a string to be any sequence of printable characters that is not a keyword and does not contain any whitespace. Strings are legal as the operand of a <I>path, text,</I> or <I>action</I> clause, and as labels where needed. Single or double quotes may be used to delimit a string, and, except in the case of labels, prudence dictates doing so. The quotes, however, are not strictly required if the string contains no whitespace; I have, in a rush, written lines such as<P>
<pre>action mail</pre>
with only a token amount of guilt (sorry) for omitting the quotes around mail. Within a string, all characters are taken literally, including the backslash character (\). There is no provision for specifying control characters. There is only one restriction on allowable character codes within a string: single and double quote characters cannot both appear within the same string. If you need to include double quotes within a string, delimit that string with single quotes (and vice-versa).<P>
If your editor can generate control characters, you can put them into CMENU strings. In practice, however, I've never run across the need to insert a non-printable character into any CMENU text string.<P>
Identifiers, used to assign labels to menus and items, follow the same naming rules as C variables, with one exception: case is insignificant. Internally, all identifier names are represented by lower-case characters.<P>
Any token beginning with a digit is parsed as the beginning &#151; and typically the end, since meaningful values are all single-digit here &#151; of a decimal integer value, appropriate only as the operand to either the <I>spacing </I>or <I>columns</I> options.<P>
Finally, the # character (except inside a quoted string) denotes a comment. All characters from # to the end of the line are ignored. A line may begin with #.<P>
<h4><FONT COLOR="#000080"><A name="004C_001C">The Saga Of Pathname Delimiters<A name="004C_001C"></FONT></h4></P>
Even after years of programming in C under DOS, I still forget to double up the backslashes in pathname strings at least haft of the time. For example, I'll have a statement at the top of my C program that looks something like:<P>
<pre>#define PATH "c:\foo\bar"</pre>
The compiler sees a string containing <I>c:,</I> a formfeed, <I>oo</I>, a backspace, and <I>ar</I>. This is clearly not the intended result. What I really meant to write was:<P>
<pre>#define PATH "c:\\foo\\bar"</pre>
This kind of goof draws no compilation errors; often, it isn't until after I've become thoroughly confused and fired up the debugger that I find the mistake and kick myself. To keep from having to use the double-backslash notation in CMENU source files, I decided not to give the backslash character any special meaning in the CMENU specification language. As described above in the section on strings, there is no notation for escape sequences and single backslashes in strings are taken literally.<P>
Originally, I had included a feature in <I>cmenu</I> whereby any forward-slash (/) characters encountered in <I>path</I> clauses are automatically mapped into the paths-delimiter character appropriate for the target operating system (i.e., either a back- or forward-slash.) I did this only for the <I>path</I> clause, however, because that is when most CMENU pathnames appear. Later, Jeff Dean pointed out to me that pathnames written with forward-slash (/) characters under DOS worked just as well as ones with backslash (\) characters! My copy of the Waite Group's MS-DOS Bible didn't mention any such equivalence, however, so I began to wonder.<P>
As it turns out, the slash-translation is performed by the C file I/O library functions supplied with the various C compiler packages, and not by DOS itself. Performing such translation explicitly within a C program for DOS is therefore redundant, and I removed my original translation code from CMENU.<P>
Then, I found that pathnames written with forward-slashes worked correctly in <I>path</I> statements, but not in <I>action</I> clauses. Thinking more about it, I ought not have been surprised: CMENU action statements are run by simply passing the supplied action text to the operating system's own command interpreter, not to a C file I/O function. Thus the slash-translation provided in the C file I/O library never gets performed, and DOS ends up choking on the forward-slashes.<P>
The net result of all this is the following rule of thumb: to be absolutely safe, always use backslashes. If you prefer to use forward-slashes, then use them only in a <I>path</I> clause, never in an <I>action</I> clause.<P>
<h4><FONT COLOR="#000080"><A name="004C_001D">A Sample Menu System<A name="004C_001D"></FONT></h4></P>
<A href="fig4.htm">Figure 4</a>
and <A href="fig5.htm">Figure 5</a>
represent a small-scale menu system illustrating most of CMENU's features. I've arbitrarily chosen a UNIX-based example, but a DOS version would not be too different.<P>
In <I>t.mnu</I> (<A href="fig4.htm">Figure 4</a>)
, the main menu has no identifier label (OK for the initial menu in a file), allows shell escapes, and is to be displayed with double spacing on the screen. There are nine items in this main menu.<P>
The first item illustrates the automatic prompting feature of CMENU that is in effect when the <I>DEF_PROMPT</I> symbol (to be covered later in the <I>rmenu</I> section) is set to <I>ON_ERROR</I>. This causes <I>rmenu</I>, in the absence of an explicit <I>prompt</I> or <I>noprompt</I> option, to prompt after an action has been completed if and only if the status returned by that action is non-zero. In this example, a prompt is issued only if the user typed an <I>e</I> in response to the prompt displayed by the <I>test.sh</I> shell script (see <A href="fig6.htm">Figure 6</a>)
. Upon return from <I>test.sh,</I> the highlight bar moves over to the item labeled "zot" below.<P>
Since DOS systems do not provide standardized support for direct return values from system calls, the <I>ON_ERROR</I> option for the <I>DEF_PROMPT</I> feature is only meaningful under UNIX. Under DOS, <I>DEF_PROMPT</I> may be set to either <I>YES</I> or <I>NO</I>, and individual menu items may always override that default by including the <I>prompt</I> or <I>noprompt</I> options.<P>
The second item in the main menu calls up an external menu, <I>t2.mnc,</I> located in subdirectory <I>test</I>. Since the item path is given relatively (that is, no leading / character or, if it were under DOS, no drive letter either), the path is treated as a subdirectory of the current default menu path. Since no <I>path</I> clause was specified in the menu options section, the default menu path is the current working directory at the moment of <I>rmenu</I> invocation.<P>
The third and fourth items illustrate different ways to<I> </I>invoke an action. Using the <I>exec</I> command (UNIX only) saves a process.<P>
Item zot (lines 34-38) contains help text. This text is<I> </I>displayed on the screen only when the highlight bar is on that<I> </I>item. Note that in order to display the double quotes around<I> </I>the word "Zot," the entire help text is delimited by single<I> </I>quotes.<P>
Finally, the <I>prompt</I> command in menu item <I>zot</I> causes a<I> </I>prompt to be issued after the action is executed, forcing the<I> </I>user to press a key before the information left on the screen is<I> </I>erased and the menu screen is redisplayed.<P>
The next item simply illustrates how <I>nextitem</I><I> </I>specifications may be backward as well as forward.<P>
The next item invokes the local menu named bar,<I> </I>appearing at the end of the file. The last few items are just filler, to<I> </I>illustrate what happens when the total number of items<I> </I>exceeds the capacity of the default screen arrangement. Since<I> </I>there are 18 lines available for item information in the<I> </I>standard 24-line screen setup, double spacing the items means that<I> </I>only nine would fit in the single-column format. If an<I> </I>additional menu item were created by cloning the filler items, then<I> </I><I>rmenu</I> would automatically go into two-column mode in order<I> </I>to preserve the double spacing specified in line 13. If the<I> </I>spacing were set to <I>1</I> or omitted entirely, <I>rmenu</I> would go into<I> </I>single-spacing mode and remain in single-column mode. There<I> </I>is a function in <I>rmenu</I> devoted entirely to determining the most<I> </I>appropriate screen arrangement for any given menu. That<I> </I>function uses a heuristic based upon the number of items in<I> </I>the menu and any explicit <I>spacing</I> and <I>column</I> directives<I> </I>given. I'll cover this, in gory detail, when discussing the <I>rmenu</I><I> </I>program later on in the series.<P>
Following the <I>endmenu</I> keyword, a second local menu<I> </I>named bar is defined. The local menu options serve to disable<I> </I>shell escapes and to set the default path for actions in this<I> </I>menu to <I>/usr/bin</I>. Since setting a path this way just generates<I> </I>a <I>cd</I> statement before running an action, a named action need<I> </I>not necessarily reside in the directory specified in a <I>path</I><I> </I>clause, as long as the program can be found somewhere along<I> </I>the default system path. In many system paths, the current<I> </I>directory is searched first; if this is the case on your system,<I> </I>any executable commands in the directory named by a <I>path</I><I> </I>clause take precedence over similarly named commands<I> </I>residing elsewhere along the system path.<P>
There is nothing startlingly new<I> </I>about the three items in the bar menu. I<I> </I>used semicolons instead of newline to<I> </I>separate some of the clauses, just to<I> </I>show that it's permissible.<P>
The second menu file, <I>t2.mnu</I><I> </I>(<A href="fig5.htm">Figure 5</a>)
 also lacks interesting features; it<I> </I>was included to complete the<I> </I>illustration of a two-file menu system. Note<I> </I>that the default path for all actions is<I> </I>the same as the default path of the<I> </I>calling menu (in this case, the path<I> </I>specified by the second item in the first<I> </I>menu of the <I>t.mnu</I> file), since menu foo<I> </I>contains no explicit <I>path</I> clause to<I> </I>override that default path.<P>
One final note: an action clause may<I> </I>contain explicit commands to change<I> </I>the path, effectively superseding all<I> </I>previous default paths. An extraneous <I>cd</I><I> </I>command may be executed if a <I>path</I><I> </I>clause is given and an explicit <I>cd</I><I> </I>command is present within the action text.<I> </I>Such extra <I>cd</I> commands generate only<I> </I>a negligible quantity of CPU overhead<I> </I>and may be effectively ignored.<P>
<h4><FONT COLOR="#000080"><A name="004C_001E">Common Menu<A name="004C_001E"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="004C_001F">Data Structures<A name="004C_001F"></FONT></h4></P>
There are three header files in the CMENU package. The master header<I> </I>file, <I>cmenu.h</I>, contains the symbolic<I> </I>constant definitions (<I>#define</I> statements)<I> </I>that control common data structures<I> </I>and operating-system-specific code for<I> </I>both the <I>cmenu</I> and <I>rmenu</I> programs.<I> </I><I>cmenu.h</I> is included by all program<I> </I>modules, so it performs the inclusion of the standard C header<I> </I>file, <I>stdio.h</I>.<P>
Besides including <I>cmenu.h</I>, the <I>cmenu</I> and <I>rmenu</I> programs<I> </I>each have their own personal header files, named <I>ccmenu.h</I><I> </I>and <I>rcmenu.h</I> respectively. Both of these header files use the<I> </I>symbolic constants and data types defined in <I>cmenu.h</I> to build<I> </I>the actual data structures needed to perform their specific<I> </I>tasks.<P>
We'll look first at the common, elementary structures<I> </I>defined in <I>cmenu.h</I>, so we can see how <I>cmenu</I> and <I>rmenu</I> later<I> </I>build upon them.<P>
<h4><FONT COLOR="#000080"><A name="004C_0020">The Basics<A name="004C_0020"></FONT></h4></P>
As noted earlier, <I>cmenu</I> and <I>rmenu</I> share the intermediate<I> </I><I>.mnc</I> file format; consequently, most of <I>cmenu.h</I> (<A href="list1.htm">Listing 1</a>)
 is<I> </I>devoted to declarations of the structure types used in that<I> </I>format. The two major structures are named <I>MENU</I> and <I>ITEM</I>.<I> </I>Within these two structure types, string elements are all<I> </I>defined as <I>char</I> arrays (as opposed to pointers), Boolean<I> </I>elements have type <I>BOOL</I> (really just <I>char</I>), logical and<I> </I>multiple-choice elements have type <I>char</I>, and numeric elements have<I> </I>type <I>int</I> (even though they would never be negative and<I> </I>probably never exceed a value of 255).<P>
The logical elements have three possible values: <I>YES, NO</I>,<I> </I>and <I>DEFAULT</I> (as opposed to the Booleans, which can only be<I> </I><I>TRUE</I> or <I>FALSE</I>). <I>YES</I> and <I>NO</I> values appear when an explicit<I> </I>option was written for that element in a menu or item definition;<I> </I>the value <I>DEFAULT</I> signifies that no explicit option was written,<I> </I>and <I>rmenu</I> should, in that case, perform the actions dictated by<I> </I>a set of default action definitions specified in the <I>rcmenu.h</I><I> </I>header file.<P>
If a text element is not specified, it is represented as the<I> </I>null string (first character is a '\0'). If a numeric element is<I> </I>omitted, the value inserted is <I>DEFAULT</I>, as described above.<P>
A <I>MENU</I> (a <I>typedef</I>ed alias for <I>struct menu</I>) contains the<I> </I>following elements:<P>
<B>title</B> &#151; The menu title, displayed at the top of a menu screen<P>
<B>path</B> &#151; The default action path for all items (absolute or relative)<P>
<B>nitems</B> &#151; The number of items present in the menu<P>
<B>align</B> &#151; (not used)<P>
<B>columns</B> &#151; Number of columns specified for the item display<P>
<B>spacing</B> &#151; Spacing specified for the column display<P>
<B>widest</B> &#151; Length of the widest item text (in characters)<P>
<B>escape</B> &#151; Whether shell escapes are permitted<P>
An <I>ITEM</I> (really <I>struct item</I>) contains:<P>
<B>text</B> &#151; The text to be put up to represent that item (may be truncated if the space is needed for multiple columns)<P>
<B>path</B> &#151; the path for the item (absolute or relative)<P>
<B>action</B> &#151; The text of the command(s) to be submitted to a <I>system()</I> call when the item is chosen to be run, orthe name of an external menu if the action is <I>emenu</I><P>
<B>help</B> &#151; The text of any help info, put up on the screen when the item is under the highlight bar (never truncated)<P>
<B>pre_clear (logical)</B> &#151; Whether to clear the screen before the action<P>
<B>post_clear (logical)</B> &#151; Whether to clear the screen after the action<P>
<B>prompt (logical)</B> &#151; Whether to pause before returning to menu<P>
<B>acttyp (multi-choice)</B> &#151; Tells what brand of action to perform (choices: command, lmenu, emenu or exit &#151; represented by the <I>ACT_</I>* symbolic constants)<P>
<B>lmenunum</B> &#151; If the <I>acttyp</I> is <I>ACT_LMENU</I>, specifies the index for the specified local menu in the menu table<P>
<B>nextcode (multi-choice)</B> &#151; Tells how the next item is to be determined (choices: first, last, next, or direct &#151; <I>NXT</I>_* symbols)<P>
<B>nextitem</B> &#151; If nextcode is <I>NXT_DIRECT</I>, this contains the index of the next item to be highlighted.<P>
The way that <I>MENU</I> and <I>ITEM</I> objects are<I> </I>combined is not specified in <I>cmenu.h</I>,<I> </I>because that combination is different in<I> </I><I>cmenu</I> than it is in <I>rmenu</I>. For the<I> </I>remainder of this installment I'll focus<I> </I>on the <I>cmenu</I> program and its own data<I> </I>data structures.<P>
<h4><FONT COLOR="#000080"><A name="004C_0021">The <B><I>.mnc</I></B> Format<A name="004C_0021"></FONT></h4></P>
The format of compiled .<I>mnc</I> files is<I> </I>summarized in <A href="fig7.htm">Figure 7</a>.
 Remember,<I> </I>this is a binary format, not an ASCII<I> </I>one.<P>
The first item in an <I>.mnc</I> file is an<I> </I>integer value that tells how many (local)<I> </I>menus are defined in the file.<I> </I>Immediately following this count is the <I>MENU</I><I> </I>structure for the first menu, and after<I> </I>that come the <I>ITEM</I> structures for each<I> </I>item in the menu. The number of items<I> </I>in each menu is part of the information<I> </I>stored in the associated <I>MENU</I> header, so<I> </I>there's no need to store separate item<I> </I>counts in the file format.<P>
That's it; the <I>.mnc</I> format is fairly<I> </I>simple, conceptually. To actually<I> </I>generate it, however, requires a bit<I> </I>more complexity... now the real fun<I> </I>begins!<P>
<h4><FONT COLOR="#000080"><A name="004C_0022">At Last, <B><I>cmenu</I><A name="004C_0022"></B></FONT></h4></P>
The <I>cmenu</I> program is essentially a big state machine, whose purpose is to scan through the sequential ASCII token stream of one or more CMENU specification files and produce a correctly compiled <I>.mnc</I> output file corresponding to each input file.<P>
At the heart of <I>cmenu's</I> operation is a structure named <I>keywords</I>, defined in <I>ccmenu.h</I> (<A href="list2.htm">Listing 2</a>,
 lines 190-228). <I>keywords</I> defines a couple of attributes to be associated with each possible keyword token. The tokens represent each symbol, keyword, or special condition (such as <I>EOF</I>) that the CMENU language recognizes.<P>
The first attribute, <I>keyword</I>, is the text of the keyword itself; for tokens that have no printing text associated with them, I've contrived some special identifying sequences (see lines 191 and 223-226) that assisted me during interactive debugging of the <I>cmenu</I> program.<P>
The other attribute is a pointer to the processing function called when the associated token shows up in the input stream. All token processing functions are named <I>do_whatever</I>, where <I>whatever</I> is the name of the token. There are also additional <I>do_whatever</I> functions not tied to a particular token, but called occasionally under special circumstances.<P>
An enumeration constant list (lines 43-58) defines a symbolic name for each keyword. These symbolic names appear in exactly the same order as their corresponding <I>keywords</I> table entries; thus, the symbolic name for each token has a value equal to that token's physical index position in the <I>keywords</I> array. Since the symbolic values are used to represent tokens during the parsing of input text, this arrangement has a side-effect that facilitates debugging of the <I>cmenu</I> program: you can keep a running display of the ASCII string associated with the most recently parsed token by placing the expression<P>
<pre>keywords[token].keyword</pre>
into a watch window.<P>
For compilers that do not support enumeration constants, the "old-fashioned" way of defining a set of sequential symbolic values is shown in lines 60-99. This section of conditionally-compiled code is used instead of the <I>enum</I> section when <I>__STDC__</I> (a pre-defined symbolic constant indicating ANSI compliance) is undefined.<P>
There are a couple of key global state variables that describe which portion of a menu definition is currently being processed. The first of these, <I>in_menu</I>, is a simple Boolean variable telling whether or not a menu definition is being processed. <I>in_menu</I> remains <I>FALSE</I> until the first menu clause is encountered; from that point on, <I>in_menu</I> is <I>TRUE</I> between each menu clause and <I>endmenus</I> keyword, <I>FALSE</I> otherwise.<P>
The other critical state variable is <I>in_item</I>. This one is set to <I>TRUE</I> every time the first item clause of a menu is encountered, and reset to <I>FALSE</I> (along with <I>in_menu</I>) each time <I>endmenu</I> is processed.<P>
Both of these state variables are initialized to <I>FALSE</I> near the start of <I>do_menu()</I>, and thereafter their values toggle as necessary under control of the appropriate token-processing functions.<P>
With the <I>keywords</I> structure and state variables all in place, <I>cmenu's</I> main processing loop can be frightfully simple. Indeed, lines 71-81 of <A href="list3.htm">Listing 3</a>
(a partial listing of the source file <I>cmenu1.c</I>) make up this entire loop. The code relies, however, on the token scanning function <I>gettok()</I> to parse the next little piece of the input stream into a token value and associated detail values.<P>
If the next token is a string, for example, then <I>gettok()</I> returns the token <I>T_STRING</I>. The actual text of the string is stuffed into a global <I>char</I> array named <I>tparam</I>.<P>
The main loop can prevent the token-processing functions from having to perform a common error-checking test by making sure that, when not currently within a menu (i.e., whenever <I>in_menu</I> is <I>FALSE</I>), the <I>menu</I> keyword is the next token scanned. Whenever any token other than <I>menu</I> is encountered outside of a menu definition, an error is reported (line 75) and processing of the current file terminates.<P>
No other error condition is as universally easy to detect, so any further diagnostics are relegated to specific token-processing functions. Lines 78-80 dispatch control to the appropriate processing function, and check for the possibility of a fatal error before continuing on to the next loop iteration.<P>
<h4><FONT COLOR="#000080"><A name="004C_0023">Information Economy<A name="004C_0023"></FONT></h4></P>
Now let's return to the <I>ccmenu.h</I> header file and investigate some new data structures.<P>
The CMENU language supports forward references in both menu and item label references, so we need some way of keeping track of which menus and items have been defined so far, which ones have not, and where those references came from so they can be resolved when possible, or diagnosed as unresolved reference errors otherwise.<P>
There is also the matter of the menu and item identifier names. There is no place for those identifiers in the <I>.mnc</I> file format, since by the time the <I>.mnc</I> file is written, each reference to a menu or item has been resolved into an integer index value that allows direct access to the menu or item desired through a simple indexing operation.<P>
So, what's needed is a set of data structures that contain the elementary <I>MENU</I> and <I>ITEM</I> structures as subsets of larger structures. These larger structures add the additional pieces of data necessary to support the compilation process, but still allow the essential <I>MENU</I> and <I>ITEM</I> information to be extracted, in the required elementary format, when the time comes to write an output file.<P>
The <I>typedefs</I> for just such a set of incremental structures can be found in lines 27-37 of <A href="list2.htm">Listing 2</a>.
 The first definition, <I>IINFO</I>, is a structure containing just two elements: a name string, and an <I>INFO</I> structure. The second <I>typedef</I>, <I>MINFO</I>, is a structure containing a name string, a <I>Processed</I> flag to indicate completion of menu processing, a <I>MENU</I> structure describing the properties of the menu, and an array of pointers to the <I>IINFO</I> structures that make up the individual items associated with the menu.<P>
The decision to use an array of pointers to structures in the <I>Items</I> array, but actual instances for the other structure elements (<I>Item </I>and<I> Menu</I>), actually came about as the result of much trial-and-error. The goal was to find an ideal balance for this application between memory-efficiency and coding clarity. In C, unfortunately, those two properties tend to unfold in inversely proportional quantities within any sufficiently complex application. Finding the right balance can be a challenging task.<P>
In order to make efficient use of available memory when the size of an array is not fixed at compile time, we need to use dynamic memory allocation to obtain exactly the needed quantity of memory, and no more, at runtime. When the storage for an object is allocated dynamically, then pointers must be used to access the data &#151; and manipulating pointers to objects is usually more complex than manipulating just the objects themselves.<P>
If more than one level of dynamic arrays are involved, then things get positively twisted. In my first design for <I>cmenu</I>, I attempted to use a data structure that had multiple levels of dynamically-allocated arrays. (Anyone remember the tricky dynamically-allocated arrays from my Mini-Database System series in <I>CUJ</I> last year? And that was only one level!) Needless to say, it was a mess. I learned, however, that it was still possible to squeeze much good use out of CMENU's small-model memory space even without many of the dynamic allocation tricks. Most of the memory goes to hold <I>ITEM</I> information, anyway; why not restrict dynamic allocation to only the memory needed for <I>ITEM</I> structures? The resulting code is much easier to document and understand than my earlier multilayered dynamic scheme.<P>
The <I>MINFO</I> structure applies to a single menu only, so there is an array of <I>MAX_MENUS MINFO</I> structures defined in line 235 as <I>MInfo</I>. The dimension of <I>MAX_MENUS</I> limits the number of structures that may be defined within a single source module; if long menu source files give you memory problems, reducing the value of <I>MAX_MENUS</I> offers quick memory relief (but might make it necessary to split some large <I>.mnu</I> files into smaller pieces).<P>
The final major data structure in the <I>cmenu</I> program is the forward-reference table, <I>fwd_refs</I>, defined in lines 241-245. This table performs the task of tracking forward references to named items in a menu. No such corresponding table is needed to handle forward menu references, however. Here is why: The order of items within a menu is significant; they should appear on the screen in the same order as their specification in the source file. Yet, how is the compiler supposed to behave when a reference is made to an as-yet-undefined item, one that could appear anywhere from the current point in the menu source to the end of the menu? Does the compiler immediately create an item record reserved for the future item, and add it to the array of items? If so, then the physical order of the items gets messed up (this isn't an obvious side-effect; my first stab at this code utilized an <I>IINFO</I> "<I>Processed</I>" flag similar to the <I>MINFO</I> flag of the same name, without taking the aforementioned phenomenon into consideration. Surprise, I couldn't get forward references to work!)<P>
Rather than creating an <I>IINFO</I> structure when a forward reference in encountered, the present scheme simply registers the reference into the <I>fwd_refs</I> table (including the line number of the reference, for diagnostic purposes), and goes on processing more menu items. Whenever a new labeled item definition is encountered, <I>cmenu</I> makes a quick check to see if any references have been made to that item label; if found, the references are resolved by copying the index number of the new item definition into the location whose address was saved in the forward reference table. If any unresolved references remain at the end of the menu definition, the precise line number of the reference can even be supplied in the error diagnostic. The code that handles this is not very complicated, but has proven immensely effective. If I were really smart, I would have written it this way in the first place, but then I'd have missed another opportunity to play with Turbo Debugger!<P>
The remaining definitions in <I>ccmenu.h</I> are for miscellaneous scratch pointers, global variables, and constants. Next time, we'll journey through the rest of <I>cmenu's</I> procedural code.<P>

<h4><a href="../../../source/1992/jan92/zolman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
