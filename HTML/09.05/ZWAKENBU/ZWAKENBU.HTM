


<HTML>
<HEAD>

<TITLE>May 1991/Inexact Alphanumeric Comparisons</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Inexact Alphanumeric Comparisons<A name="0111_008E"><A name="0111_008E"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0111_0000"><A name="0111_0000">Hans G. Zwakenberg</font></h3><hr><blockquote><P>
<P><i><A name="0111_0000"><A name="0111_0000">Hans G. Zwakenberg has been active in the software industry since 1984. He worked for several companies as a software developer and marketer. More recently he was appointed marketing manager by Borland International Paris Office for the Benelux area (Belgium, Netherlands and Luxemburg). Currently an independent consultant, he specializes in relational database development. Hans can be reached at Flora 13, 7422 LN Deventer, The Netherlands, phone (int+31) 5700 50683.</i></P><P>
One feature that makes a database application much more useful to the end-user is the ability to perform inexact alphanumeric searches. You need only approximate knowledge of a keyword to retrieve the correct record. Moreover, a small typo in a keyword doesn't give you just a "record-not-found" error message. Instead, you get a number of records, from which you can select the right one. To include this type of graceful behavior into your application, you must determine to what extent two character strings differ. One measure comes from comparing the phonetics of both strings. I'll present another approach, using a simple metric known as the Levenstein Distance.<P>
<h4><FONT COLOR="#000080"><A name="0111_008F">Algorithm<A name="0111_008F"></FONT></h4></P>
The Levenstein algorithm determines how many mutations are needed to transform string1 into string2. Three types of mutation are possible:<P>
<UL><li>addition of a character (if string1 is shorter than string2)</li>
<li>deletion of a character (if string1 is longer than string2)</li>
<li>changing a character (if characters compared don't match)</li></UL>
Each of these mutations is assigned an individual penalty value. The Levenstein algorithm arrives at a final penalty value by adding all penalties for each required mutation. A final score of zero denotes two equal strings. The higher the score, the more the strings differ.<P>
<h4><FONT COLOR="#000080"><A name="0111_0090">Implementation<A name="0111_0090"></FONT></h4></P>
To explain how the algorithm is implemented I'll walk through function <I>l_distance</I> in <A href="list1.htm">Listing 1</a>
(<I>ld.c</I>). The first two lines define a couple of variables. The next two determine the length of the strings to be compared. The string length is assigned to variables <I>r_len</I> and <I>f_len</I>. To save memory space and improve execution speed, the maximum length is limited by the constant <I>COMP_LEN</I>. You may change this value as needed. Lower values speed execution and minimize memory requirements, but they also compare fewer characters in the strings.<P>
The next section initializes <I>distance</I>, a two-dimensional integer array. You can visualize <I>distance</I> as a small spreadsheet. The top row is filled with penalty values for the addition mutation. The leftmost column is filled with penalty values for the deletion mutation. The nested loop that follows fills the <I>distance</I> array with the appropriate values. To continue the spreadsheet analogy, the bottom right cell contains the final score &#151; the Levenstein Distance. This integer value is returned to the calling routine.<P>
To produce a stand-alone program, remove the comment from the <I>#define</I> <I>DEBUG</I> directive, then recompile and link <I>ld.c</I>. This program serves a number of purposes. It enables you to test drive the routine and feed it different sets of strings. That shows you how fast the Levenstein Distance increases with increasingly differing strings. The stand-alone version dumps the content of <I>distance</I> (less the top row and left column). That lets you see how the final score is determined.<P>
As a guideline, Levenstein Distances below 10 are acceptable, at least if you use the Dutch language and stick to the values I gave the variables <I>addition</I>, <I>change</I>, and <I>deletion</I>. You will need to experiment with different values for these three variables for each language you use. Just feed the function sets of strings you consider sufficiently alike. Note the final score for each set. If any set scores higher than 10, change the value of the three variables and test your set of strings again. You can use a higher threshold than 10, but be careful &#151; soon you might end up with a program giving all database records as a possible answer to your question. Remember, the idea is to narrow down the number of possible answers from which the end-user must choose. Only increase the threshold your program uses as a last resort.<P>
<h4><FONT COLOR="#000080"><A name="0111_0091">A Useful Filter<A name="0111_0091"></FONT></h4></P>
As a bonus I've included <I>is_alike</I>, which acts as a filter. (See <A href="list2.htm">Listing 2</a>.
) All strings passing this filter are similar enough to the required string to be possibly correct. <I>is_alike</I> is an adaptation of <I>l_distance</I>, modeled after the <I>like</I> matching operator that gives Paradox queries so much flexibility. <I>is_alike</I> uses four steps to either reject or accept a string:<P>
1.<I> is_alike</I> compares the first character of both strings. Uppercase and lowercase differences are ignored in this comparison and in any subsequent comparison. If first characters don't match, the string is rejected.<P>
2. If first characters match, <I>is_alike</I> calculates the maximum allowable difference and stores it in <I>threshold</I> (see <A href="list2.htm">Listing 2</a>)
. The formula used is <I>(1</I> + <I>((strlen(string1)</I> +<I>2)</I> <I>/ 4))</I>.<P>
3. <I>is_alike</I> checks the length difference between the two strings. The absolute value of the length difference should be smaller than or equal to <I>threshold</I>. If the difference is larger than <I>threshold</I>, the string is rejected. If not, <I>is_alike</I> continues to the last step.<P>
4. <I>is_alike</I> uses <I>l_distance</I> to calculate the Levenstein Distance. This value should be smaller than or equal to <I>threshold</I>. If so, the string passed the test and is accepted. If the calculated distance is larger than <I>threshold</I>, the string is rejected.<P>
Note that <I>is_alike</I> is not a full emulation of the Paradox <I>like</I> operator. The Paradox <I>like</I> operator checks if a character in string1 exists in string2 and ignores letter positions within strings. Since Levenstein's algorithm does check on letter position, I compensated for this by lowering the penalty for a <I>change</I> and <I>deletion</I> mutation. If these adjustments aren't enough, you could also change the formula that calculates <I>threshold</I>. As with <I>l_distance</I>, experimenting with the various parameters will give you the behaviour you're after.<P>
<h4><FONT COLOR="#000080"><A name="0111_0092">Possible Improvements<A name="0111_0092"></FONT></h4></P>
I didn't spend any time optimizing these routines, nor have I done any benchmarking. For execution speed, it is out of the question to call <I>malloc</I> to allocate <I>distance</I> each time the function gets called. So I declared the array global, with <I>COMP_LEN</I> limiting its size. Initially, in the nested <I>for</I> loop calculating the Levenstein Distance, each loop contained a call to <I>strlen</I>. These calls were replaced by references to <I>r_len</I> and <I>f_len</I>. At this point, I quit optimizing due to lack of time. Improvements are possible for both memory consumption and execution speed:<P>
<UL><li>Memory usage could be reduced significantly, but at the cost of slower execution. Declaring <I>distance</I> to be a two-dimensional array of <I>unsigned char</I> would reduce its size by a factor of four, but the compiler would need to include extra code to type-cast integers to <I>unsigned chars</I>. This extra code will slow down the process.</li>
<li>Execution speed can be slightly increased by using pointers instead of indexes to access <I>distance</I>. Pointer arithmetic is faster than index arithmetic. Comparing strings with an average length of seven characters, you would access <I>distance</I> 64 times within the nested loop for each set of strings you want to compare. Switching to pointer arithmetic might pay off.</li></UL>
I would be grateful to hear from anyone implementing these suggestions or any other improvements. Better still, share your ideas by sending a letter to <I>CUJ</I> describing your implementation.<P>
<h4><FONT COLOR="#000080"><A name="0111_0093">Conclusion<A name="0111_0093"></FONT></h4></P>
Levenstein's technique for determining to what extent strings differ is a useful algorithm to have in your bag of tricks. Instead of doing complex phonetic comparisons, it uses comparatively simple metrics to arrive at a conclusion. Levenstein's algorithm can perform inexact string comparisons during database searches. Alternatively, it can be used for input validation. For example, if you were to write a command processor, this algorithm could provide it with some tolerance for small typos.<P>

<h4><a href="../../../source/1991/may91/zwankenb.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
