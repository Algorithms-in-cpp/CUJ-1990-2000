


<HTML>
<HEAD>

<TITLE>May 1991/Image Processing</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Image Processing<A name="010B_008C"><A name="010B_008C"></font></h2><P>
<h3 align="center"><A name="010B_0000"><A name="010B_0000">Part 2: Displaying Images And Printing Numbers</h3><P>
<h3 align="center"><font color="#800000">Dwayne Phillips</font></h3><hr><blockquote><P>
<P><i><A name="010B_0000"><A name="010B_0000">Dwayne Phillips works as a computer and electronics<I></I> <I></I>engineer with the United States Department of Defense. He has<I></I> <I></I>a Ph.D. in electrical and computer engineering at Louisiana<I></I> <I></I>State University. His interests include computer vision,<I></I> <I></I>artificial intelligence, software engineering, and programming<I></I> <I></I>languages.<I></I></i></P><P>
Image processing is a visual task. You therefore must have a method of displaying images in various forms in order to process them. The first article of this series (<I>CUJ,</I> March 1991) discussed image input and the Tag Image File Format. This article presents techniques to print the numbers in an image, display the numbers in an image on a CRT, and display the image in color and grayscales on EGA and VGA monitors.<P>
The C Image Processing System (CIPS) ties together these image-display subroutines. (I will include image processing operators in later articles.) The CIPS platform can call all the subroutines. CIPS was compiled and linked using Microsoft C 6.0. Certain display manipulation calls are unique to Microsoft, but you can substitute equivalents from Turbo C or other C implementations.<P>
A key feature of CIPS is that it does not require a special image processing board, math coprocessor, 80286, or top of the line display. CIPS is a software system that runs on a basic PC, though a hard disk is highly recommended. While CIPS works for VGA, EGA, CGA, and monochrome displays, the system looks best with a VGA monitor. (You'll have to wait until next month to display images on CGA and monochrome).<P>
<A href="list1.htm">Listing 1</a>
shows the function <I>main</I> for CIPS. It declares two image arrays, each of 100x100 <I>shorts.</I> (See the March 1991 article for the <I>cips.h</I> header and the definition of <I>ROWS, COLS,</I> and other constants.) The image would look sharper if the image arrays were 500x500. Due to limitations of DOS, Intel's 80x86 segmented architecture, and other reasons, such large arrays are impractical. CIPS passs these two image arrays to various operators. Two arrays are necessary because most operations require one array for input and one for output.<P>
The heart of <A href="list1.htm">Listing 1</a>
is a simple user interface that gets parameters from the user and calls the available functions. <A href="fig1.htm">Figure 1</a>
shows the CIPS main menu (displayed by <I>show_menu</I>). All other menus are as simple as the main menu and are self-explanatory.<P>
<h4><FONT COLOR="#000080"><A name="010B_008D">The Main Menu<A name="010B_008D"></FONT></h4></P>
<B>Choice one </B>in the main menu displays an image header. CIPS calls the <I>read_tiff_header</I> function (presented in the March 1991 article) and displays the header information.<P>
<B>Choice two</B> displays the image numbers on the screen as text. Recall that images are two-dimensional arrays of numbers. When the operators that process these arrays do not return the expected results, you can stop and look at the numbers. CIPS first reads an image using <I>read_tiff_image,</I> then calls the function <I>show_image</I> (<A href="list1.htm">Listing 1</a>)
 to display the numbers. <I>show_image</I> prints 20 rows of 18 columns each on the CRT.<P>
Functions that operate on an image do not interact directly with the user. Instead, the system employs various user-interface functions. This structure allows you to write stand-alone image-processing programs in which you set the parameters in code, call the desired functions, and come back in several hours when the functions finish. The advantages of this system will become more apparent in future articles when certain functions will require large amounts of time to complete.<P>
The parameters in all CIPS functions have the same form. Each function operates on an image file. The function <I>get_image_name</I> gets this file name. Four parameters important to all images &#151; <I>il</I> (initial line), <I>ie</I> (initial element), <I>ll</I> (last line), and <I>le</I> (last element) &#151; describe the four corners of the 100x100 image array. The images themselves are usually 500x500 or 600x600. CIPS, however, can handle only 100x100 portions at a time. The function <I>get_parameters</I> in <A href="list2.htm">Listing 2</a>
asks the user to specify these parameters.<P>
<B>Choice three</B> from the main menu sends the image numbers to a line printer. This choice prints a larger part of the image than the portion displayed from choice two. CIPS reads the image as in choice two and calls the function <I>print_image</I> (<A href="list3.htm">Listing 3</a>)
, which opens the printer file and calls <I>perform_printing</I> to do the printing. <A href="fig2.htm">Figure 2</a>
shows an example printed output.<P>
The main limitation of printing the image numbers is the width of the paper. Using the default 10 characters per inch, you can fit only 17 columns of data on a page. Most printers have some form of condensed printing. My Hewlett-Packard DeskJet has several modes and fonts. You can send the printer commands from the code and experiment with fitting columns of data on a page. In one of the DeskJet modes, I can print 50 columns. The comments in <A href="list3.htm">Listing 3</a>
explain how and where to insert commands to your printer.<P>
<B>Choice four</B> displays the actual image. This month I discuss EGA and VGA displays. The next installment of this series will discuss display using halftoning, which works for CGA and monochrome monitors. EGA displays up to 640x350 pixels with 16 colors. VGA displays up to 640x480 pixels with 16 colors. VGA will also display 320x200 pixels with 256 colors. Example images I'll use have either 16 or 256 shades of gray. The function <I>display_menu_for_display_image</I> asks the user the type of image, the type of display adapter, and the desired method of display (see <A href="list4.htm">Listing 4</a>)
. CIPS then calls <I>display_image.</I><P>
<h4><FONT COLOR="#000080"><A name="010B_008E">Displaying The Image<A name="010B_008E"></FONT></h4></P>
Two values obtained here, <I>invert</I> and <I>color_transform</I>, need more explanation. The <I>invert</I> variable causes the display to be normal or inverted in color (like a photo negative). Sometimes the scanning process will produce a negative of the original image. Using <I>invert</I> allows you to display the negative as a positive.<P>
The <I>color_transform</I> variable determines how to display an image with 256 shades of gray on a display that will show only 16. In this article we will map the 256 shades down to 16 in a simple and straightforward manner by dividing the original value by 16. In a future installment on histograms, CIPS wil use the <I>color_transform</I> variable.<P>
The function <I>display_image</I> (<A href="list4.htm">Listing 4</a>)
 first sets the <I>horizontal, vertical,</I> and <I>display_mode</I> variables. <I>horizontal</I> and <I>vertical</I> limit the size of the displayed image. They depend on the type of monitor, its mode, and the size of the image file. <I>display_mode</I> depends on the type of monitor and mode chosen by the user. <I>display_image</I> then sets the display to graphics mode.<P>
<I>display_image</I> reads in 100x100 portions of the image and calls the function <I>display_image_portion</I> to display them. <I>display_image_portion</I> first looks at the <I>invert</I> parameter. If the user specified <I>invert=1</I>, the code goes through the image array and reverses the numbers by subtracting each value from the maximum display value. Next, the function loops through the image array and sets the pixels on the display. The four <I>if</I> statements in the loops set the color transform by dividing the number of colors in the image by the number of colors in the display.<P>
There is one catch to displaying the images in color. The original images were scanned into gray scales, not color. Scanning color photographs into files with a color scanner (and then displaying them in color) is a completely different subject. When you display a gray scale image using colors, the result appears a bit odd. The function <I>display_16_shades_of_gray</I> displays 16 shades of gray, rather than 16 colors. <A href="fig3.htm">Figure 3</a>
shows the values as defined in the file <I>graph.h</I>, a Microsoft C 6.0 file with equivalents in other C compilers. A <I>long</I> (4-byte) word defines the 16 color values.<P>
The three least-significant bytes of the <I>long</I> are the blue, green, and red values. Each of the values can only be six bits, and so ranges from <I>0 to 63 (00 to 3f hex)</I>. Notice in <A href="fig3.htm">Figure 3</a>
that<I>_BLUE = 0x2a0000</I> (the blue value is <I>42</I> and the red and green are zero), <I>_GREEN = 0x002a00</I> (green is on and blue and red are off), and<I>_RED = 0x00002a</I> (red is on and blue and green are off). To remap the 16 colors to be any shade, tint, or hue, you use the <I>_remappalette</I> function (a Microsoft function that also exists in Turbo C).<P>
I want the 16 colors to be 16 shades of gray. Notice that <I>_BLACK, _WHITE, _GRAY</I>, and _<I>BRIGHTWHITE</I> each has equal values of blue, green, and red. When the three color guns have equal values, the result is a shade of gray. Therefore, the function <I>display_16_shades_of_gray</I> remaps the 16 color values to 16 gray shades by setting blue, green, and red to equal values ranging from <I>0</I> to <I>63</I> in steps of four.<P>
<h4><FONT COLOR="#000080"><A name="010B_008F">Example Images<A name="010B_008F"></FONT></h4></P>
<A href="photo1.htm">Photograph 1</a>
shows a boy and <A href="photo2.htm">Photograph 2</a>
shows a house as displayed by CIPS. CIPS displayed these photographs in 16 shades of gray on a VGA monitor. An EGA monitor displays them exactly the same. I took the original photographs in black-and-white and scanned them with a Hewlett-Packard ScanJet Plus. CIPS displayed them and I took the photographs you see here using black-and-white film. (See the <A HREF="sidebar.htm">sidebar</A> on shooting images on a CRT.) CIPS took about one minute to display these on my 10 Mhz 80286 machine. Your speed will vary according to your processor and disk drive speed. You can obtain these and other images on disk through <I>The C Users Journal.</I><P>
<I>[Ed. Note: The CIPS source files printed in the March issue are not reproduced here because of their length. cip.h,tiff.c, and rtiff.c are available on the March code disk.]</I><P>

<h4><a href="../../../source/1991/may91/phillips.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
