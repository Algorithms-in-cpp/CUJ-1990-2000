


<HTML>
<HEAD>

<TITLE>March 1991/Stepping Up To C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Stepping Up To C++<A name="0097_005A"><A name="0097_005A"></font></h2><P>
<h3 align="center"><A name="0097_0000"><A name="0097_0000">Writing Your First Class</h3><P>
<h3 align="center"><font color="#800000">Dan Saks</font></h3><hr><blockquote><P>
<P><i><A name="0097_0000"><A name="0097_0000">Dan Saks is the owner of Saks &amp; Associates, which offers consulting and training in C, C++ and Pascal. He is also a contributing editor of TECH Specialist. He serves as secretary of the ANSI C++ committee and is a member of the ANSI C committee. Readers can write to him at 287 W. McCreight Ave., Springfield, OH 45504 or by email at dsaks@wittenberg. edu.</i></P><P>
Over the past two years I've spoken with many C programmers who are thinking about switching to C++. Nearly all have heard about the highly touted benefits of object-oriented programming (OOP) and C++. Although a few are skeptical about the benefits of C++, most programmers are intrigued and want to know more about it.<P>
As I mentioned in my last column, I think some apprehension is justified. C++ is not as widely available as C. Where C++ is available, the development tools are sometimes lacking. And there's no formal standard for C++. Many C programmers are just starting to appreciate programming in a mature, standardized language. Understandably, they are reluctant to switch to C++.<P>
Most of all, I think C programmers are confused, intimidated, or just put off by the overly zealous preaching of a few highly vocal "true believers" in OOP. These zealots are hard to avoid &#151; every software development organization seems to have at least one. The zealots want you to believe that you shouldn't use C++ for anything other than OOP (using both inheritance and polymorphism).<P>
I've heard C programmers express their frustration with learning C++ under the shadow of a zealot. It's rather disconcerting to have your self-improvement efforts belittled by someone who thinks you haven't improved enough. You expect to hear, "Keep up the good work!" Instead you hear, "OK, but you really could have done it better." (Some of my former university students will probably be amused to read this, wondering, "When did this guy mellow out?" Age works wonders on us all.)<P>
The fact is, to a C programmer, C++ has many new features. Don't expect to grasp them all at once. Many of these features are intended to solve problems that arise in large-scale software systems. Small programming examples such as printing <I>Hello, world</I>, rarely make a convincing case for the advantages of C++ over C. To really learn C++, you need to work through large examples that take time to develop.<P>
Complex programming problems usually have more than one solution. You should try different approaches to see which one works best for each situation. As Bjarne Stroustrup wrote in his first book on C++, "To write good programs takes intelligence, taste, and patience. You are not going to get it right the first time; experiment!" <a href="#ref1">[1]</a><P>
Experimenting is fine if you're just writing practice programs, but most programmers must work for a living. They don't have much spare time to experiment with different design and programming techniques. Programmers and project managers must continue to try new tools and techniques to improve quality and productivity, but too much innovation all at once is risky.<P>
If you use object-oriented techniques in your first large C++ program, you might develop some reusable components that dramatically reduce the program's code size. More likely, you'll make lots of mistakes. If you believe, as Fred Brooks suggests <a href="#ref2">[2]</a>, that you should "plan to throw one away," then maybe you can plunge into C++ and OOP all at once. If you're not prepared to throw the program away, you're courting disaster.<P>
<h4><FONT COLOR="#000080"><A name="0097_005B">Learning C++ In Stages<A name="0097_005B"></FONT></h4></P>
As an alternative, I think it's not only possible but preferable, to learn and apply C++ in stages. You can't learn to use virtual functions (polymorphism) unless you understand inheritance, and inheritance only makes sense if you understand classes (encapsulation). The best way to learn encapsulation is to apply it in real programs, and you can write lots of useful C++ programs using encapsulation without inheritance. Languages that provide encapsulation without inheritance are called <I>object-based</I> <a href="#ref3">[3]</a>, whereas languages that support inheritance are called <I>object-oriented</I>.<P>
Most people learn to program by reliving the evolution of programming languages. New languages appear as programmers run up against the limitations of existing languages. Object-based languages, like Ada and Modula-2, represent a major evolutionary step between data-structured languages, such as C and Pascal, and object-oriented languages such as C++. Just as the languages took years to evolve, programmers need time (months, if not years) to progress through these evolutionary stages. Everyone progresses at a different rate.<P>
If you've ever tried explaining the virtues of pointers and user-defined data types to a FORTRAN programmer, then you probably know what I'm talking about. Most FORTRAN programmers who crunch numbers for a living can't understand why arrays aren't adequate for structuring any collection of data you could ever want. I've had similar difficulty explaining information hiding (encapsulation) to students who have never maintained someone else's code. If you haven't experienced the problem, you can't appreciate the solution.<P>
Many C programmers want to start using C++, but they're reluctant to take the OOP plunge. OOP is not the only reservation programmers have about C++, but it is significant. C++ is, for all practical purposes, a superset of C. C++ was designed to be integrated with existing C code and practice. The language permits you &#151; but doesn't force you &#151; to overhaul your design and programming styles. You can gain a lot by using C++, even if you only apply it a little bit at a time.<P>
If you want to start small with C++, then use it as an object-based language. Find some part of your application that could be a separate, well-defined entity, and implement that entity as a class. Try writing the class so that its public interface hides the implementation details from the rest of the application. The following example does this by analyzing the weaknesses of an existing C program.<P>
<h4><FONT COLOR="#000080"><A name="0097_005C">A Cross-Reference Generator<A name="0097_005C"></FONT></h4></P>
A cross-reference generator program reads a document and prints an alphabetized list of the words appearing in that document. Each word in the output listing is followed by a sequence of line numbers on which that word appears in the document. For example, if the word <I>object</I> appears once on lines 3, 19, and 100, and twice on line 81, then the cross-reference listing entry for object is<P>
<pre>object   3 19 81 100</pre>
This program is suggested as exercise 6-3 in K &amp; R <a href="#ref4">[4]</a>.<P>
<A href="list1.htm">Listing 1</a>
shows a portion of <I>xr.c</I>, an implementation of the cross-reference generator. <I>xr</I> is based on the solution presented by Tondo and Gimpel <a href="#ref5">[5]</a>. I modified their solution to compile in C++ as well as C, and made a few small stylistic changes.<P>
<I>xr</I> works as follows: Each call to <I>getword</I> reads the next word, punctuation character, or newline character from the input document. If <I>getword </I>returns a word (a sequence of letters and digits starting with a letter), the program adds an entry to the cross-reference table containing that word and the current line number. If <I>getword </I>returns a newline, the programs increments the current line number. After reading the entire input, the program prints the cross-reference listing.<P>
<h4><FONT COLOR="#000080"><A name="0097_005D">Hiding The Details<A name="0097_005D"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
illustrates a problem that plagues most large programs. The program contains declarations at the main level that reveal design and implementation decisions made at lower levels. These declarations reduce the program's readability and maintainability by cluttering the main level with inappropriate detail. This clutter isn't much trouble in small programs but can be overwhelming in programs with tens or hundreds of declarations.<P>
For example, it's evident from <A href="list1.htm">Listing 1</a>
that <I>xr </I>implements the cross-reference table as a binary tree. Why? For starters, the function that adds an entry to the cross-reference is called <I>addtree</I>, and the output function is called <I>printtree</I>. Both functions accept <I>root</I> as an argument, and <I>root</I> is of type <I>treenode</I> *.<P>
If you refer to my description of how <I>xr</I> works, you'll see that it never mentions trees. At this level in the program design, you don't need to know <I>how</I> the table is implemented, but you should know <I>what</I> the table does<P>
A good implementation of the cross-reference program keeps these concerns separate. Each design decision, like the structure of the cross-reference table, should be hidden in a separate part of the program. This practice of isolating design decisions is known as information hiding or data hiding. In the OOP world, it's called encapsulation.<P>
C provides only limited support for encapsulation. You hide information by placing code in separately compiled modules. Understanding the technique and its limitations will help you appreciate C++ classes, so I'll demonstrate the technique by applying it in the implementation of <I>xr</I>.<P>
<h4><FONT COLOR="#000080"><A name="0097_005E">Encapsulation With C<A name="0097_005E"></FONT></h4></P>
<A href="list2.htm">Listing 2</a> through <A href="list4.htm">4</A> present a better implementation of <I>xr </I>using some encapsulation by separate compilation. <I>xr.c </I>(<A href="list2.htm">Listing 2</a>)
 is the main source file. The implementation of the cross-reference table is hidden in <I>xrt.c</I> (<A href="list3.htm">Listing 3</a>)
. The header <I>xrt.h</I> (<A href="list4.htm">Listing 4</a>)
 defines the interface to <I>xrt.c</I>. That is, the header declares the functions through which the main program accesses the hidden table.<P>
Notice that all evidence that the cross-reference table is a binary tree is gone from the <I>xr.c.</I> The variable <I>root</I>, the functions <I>addtree</I> and <I>printtree</I>, and the <I>struct</I> definitions have all been moved from <I>xr.c</I> to <I>xrt.c. root, addtree</I>, and <I>printtree</I> are declared static in <I>xrt.c</I>, so they can't be referenced directly by code in <I>xr.c</I>.<P>
The functions <I>xrt_add</I> and <I>xrt_print</I>, declared in <I>xrt.h </I>and defined in <I>xrt.c</I>, provide the only access from <I>xr.c</I> to cross-reference table data structure. Instead of calling <I>addtree </I>directly, <I>main</I> must call <I>xrt_add. xrt_add</I> passes <I>root</I> to a call to <I>addtree</I> but keeps both <I>root</I> and <I>addtree</I> hidden inside <I>xrt.c</I>. Similarly, <I>main</I> must call <I>xrt_print</I> to invoke <I>printtree</I>.<P>
The key to this encapsulation technique is the selective use of the static storage specifier. You place the data to be hidden, along with the functions that manipulate that data, in a single, separate source file. You declare all the data at file scope, and almost all of the functions <I>static</I>. The only functions that should be <I>extern</I> are those few that grant access to the data structure from the outside world. The access function names and prototypes should clearly indicate <I>what</I> they do, but give little or no clue as to <I>how</I> they work.<P>
This implementation of <I>xr</I> is more readable than the first one. The input processing is clearly distinct from the table processing. <I>main</I> more clearly describes what it does without unnecessary and intrusive details about the inner workings of the table. This program is also more maintainable. The structure of the cross-reference table is so well hidden that you can change it to a b-tree or hash table without even recompiling the main source file.<P>
<h4><FONT COLOR="#000080"><A name="0097_005F">Where C Breaks Down<A name="0097_005F"></FONT></h4></P>
Ideally, each encapsulation unit hides a single design decision. However, the table implementation in <I>xrt.c</I> (<A href="list3.htm">Listing 3</a>)
 actually embodies two decisions:<P>
<UL><li>the table is a binary tree</li>
<li>each sequence of line numbers is a singly-linked list referenced by a single pointer in each tree node</li></UL>
Just as the implementation of the table should be hidden from <I>main</I>, the implementation of each line number sequence should be hidden from the table module.<P>
Unfortunately, the separate compilation technique that seems to work so well at hiding the table is completely inadequate for hiding the implementation of the line number sequences. The problem is that there's exactly one sequence for each tree node. The representation of a sequence must be declared as part of <I>struct treenode</I>. You can't store the sequences in static data in another module.<P>
So what do you do? Implement line number sequences as a C++ class.<P>
<h4><FONT COLOR="#000080"><A name="0097_0060">Encapsulating With C++<A name="0097_0060"></FONT></h4></P>
The header file <I>ln_seq. h</I> (<A href="list5.htm">Listing 5</a>)
 contains the declaration for a class of line number sequences called <I>ln_seq. ln_seq</I> provides a constructor and two public access functions: <I>add</I> and <I>print</I>. The class has one private data member, <I>first</I>, which points to the first element in the linked list implementation of the sequence.<P>
Note that the type of each linked list node, <I>listnode</I>, is a nested type. That is, <I>listnode</I> is declared inside class <I>ln_seq. </I>Versions of C++ compatible with AT&amp;T C++ 2.0 (or earlier) treat nested classes as if they were declared in the scope of the enclosing class, but AT&amp;T C++ 2.1 (and the current draft standard for C++) treat nested classes as local to the enclosing class. My intention in <A href="list5.htm">Listing 5</a>
is that <I>listnode </I>should be private within <I>ln_seq.</I> Although many compilers don't yet enforce this access restriction, they will eventually.<P>
<I>ln_seq. cpp</I> (<A href="list6.htm">Listing 6</a>)
 implements the member functions of the class. The constructor <I>ln_seq::ln_seq</I> is trivial &#151; it just initializes the list to <I>null</I>. The body of <I>ln_seq::print</I> is simply the <I>for</I> loop that appeared in <I>xrt_print. ln_seq::add </I>is the <I>addnumber</I> function from <A href="list3.htm">Listing 3</a>,
 with one noteworthy change.<P>
<I>ln_seq::add</I> contains additional code to handle the case where the list is empty, i.e., <I>first</I> is <I>null. addnumber</I> never confronts this case because <I>addtree</I> (<A href="list3.htm">Listing 3</a>)
 creates each list with an initial node. I could have written the constructor to initialize the sequence with an initial line number, but handling the <I>null</I> in the <I>add</I> function is easier.<P>
<A href="list7.htm">Listing 7</a>
shows <I>xrt.cpp</I>, the cross-reference table handler rewritten using the line number sequence class. It now shows no hint of how the sequences are implemented. You can safely change the implementation of <I>ln_seq</I> without changing <I>xrt. cpp</I> (although you will probably need to recompile).<P>
For example, if you use only a single pointer to the head of each list, then every time you add an element, you have to search through the entire list to find the end. If you track the end of each list in a second pointer, you eliminate the searching. <A href="list8.htm">Listing 8</a>
and <A href="list9.htm">Listing 9</a>
show this alternative implementation.<P>
An added benefit of using classes is that it forces you to think carefully about the interfaces between components of your program. For example, notice that the first parameter of <I>addnumber</I> (<A href="list3.htm">Listing 3</a>)
 is a <I>treenode</I>, not a <I>listnode</I>. The function adds a line number to the sequence in a tree, rather than to a list by itself. The sloppiness of this design becomes apparent when you try to transform it into a member function of the line number sequence class.<P>
<h4><FONT COLOR="#000080"><A name="0097_0061">Looking Ahead<A name="0097_0061"></FONT></h4></P>
<I>xr</I> is now an object-based program with lots of line number sequence objects. It uses only the most basic features of C++, but I think the C++ version of <I>xrt</I> (<A href="list7.htm">Listing 7</a>)
 is better organized and more readable than the C version (<A href="list3.htm">Listing 3</a>)
. More improvements could be made, but they will keep until some future column.<P>
You don't need a crash course in object-oriented design to write your first practical C++ class in a real-live application. Just identify a design decision and create a class to hide it. With practice, you'll get good at it.<P>
<h4>References</FONT></h4></P>
<a name="ref1">[1]</a>     Stroustrup, Bjarne, <I>The C++ Programming Language</I>. Addison-Wesley, Reading, MA, 1986.<P>
<a name="ref2">[2]</a>     Brooks, Fred, <I>The Mythical Man-Month</I>. Addison-Wesley, Reading, MA, 1975.<P>
<a name="ref3">[3]</a>     Wegner, Peter, "Concepts and Paradigms of Object-Oriented Programming," <I>OOPS Messenger</I>, Vol. 1, No. 1, Aug 1990.<P>
<a name="ref4">[4]</a>     Kernighan, Brian and Ritchie, Dennis, <I>The C Programming Language</I>, 2nd ed. Prentice-Hall, Englewood Cliffs, NJ, 1988.<P>
<a name="ref5">[5]</a>     Tondo, Clovis and Gimpel, Scott, <I>The C Answer Book</I>, 2nd ed. Prentice-Hall, Englewood Cliffs, NJ, 1989.<P>

<h4><a href="../../../source/1991/mar91/saks.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
