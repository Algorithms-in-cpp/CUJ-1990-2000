


<HTML>
<HEAD>

<TITLE>March 1991/Building Embedded Systems With Turbo C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Real-Time Programming</FONT></H2>

<hr><h2 align="center"><font color="#800000">Building Embedded Systems With Turbo C<A name="0084_004C"><A name="0084_004C"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0084_0000"><A name="0084_0000">Pat Villani</font></h3><hr><blockquote><P>
<P><i><A name="0084_0000"><A name="0084_0000">Pat Villani received his B.S.E.E. from Polytechnic Institute of Brooklyn and his M.S.E.E. from Polytechnic Institute of New York. Pat has developed applications ranging from avionics and guidance to computer peripherals. He is president of Network Software Systems, Ltd., which specializes in C applications and embedded control systems. Readers may reach him at (908) 206-0320.</i></P><P>
Embedded systems have traditionally represented a specialized area of computer science and electrical engineering, an application where both disciplines merge. System design often requires tradeoffs between programming convenience and system cost. Quite often, code produced for embedded systems is created by both software and hardware engineers.<P>
The first microprocessors used in embedded systems implemented a lot of code in assembly langauage because of the type of software development packages available for these processors. These packages were often expensive and required the manufacturer's development system or a large machine to build code. Only large corporations could afford these programming platforms. As microprocessor capabilities increased, manufacturers introduced programming langauges geared toward embedded systems. These new languages were limited to the same platforms, so the trend of limited embedded system development continued.<P>
Concurrently, great strides were made in desktop computers. These computers, based on the same microprocessors that were used in embedded systems, were capable of running applications and small software development packages that targeted these machines. Further developments in desktop computers enabled the developers of these packages to include more advanced features. The result: powerful langauges such as the Borland Turbo languages and Microsoft languages that include debuggers and integrated development environments that allow rapid development of applications.<P>
Today, low-cost clone motherboards, hybrids, and single chip computers based on XT and AT architectures exist. When combined with low-cost peripherals, these motherboards and devices present a unique opportunity to system developers. Low-cost and small-volume controllers, data loggers, and specialized processors are feasible. Adapting langauges such as Turbo C to produce code for these environments makes these designs even more affordable.<P>
<h4><FONT COLOR="#000080"><A name="0084_004D">Basic Principles<A name="0084_004D"></FONT></h4></P>
Compilers such as Borland Turbo C generate efficient code that is independent of any operating system. What ties the compiler to an operating system or any environment is the system startup code and the libraries that are linked to produce the executable object file. Replacing these files with new files specific to embedded systems allows the code to work in an embedded system.<P>
The first file you must replace is the startup file. Turbo-C uses one of the files <I>COx. OBJ</I> (where <I>x </I>is <I>T, S, L</I>, etc., depending on the memory model used) found in <I>\TC\LIB</I>. This file transforms the unique parameters of MS-DOS passed at startup into the conventional C environment <I>argc, argv, envp</I>, and <I>errno</I>. The file also sets up the stacks and aligns the segments of memory.<P>
The next file that you must replace is the corresponding flavor of <I>\TC\LIB\Cx.LIB</I>. This file contains all the operating system calls, such as <I>read</I> and <I>write</I>. It also contains library functions such as <I>strcpy</I> and <I>tolower</I>. Our approach is to replace this file with a new library emulating these calls.<P>
<h4><FONT COLOR="#000080"><A name="0084_004E">Design Advantages<B><A name="0084_004E"></B></FONT></h4></P>
Rapid development is a key factor in today's market. This approach helps the system developer achieve this goal by reducing development time. The project is developed using the Turbo C integrated environment or Turbo Debugger. When the developer is satisfied with the code's functionality, the code is recompiled and linked using make files and the command line environment. A commercial or public domain locater is then used to create an EPROM for the target system.<P>
The project is quickly debugged in a convenient environment in which code changes are rapidly made and revision control is maintained. Using the Turbo Debugger, nearly all C code and assembly code can be debugged, registers examined, breakpoints set, etc., without the need for a costly in-circuit emulator. If a suitable ROM monitor is used during the final debug cycle, an in-circuit emulator may not be needed at all.<P>
Since the code is transported from an MS-DOS environment to a target system, the functional code can be easily transported to a different 80x86-based target system by simply changing the device drivers and library I/O files. This built-in hardware independence aids the developer in writing reusable code, further reducing development time in future projects.<P>
<h4><FONT COLOR="#000080"><A name="0084_004F">Example Project<B><A name="0084_004F"></B></FONT></h4></P>
The development of a simple 8086 ROM monitor illustrates this design approach (<A href="list1.htm">Listing 1</a>)
. The monitor, called <I>mon86</I>, performs two functions:<P>
<UL><li>examine and change memory</li>
<li>go to specified address</li></UL>
It uses a simple table-driven executive that can be extended by adding new table entries and suitable functions to execute these new commands. An error function terminates the table.<P>
The monitor uses only Turbo C calls that comply with both SVID and POSIX definitions, improving portability. DOS-unique system calls, such as <I>INT21</I>, etc., are not used. Using them would complicate the code by requiring the use of conditional preprocessor directives to selectively include the non-portable sections of code. It also complicates library coding, since it requires that DOS code also be emulated.<P>
For this project, the C library is broken into two libraries: a system call emulation and a portable C library. The example project uses simple I/O calls such as <I>read</I> and <I>write</I>. The functions <I>open, close</I>, and <I>ioctl</I> are also implemented for completeness. Restricting I/O function calls to this small set reduces the work required to implement the emulation package.<P>
The monitor C library calls are limited to simple <I>getc</I> and <I>putc</I>. These calls are implemented as links to Turbo C calls <I>_fputc</I> and <I>_fgetc</I>, which allow for full use of Turbo C's <I>&lt;stdio.h&gt;</I>, further enhancing portability. Also, simple formatted output is required for memory display. To achieve this with an eye on portability, the library provides an integer-only <I>printf</I>. The choice of a limited <I>printf</I> has two justifications:<P>
<UL><li>it is simpler to implement, because it does not require knowledge of compiler floating point representation</li>
<li>limiting its use to <I>int</I> and <I>long</I> guarantees that the floating-point library is not used, yielding smaller ROM code.</li></UL>
A machine library, called <I>libm. lib</I>, is also needed. This library is a collection of all subroutines required to supplment C operations not supported by the processor itself, such as <I>long</I> divides, multiplies, etc. These subroutines are naturally operating system independent. It is best to extract them from the Turbo C library as needed during the ROM build portion of the project. A limited library is built at that time by linking the final MS-DOS code, noting the routines used in the code map, and extracting and creating a new library of just those routines.<P>
<h4><FONT COLOR="#000080"><A name="0084_0050">Startup Assembly Code<B><A name="0084_0050"></B></FONT></h4></P>
Probably the most important piece of code for an embedded system is the system startup code (<A href="list2.htm">Listing 2</a>)
. This code will vary from compiler to compiler, but the same operations generally appear in some form. The first part of the module is usually initialization related to the assembler or compiler. For Turbo C, this is the specification of segments. It is here that the order of segments for the module is first specified. Turbo C requires three segments, MS-DOS requires one.<P>
MS-DOS requires a stack segment. In a .<I>EXE file</I>, this is the only segment specified in the header that is separate from the rest. That is why the stack segment is used by some locate utilities as a place to separate RAM code from ROM code when generating hex files suitable for EPROM programmers.<P>
Turbo C requires only three segments, <I>_TEXT, _DATA</I>, and <I>_BSS</I>. These closely follow the UNIX C model. The <I>mon86</I> generated here is a small version, therefore, the <I>CODE</I> segment is text only, and the <I>DATA</I> segment is used for data, bss (data initialized to zeros), and stack. These segments are mapped into <I>DGROUP</I>.<P>
All 80x86 processors begin executing code after reset at address 0xffff:0x0000. The usual procedure is to place a <I>far</I> jump at this location to the ROM entry address. For our example, the system entry point is defined as the <I>far</I> procedure <I>entry</I>. This label is used as the startup address supplied to the locater.<P>
Next, the processor is initialized. Initializing the processor means intializing any segment registers that the processor needs for proper operation. Since the module presented here is for an 8086 or 8088 machine, only the segment registers must be initialized. Note that segment register initialization is performed with all interrupts disabled, which prevents spurious interrupts that may occur during power-up from crashing the system.<P>
Once the processor is initialized, it usually requires the proper setting of the stack pointer. For this example, all you must do is initialize the <I>sp</I> and <I>bp</I> registers. Note that initializing the <I>bp</I> register is required by Turbo C code generation conventions, not by the 8086.<P>
Special hardware initialization should be performed after the processor has been initialized. This includes initializing the interrupt vector table, moving the data segment to RAM, and initializing the <I>_BSS</I> segment to all zeros to match C programming conventions. The example in <A href="list2.htm">Listing 2</a>
includes a hook for hardware initialization with a call to <I>__hdw_init</I>. (For clarity, I've omitted moving data and initializing vectors.)<P>
After system initialization, you must enter <I>main</I> so the application can run. You enter <I>main</I> by building the stack frame containing the arguments <I>envp, argv</I>, and <I>argc</I>. You use these arguments to pass system configuration information, dip switch settings, etc. to your C code. These arguments also serve as a convenient debugging tool, since you can test different configuration switch positions by passing a command line argument during the debugging phase.<P>
One critical piece of code that all systems require is the function <I>exit</I>. This code is very implementation sensitive. You may want to light LEDs and sound alarms. In certain cases, you may want only to display a message and restart. What to do when the application terminates must be decided during system design. The startup code also contains a call to <I>exit</I> just after the call to <I>main</I>, which allows <I>main</I> to return to its caller if an error occurs.<P>
One final small but necessary bit of code is <I>errno. errno</I> is the location where C usually stores an integer value to signify the error condition that occurred during a library or system call. Although using <I>errno</I> this way is not necessary in all embedded systems, it is safer to follow convention than risk an unkown subroutine yielding a link error. Your system call emulation will also make use of this variable, allowing for a closer emulation.<P>
<h4><FONT COLOR="#000080"><A name="0084_0051">Operating System Emulation<B><A name="0084_0051"></B></FONT></h4></P>
The design example uses a single file for operating system emulation (<A href="list3.htm">Listing 3</a>)
. This code closely emulates the standard C equivalents. Following this practice minimizes ROM debugging.<P>
A small data structure, <I>fd</I>, tracks file status. The only parameter set by <I>open</I> and <I>close</I> are file open or close status. This structure can be extended to satisfy system requirements, but should be kept as simple as possible to assure ease of debugging. The <I>open</I> call checks for only a single possible file to be opened. <I>/der/con</I> (the control console), <I>stdin, stdout</I>, and <I>stderr</I> are also hard-wired as read-only or write-only, as appropriate. In some systems, <I>open</I> and <I>close</I> will link to the I/O drivers to perform driver initialization.<P>
The most used portion of the emulation code is the functions <I>ioctl, read,</I> and <I>write</I>. The function <I>ioctl</I> is most often used for setting baud rates, screen modes, etc. It is shown here for completeness. The <I>write</I> function simply links to the driver call <I>_cout</I> (<A href="list4.htm">Listing 4</a>)
. It maps newlines into carriage return and line feed pairs. The <I>read</I> function buffers input. It terminates each request on receipt of a newline. Any necessary processing to put text in canonical C form should be performed here.<P>
<h4><FONT COLOR="#000080"><A name="0084_0052">Portable Library Functions<B><A name="0084_0052"></B></FONT></h4></P>
In order to simplify debugging, standard I/O calls should be emulated. This example uses <I>getc, puts</I>, and <I>printf</I>. The functions here must closely emulate their respective MS-DOS counterparts, preventing unexpected surprises in the target system.<P>
Examining Turbo C's &lt;<I>stdio.h</I>&gt; file reveals that <I>getc</I> is a macro that invokes <I>fgetc</I> (as is typical in many systems). However, <I>_fgetc</I> calls DOS through another function, <I>_fgetc</I>. Therefore, your code closely follows this by mapping <I>_fgetc</I> and <I>_fputc</I> to return the correct values for success and error (<A href="list5.htm">Listing 5</a>)
. A simple <I>puts</I> is implemented in a portable fashion through calls to <I>putchar</I> (<A href="list6.htm">Listing 6</a>)
.<P>
This application uses the abbreviated version of <I>printf</I> described earlier (<A href="list7.htm">Listing 7</a>)
. This function only calls <I>write</I>, which minimizes unexpected dependencies on other library functions. Guaranteeing that floating point is not used helps in not wasting ROM space, usually a premium when system cost is considered. In many embedded applications, the only requirements for floating point support result from <I>printf'</I>s floating point display options.<P>
<h4><FONT COLOR="#000080"><A name="0084_0053">Programming And Debugging<A name="0084_0053"></FONT></h4></P>
Turbo C's greatest asset is its integrated programming environment. A bug can be quickly discovered and the code can be quickly recompiled from the same environment. Typically, it is in this environment that the first operational code is developed. (An interesting note: the new environment for Turbo C++ includes a register display window that works well with files assembled using the masm debugging switch). This phase should be used for all logic testing and customer demonstrations, since it is the most flexible of the development phases.<P>
Once the main logic has been debugged, the code should be linked with the portable libraries and tested. <A href="list8.htm">Listing 8</a>
shows an example make file. Both DOS and ROM version targets should be defined, so that any changes that may be necessary to the main logic resulting from target system testing can be incorporated into the DOS version and retested in the integrated environment. The make file presented here also contains two additional targets, <I>ex0</I> and <I>ex0r</I>. These targets are typically limited versions that test the device drivers. Quite often, these versions provide repeating patterns and echo routines for testing peripherals. Upon satisfactory completion of testing, the resulting code is burned into a final EPROM and delivered.<P>
<h4><FONT COLOR="#000080"><A name="0084_0054">Conclusions<A name="0084_0054"></FONT></h4></P>
This example provides a good start for an embedded system design. Although the XT and AT architecture is used for this example, the techniques presented here are not limited to them. These techniques have been used for new designs in projects ranging from simple computer peripherals, such as printers and tape transports, to specialized sonar signal analysis hardware. They provide a broad approach that can be applied to both native and cross compilations, substituting cross compilers and cross compilation targets in the make file.<P>
Of course, an embedded system need not include support for <I>printf, read, or write</I>. An application can instead make simple calls directly to the device driver, which results in much smaller code. However, since many tradeoffs are considered during the system design phase, more often than not the extra functions are worth providing.<P>

<h4><a href="../../../source/1991/mar91/villani.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
