

<HTML>
<HEAD>

<TITLE>June 1994/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="012F_0099"><A name="012F_0099"></font></h2><hr>
<BLOCKQUOTE>
<h4><FONT COLOR="#000080"><A name="012F_0000"><A name="012F_0000">Errata</FONT></h4></P>
Errata for Chuck Allison's column, "Code Capsules: The Preprocessor," <I>CUJ</I>, March 1994:<P>
1)     Page 103, column 1, change<P>
<pre>((-4) &gt;=0 ? (4) : (-(4)))</pre>
to<P>
<pre>((-4) &gt;= 0 ? (-4) : (-(-4)))</pre>
2)     Page 105, column 1, change<P>
<pre>#ifdef __cplusplus
#endif</pre>
to<P>
<pre>#ifdef __cplusplus
}
#endif</pre>
3)     Page 106, column 2, add a semi-colon after <I>assert(x != y)</I> in:<P>
<pre>if (x &gt; 0)
   assert(x != y); /* semi-colon was missing */</pre>
4)     Delete the following lines from Listing 5:<P>
<pre>#undef assert
#ifdef NDEBUG
#define assert(cond)
   (void) 0
#else</pre>
pjp<P>
In December's issue, a reader Mr. Hardy asked about pcx importing in C. First, he should probably get one of the good inexpensive compilers like Turbo, Quick C, etc. But then, I have found that Genus Microprogramming's pcx toolkit is an exceptional value and the tech people are friendly and helpful. In addition, Mr. Hardy could download a handy pcx drawing program (shareware license is only $45). All in all, this would be a good budget way to get into what he wants to do.<P>
Genus Microprogramming's number is 1 800 227 0918. Hope this helps him. :&gt; <I>uunet!sosc1.sosc.osshe.edu!ferrell</I><P>
P.J. Plauger<P>
Frank Campbell's letter reminds me of something I like to say: Computer Science is an oxymoron. There is no science to computers (well, there is science, but just getting a computer science degree does not make one a good practicioner). Software is like any writing: good writers are rare and hard to find. It is much more of an art than a science. And many who preach computer science cannot write very good programs. Many (SEI?) want to make writing software a "process." But I don't see how you can effectively make a process for creativity if you want high quality software (maintable, easy to use, easy to modify, efficient).<P>
I also liked the fact you said "where C++ comes into its own is with larger programs (where 'large' is admittedly a relative term)." I like this position much better than the one you advocated several years ago where "anything over 100k lines should be written in ADA." I had an electronic conversation about "large" with Dennis Ritchie several years ago. What he discussed was that the idea behind Unix was not building large monilithic systems, but writing a number of smaller programs which communicated effectively. It is far easier to integrate independent programs into a system than have one big program lots of people work on. (They reprinted much of this letter several years ago in <I>DDJ</I>. I can dig it up for you if you want to republish. I wrote the letter to <I>DDJ</I> in response to an interview with someone who said "C is a brain-dead language" ;-) )<P>
Manuel Lopez talked about Pc/VI. If memory serves me correctly, PC/VI was an excellent vi clone &#151; too good, it was vi &#151; they were sued by ATT and had to close shop (this is from recollection). I used the Manx Z briefly and wasn't thrilled by it.<P>
What is very good is Elvis (a vi clone). It is distributed as part of the GNU project and runs on MS-DOS and Unix. A major advantage is it runs the same way on both systems. In addition, when xterm windows on unix are resized, elvis adjusts its size dynamically to the correct dimensions (a major advantage over other vi-s). Also, it sidescrolls for long lines.<P>
One of these days, I still have to learn EMACS &#151; and start using it.<P>
marty<br>
<I>leisner@eso.mc.xerox.com leisner.henr801c@xerox.com</I> Member of the League for Programming Freedom<P>
<I>As a writer myself, I can't help but agree that both programming and writing are creative processes. But as a person who endeavors to be professional about both, I also keep striving for a "process" that improves my chances of being adequately creative on demand. You should notice that picking a text editor you know, love, and are comfortable with is one of the small things you do to up the odds that you'll deliver the goods. Both of these letters underscore the importance of that choice. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
I noticed while reading "C++ Library Ground Rules" in the November issue of <I>The C Users Journal</I> that the C++ Standards Committee may approve using header names with no suffix added. This would ruin the logic behind the way I store files on my hard disk. The sorting scheme I use is to sort first by extension and then by name. Hence the uppermost files in any directory listing are subdirectories. The remainder of the filenames in the listing all have extensions.<P>
If the C++ Standards Committee adopts this naming convention then all C++ header files will be intermixed with subdirectory names on my hard disk. Furthermore some vendors supply software that have a few miscellaneous files without extensions which would also be intermixed with the subdirectory names and header names. The first thing I would have to do is add my own extension to all the C++ headers.<P>
I urge, through you, that the C++ Standards Committee adopts a naming convention for C++ headers that includes a suffix. For example *.hpp or *.hp, or even *.hxx. If this were the case then any file with an extension of hpp (or hp or hxx) would be guaranteed to be a C++ header file. I know this is a minor point but just in case others are concerned I want to add my name to the list.<P>
Best Regards<P>
Pete Melissakis<P>
<I>The final word may have only recently been spoken in the C++ standard. (An odd comment, this, on a standards effort that has entered its fifth year, for a language in use for over a decade</I>, nicht wahr?) <I>Tom Plum and I have already discovered similar problems in retreading C source-code control techniques for C++ code. Watch this space. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger;<P>
I have been a CUG member and <I>C Users Journal</I> subscriber for many years, and I have enjoyed your column on the C standards as well as your books on the same subject. I have found that your books and columns have given me ample material to help me in my development efforts, especially since an important focus for me is portability.<P>
As you delve into C++ and the integration of C constructs and libraries into the new language standard, you do an excellent job of pointing out the successes and the "gotchas" that a standards organization goes through to accomplish what must seem an insurmountable task.<P>
It is your latest "Standard C" columns (<I>CUJ</I> Dec. '93) that prompts me to write, because you make a statement that is confusing and unsettling to someone who has been programming in C for many years. On the third page, you touch on the use of the <I>NULL</I> macro, and give some of the conversions used in many dialects of C, then you go on to say that we shouldn't be using <I>NULL</I> in new programs. Do you mean C++ programs? I have been using <I>NULL</I> explicitly for years and find it to be an excellent way to "document" what I mean in certain pointer expressions. I don't do nearly as much development now as I used to, but I'd hate to think that all the programs I've written to date share one large ignorant flaw in the use of the <I>NULL</I> macro. If you get a chance, it would be very helpful to get a quick clarification on this. Thanks so much for your time, and keep up the great work!<P>
Brian Smithson<br>
Project Manager<br>
Workgroup Solutions, Inc.<P>
<I>I too have used</I><I> </I>NULL<I> for decades as a great way to document that I am using a null pointer constant. It is also useful, in very limited circumstances, to be sure I pass a pointer-size argument in the absence of a function prototype. The only such context that is now socially acceptable is when calling a function that takes a varying-length argument list. And the risk is still great that</I> NULL<I> may not have exactly the right representation, since it only assuredly looks like a pointer to void, not like a pointer to function or even some complete data type.</I><P>
<I>Stronger type checking, both in C and C</I>++<I>, now encourages me to shelve that long-standing style rule. A bald 0 is now almost always clearly a null pointer constant, both to the translator and to the human reader, just from context:</I><P>
<pre>if (p !=0)
   ...</pre>
<I>Where it is not clear, I strongly favor an explicitly cast zero, as in </I>(int *)0<I>, to make the intent obvious to all comers. There is no real need for </I>NULL<I> in this scheme. So since</I> NULL<I> can cause minor headaches in C++ programs, I've learned to stop writing it. I've been happy with the new style, so far. &#151; pjp</I><P>
Dear Mr. Plauger,<P>
I have recently took on the task of teaching myself C. After graduating college with a minor in computer science, I wanted to get more information on the programming language that they did not offer at my school, but I heard so much about. The classes I got a background in is assembly, COBOL, Basic, and Pascal.<P>
The first tasks I did was to subscribe to <I>The C Users Journal,</I> bought a compiler (Turbo C), and several books on the basic syntax. Out of all the information that I have accumulated since these early days, I have found no information on using C on a Novell network. Could you help me find the information I need for building functions that have record lock capabilities for the DBMS I'm trying to write. As networking, downsizing, and rightsizing continue to grow the information myself and maybe others need cannot be found. It would also be helpful if the magazine could have an article about this specific subject, or on the subject of DBMS on a network. Thanks for all the useful information over the past year.<P>
Sincerely,<P>
Randy Chapman<br>
5843 Georgetown Colony<br>
Houston, TX 77084<P>
<I>I was in a computer bookstore yesterday and recall seeing at least two titles that offered to teach a modicum of Novell network programming using C, but I don't recall authors or titles. We run an occasional article on the same subject, but probably not more often than once a year or so. Your request is noted. &#151; pjp</I><P>
<I>[Two books you may want to investigate are:</I> Netware System Interface Technical Overiew<I>, ISBN 0-201-57027-0, and</I> Netware 386 Programmer's Guide,<I> ISBN 0-201-57709-7, both published by Addison-Wesley. The first book is the offical reference to Novell's C Network Compiler, and describes all of the NetWare 2.15 API. The second book focuses on NetWare Loadable Modules (NLMs) and version 1.2 of the NetWare C Interface Library. These books are available from the C Users Bookstore &#151; contact R&amp;D Publications at (913) 841-1631. &#151; mb]</I><P>
Dear PJ<P>
I want to start off by commending you very highly indeed for producing such an excellent magazine. In my opinion it presents just the right balance between technical articles and advertisements, making it appealing to a wide range of audience. Being one of the few (if not the only person) trying to make a living in Cape Town as a freelance software engineer, I treat it as a lifeline in this often "turbulent" world of new software developments.<P>
The reason for writing this letter is that I really want to throw the cat amongst the pigeons by raising a very touchy subject indeed, and that is software documentation. A colleague and myself have been using Nassi-Schenidermann structure charts for a very long time, and not only for purposes of documentation, but also for purposes of conceptualising and writing code. It is our opinion that there is no point in attempting to write code until you have got your "ducks in a row," because if you haven't, you often "bend" the code to solve what may have been a poorly conceived solution. Why should you then, once you have been through the process of conceptualisation, throw it all away by transferring your thoughts to code using your own personal programming style only?<P>
I believe that there must be merit in what I am saying, otherwise a company like SIP Software Solutions wouldn't have a market for their GESY product today. Perhaps you could consider asking them to write a technical article for a future publications, on the benefits of using their approach to software development. Or am I perhaps seeing the world through the eyes of a software engineer as opposed to a computer scientist &#151; scientists invent and develop the technology whereas engineers have to implement and maintain it. It worries me though that I have never seen anyone else using this technique.<P>
There are two other aids that my colleagues and myself have also developed over the years. The first is to replace the zillions of curly braces in a piece of code with something a little more user-friendly, and that is to create a small header file called syntax.h which consists of the following:<P>
<pre>#define FALSE     0
#define TRUE      !FALSE
               // !!! Strictly according to C
#define END_if }
#define END_while }
etc.</pre>
(Unfortunately the definition of <I>TRUE</I> backfired on us because the rest of the world is using <I>#define TRUE 1.</I>)<P>
The other aid which I find to be tremendously useful is to prefix variables with up to three lower-case letters indicating what type of variable it is (I believe it is called Hungarian notation), much like the system used in Windows and BORLAND's Object Windows. The reason is quite simple, and that is once the variable declaration is no longer visible, it is no longer obvious what data type that variable represents. For example, <I>t</I> could be an integer, a pointer to a structure, or whatever, whereas <I>psTime</I> is clearly a pointer to a time structure. Once again, I have never seen anyone else using it to the same extent as I do, i.e. every single variable has a prefix.<P>
<A href="list1.htm">Listing 1</a>
shows an example program using these techniques. Of course, it helps greatly to have a compiler which displays the code and comments in different colours, thus improving the readability! <A href="list2.htm">Listing 2</a>
shows what the code looks like once it has been through a NassiSchneidermann generator. Naturally it doesn't help if the pseudo-code is just a regurgitation of the actual code, it should rather describe the process.<P>
In Bruce Eckel's book C++ <I>Inside and Out</I> he cites one of the reasons for using C++ as its tendency to be self-documenting, which is good because documentation is not maintained anyway. I don't disagree with him, but I also feel that a good software engineer is one who maintains the right balance between creativity and discipline. I, for one, would really appreciate some more articles in <I>CUJ</I> on the less glamorous software issues such as the design process, the software life cycle, and documentation and maintenance.<P>
Yours faithfully<P>
Jan Booysen<br>
11 Centlivres Crescent<br>
7441, BLOUBERGRANT<br>
South Africa<P>
<I>I've seen all the techniques you favor used to advantage on various projects over the years. I tell you what I tell everyone else &#151; if it works for you, stick with it. I'd run more articles on programming style and documentation if most submissions weren't so darned abstract. We endeavor to meet the needs of practicing C and C</I>++<I> programmers, not debate the putative merits of various approaches to software engineering. Few articles offer pragmatic advice at the direct level found in your letter. &#151; pjp</I><P>
Dear P.J. Plauger:<P>
I just read your article on "Standard C" in the January issue of the <I>CUJ</I> and I have one question. On page 14, you have the following:<P>
<pre>int d1, d2, n1, n2, i;
i = sscanf("123", "%d%n%n%d", &amp;d1, &amp;n1, &amp;n2, &amp;d2);</pre>
You indicated that the value <I>3</I> is assigned to <I>i</I>. However, my reading of K&amp;R tells me that <I>%n</I> does not increment the converted item count and so I would expect the value <I>1</I> to be assigned to <I>i</I>. After reading your article, I did not get the impression that this is a change, but merely a clarification of the standard. Could you then resolve this inconsistency then?<P>
Jim Hsin<br>
<I>jimh@netcom.com</I> "Fiat Slug!"<P>
<I>You're right. My reading of the C Standard says that the value</I><I> 1</I><I> should be stored in </I><I>i</I><I>. Thanks, &#151; pjp</I><P>

<h4><a href="../../../source/1994/jun94/letters.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
