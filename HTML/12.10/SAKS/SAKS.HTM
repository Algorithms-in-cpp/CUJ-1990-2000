

<HTML>
<HEAD>

<TITLE>October 1994/Stepping Up To C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Stepping Up To C++<A name="0193_00E0"><A name="0193_00E0"></font></h2><P>
<h3 align="center"><A name="0193_0000"><A name="0193_0000">Designing Generic Container Classes, Part 4</h3><P>
<h3 align="center"><font color="#800000">Dan Saks</font></h3><hr><blockquote><P>
<P><i><A name="0193_0000"><A name="0193_0000">Dan Saks is the president of Saks &amp; Associates, which offers consulting and training in C++ and C. He is secretary of the ANSI and ISO C++ committees. Dan is coauthor of C++ Programming Guidelines, and codeveloper of the Plum Hall Validation Suite for C++ (both with Thomas Plum). You can reach him at 393 Leander Dr., Springfield OH, 45504-4906, by phone at (513)324-3601, or electronically at dsaks@wittenberg.edu.</i></P><P>
This is the fourth part in my series on designing and implementing generic container classes. A container (a.k.a. collection) is a data structure, such as a list, tree, or vector, that holds other objects. A generic container class is a single class definition for a particular type of container that you can readily adapt to hold objects of various types. In contrast, a specific container class holds objects of only one specific type.<P>
In the first part of this series I introduced one popular design for generic containers, namely, as containers of <I>void *.</I> (See "Stepping Up to C++: Designing Generic Container Classes, Part 1," <I>CUJ</I>, June, 1994.) As such, a generic container actually holds pointers to the elements in the collection, rather than holding the elements themselves. <I>void *</I> is the generic pointer type &#151; a pointer to void can hold the address of any type of object. Thus, you can put objects of any type into one of these generic containers.<P>
My example has been a class called <I>genq</I> that implements a generic first-in-first-out queue as a list of pointers to <I>void</I>. The private data of a <I>genq</I> object is a pair of pointers to the first and last cell, respectively, in a linked list of cells. Each cell contains a pointer (of type <I>void *</I>) to a queued element along with a pointer to the next cell in the list.<P>
<I>genq</I> has undergone several revisions over its lifetime. In Part 2 of this series (August, 1994), I replaced <I>genq'</I>s<I> print</I> member function with a much more general iteration function called <I>apply</I>. In Part 3 (September, 1994), I replaced the iteration function with an even more general iterator object type.<P>
The latest version of the <I>genq</I> class definition (with a nested iterator type) appears in <A href="list1.htm">Listing 1</a>.
 <I>genq</I> provides a default constructor, along with the following operations:<P>
<I>void append(void *e)</I> &#151; append element <I>e</I> to the end of a queue.<P>
<I>int remove(void *&amp;e)</I> <I></I>&#151; for a non-empty queue, remove an element from the head of the queue, place it in <I>e</I>, and return non-zero; for an empty queue, simply return zero without changing <I>e</I>.<P>
<I>genq</I> also provides a nested iterator type with the following operations:<P>
<I>iterator(genq &amp;q)</I> <I></I>&#151; initialize an iterator for iterating through <I>genq q</I>.<P>
<I>void *next()</I> <I></I>&#151; return the address of the next object in the queue associated with the iterator; or return a null pointer if no next object exists.<P>
The corresponding member function definitions, for both <I>genq</I> and <I>genq::iterator</I>, appear In <A href="list2.htm">Listing 2</a>.
<P>
Last month, I stated erroneously (in the introductory part of the article) that <I>genq</I> had a default constructor and a member function called <I>clear</I>. It did in its earlier incarnations. However, by Part 3, I had moved the default destructor and <I>clear</I> from <I>genq</I> into the wrapper classes such as <I>intq</I> and <I>strq</I>. I introduced wrapper classes in Part 2 as a technique for reconstructing static type information lost by using <I>void *</I> as the generic container element type.<P>
<h4><FONT COLOR="#000080"><A name="0193_00E1">Type Information Lost<A name="0193_00E1"></FONT></h4></P>
A queue of <I>void *</I> is generic simply because C++ applies very lax type checking to <I>void *</I>. A C++ program can convert any data pointer to a <I>void *</I> without using a cast. (However, it cannot convert a function pointer to <I>void *,</I> nor a <I>const</I> or <I>volatile</I> qualifier, without a cast.) Of course, this flexibility has a price, namely, that conversion to <I>void *</I> strips away static type information. Consequently, a generic container of <I>void *</I> knows very little about the objects it contains, and therefore cannot support as many operations as a container for a specific object type. The <I>clear</I> member function is a case in point.<P>
In Part 1, I presented two specific container classes, i<I>ntq</I> and <I>strq</I>. An <I>intq</I> is a queue of <I>int</I> and a <I>strq</I> is a queue of <I>str</I> (a variable-length string class type). It was the obvious similarity in these two classes that launched this quest for a single generic queue to replace them both.<P>
<I>intq</I> and <I>strq</I> each had a public member function called <I>clear,</I> implemented as shown in <A href="list3.htm">Listing 3</a>.
 (The <I>T</I> in the class name <I>Tq</I> stands for the type of elements in the queue, which in my examples has been either <I>int</I> or <I>str</I>.) The <I>clear</I> function is pretty straightforward; it visits each cell in the queue and applies<P>
<pre>delete p;</pre>
where <I>p</I> is the pointer to the current queue cell. That <I>delete</I> expression does more than just deallocate memory; it applies a destructor, if any, to the cell object addressed by <I>p</I>.<P>
The <I>cell</I> type that I used with <I>Tq</I> doesn't have an explicit destructor, but it has two data members:<P>
<pre>cell *next;
T element;</pre>
Although <I>next</I> has type <I>cell *</I>, which never has a destructor, <I>element</I> has type <I>T</I>, which could easily be a type, such as <I>str</I>, that has a destructor. In that case, the compiler synthesizes a destructor for <I>cell</I> which invokes the destructor for <I>element</I>. Thus, when <I>T</I> is <I>str</I>,<P>
<pre>delete p;</pre>
destroys the string stored in the cell as part of destroying the cell.<P>
Unlike a type-specific queue, a <I>genq</I> can't destroy the queued elements automatically. The element type in a <I>genq</I> cell is <I>void *</I>, which does not demand destruction. Thus, the generated cell destructor is <I>vacuous</I> or <I>trivial</I> <I></I>&#151; it does nothing, and the compiler may optimize it away. If, in a <I>genq</I>, the cell's element actually points to an object that has a destructor (as is the case when <I>element</I> actually points to a <I>str</I> object), then<P>
<pre>delete p;</pre>
in <I>clear</I> may cause memory leaks by failing to call that destructor. Again, converting a <I>str *</I> into a <I>void *</I> strips the static type information that a compiler needs to generate the appropriate destructor for the object referenced by the resulting <I>void *</I>.<P>
In Part 1, I tried fixing that leak by adding the line<P>
<pre>delete p-&gt;element;</pre>
to the <I>clear</I> function just before the existing <I>delete</I> expression. Alternatively, I could have written a destructor for the cell type as<P>
<pre>~cell() { delete element; }</pre>
so that deleting cell pointer <I>p</I> would invoke this destructor, and thus automatically delete <I>p-&gt;element.</I> Either way, <I>element</I> is still a pointer to <I>void</I>, which carries with it no information about the destructor for the object to which it points. Adding the extra <I>delete</I> expression will reduce, and sometimes eliminate the leaks, but don't count too heavily on it.<P>
In Part 2, I solved that problem by implementing type-specific wrapper classes around <I>genq</I>. That is, I wrote new versions of <I>intq</I> and <I>strq</I> that each wrapped a thin layer of member functions around a <I>genq</I>. The wrapper for a specific type uses explicit type conversions (casts) and a little extra code to restore the compile time type information lost by using <I>void *</I> elements. By confining the casts to just one small part of the code, wrappers make <I>genqs</I> both safer and easier to use.<P>
When you design a generic version of a specific container, you should expect that you won't be able to implement some of the functions from the specific container as part of the generic. You may have to omit some functions from the generic and implement them as part of a wrapper. That's exactly what I did with the <I>clear</I> function. When I moved <I>clear</I> from the generic to the wrapper, I had to drag the destructor along because all it does is call <I>clear</I>.<P>
Writing type-safe wrappers is not always easy. Ideally, the author of the generic should supply wrappers for every conceivable element type, but that's just not feasible. Thus end-users (in this case, application programmers) often must write their own wrappers.<P>
Last month, I said I'd look at techniques for automatically generating type-specific wrapper classes. But I forgot that there's another variation on generic containers that I should cover first.<P>
<h4><FONT COLOR="#000080"><A name="0193_00E2">Generic Containers of ABCs<A name="0193_00E2"></FONT></h4></P>
No doubt some of you have been wondering why I used a pointer to <I>void</I> as the generic container element type, when I could have used a pointer to an abstract base class instead. After all, C++ supports object-oriented programming techniques. Why not use them?<P>
An abstract base class (ABC) is a class with at least one pure virtual function. You cannot create objects of the ABC type, but you can derive classes from the ABC and create objects of the derived types. Whereas a pointer to <I>void</I> carries very little type information, a pointer or reference to an ABC type carries a potentially hefty bundle of type information in the form of overridden virtual functions. It's possible that using virtual functions may eliminate the need for wrapper classes. Let's try and see what happens.<P>
As you design a family of generic containers around an ABC, you must identify what the containers need to know about, or do to, the objects they contain. You use these requirements to design an ABC with declarations for pure virtual functions capable of supplying the required information and operations. Then you implement the generic containers using elements that are pointers to this ABC. The containers use virtual function calls to get the proper type-specific behavior from the objects they contain.<P>
For example, the <I>clear</I> function in a generic queue needs to know how to destroy an object in the queue. If the queue cell's element type is a pointer to an object with a virtual destructor, deleting that pointer invokes that object's destructor. Similarly, the generic queue's <I>remove</I> function must be able to copy an object from the queue. A virtual assignment operator <I>(operator=)</I> can fill that need quite well.<P>
<A href="list4.htm">Listing 4</a>
shows the header <I>common.h</I>, which defines class <I>common,</I> an abstract base class for containable objects <I></I>&#151; objects you can store into a generic container. <I>common</I> is based loosely on a class with the same name that AT&amp;T distributed with its early releases (versions 1.x) of the original C++ compiler. Class <I>common</I> also bears some resemblance to class <I>Object</I> in the NIH (National Institutes of Health) Class Library (<a href="#gorlen">Gorlen, et. al. [1990]<a name="xxx"></a>).<P>
My version of class <I>common</I> declares the following operations, all pure virtual:<P>
<I>common &amp;operator=(const common &amp;c)</I> <I></I>&#151; assign one <I>common</I> object to another, and return (a reference to) the left-hand operand.<P>
<I>common *dup() const</I> <I></I>&#151; return a duplicate copy of a <I>common</I> object.<P>
<I>size_t size() const</I> <I></I>&#151; return the size of a <I>common</I> object.<P>
<I>ostream &amp;write(ostream &amp;s) const</I> &#151; write a <I>common</I> object to an <I>ostream</I>.<P>
<I>istream &amp;read(istream &amp;s)</I> &#151; read a <I>common</I> object from an <I>istream</I>.<P>
Class <I>common</I> also provides a virtual (but not pure virtual) destructor with an empty body. As I explained a few months back, you must supply a definition for a pure virtual destructor, even if that definition has an empty body. Otherwise, you'll get a linker error. (See "Stepping Up to C++: Compilation Firewalls, Part 2," <I>CUJ</I>, May, 1994.)<P>
As an added bonus, <I>common.h</I> defines stream input and output operators <I>&gt;&gt;</I> and <I>&lt;&lt;</I> to put a prettier face on the read and write operations.<P>
Class <I>comq</I> is a generic queue that uses elements of type <I>common *</I>. The class definition for <I>comq</I> appears in <A href="list5.htm">Listing 5</a>,
 and the accompanying non-inline member function definitions appear in <A href="list6.htm">Listing 6</a>.
 These <I>comq</I> listings are strikingly similar to the most recent <I>genq</I> listing (<A href="list1.htm">Listing 1</a>
and <A href="list2.htm">Listing 2</a>)
. The most obvious difference is that <I>comq</I> uses <I>common * </I>in most (but not all) places where <I>genq</I> uses <I>void *. comq</I> also provides a <I>clear</I> function and a destructor (as discussed earlier) that <I>genq</I> does not. In addition, there are a few subtle, but important, differences worth noting.<P>
Rather than add a second <I>delete</I> statement inside the loop in the <I>clear</I> function (<A href="list6.htm">Listing 6</a>)
, I chose to add a destructor to the cell. The <I>delete</I> statement in <I>clear</I> invokes the cell's destructor, which in turn invokes the queued element's virtual destructor by deleting the element pointer. As a matter of style, I prefer to do resource management down in the class that owns the resource. In this case, the class is <I>comq::cell</I> and the resource is the object addressed by the cell's element pointer.<P>
In a few places, I translated parameters of <I>genq</I> member functions with parameters of type <I>void *</I> into <I>comq</I> member functions with parameters of type <I>[const] common &amp;.</I> For example, the declaration for <I>genq::append</I> is<P>
<pre>void genq::append(void *e)</pre>
but the declaration for <I>comq::append</I> is<P>
<pre>void comq::append(const common &amp;e)</pre>
Except for this, the functions are identical.<P>
The reason for this change is to make <I>comqs</I> look as if they have value rather than pointer semantics. <I>genqs</I> have obvious pointer semantics. For instance, calls to <I>genq::append</I> typically have the form<P>
<pre>q.append(new T(e));</pre>
But applications rarely call <I>genq:append</I> directly. Rather, they call a type-specific wrapper class's <I>append</I> function using an expression of the form<P>
<pre>q.append(e);</pre>
In turn, the wrapper's <I>append</I> function calls <I>new</I> and passes the resulting pointer to <I>genq::append</I>. All the wrapper class's member functions work in concert to create the illusion that the type-specific container class traffics in objects rather than pointers.<P>
A large part of my reason for using <I>common</I> <I>*</I> instead of <I>void</I> <I>*</I> is that I'm hoping to supply the generic queue with enough type information so that it doesn't need wrapper classes. At the same time, I don't want to lose the convenience of value semantics that the wrappers provide. Thus, the <I>comq</I> member functions must have (or at least look like they have) value semantics. Passing arguments by <I>reference-to-const</I> fills that bill quite nicely.<P>
However, a <I>comq</I>, like a wrapper class, only creates the appearance of value semantics; somewhere inside its <I>append</I> function, a <I>comq</I> must create its own dynamically-allocated copy of the queued value, so it can destroy the copy later on. <I>genq</I> needs a wrapper class to make the correct copy. <I>comq</I> uses <I>common'</I>s virtual <I>dup</I> function to make the copy. Again as a matter of style, I elected to call <I>dup</I> inside the cell's constructor to preserve the symmetry of resource allocation and deallocation with the cell class. The call to <I>dup</I> actually appears in the member-initializer for <I>element</I> in the cell constructor (<A href="list5.htm">Listing 5</a>)
.<P>
<I>comq::remove</I> has a parameter of type <I>common &amp;,</I> rather than <I>void</I> <I>*&amp;</I> as in <I>genq::remove</I>. The body of <I>comq::remove</I> (<A href="list6.htm">Listing 6</a>)
 is identical to <I>genq::remove</I> (from <A href="list2.htm">Listing 2</a>)
, except for the assignment statement<P>
<pre>e = *p-&gt;element;</pre>
which passes an element from the queue back through reference parameter <I>e.</I><P>
In <I>genq::remove</I>, the assignment is just<P>
<pre>e = p-&gt;element;</pre>
which passes the address of the queued object through a reference to a <I>void</I> <I>*</I>. Once again, applications rarely see these pointers to void. A type-specific wrapper intercepts the <I>void</I> <I>*</I>, casts the pointer to its original type, and then hands the queued object's value back to the application by copying it through a reference parameter.<P>
However, since <I>comq</I> dispenses with the wrapper class, <I>comq's remove</I> should copy the queued object's value (not its address) back to the application. (Again, users should see <I>comqs</I> as containing values, not pointers.) Since it doesn't know the exact type of the queued object, <I>comq::remove</I> needs a virtual assignment operator that copies objects appropriately. The assignment<P>
<pre>e = *p-&gt;element;</pre>
copies the value of the queued object into the object referenced by <I>e</I> using <I>e</I>'s virtual <I>operator=.</I> (This statement needs <I>a *</I> (dereferencing operator) on the right-hand side because <I>p-&gt;element</I> has type <I>common *</I>, but <I>e</I>'s<I> operator=</I> requires a right operand of type <I>common.</I>)<P>
<h4><FONT COLOR="#000080"><A name="0193_00E3">Adapting <B><I>common</I></B> for Specific Uses<A name="0193_00E3"></FONT></h4></P>
Although <I>comqs</I> no longer need wrapper classes (or so it seems), it turns out that <I>comqs are</I> not all that easy to use. The problem is that you can't just put any old object, like an <I>int</I> or a <I>str,</I> into a <I>comq.</I> You can only put objects of a type derived from <I>common</I> into a <I>comq.</I> Thus, if you want to use a <I>comq</I> as a queue of <I>str</I>, you must derive a class from <I>common</I> to be a containable <I>st</I>r <I></I>&#151; a <I>str</I> that can go into a queue. <A href="list8.htm">Listing 8</a>
shows the definition for class <I>comstr</I>, a containable <I>str.</I><P>
Class <I>comstr</I> is not an ABC. It has a private data member of type <I>str</I> (for holding a queued value), and it overrides all the pure virtual functions inherited from <I>common</I> with functions that make a <I>comstr</I> act like a <I>str</I>. <A href="list9.htm">Listing 9</a>
shows the definitions for these overriding functions, all of which are pretty straightforward except for <I>operator=.</I><P>
<I>comstr::operator=</I> assigns one <I>comstr</I> to another. Normally, you'd declare the <I>comstr</I> assignment operator as<P>
<pre>comstr &amp;operator=(const comstr &amp;c);</pre>
to match the typical form of a generated assignment. But in this case, the assignment operator must override <I>operator=</I> in base class <I>common.</I> An overriding function must have exactly the same signature (sequence of parameter types) as the function it overrides. Therefore, the right-hand operand of the <I>comstr</I> assignment operator has type <I>const common &amp;,</I> not <I>const comstr &amp;.</I> Nonetheless, the left operand is a <I>comstr</I>, because it's the object addressed by <I>this.</I> In a non-static <I>comstr</I> member function, <I>this</I> has type <I>comstr *const.</I><P>
All that's really involved in copying one <I>comstr</I> to another is to copy their <I>e</I> data members (using the <I>str</I> assignment operator). However, the right operand of <I>comstr::operator=</I> is declared as <I>common,</I> which has no data members. Thus, <I>comstr::operator</I> must boldly cast its right operand to <I>comstr</I> (actually <I>const comstr &amp;</I>) so it can access the data member that we all hope is there.<P>
Therein lies a real weakness of this design. Since <I>comqs</I> don't use wrappers, a <I>comq</I> that's a queue of <I>int</I> (actually <I>comint)</I> has the same static type as a <I>comq</I> that's a queue of <I>str</I> (actually <I>comstr).</I> The compiler can't catch errors such as removing an object that's actually a <I>comstr</I> into an object that's a <I>comint.</I> The only way to prevent this inadvertant type conversion is with runtime type checking inside <I>comq::remove.</I><P>
In a sense, using <I>comqs</I> instead of <I>genqs</I> merely trades one tedious job for another. <I>comqs</I> don't use wrappers, but they do need a different derived class for each containable object. Writing a type-specific derived class is a task comparable to writing a type-specific wrapper.<P>
<A href="list9.htm">Listing 9</a>
shows my queue testing program adapted for <I>comqs</I> as a queue of <I>str.</I> The output operator points out yet another problem with this design &#151; it doesn't eliminate all the casts from the application code. The <I>comq</I> iterator's <I>next</I> function returns the address of a queued object as a <I>common *,</I> and the application must cast it back to its original type. Maybe <I>comqs</I> do need wrapper classes after all.<P>
<h4><FONT COLOR="#000080"><A name="0193_00E4">What's Wrong With This Picture<A name="0193_00E4"></FONT></h4></P>
These various problems with containers of ABCs are really surface indicators of a fundamental design flaw. I believe that using containers of <I>common *</I> as generic containers is a misuse of inheritance and polymorphism.<P>
As I've said before, I believe that most applications need homogenous containers that employ static (translation-time) type checking. Type-specific wrappers offer just that. Containers of <I>common *</I> don't. In fact, by using <I>common *</I> as a kind of generic data pointer, containers of <I>common *</I> use inheritance as a way to weaken the type checking they apply to the objects they contain. That's not what inheritance is for.<P>
In general, you should use inheritance to capture logical relationships between types, not as an implementation trick. In particular, inheritances model <I>Is-A</I> relationships, such as: a sequential file <I>Is-A</I> file, a dialog box <I>Is-A</I> view, and a manager <I>Is-A[n]</I> employee. But objects of types derived from <I>common</I> have no inherent relationship beyond some programmers desire to shoe-horn them all into a common container framework.<P>
I don't mean to suggest that you should never create containers of polymorphic objects. For example, I think it's perfectly alright to represent a desktop in a windowing environment as a collection of dialog boxes, message boxes, edit windows, and other types derived from a common ABC called <I>view.</I> The fact is, even if you never place views into containers, all these different views have inherent commonality that an inheritance hierarchy models extremely well. I wouldn't even call the desktop a heterogenous container. I'd say it's a homogeneous container of views.<P>
Also understand that the judgments I make about using C++ do not necessarily apply to all programming languages. C++ was designed to favor strong static checking and minimize run-time support. As such, good C++ designs build on that strength. On the other hand, highly dynamic languages and environments, such as Smalltalk, support different approaches. Smalltalk container classes are much more like containers of <I>common *.</I> (In Smalltalk, they are containers of <I>Objects.</I>) Thus, this approach isn't wrong per se; it's just not good C++.<P>
<h4>References</FONT></h4></P>
<a name="gorlen"></a>Keith Gorlen, Sanford Orlow and Perry Plexico. <I>Data Abstraction and Object-Oriented Programming in C</I>++. (John Wiley &amp; Sons, 1990.)<P>
<h4><a href="list7.htm">Listing 7</a></h4>

<h4><a href="../../../source/1994/oct94/saks.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
