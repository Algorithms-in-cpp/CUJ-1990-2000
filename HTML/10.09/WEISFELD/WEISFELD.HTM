


<HTML>
<HEAD>

<TITLE>September 1992/Synchronizing Processes Using Critical Sections</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Synchronizing Processes Using Critical Sections<A name="01B7_00DD"><A name="01B7_00DD"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="01B7_0000"><A name="01B7_0000">Matt Weisfeld</font></h3><hr><blockquote><P>
<P><i><A name="01B7_0000"><A name="01B7_0000">Matt Weisfeld is currently employed by the Allen-Bradley Company as a Senior System Test Engineer and is responsible for the development of test software on VAX/VMS, UNIX, DOS and other platforms. The author holds an M.S. in Computer Science, an M.B.A., and has taught computer programming and software design at two universities. Matt can be reached at maw@mailhost.da.hh.ab.com.</i></P><P>
Synchronizing multiple processes on one computer can be accomplished using shared synchronization flags, since all processes share the same memory. However, when processes running on different computers need to be synchronized there is no local memory to share. To allow the computer platforms to communicate, they must be connected by a network.<P>
The same approaches used to synchronize processes on a single computer platform can be used to synchronize processes across multiple platforms. Critical sections are one of the many strategies available. This article describes an implementation of a critical-section algorithm using C. The algorithm referenced in this article is from the book <I>Operating System Concepts</I> (Silberschatz, et al. 1991).<P>
<h4><FONT COLOR="#000080"><A name="01B7_00DE">Critical-Section Program Structure<B><A name="01B7_00DE"></B></FONT></h4></P>
A critical section is a segment of code that allows a process to access shared data. Each process has one critical section. Only one process at a time can execute in its critical section. To assure that this is the case, a process must request permission to enter its critical section.<P>
A strict program structure controls these permissions. The code contains four separate sections of code: entry, critical, exit, and remainder. In the entry section, a process requests permission to enter its critical section. The critical section itself is the only code where a process can change common data. When a process no longer needs to be in its critical section it enters an exit section. Here a process relinquishes control and allows other processes a chance to enter their critical sections. Finally, in the remainder section a process performs tasks that do not affect the common data.<P>
The program structure must satisfy three requirements:<P>
<UL><li>Mutual exclusion &#151; only one process at a time may execute in its critical section.</li>
<li>Progress &#151; only those processes actively interested in entering their critical sections may participate in determining which process enters its critical-section next. That is, if no process is executing in its critical section, but some processes want to enter their critical sections, then only those processes that are not executing in their remainder section can decide who goes next.</li>
<li>Bounded waiting &#151; a process cannot be locked out of its critical section forever. That is, there must be a limit on the number of times that a process can enter its critical section, pre-empting a previous request made by another process to enter its critical section.</li></UL>
<h4><FONT COLOR="#000080"><A name="01B7_00DF">The Implementation<A name="01B7_00DF"></FONT></h4></P>
<A href="fig1.htm">Figure 1</a>
contains the critical-section algorithm in pseudocode, as published by Silberschatz, Peterson, and Galvin. This algorithm satisfies the requirements previously mentioned. First, a process is granted permission to enter its critical section only if all status flags are not <I>IN_CS</I> (mutual exclusion). Second, the <I>turn</I> variable can only be modified when a process enters or leaves its critical section (progress). Third, when a process leaves its critical section, it must choose a successor from the first process in the cycle (bounded waiting). The line of code,<P>
<pre><I>j:=turn</I>+<I>1 mod n;</I></pre>
assures that a turn is given to each requesting process within <I>n</I>-1 turns. <A href="list2.htm">Listing 2</a>
contains the implementation of the algorithm in C. I attempt to keep the code true to the algorithm. Since C does not have an <I>until</I> command, I used a <I>do-while</I> loop. The only difference in logic is to <I>not</I> the expression in the<I> do-while</I> loop. In this way, the flow of the logic remains as close to the algorithm as possible.<P>
The algorithm in <A href="fig1.htm">Figure 1</a>
is valid for any number of processes (P0, P1,..., Pn-1). However, to keep the discussion as simple as possible, I used only three processes in this example. These processes are running on three VAXstations (of various models), running VMS and connected by DECnet. Each VAXstation has one process running that will participate in this synchronization. The processes are running in a master/slave relationship. The master is <I>NODE0</I>, and the slaves are <I>NODE1</I> and <I>NODE2</I>. The intent is to have all processes start at approximately the same time. To do this, each slave sets a flag when it is ready to start. Then it waits. When the master reaches the starting point, it checks the flags of both slaves to see if they are ready. If either one of the slaves is not ready, the master will continue to check the flags until both are set. At this point the master sends a signal for both slaves to proceed, clears the flags, and continues on its way. It is important to note that these flags are not part of the criticalsection algorithm, however, their access is regulated by the critical sections.<P>
Two common data structures maintain process synchronization. These variables are called <I>status</I> and <I>turn</I>. Each process has its own <I>status</I> variable that indicates its current state. Possible states are <I>IDLE</I> (when the process has no interest in entering its critical section), <I>WANT_IN</I> (when the process is requesting permission to enter the critical section), or <I>IN_CS</I> (when the process is currently in its critical section). All elements are initially idle. <A href="list1.htm">Listing 1</a>,
 <I>enet_cs.h</I>, contains the definitions of these states.<P>
The algorithm utilizes an array to hold all the status variables. In this implementation, the status variables are located in a shared data file. Instead of using an offset into an array, it uses an offset into a file. This offset is represented by the process number, which is always between 0 and <I>n</I>--1. The other variable, called the <I>turn</I> variable, is a single data item. It indicates which process is next in line for permission to enter its critical section. Again, the number for <I>turn</I> is identified by the process number <I>n</I>.<P>
One of the systems, not necessarily one with competing processes, owns the data file where the shared data resides. The file consists of the status variables (an offset represented by the process number). Thus, for three processes, <I>P1</I> is at offset 0, <I>P2</I> is at offset 1, and <I>P3</I> is at offset 2. The turn flag is at offset <I>PROCESSES+0</I>, and since <I>PROCESSES = 3</I>, the turn flag is at offset 3. The signal flags for <I>NODE1</I> and <I>NODE2</I> are at <I>PROCESSES</I>+<I>1</I> and <I>PROCESSES+2</I> respectively. (See <A href="list1.htm">Listing 1</a>.
)<P>
To access this file the programs use DECnet. The following code opens the files:<P>
<pre>FILE *fp;
char filename[100] =
"node\"account password\":: [directory] filename";
fp = fopen(filename, "a+");</pre>
The <I>filename</I> variable must contain a valid DECnet command. The backslashes are needed to spare the quotes from the C preprocessor. Notice that the <I>password</I> is needed to obtain access to a foreign node. After this command is executed, the variable <I>fp</I> contains all the information necessary to access the file. No further reference to the foreign node is needed. This implementation uses DECnet; however, any other compiler/system that allows a process to open a file residing on another host will suffice.<P>
To keep the critical-section code as clear as possible, library routines were developed to deal with the DECnet activity. For example, to obtain the information in a specific file location (ie., <I>TURN LOC</I>), the code<P>
<pre>turn_num = cs_read(TURN_LOC);</pre>
is executed.<P>
<A href="list3.htm">Listing 3</a>
contains the code for the DECnet libraries. The main point of interest with the DECnet libraries relates to how the code handles the situation when it is denied access to the file. This will happen if another process has opened the file. The message that VMS deposits in <I>errno</I> (defined by Standard C) when a file is controlled by another process is 65,535 (hex ffff). So as long as this is the message received, the code simply loops until successful. However, if any other error message is encountered, the process terminates. One other point of interest is the mode by which the file is opened. Since VMS maintains versions of all files, every time a file is opened, it creates a new version. This is not desirable in the implementation of the critical-section problem. Thus, the file must be opened in <I>append</I> mode. In this way, no new version of the file is created.<P>
<A href="list4.htm">Listing 4</a>
contains the code for all critical sections. Actually, the contents of the critical section has no bearing on the algorithm itself. None of the shared synchronization flags are ever updated in a critical section. In this example, only the flags that indicate if the slaves are ready are updated. Notice that one routine, called <I>critical-section</I>, handles all nodes. The process number causes the <I>switch</I> statement to execute the appropriate critical section.<P>
To initiate the program enter the following command at the prompt:<P>
<pre>$ ENET_CS node</pre>
The value of <I>node</I> specifies the process value for the specific instance of the code. In this way, the same executable can be used on all systems. Notice that the slaves, <I>NODE1</I> and <I>NODE2</I>, set their proper flags and then return from their critical section with the value <I>STOP</I>. The master, <I>NODEO</I>, checks to see if the slaves are ready, if they are, then the master clears them and returns with the value <I>STOP</I>, since it has completed its mission. If one or both of the slaves are not ready, then the master simply returns with the value <I>NORMAL</I>, signaling that it has not found what it was looking for. In this case, the master will continue to request permission to enter its critical section until it finds that both slaves are ready. Note that the master <I>never</I> loops in the critical section. No process should ever loop in the critical section.<P>
<h4><FONT COLOR="#000080"><A name="01B7_00E0">Conclusion<B><A name="01B7_00E0"></B></FONT></h4></P>
There are other means of synchronizing processes and sharing resources. The chief advantage of the method described here is the ability to synchronize processes running on multiple computer platforms. As a result, the method makes it possible to make the platforms more transparent to the processes. For programmers, this represents a small but significant increase in the ability of code to migrate to future computer platforms.<P>
<h4>References</FONT></h4></P>
Silberschatz, A., A. J. Peterson, and P. Galvin. 1991. <I>Operating System Concepts</I>, 3d ed. Reading, MA: Addison-Wesley Publishing Company.<P>

<h4><a href="../../../source/1992/sep92/weisfeld.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
