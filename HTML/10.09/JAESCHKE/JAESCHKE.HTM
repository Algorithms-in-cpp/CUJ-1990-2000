


<HTML>
<HEAD>

<TITLE>September 1992/Doctor C's Pointers</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Doctor C's Pointers&reg;<A name="01E0_00E5"><A name="01E0_00E5"></font></h2><P>
<h3 align="center"><A name="01E0_0000"><A name="01E0_0000">Data Structures, Part 16: Trees III</h3><P>
<h3 align="center"><font color="#800000">Rex Jaeschke</font></h3><hr><blockquote><P>
<P><i><A name="01E0_0000"><A name="01E0_0000">Rex Jaeschke is an independent computer consultant, author and seminar leader.He participates in both ANSI and ISO C Standards meetings and is the editor of The Journal of C Language Translation, a quarterly publication aimed at implementors of C language translation tools. Readers are encouraged to submit column topics and suggestions to Rex at 2051 Swans Neck Way, Reston, VA 22091 or via UUCP at rex@aussie.com.</i></P><P>
Last month I began listing a program that managed a dynamically allocated tree. Missing from that listing were the <I>help</I> and <I>odd node</I> options. This month's column presents these options along with the stack routines used by the print routine to traverse the tree, and the free-node list-management routines.<P>
This month I also provide the <I>remove node</I> option source. This is by far the most complicated option. Removing a node that has no children or only one child is not very difficult, but removing one that has two children is non-trivial since it involves rearranging the tree structure.<P>
The stack-management code is almost identical to that used in the stack columns some months ago. Instead of pushing and popping integers, however, now I push and pop pointers to nodes.<P>
The free-node list-management code was also borrowed from an earlier installment; that on linked lists. In that case, I added a newly freed node to the front of a free-node linked list. I could have done likewise here, but rather than use a linked list I use a binary tree instead. The only difference is that every node in the free-node list has only a left child and that leads to the next free node. Whenever a node is freed, it is added to the free node list by making it the new root and by having its left child pointer point to the old root. As such, in a sense, it behaves just like a linked list.<P>
<A href="list1.htm">Listing 1</a>
contains the remaining code.<P>
Consider the case where you add the following nodes to a new tree in the following order: green, blue, black, brown, red, orange, and white. After doing this, enter the commands shown in <a href="fig1.htm">Figure 1a</a>
to see how the tree has been stored. <a href="fig1.htm#fig1b">Figure 1b</a>
contains the output produced from the print-tree option. The seven nodes are evenly distributed across the tree, which has a depth of three. The tree is perfectly balanced.<P>
Now, consider the case where you add the nodes in alphabetical order: black, blue, brown, green, orange, red, and white. After doing this, enter the commands shown in <a href="fig2.htm">Figure 2a</a>
to see how the tree has been stored. Of course, the tree still has seven nodes, however, the depth has increased from three to seven. <a href="fig2.htm#fig2b">Figure 2b</a>
shows how the tree looks now. As the depth of the tree is much greater, locating any given node takes longer on average since you don't eliminate any subtrees as you navigate down the list.<P>
Not surprisingly, entering the same nodes in descending alphabetical order produces a similarly-shaped tree except the nodes are joined via the left branch. For example, the code shown in <a href="fig3.htm">Figure 3a</a>
results in the tree shown in <a href="fig3.htm#fig3b">Figure 3b</a>.
<P>
In the final example, you add the following nodes in the order shown: green, blue, black, brown, cherry, and red. You then proceed to remove nodes and print out the tree after each step so you can see how the tree's shape has changed. Some of the nodes deleted have two children, some only one, and some none at all. You also delete the root node. The code shown in <a href="fig4.htm">Figure 4a</a>
results in a tree shaped as in <a href="fig4.htm#fig4b">Figure 4b</a>.
<P>
When the blue node (which has a parent and two children) is deleted as in <a href="fig5.htm">Figure 5a</a>,
 the result is the tree shown in <a href="fig5.htm#fig5b">Figure 5b</a>.
<P>
When the black node (which has a parent and no children) is deleted as in <a href="fig6.htm">Figure 6a</a>,
 the result is the tree shown in <a href="fig6.htm#fig6b">Figure 6b</a>.
<P>
When the brown node (which has a parent and one child) is deleted as in <a href="fig7.htm">Figure 7a</a>,
 the result is the tree shown in <a href="fig7.htm#fig7b">Figure 7b</a>.
<P>
And when the green node (which has no parent and two children) is deleted as in <a href="fig8.htm">Figure 8a</a>,
 the result is the tree shown in <a href="fig8.htm#fig8b">Figure 8b</a>.<P>

<h4><a href="../../../source/1992/sep92/jaeschke.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
