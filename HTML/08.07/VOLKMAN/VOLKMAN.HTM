


<HTML>
<HEAD>

<TITLE>July 1990/Multitasking With The DESQview API C Library</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjul.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   User Reports</FONT></H2>

<hr><h2 align="center"><font color="#800000">Multitasking With The DESQview API C Library<A name="0195_00E3"><A name="0195_00E3"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0195_0000"><A name="0195_0000">Comments By Victor Volkman</font></h3><hr><blockquote><P>
<P><i><A name="0195_0000"><A name="0195_0000">Victor R. Volkman received a B.S. in computer science from Michigan Technological University in 1986. His areas of interest include database internals, compiler semantics, and graphics applications. He is currently employed as software engineer at Cimage, Inc. of Ann Arbor, Michigan. He can be reached at the HAL 9000 BBS, 313-663-4173, 1200/2400 baud.</i></P><P>
Since its introduction in 1985, DESQview has become one of the most popular multitasking environments available for the PC. It provides many of the advanced features of OS/2 without requiring expensive hardware and software, and without forsaking your existing PC-DOS development tools and environment. Environments which fully support multitasking must provide an operating system interface for the application developer. Quarterdeck Office Systems's DESQview Application Program Interface (API) allows C programmers to access its entire set of operating system functions for multitasking, event queues, mailboxes, windows, dialog boxes, and more. C compilers currently supported include Microsoft, Borland, Lattice, Metaware, and Watcom. DESQview APIs are also available for BASIC, Pascal, and database languages.<P>
The DESQview API is especially useful for developing networking and parallel processing simulations. Simulating a network or parallel processing problem helps solidify the algorithms used without tying up expensive resources during development. One problem which I have previously investigated with parallel processing simulators is that of approximating the roots of a function. This problem was first suggested to me in 1986 by Prof. Dave Poplawski of the Michigan Technological University. The roots of the function <I>f(x)</I> are those values of <I>x</I> where <I>f(x)</I> =<I> 0</I>. The most efficient solution is to evenly partition the possible range of the root between competing CPUs. In a simulator, each CPU is modeled by a single task running concurrently with many others. I first implemented my model using the Intel HyperCube simulator on a VAX-11/750 under BSD UNIX 4.2. The ease with which the DESQview API implements the parallel root finder demonstrates the power of DESQview's task management and intertask communication abilities. This article will detail the multitasking features available in the DESQview Application Programming Interface (API) C Library and present a small application in C.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0195_00E4">The DESQview Environment<A name="0195_00E4"></FONT></h4></P>
Before delving into the parallel root application, I will explain how DESQview interacts with MS-DOS and your application programs. DESQview is a preemptive multitasker which provides a fixed time-slice to every program running on your computer. When one program uses up its time-slice, DESQview intervenes and switches the context to the next available program waiting in line. In a non-preemptive system such as MS-Windows, the program running in the foreground must explicity relinquish control before others can execute. Each program loaded by DESQview can have its own window with up to 640K available for its MS-DOS session. These windows are mapped into EEMS or EMS 4.0 memory or else swapped to disk when not in use. Although DESQview will run on any PC compatible, it is most effective when teamed up with the built-in memory management capabilities of an 80386 processor.<P>
DESQview supports a multitasking interface in three different models: tasks, applications, and processes. The task model allows you to run more than one function in a program simultaneously. These tasks are also referred to as execution threads. To start a new task, call <I>tsk_new()</I> with a pointer to the function for the thread to execute. The only limit to the number of simultaneously executing tasks is the size of your program stack, since the stack for each child task must be allocated only from the parent's stack. DESQview tasks share the same program space, but not the same stack space. Since the parallel root finder requires little stack and heap space, the task model was chosen for multitasking.</FONT></FONT><P>
The application model is only slightly more sophisticated than the task model. An application can consist of several tasks, each with its own screen window. One window is designated as the foreground window and receives a larger time-slice than the remaining windows by default. Although the windows are all logically related to the same process, they can be physically resized and moved as if they were separate processes. Applications are like tasks in that they are executing within the same program space. An application could be considered to be midway between a task and a process.<P>
The process model allows for the greatest degree of multitasking independence. Each process is allocated its own window with up to 640K for its MS-DOS session. Processes have totally separate program, stack, and heap spaces. Additionally, processes need not even be executing the same program at all, making them ideal for client/server applications such as database servers and print servers. This also implies that processes cannot communicate with global variables. Fortunately, DESQview provides a mailbox facility for communicating between tasks and processes in the system.<P>
<h4><FONT COLOR="#000080"><A name="0195_00E5">Critical Sections And Semaphores<A name="0195_00E5"></FONT></h4></P>
Whenever programs share data in any network or multitasking system, they must use an arbitration system to determine who is allowed to read or write the data. Otherwise, data may be lost or corrupted when two programs attempt to write data to the same place. In a networking scenario, record locking of data files is often sufficient to control access. However, when two tasks want to access the same global variable no such simple metaphor exists. The problem of controlling access to shared program data can be effectively solved using the semaphore control model.<P>
Any part of a program which reads or writes shared data could potentially be a critical section. A critical section is a part of a task which must be completed without interruption by the scheduler. If two or more tasks are executing their critical sections simultaneously, then a data collision is an immediate hazard. For example, a bank teller initiates both <I>Task #1</I> and <I>Task #2</I> to update my account balance, which is initially $500. <I>Task #1</I> is supposed to deposit $100 and <I>Task #2</I> should withdraw $200. Each task will read the balance, modify the balance, and then write back the balance. The two tasks are asynchronous with respect to each other. In <A href="fig1.htm">Figure 1a</a>,
 <I>Task #2</I> overwrites the balance and causes the deposit made by <I>Task #1</I> to be lost. <A HREF="fig1.htm">Figure 1b</a>
shows the correct answer when the critical sections which read and write the account balance are respected.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
A semaphore is a counter indicating the number of processes attempting to execute a critical section. A software semaphore is like a railroad semaphore that prevents more than one train from entering the same section of track. DESQview provides support for semaphores through the mailbox API calls. The <I>mal_lock()</I> function allows a mailbox to be used as a semaphore. The first task that calls <I>mal_lock()</I> against a mailbox becomes its owner. When other tasks call <I>mal_lock()</I> they are automatically suspended until the owner relinquishes control with a <I>mal_unlock() </I>call. Protecting critical sections is now as simple as surrounding them with calls to <I>mal_lock()</I> and <I>mal_unlock()</I>. The <I>sendv()</I> function in <I>MONITOR.C</I> (<A href="list1.htm">Listing 1</a>)
 is such an example.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0195_00E6">The Monitor<A name="0195_00E6"></FONT></h4></P>
A monitor is a set of functions which integrates data structures and functions to control the synchronization of concurrent tasks. A monitor may be implemented with semaphores, events, and messages. Just as a program is an abstract concept for a set of functions, a monitor is an abstraction for interprocess communication. The monitor can hide the low-level implementation details sufficiently so the programmer can safely ignore them.<P>
The monitor becomes the central repository for critical sections and shared variables. Since the monitor contains all references to the data structures, they can be reduced to static local variables. Consequently, the tasks access the data only through the monitor and therefore will have no critical sections of their own. The monitor is passive and executes only when called from a task. <A href="fig2.htm">Figure 2</a>
shows a monitor controlling access from <I>N</I> processes to the shared data.</FONT></FONT><P>
Hwang and Briggs (1984) considered monitors such a powerful paradigm that they presented a special Pascal-like syntax for describing them. In practice, these constructions require awkward macros that are difficult for the novice to debug. Instead, moving the monitor's global variables and functions into a separate source file is sufficient to hide its implementation. The monitor for the parallel root finder is encapsulated in <I>MONITOR</I><I><B>.</I></B><I>C</I> and <I>MONITOR</I><I><B>.</I></B><I>H</I> (see <A href="list1.htm">Listing 1</a>
and <A href="list2.htm">Listing 2</a>)
.</FONT></FONT></FONT></FONT><P>
Hwang and Briggs also asserted that any complex system can be decomposed into a set of processes and monitors allowing them to communicate. This decomposition can greatly simplify program maintenance and verification of correctness. When data structures must be changed, it is easy to determine whether the monitor will be affected. New processes and monitors can also be added without upsetting the entire system.<P>
<h4><FONT COLOR="#000080"><A name="0195_00E7">Root Finder: Main Program<A name="0195_00E7"></FONT></h4></P>
A monitor simplifies the job of the parallel root finder. The file <I>FINDROOT.C</I> (<A href="list3.htm">Listing 3</a>)
 contains just three functions: <I>main(), task_findroot(),</I> and <I>f()</I>. <A href="tab1.htm">Table 1</a>
lists all the DESQview API functions used in the root finder application. The <I>main()</I> function initializes the API, opens a window, starts the tasks, waits for completion, and then displays the results. The first step of initialization is to determine if DESQview is running or not. The <I>api_init()</I> call returns the current DESQview version or zero if DESQview is not active. The <I>api_level()</I> call asserts the version of the API interface you will be using. Setting <I>api_level()</I> ensures upward compatibility with future DESQview versions.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
After intializing DESQview, the <I>main()</I> function opens a new window for itself which reports status messages on the root finding process. The <I>win_new()</I> function creates a new window based on the window title, height, and width. Next, the <I>win_move()</I> function moves the window into place. The <I>win_logattr()</I> and <I>win_attr()</I> calls ensure the text color is readable. The <I>win_frame()</I> and <I>win_unhide()</I> calls set flags to disable the window border and mark it as displayable. Finally, <I>win_top()</I> redraws the window using all of the attributes and flags set by the previous window calls.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Before starting the tasks, the monitor must be initialized. The <I>open_monitor()</I> function first creates a mailbox to be used strictly as a semaphore, then allocates memory for a <I>MONITOR</I> structure which will track messages passed between tasks. After opening the monitor, a priming <I>MASTER</I> message must be sent through the monitor. This message will be claimed by the first task to find the root in its interval.</FONT></FONT></FONT></FONT></FONT></FONT><P>
Once everything has been initialized, starting the tasks is easy. A call to <I>tsk_new()</I> starts a new task:</FONT></FONT><P>
<pre>task_han = tsk_new(task_findroot, stacks[i],
               STACKSIZE, " ", 0, 0, 0);</pre>
The <I>tsk_new()</I> function returns a task handle which can be used to suspend, resume, or abort the task. The first parameter is a pointer to a function returning an integer. More precisely, the parameter should be a pointer to a <I>void</I> function since the return value cannot be accessed. The second parameter is a pointer to the stack for the new task. The child task's stack must be allocated from the parent task's stack. Otherwise, the C compiler's assumptions about the stack segment will be invalid. In <I>FINDROOT.C</I>, a two-dimensional array variable called <I>stacks</I> is declared locally. (An alternative would be to call the MSC function <I>alloca()</I> to allocate a block directly from the stack.) The third parameter specifies the size of the stack available to the child task. The remaining four parameters allow a window to be automatically created when the child task starts up.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
A task receives its parameters in a mail message. Unlike the C standard library <I>spawn()</I> functions, the DESQview <I>tsk_new</I> function cannot directly pass parameters to the spawned process. Fortunately, you can find a task's mailbox by calling <I>mal_of()</I>, passing the task handle. Calling <I>mal_write()</I> sends a copy of the string to the child:</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>sprintf(node_str, "%d", i );
mal_write(mal_of(task_han), node_str,
        sizeof(node_str));</pre>
Once the tasks are up and running, the <I>main</I> program has nothing to do but wait for the final answer and display the results. The <I>MASTER</I> task is responsible for notifying the <I>main </I>program with the <I>TERMINATE</I> message.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0195_00E8">Root Finder: Child Tasks<A name="0195_00E8"></FONT></h4></P>
The real work of root finding takes place in <I>task_findroot()</I>. The only parameter which <I>task_findroot()</I> needs to know is its node number assigned by its parent. Each task computes one value for <I>f(x)</I> and then communicates with its neighbors to find the interval where the root is. Before a task can begin searching for a root, it must know its node number. The node numbers run from zero to <I>NUMPRC-1,</I> where <I>NUMPRC</I> is the number of processes being simulated. The parent task sends the node number to the mailbox of each child task. The child task must first call <I>mal_me()</I> to learn its mailbox handle, then call <I>mal_read()</I> with the mailbox handle to obtain a pointer to the message. Since <I>mal_write()</I> wrote the message, the call to <I>mal_read()</I> returns a pointer to a copy of the message rather than a pointer to the parent's message buffer.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
After finding its node number, each task opens its own window by calling the API function <I>win_new()</I>. The node number is used to size and position each window so that they don't overlap on the screen. If there are more than four tasks, the windows will be only half the width of the screen. <A href="fig3.htm">Figure 3</a>
shows a screen dump from a program run with four tasks.</FONT></FONT><P>
When the child task's window is set up, it enters the main DO loop and computes its <I>f(x)</I> value. Each task is assigned an interval whose size is determined by the global interval of interest divided by the number of nodes:<P>
<pre>interv = (global_x1-global_x0)/(NUMPRC);</pre>
The variables<I> global_x0</I> and <I>global_x1</I> are the left and right boundaries respectively of the global interval. The <I>MASTER</I> task will adjust the global interval once during each iteration to narrow the search boundaries. Figures <A href="fig4.htm">4a through 4c</a>
show how the interval decreases over three iterations. Each task can compute its <I>f(x)</I> value as follows when it knows the left-hand boundary, its node number, and the size of the interval:</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>y1 = f(global_x0+interv* (node+1));</pre>
After computation, two asynchronous communications allow a given node to find the function results of its neighbor node. First, all even nodes send their values to their right neighboring node. Second, all odd nodes send their values to their neighbor on the right. Node <I>0</I> only has a neighbor to the right and node <I>NUMPRC-1</I> only has a neighbor on the left. <A href="fig5.htm">Figure 5</a>
illustrates both stages of the communications. This message passing pattern fits well with hypercube architectures, which require communications to be between adjacent nodes.</FONT></FONT></FONT></FONT><P>
Finally, each child task must determine if the root lies within its assigned interval. If <I>f(x0)</I> * <I>f(x1)</I>  is negative, then <I>f(x)</I> must have crossed the X-axis in that interval. In other words, the root was below the X-axis at one end of the interval and above the X-axis at the other end. This test is unreliable if more than one root appears in any interval. <A href="fig6.htm">Figure 6</a>
shows that if the line crosses the axis an even number of times in the interval, the test fails. A more advanced root finder would be able to handle multiple roots.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The node that discovers the root computes the new boundary conditions. Note that all other processes must synchronize against this controller node. This synchronization ensures a correctly placed interval for the following iteration. If the <I>MASTER</I> task finds that current interval to be less than <I>EPSILON</I>, then it sends the <I>TERMINATE</I> message instead of relinquishing the <I>MASTER</I> status. These <I>TERMINATE</I> and <I>MASTER </I>messages are not addressed to a specific node but to dummy nodes which can be received from any task. When the <I>main</I> program receives the <I>TERMINATE</I> notification, the child tasks finish and are deallocated.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0195_00E9">Root Finder: Inside The Monitor<A name="0195_00E9"></FONT></h4></P>
As mentioned earlier, <I>MONITOR.C</I> and <I>MONITOR.H </I>contain the monitor used for the parallel root finder. This monitor consists only of the functions <I>open_monitor()</I>, <I>close_monitor()</I>, <I>sendv()</I>, and <I>recvl()</I>. You must first call the <I>open_monitor()</I> function to initialize the monitor's data structure. <I>open_monitor()</I> opens a new mailbox, assigns the name requested by the user, and then allocates a monitor structure.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>close_monitor()</I> function disables the monitor by closing the mailbox, freeing the monitor structure, and setting the monitor pointer to <I>NULL</I>.</FONT></FONT></FONT></FONT><P>
The <I>sendv()</I> and <I>recvl()</I> entry points are the only functions to actually use a semaphore. Both functions attempt to lock the semaphore handle before accessing the variables within their critical sections. The first task to call <I>mal_lock()</I> becomes the owner of the semaphore. Other tasks that attempt to call <I>mal_lock()</I> before the owner calls <I>mal_unlock()</I> are suspended. Tasks in a suspended state must forfeit their timeslices until the expected condition occurs. After taking the semaphore, the <I>sendv()</I> entry point simply records the message value and its destination in the monitor. Finally, <I>sendv()</I> releases the semaphore.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>recvl()</I> function blocks the calling task until a message from the requested node is received. After obtaining the semaphore, <I>recvl()</I> checks whether the message has arrived. If it has not arrived, <I>recvl()</I> releases the semaphore and forfeits the rest of its timeslice via <I>api_pause()</I> in order to avoid a busywait in the task awaiting a message. The <I>recvl()</I> entry point continues its strategy of lock, test, and unlock as long as necessary. When the message finally arrives, the value is copied to the address specified in the <I>val_p</I> parameter. <I>recvl()</I> then unlocks the semaphore so the process can begin again.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0195_00EA">Implementation Notes<A name="0195_00EA"></FONT></h4></P>
The DESQview-specific version of the parallel root finder was implemented on a 16MHz 80286 computer running MS-DOS 3.30. The program was developed and tested in conjuction with DESQview version 2.25, but should work fine with any version 2.01 or later. The root finder was compiled with Microsoft C 5.1 and linked with the DESQview API C Library version 1.2.<P>
Although the API C Library claims to be reconfigurable to any memory model, I used only the large model (code &gt; 64K, data &gt; 64K) as recommended by Davis (1989). The root finder executable is about 42K excluding stack requirements. Unlike many other windowing and menu packages which could add up to 100K to your application, the DESQview API typically adds less than 10K of overhead, since most API functions are stubs that pass the parameters along to the DESQview kernel. This stub approach is similar in concept to the Dynamic Link Library (DLL) of OS/2, but requires that DESQview be resident in memory before a program can call API functions.<P>
<h4><FONT COLOR="#000080"><A name="0195_00EB">Conclusion<A name="0195_00EB"></FONT></h4></P>
With the recent introduction of multiple-CPU 80386 computers by Zenith, Compaq and others, the development of parallel programs has jumped from the theoretical to the practical. Since the cost of parallel computers will always exceed the cost of single-CPU computers, simulating parallel algorithms with a multitasking system remains an attractive development alternative.<P>
The parallel root finder demonstrates the ease with which multitasking programs can be developed using the DESQview API C library. The root finder also takes advantage of the intertask communication and windowing capabilites of the API. The DESQview API can also manage many other aspects of your application environment including event queues, dialog boxes, keyboards, mice, timers, and scheduling. You can be certain the DESQview API will continue  to play a role in extending the capabilities of MS-DOS programs in the 1990s.<P>
<h4><FONT COLOR="#000080"><A name="0195_00EC">Annotated Bibliography<A name="0195_00EC"></FONT></h4></P>
Davis, Stephen R., DESQview: A Guide to Programming the DESQview Multitasking Environment, Redwood City, CA: M&amp;T Publishing Inc., 1989.<P>
The definitive tutorial for those interested in writing applications to use the full power of DESQview. Davis covers windowing, multitasking, interprocess communication, generalized message input, memory management, critical sections, and semaphores. Unfortunately, it does not include a complete catalog of the function library.<P>
<I>DESQview API C Library</I>, Santa Monica, CA, Quarterdeck Office Systems, 1988.<P>
Covers the Applications Programming Interface (API) for C. A complete alphabetical listing of all API functions, parameters, descriptions, and return values is provided. Several DESQview-specific programs demonstrate intertask communication, process creation, timers, menus and event handling.<P>
Hitt, Frederick J. "Drawing Out DESQview Power", <I>PC Tech Journal</I>, April 1989, pp. 47-61.<P>
Covers the entire set of API functions in a relatively short space. Hitt covers many of the low-level details of multitasking and how it is enhanced with the 80386. There is also a practical list of do's and don'ts for controlling multitasking programs. No source programs are provided.<P>
Hwang, Kai and Briggs, Fay, <I>Computer Architecture and Parallel Processing</I>, New York, NY, McGraw-Hill Inc., 1984. pp. 570-577.<P>
A textbook that includes many dissections of parallel computer and supercomputer architectures. It provides a thorough survey of memory, I/O, pipelining, vector processing, array processors, multiprocessor systems, and data flow computers. Software techniques, such as semaphores and monitors, for effectively utilizing parallel processing are emphasized at each step.<P>
Parker, Tim. "Software Review: DESQview 2.2, API Toolkit", <I>Computer Language</I>, Vol. 6, No. 4, April 1989, pp. 115-118.<P>
A user report divided between the DESQview 2.2 environment and the DESQview API Toolkits for C and Pascal. Parker gives an accurate account of the major features of DESQview 2.2 and how they work. Additionally, he presents a very simple overview of the API functions, API Debugger, and API Panel Design Tool.<P>

<h4><a href="../../../source/1990/jul90/volkman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
