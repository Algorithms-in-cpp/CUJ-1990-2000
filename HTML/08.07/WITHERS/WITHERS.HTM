


<HTML>
<HEAD>

<TITLE>July 1990/OS/2 Anonymous Pipes</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjul.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">OS/2 Anonymous Pipes<A name="0179_00CF"><A name="0179_00CF"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0179_0000"><A name="0179_0000">Bob Withers</font></h3><hr><blockquote><P>
<P><i><A name="0179_0000"><A name="0179_0000">Bob Withers has a BS in computer science from Oakland University in Rochester, MI and has been active in data processing for 20 years. He began programming for micros in 1985 and has focused increasingly on C and 0S/2. Currently, he works for Texas Instruments as a member of its Group Technical Staff. He can be contacted at 649 Meadowbrook St., Allen, TX 75002.</i></P><P>
In this article I'll discuss the anonymous pipe interprocess communication (IPC) feature of OS/2 and present a short example program to demonstrate its use. Anonymous pipes allow stream communication to occur between two related processes. Anonymous pipes are different from named pipes because anonymous pipes are identified solely by file handles. An OS/2 anonymous pipe can only be used for communication between two processes which share the same <I>command subtree</I>. In other words, the anonymous pipe handles must be inherited from a parent process.<P>
An anonymous pipe is created via the <I>DosMakePipe() </I>API function, which accepts pointers to two file handles and returns handles for reading and writing to the pipe. You can pass <I>DosMakePipe()</I> an additional, third parameter to specify the pipe's size in bytes. OS/2 implements the pipe as a circular buffer. When a process writes to the pipe, the data is placed in the buffer. If the buffer becomes full, the writing process is blocked until data is removed from the buffer via the read handle.</FONT></FONT></FONT></FONT><P>
Since anonymous pipes are identified only by file handles &#151; handles which must be inherited by a child process &#151; it's reasonable to ask how the child process knows which handles to use. The answer is that unless some other form of communication has occurred between parent and child, it doesn't. In fact, the child doesn't even know it has inherited file handles. Though a parent process can use several methods to advise a child of the pipe's handles, it's more common to leave the child process in the dark, so to speak. In general, a parent redirects a child's <I>STDIN, STDOUT</I>, and/or <I>STDERR</I> streams to an anonymous pipe, altering the normal processing of the child without its ever knowing. This is how the OS/2 command shell, <I>CMD</I><I><B>.</I></B><I>EXE</I>, supports command line redirection and is the approach taken in my sample program <I>ROUTEMSG.</I></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0179_00D0">The Sample Program<A name="0179_00D0"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
shows the source code for a short OS/2 utility named<I> </I><I>ROUTEMSG</I>, and <A href="list2.htm">Listing 2</a>
shows the <I>makefile</I> used to compile and link it. The purpose of <I>ROUTEMSG</I> is to capture the output of a child process and write it to an ASCII file, as well as display it on the video screen. <I>ROUTEMSG</I> executes a child process and redirects its <I>STDOUT</I> and<I> STDERR</I> streams to an anonymous pipe. I find this utility very handy for running large <I>makefiles</I>. All compiler messages are captured to an ASCII file, leaving me free to switch to another screen group while the compile(s) run in the background. After the <I>make</I> is complete, I can check the ASCII file for error messages and make corrections. Having the compiler output also appear on the video display allows me to switch back to the session running the compile to monitor its progress. Following is the command line syntax for running <I>ROUTEMSG</I>:</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>ROUTEMSG &lt;filename&gt; &lt;pgmname&gt; [&lt;args&gt; ...]</pre>
where<P>
filename    -  the name of the ASCII file used to capture the child's output</FONT></FONT><P>
pgmname  -  the name of the program to run</FONT></FONT><P>
args          -  optional command line arguments used by &lt;pgmname&gt;</FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0179_00D1"><I>ROUTEMSG</I><B> Details<A name="0179_00D1"></B></FONT></h4></P>
Letters (A) through (M) below expand on comments referenced in <A href="list1.htm">Listing 1</a>.
<P>
(A) The program begins by checking receipt of the minimum required command line arguments, namely the <I>&lt;filename&gt; </I>and<I> &lt;pgmname&gt; </I>arguments.</FONT></FONT></FONT></FONT><P>
(B) The OS/2 <I>DosOpen() </I>API function opens <I>&lt;filename&gt;</I> as output and instructs the operating system to either create it or truncate any existing file. Note that the <I>NOINHERIT</I> flag is explicitly set to prevent the child process from inheriting this file handle, thereby maintaining the default number of handles available to the child. Allowing the child to inherit unneeded handles could cause the child process to fail due to a lack of "real" handles for its own use.</FONT></FONT></FONT></FONT></FONT></FONT><P>
(C) The <I>DosMakePipe()</I> API creates the anonymous pipe and returns read and write handles in the <I>fh_piperead </I>and<I> fh_pipewrite</I> variables respectively.</FONT></FONT></FONT></FONT></FONT></FONT><P>
(D) The <I>STDOUT</I> and <I>STDERR</I> handles inherited from the parent process, most likely the command shell <I>CMD</I><I><B>.</I></B><I>EXE</I>, are not needed and are closed.</FONT></FONT></FONT></FONT></FONT></FONT><P>
(E) Handles for the <I>STDOUT</I> and <I>STDERR</I> processes are redirected to the pipe's write handle via the <I>DosDupHandle</I> API function. The <I>DosDupHandle()</I> service creates a new handle by which an existing stream may be referenced. The second parameter points to a variable of type <I>HFILE</I> (Handle of a FILE) which contains the newly assigned file handle. If this variable is initialized to <I>OxFFFF</I>, OS/2 selects an unused handle and assigns it. Otherwise, as in the sample, the initialized value is used as the new file handle. I use this mechanism to force <I>DosDupHandle()</I> to reassign the pipe write handle to the <I>STDOUT</I> and <I>STDERR</I> handles.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
(F) I use the <I>DosSetFHandState</I> API to modify the pipe read handle so that the child process doesn't inherit it. The reasoning is the same as described in item (B).</FONT></FONT><P>
(G) Since <I>ROUTEMSG </I>does not intend to write to the pipe, the handle obtained for this purpose can now be closed. The pipe won't be destroyed, however, since there are still open handles which reference it, namely<I> STDOUT, STDERR,</I> and <I>fh_piperead.</I></FONT></FONT></FONT></FONT></FONT><P>
(H) The child program name is formatted, if necessary, to include a <I><B>.</I></B><I>EXE </I>extension since the OS/2 API used to create child processes requires filename extensions.</FONT></FONT><P>
(I) The command line to be passed to the child process is formatted. OS/2 requires the program name followed by a <I>NUL</I> byte and then followed by the program's command line arguments &#151; each separated by one or more spaces and terminated by two <I>NULL</I> bytes.</FONT></FONT></FONT></FONT><P>
(J) The <I>DosExecPgm</I> API function now invokes the child program. This call requests asynchronous execution of the child and parent processes. By passing a <I>NULL</I> pointer for the environment strings, I instruct OS/2 to use a copy of the current processes environment for the child.</FONT></FONT></FONT></FONT><P>
(K) The "pipe write" file handles redirected earlier to <I>STDOUT</I> and <I>STDERR</I> are no longer needed (they have already been inherited by the child) and are closed. This is more than simply "clean-up". The read handle to the pipe will not be notified that the pipe has no writers until all write handles are closed. Leaving these two handles open in our process will cause <I>ROUTEMSG</I> to block forever waiting for something to be written to the pipe.</FONT></FONT></FONT></FONT></FONT></FONT><P>
(L) We finally get to the meat of the program &#151; so far everything has been initialization. This <I>while </I>loop reads data from the pipe and directs it to both the screen and the output file. I use the <I>VioWrtTTY</I> function to display data on the video screen and <I>DosWrite</I> to update the output file. The loop terminates if the <I>DosRead </I>function returns zero bytes read or if 0S/2 detects an error reading the pipe. The significance of zero bytes being returned by <I>DosRead()</I> is that the pipe is empty and no write handles exist.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
(M) The remaining open handles are closed and the program is terminated.<P>
<h4><FONT COLOR="#000080"><A name="0179_00D2">Summary<A name="0179_00D2"></FONT></h4></P>
I've presented a brief introduction to 0S/2 anonymous pipes and shown you where this form of IPC is most useful &#151; modifying the standard stream processing of a child process. I've tried to point out some aspects of anonymous pipes that aren't immediately obvious after a casual reading of the 0S/2 documentation. In addition, I hope the <I>ROUTEMSG</I> utility is a useful addition to the tool-chests of other 0S/2 developers.</FONT></FONT><P>

<h4><a href="../../../source/1990/jul90/withers.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
