


<HTML>
<HEAD>

<TITLE>July 1990/Resident Print Handlers Using Turbo C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjul.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Resident Print Handlers Using Turbo C<A name="0184_00D3"><A name="0184_00D3"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0184_0000"><A name="0184_0000">Roger T. Stevens</font></h3><hr><blockquote><P>
<P><i><A name="0184_0000"><A name="0184_0000">Dr. Roger T. Stevens is a member of the technical staff of the MITRE Corporation, Bedford, MA. He holds a B. A. degree in English from Union College, an M. A. in Mathematics from Boston University, an M. Eng. in Systems Engineering from Virginia Tech and a PhD. in Electrical Engineering from California Western University. Dr. Steven's books Graphics Programming in C and Fractal Programming in C were published by M &amp; T Publishing.</i></P><P>
The MS-DOS screen dump program works well with many dot matrix printers; but fails to fully exploit the capabilites of more sophisticated printers such as ink jet or color thermal printers. The software described here dumps an EGA color screen written in text mode to a CalComp Plotmaster color printer, using techniques that can easily be adapted to many other types of printers.<P>
<h4><FONT COLOR="#000080"><A name="0184_00D4">Planning The Display Size<A name="0184_00D4"></FONT></h4></P>
Most printers handle graphics data a line at a time, first receiving characters that define the number of bytes of graphics data to follow, and then the graphics data for a line. Each transmitted bit represents a dot on the paper. The resolution and transmission codes tend to be different for each printer.<P>
Most printers have a much higher resolution than the EGA display. Thus, the first step in planning a printer graphics display is to determine how many dots are to be printed for each display pixel. You must compare the printer resolution (obtained from the printer documentation) with the color card resolution. The EGA display has 640 pixels horizontally by 350 pixels vertically, giving an aspect ratio of 4:3. However, the pixels on the EGA do not have the same size in both directions; a pixel's vertical size is 1.37 times its horizontal size. The CalComp Plotmaster printer, for example, has a graphics area of 2000 dots horizontally by 1600 dots vertically in the landscape mode. The dots on the printer are square with the same horizontal and vertical sizes.<P>
With this hardware, three printed horizontal dots can be used to represent each horizontal pixel, resulting in a graphics area of 1920 horizontal dots (640 x 3) and ideally, 1440 vertical dots to keep the proper proportions. Printing four vertical dots for every one in the original display gives 1400 vertical dots, resulting in a display that is close to the proper proportions.<P>
Alternatively, one might use wider margins and print two horizontal dots for each horizontal pixel, giving 1280 printed dots horizontally. To maintain the proper proportions, there should be 960 vertical dots. Unfortunately, the best manageable approximation is three vertical dots for each horizontal pixel, producing 1050 printed dots. Though this will give a larger vertical dimension than desired, it is acceptable in representing a text display: when trying to copy a graphics display, the printer may reproduce circles as ovals.<P>
<h4><FONT COLOR="#000080"><A name="0184_00D5">Alphanumerics &#151; Text To Graphics<A name="0184_00D5"></FONT></h4></P>
In the EGA text mode screen, contents are stored beginning at address <I>B8000H</I>. The screen consists of 25 rows of 80 characters. The characters are stored in sequence, using two bytes for each. The first byte is the ASCII value of the character; the second byte is the attribute, which contains color information for both the character and the background.</FONT></FONT><P>
You can't replicate the shape (and possibly the color) of the screen display by just sending characters to the printer. Instead, the printer, operating in graphics mode, must draw a reproduction of the screen display. Thus the screendump program must convert each ASCII character in display memory to the eight by 14 pixel grid which is actually written on the screen. The BIOS contains 14 bytes of shape information for each character. The eight bits in each byte represent the eight character columns, and each represents the one of the 14 character lines.<P>
Each active (light) pixel that is represented by a <I>1</I>; each inactive pixel by a <I>0</I>. The beginning address of this character array for the EGA and VGA display is found by issuing interrupt <I>10H</I> (the video services interrupt), with register <I>AH</I> containing <I>11H</I>, register <I>AL</I> containing <I>30H</I>, and register <I>BH</I> containing <I>02H</I>. The address of the beginning of the character array will be returned in registers <I>ES</I> and <I>BP</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0184_00D6">Writing To The Printer<A name="0184_00D6"></FONT></h4></P>
If a printer is assigned to parallel port <I>LPT1</I>, the same fundamental function will work to send a character to the printer regardless of the kind of printer. The function <I>put_out</I> in <A href="list1.htm">Listing 1</a>
outputs a character to the printer parallel port data register, then loops repeatedly, reading the status register until the status bit shows that the printer is ready. An <I>0DH</I> is then sent to the control port to start a strobe and an <I>0CH</I> to end the strobe. The strobe clocks the character data into the printer's receive buffer.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The function <I>print_handler</I> in <A href="list1.htm">Listing 1</a>
sends a screenful of data to the printer. To write to the CalComp Plotmaster, for example, four full sets of data are transmitted, one each for red, yellow, blue, and black. The <I>print-handler</I> function initializes the printer for graphics, then performs a loop for each of the four data sets. For each set, information on the beginning location of the display is transmitted. A loop then sends data for each of the 25 display lines. After each color panel (data set) is transmitted, the printer advances to the next one. Finally, the end-of-transmission command ejects the completed picture and returns the printer to the normal mode. The exact codes in these commands differ from printer to printer, but are usually well-documented and easy to implement.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0184_00D7">Sending A Row Of Characters In Graphics Mode<A name="0184_00D7"></FONT></h4></P>
The function <I>print_row</I> sends a row of characters to the printer. A loop repeats for each of the 80 characters in a display row. First <I>print_row</I> formulates the address in memory that contains the character to be sent. The actual address of this memory's beginning is <I>B8000H</I>. The 8086 family of microprocessors stores this address in two registers: a segment register containing <I>B000H</I> and a pointer register <I>8000H</I>. These are combined by multiplying the segment register contents by 16 and adding it to the pointer register contents. Turbo C and other implementations of C represent the address as a <I>long</I> integer consisting of the segment register contents followed by the pointer register contents. The attribute and ASCII value of the character are then read.<P>
The information for the characters comprising one display row is stored in a buffer consisting of two bytes for each of the 80 characters. The first byte contains the ASCII value of the character, and the second determines whether the foreground and background colors should be printed. The values in the attribute byte and the color panel determine the value of the second byte. It is zero if neither foreground or background is to be printed, one if the foreground is to be printed but not the background, two if the background is to be printed but not the foreground, and three if both are to be printed.<P>
Once the information for a row of characters has been deciphered and stored, <I>print_row</I> sends the information for the row to the printer. This section starts with a loop that repeats for each of the 14 lines of pixels that make up the character. Since the resolution of the printer is set to print three identical lines of dots for each line of pixels, a loop duplicates the process three times. For each printer line, <I>print_row</I> outputs the characters that specify the raster mode and the number of data bytes that follow. Two bytes of data are then sent for each character.</FONT></FONT></FONT></FONT><P>
One of four possible situations are selected by a <I>switch</I> statement. If neither foreground or background is to be printed, two bytes of zeroes are sent to the printer. If only the foreground is to be printed, two bytes in which each pair of bits corresponds to a single bit in the character representation are sent. If only the background color is to be printed, two bytes are sent; a one represents a background pixel and a zero a foreground pixel. If both foreground and background are to be printed, two bytes of 0<I>FFH</I> are sent to the printer, resulting in all pixels being printed.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0184_00D8">Replacing The Original Print Screen Function<A name="0184_00D8"></FONT></h4></P>
<I>PrtSc</I> generates interrupt <I>5</I>. To replace the standard print screen function, we must replace the standard <I>int 5</I> vector with the address of <I>print_handler</I>. The most significant byte of the int <I>5</I> vector is at address <I>17H</I>. If the original print screen function's address is still in the table, this byte should be <I>0F0H</I>, (ROM BIOS section of memory) and should be changed to use the new print routine. If the byte contains a different value, the installation program displays the message "Alternate Print Screen Routine Has Already Been Installed" and then terminates. This message will appear if the print routine has already been installed, or if a different specialized print routine has been used.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
If the new function to be installed, Turbo C's setvect command puts the address of print_handler in the vector table for interrupt 5. The function print_handler is of type interrupt, a special Turbo C type which creates a function that saves all registers at entry and restores them on exit.<P>
The registers are loaded and a <I>geninterrupt</I> command obtains the address of the 8x14 EGA character table from BIOS. This address is placed in the variable <I>new_chars</I> for future use when the interrupt is activated. The message "Text Screen Printing Routine for Plot-Master Installed" is then displayed on the screen.</FONT></FONT></FONT></FONT><P>
The Turbo C instruction <I>keep</I> is used to terminate but keep the new print screen interrupt handler resident in memory. The second parameter passed to the <I>keep</I> function is the amount of memory, in paragraphs, reserved for the function being saved. The amount of memory specified should be as little as possible, but not so small as to cut off part of the function. To determine the minimum amount of memory, temporarily comment out the main program and then compile the remainder while generating a <I>map</I> file. (In Turbo C type an <I>ALT-0</I> (Options), selecting <I>Linker</I> and then <I>Map File Detailed</I>. When compilation is completed, you can examine the <I>map</I> file to get an idea of how much memory the program requires. You should add some memory as a safety factor, convert the result to paragraphs and enter it in the <I>keep</I> statement. With the comment delimiters removed, the program can be recompiled using the tiny memory model. The compiled program should be converted from an <I>.EXE</I> program to a <I>.COM</I> program using the <I>EXE2BIN</I> utility.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
MS-DOS is not reentrant, so you must take care in designing of a function to act as an interrupt handler. Portions of the program that are to remain resident and replace the original <I>print screen</I> function must not include any calls to MS-DOS or BIOS routines. If the functions makes calls to MS-DOS or BIOS routines, it may behave unexpectedly when the interrupt is called while another MS-DOS function is active since one stack overlays another. There are ways of including checks and tests to assure that everything is compatible, but the safest method is to write the function without MS-DOS calls.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0184_00D9">Making It Work With Turbo C 2.0<A name="0184_00D9"></FONT></h4></P>
The program in <A href="list1.htm">Listing 1</a>
will work with Turbo C v1.0 or 1.5. However, it will not work with Turbo C v2.0. In the newer version, Borland has chosen to restore the original values of interrupts <I>4</I>, <I>5</I>, and <I>6</I> before leaving a Turbo C program. Thus the <I>setvect</I> command puts the address of the new <I>print</I> function into the interrupt table, but as soon as the program terminates and stays resident, the address is changed back to its original value. When the <I>PrtSc</I> key is hit, the original <I>print screen</I> function will run.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Borland's documentation doesn't call attention to the change in <I>setvect</I> but the distribution disks do include some (undocumented) files which address the problem.</FONT></FONT><P>
The assembly file <I>CO.ASM</I> contains the source code used to begin and end a Turbo C program, including the function <I>_restorezero</I>, which restores the original values of the interrupts. Remove all of this function except for the return statement. You cannot remove the entire function because it is called by several other functions. With TASM in the same directory as Turbo C rebuild the startup code by running the batch file <I>BUILD_CO.</I> This batch program will run TASM with all the proper switches set. It's best to use the TINY memory model when compiling. As a result of running this program, a new version of <I>COT.OBJ</I> is created, which replaces the version supplied with Turbo C. After compiling the print program with Turbo C using the new <I>COT.OBJ</I>, the compiled and linked program will work. </FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
This work was supported by the Department of Defense under contract AF F19628-86-C0001.<P>

<h4><a href="../../../source/1990/jul90/stevens.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
