

<HTML>
<HEAD>

<TITLE>November 1994/Standard C/C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Standard C/C++<A name="01C9_00F1"><A name="01C9_00F1"></font></h2><P>
<h3 align="center"><A name="01C9_0000"><A name="01C9_0000">Implementing &lt;ostream&gt;</h3><P>
<h3 align="center"><font color="#800000">P.J. Plauger</font></h3><hr><blockquote><P>
<P><i><A name="01C9_0000"><A name="01C9_0000">P.J. Plauger is senior editor of C/C++ Users Journal. He is convener of the ISO C standards committee, WG14, and active on the C++ committee, WG21. His latest books are The Draft Standard C++ Library, and Programming on Purpose (three volumes), all published by Prentice-Hall. You can reach him at pjp@plauger.com.</i></P><P>
<h4><FONT COLOR="#000080"><A name="01C9_00F2">Introduction <B><I>&lt;ostream&gt;</I><A name="01C9_00F2"></B></FONT></h4></P>
This is the last of three installments on the class <I>ostream,</I> defined in the header <I>&lt;ostream&gt;</I> (See "Standard C/C++: The Header <I>&lt;ostream&gt;</I>," <I>CUJ</I><I>,</I> September 1994, and "Standard C/C++: Inserters," <I>CUJ,</I> October 1994.) So far, I've shown how the draft C++ Standard defines the class and described the various member functions. I conclude this month by showing how I've chosen to implement this class.<P>
<h4><FONT COLOR="#000080"><A name="01C9_00F3">The Header File<A name="01C9_00F3"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
shows the file <I>ostream</I>, which implements the standard header <I>&lt;ostream&gt;</I>. Its principal business is defining the class <I>ostream,</I> but it also declares the manipulators <I>endl</I>, <I>ends</I>, and <I>flush</I>. The type <I>_Uninitialized</I> and the value <I>_Noinit</I> are a bit of magic needed to properly initialize the standard streams. The macro <I>_HAS_SIGNED_CHAR</I> is <I>not</I> defined for an implementation that (erroneously) fails to treat <I>signed char</I> as a type distinct from <I>char</I>.<P>
Five protected functions with secret names perform formatted output:<P>
<UL><li><I>_Ff</I> converts the <I>floatfield</I> flags into an index value (0, 4, or 8) for floating-point conversions.</li>
<li><I>_If</I> converts the <I>basefield</I> flags into an index value (0, 4, or 8) for integer conversions.</li>
<li><I>_Pad</I> inserts the characters generated by <I>_Print</I>, plus any repetitions of the fill character or zero digits (<I>0</I>).</li>
<li><I>_Pr</I> determines the (bounded) precision to use for floating-point conversions.</li>
<li><I>_Print</I> assembles the arguments for a call to <I>vsprintf</I>, declared in <I>&lt;stdio.h&gt;</I>, then calls <I>_Pad</I> to insert the padded character sequence.</li></UL>
I warned of the limitations of using the <I>fprintf</I> functions last month. I use <I>vfprintf</I> anyway because it does so much of the job, and portably in the bargain. To avoid the obvious problems, <I>_Print</I> constructs a format string with no field width and with a bounded precision. Thus, an arbitrary conversion can be stored in a fixed-length buffer. The function <I>_Pad</I> does all the things that <I>vfprintf</I> does poorly, or not at all.<P>
<I>_Print</I> is a specialized version of <I>printf</I>. Its first argument is a pointer to the first element of an array <I>code</I> of four formatting codes:<P>
<UL><li><I>code[0]</I> is <I>B</I> if an integer conversion should honor the format flag <I>show-base</I>, if a floating-point conversion should honor the format flag <I>show-point</I>, or a space character otherwise.</li>
<li><I>code[1]</I> is a dot (.) if the bounded precision_<I>Pr()</I> is the precision qualifier to use.</li>
<li><I>code[2]</I> is the conversion qualifier to use, or a space character otherwise.</li>
<li><I>code[3]</I> is the conversion specifier to use, or a space character otherwise.</li></UL>
Now you can understand how most of the formatted output functions work. Here, for example, is the definition of the inserter for type <I>short</I>:<P>
<pre>ostream&amp; operator&lt;&lt;(short _X)
   {return (_Print(&amp;"B hoB hxB hd"[_If()], _X)); }</pre>
The protected member function <I>_If</I> determines the address within the string literal that is passed to <I>_Printf</I>. If, say, the group <I>basefield</I> has only the format flag <I>hex</I> set, then the call <I>_If()</I> returns 4. The first argument to <I>_Printf</I> begins with the sequence <I>B hx</I>. If the format flag <I>showbase</I> is also set, the resultant format string on the call to <I>vfprintf</I> is then <I>%#hx</I>.<P>
With a bit of study, you should now be able to understand all the inline calls to <I>_Printf</I> within the header &lt;<I>ostream</I>&gt;.<P>
<h4><FONT COLOR="#000080"><A name="01C9_00F4">Other Files<A name="01C9_00F4"></FONT></h4></P>
<A href="list2.htm">Listing 2</a>
shows the file <I>ostream</I>.<I> c.</I> It defines the three functions you are likely to need any time you declare an object of class <I>ostream</I>, its destructor, <I>opfx()</I>, and <I>osfx()</I>. Note the use of the call <I>tie()</I> to access the stored pointer to an object of class <I>ostream</I>, just as in <I>istream::ipfx(fnt)</I>. It can be convenient to flush one output stream when inserting in another, just as you often want to flush an output stream before extracting from an associated input stream.<P>
<A href="list3.htm">Listing 3</a>
shows the file <I>osipoint.c</I>, which defines the member function <I>operator&lt;&lt;(void *)</I>. It is the only scalar formatted output function that I found too elaborate to define inline within the header.<P>
For a description of the macros <I>_TRY_IO_BEGIN</I> and <I>_CATCH_IO_END</I>, see "Standard C/C++: The Header &lt;<I>istream</I>)," <I>CUJ</I>, July 1994. They expand to different styles of exception handling, including none at all. I showed how to use them to write a generic extractor in that installment. The corresponding generic code for an inserter (in this implementation, at least) looks like:<P>
<pre>_TRY_I0_BEGIN
   if (opfx())
      &lt;perform any output&gt;
   osfx();
_CATCH_IO_END</pre>
Inserting a pointer to <I>void</I> must work in concert with extracting such a pointer. (See "Standard C/C++: Extractors," <I>CUJ</I>, August 1994.) In this implementation, the pointer overlaps an array of <I>unsigned long</I>. The function inserts elements of the array as hexadecimal integers, separated by colons. In the common case where one element of the array suffices, however, the converted pointer contains no colons.<P>
<A href="list4.htm">Listing 4</a>
shows the file <I>osprint.c</I>, which defines the member function <I>_Print</I>. It composes the format string for a call to <I>vsprintf</I> which does all the hard work in converting a string or scalar value. The varying length argument list that <I>vsprintf</I> expects is the list assembled for the call to <I>_Printf</I>. The macro <I>_MAX_EXP_DIG</I> specifies the maximum number of digits required to specify a floating-point exponent. The macro <I>_MAX_SIG_DIG</I> specifies the maximum number of significant digits required for any of the floating-point types. These are used, much as in several <I>istream</I> member functions, to define a safe buffer size for the conversion.<P>
<A href="list5.htm">Listing 5</a>
shows the file <I>ospad.c</I>, which defines the member functions <I>_Pad</I> and <I>_Pr</I>. The latter computes the bounded precision used by a floating-point conversion, as I indicated earlier. The macro <I>_MAX_SIG_DIG</I> establishes the upper bound, which should be large enough to capture all meaningful precision on a conversion by <I>vfprintf</I>.<P>
Function <I>_Pad</I> is called by <I>_Print</I> to finish a formatted output operation, as I also outlined above. The logic is, to put it mildly, intricate. It must:<P>
<UL><li>determine whether any zero digits were suppressed by bounding the precision earlier, then determine where to inject any such digits</li>
<li>determine whether any fill characters need be added, then determine where to inject any such padding</li></UL>
To keep the logic more or less readable, the code treats separately each of the five(!) places where fill characters can be injected. It also inserts all characters by calling one of two inline functions local to this translation unit:<P>
<UL><li>     <I>rep</I>, to insert a single character repeatedly</li>
<li>     <I>send</I>, to insert a character sequence once</li></UL>
The logic is nevertheless intimately dependent on the kinds of character sequences presumably generated by <I>vfprintf</I>.<P>
The remaining <I>ostream</I> member functions are relatively simple, by comparison. <A href="list6.htm">Listing 6</a>
shows the file <I>osput.c</I>, which defines the member function <I>put(char)</I>. It simply inserts the character argument into the stream buffer, with requisite checking. Note that the character inserters all end up calling <I>put(char)</I> as well.<P>
<A href="list7.htm">Listing 7</a>
shows the file <I>osistrin.c</I>, which defines the member function <I>operator&lt;&lt;(const char *)</I>. It could have been defined inline within the header, invoking the conversion specification <I>%s,</I> but that just leads to excess wheel spinning. The member function <I>_Pad</I> can perform the only difficult operation &#151; determining how to add any padding at either end of the inserted string.<P>
<A href="list8.htm">Listing 8</a>
shows the file <I>osistrea.c</I>, which defines the member function <I>operator&lt;&lt;(streambuf&amp;)</I>. It closely resembles two <I>istream</I> member functions, <I>isxtrea.c</I> (August 1994) and <I>isgstrea.c</I> (July 1994). The macro <I>_RERAISE</I> rethrows an exception from within a handler. Once again, the inner macros handle exceptions thrown during insertion, while the outer macros handle exceptions thrown during extraction.<P>
<A href="list9.htm">Listing 9</a>
shows the file <I>osflush.c</I>, which defines the member function <I>flush()</I>. And <A href="list10.htm">Listing 10</a>
shows the file <I>oswrite.c</I>, which defines the member function <I>write(const char *, int)</I>. Both simply call the appropriate <I>streambuf</I> public member function to perform the critical operation.<P>
Finally, three manipulators work only with <I>ostream</I> objects. <A href="list11.htm">Listing 11</a>
shows the file <I>endl.c</I>, which defines the function <I>endl</I>. <A href="list12.htm">Listing 12</a>
shows the file <I>ends.c</I>, which defines the function <I>ends</I>. And <A href="list13.htm">Listing 13</a>
shows the file <I>flush.c,</I> which defines the function <I>flush</I>. All three are straightforward.<P>
<I>[This article is excerpted in part from P.J. Plauger,</I> The Draft Standard C++ Library, <I>(Englewood Cliffs, NJ: Prentice Hall, 1995.]</I><P>

<h4><a href="../../../source/1994/nov94/pjp.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
