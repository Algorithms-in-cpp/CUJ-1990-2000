

<HTML>
<HEAD>

<TITLE>November 1994/Encapsulating the DOS IOCTL Interface</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Device Control</FONT></H2>

<hr><h2 align="center"><font color="#800000">Encapsulating the DOS IOCTL Interface<A name="01B2_00EB"><A name="01B2_00EB"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="01B2_0000"><A name="01B2_0000">Tom Nelson</font></h3><hr><blockquote><P>
<P><i><A name="01B2_0000"><A name="01B2_0000">Tom Nelson is an independent programmer and technical writer. His current interests are systems programming for DOS/Windows and OOP designs expressed in C++. He may be reached at 5004 W. Mt. Hope Rd., Lansing, MI 48917. Telephone (517) 322-2072.</i></P><P>
IOCTL (Input/Output Control) constitutes a subset of the MS-DOS API and forms an interface between application programs and MS-DOS device drivers. Programmers can use IOCTL to perform a wide variety of system tasks in a relatively hardware-independent manner. Though it may seem inconvenient and somewhat obscure, IOCTL is possibly among the most under-exploited group of DOS functions. It consists of a collection of some 18 subfunctions and 20 minor functions providing a wide assortment of services, albeit with its share of quirks and idiosyncrasies.<P>
Since many of IOCTL's functions seem unrelated, it's difficult to perceive them as part of a consistent, logical unit. This inconsistency, combined with its quirks, makes DOS IOCTL a good candidate for some form of encapsulation. In this article I describe how encapsulating this OS-dependent interface in C++ can make your code more maintainable and extensible, thus easier to use. You may also find this article useful if you need to convert another interface or functional group into something manageable.<P>
<h4><FONT COLOR="#000080"><A name="01B2_00EC">What IOCTL Can Do<A name="01B2_00EC"></FONT></h4></P>
IOCTL is concerned mainly with device (and file) I/O status, configuration, and control (see <A href="tab1.htm">Table 1</a>)
. IOCTL was introduced with MS-DOS 2.0 to deal with installable device drivers &#151; then a novelty for MS-DOS. Starting with MS-DOS 3.2, Generic IOCTL added low-level access to disk drives and character devices. ROM BIOS duplicated much of this capability (such as sector read/write and track format), but Generic IOCTL removed some concerns regarding incompatibilities between different BIOS implementations, allowing programmers a greater measure of device independence.<P>
You can divide IOCTL into either handle- or block-device-based functions. You can further break the handle-based functions into those dealing with files or character devices (<A href="tab1.htm">Table 1</a>)
. The file and character-device functions take an integer handle that you get from calling <I>open</I> or the equivalent. The block device functions take a logical drive number that is always "1-based"; that is, drive A: = 1, B: = 2, etc., while you indicate the default drive with 0.<P>
<h4><FONT COLOR="#000080"><A name="01B2_00ED">Class Design Issues<A name="01B2_00ED"></FONT></h4></P>
IOCTL's natural division into two main groups (handle- or drive-based) provides a framework on which to implement an encapsulated design, shown in <A href="fig1.htm">Figure 1</a>.
 The base class manages access to features common to both character and block drivers. From there, each descendant class focuses on more specific capabilities and requirements. The resulting design restricts each object to a particular handle or block device. This constraint prevents errors arising from use of invalid handles or drive codes when you access class member functions.<P>
If you want access to a character-device driver, for instance, you pass the device's handle to the class constructor for initialization. Thereafter, each member function uses only that validated handle as an argument. To access another device, you must create another IOCTL object. This design provides you with a secure pathway when you want to access a particular device driver. It's secure because of all the error checking and other implementation-specific stuff built into the class, but hidden from outside view.<P>
<h4><FONT COLOR="#000080"><A name="01B2_00EE">Handling Constructor Failure<A name="01B2_00EE"></FONT></h4></P>
A practical design must still confront the problem of constructor failure, an issue that is easy to overlook. Since constructors can't return a value indicating success or failure, the design must provide some other way to check on the constructor's success. One possible design would require each of the member functions to check for correct initialization. A slightly better approach would use a single, specially-designed member function to validate the object's initialization. However, this approach still has a drawback: in the event of constructor failure, you may need to delete the object, which you could easily forget to do.<P>
The solution I have adopted requires users to call a special front-end function or class "initializer" to create a new object <a href="#1">[1]</a>. The initializer calls the (protected) constructor, which does the actual work of initializing the object. The initializer then tests an internal data member, set by the constructor, for an indication of constructor success or failure. The initializer returns a pointer to a new object if construction was successful, or <I>NULL</I> otherwise. From a user's point of view, this approach makes object construction feel similar to calling <I>fopen</I> to open a file. (The term "class initializer" may seem like a misnomer in that it doesn't do any real initializing by itself. However, the term still seems appropriate since it's the only member function in public view empowered to create and initialize a new object.)<P>
The initializer must also be a static member of the class it initializes. Recall that static member functions, unlike normal member functions, may be called <I>before</I> an object of their class type is created. Therefore, if the initializer returns <I>NULL,</I> no object is created and the program has nothing to clean up. The code fragment in <A href="fig2.htm">Figure 2</a>
illustrates the use of static class initializers.<P>
<h4><FONT COLOR="#000080"><A name="01B2_00EF">Class Implementation Overview<A name="01B2_00EF"></FONT></h4></P>
The design implementation mirrors the basic division of the IOCTL subset into handle- and block-based functions (see <A href="fig1.htm">Figure 1</a>)
. Class <I>IoctlBase</I> sits at the top of the class hierarchy and provides two descendant classes, <I>IoctlHandle</I> and <I>IoctlBlock.</I> Class <I>IoctlHandle</I> manages access to handle-based functions for files and character device drivers, while <I>IoctlBlock</I> operates similarly for block drivers. Since you use handles to access both character devices and files, class <I>IoctlHandle</I> further serves as a base class for two other derived classes: class <I>charHandle</I> works only with handles created for character devices, while class <I>fileHandle</I> works only with file handles.<P>
Due to the volume of code necessary to implement this design, I discuss only the handle-based classes in this article. [Code for the <I>IoctlBlock</I> class appears on this month's code disk. &#151; mb] However, the <a href="sidebar1.htm">sidebar</a> presents a synopsis of all the IOCTL class member functions. Also note that class <I>charHandle</I> does not include member functions to manage device code pages. If you need these, you can easily modify <I>charHandle</I> to incorporate them, or place them in a derived class.<P>
<h4><FONT COLOR="#000080"><A name="01B2_00F0">The Base Class<A name="01B2_00F0"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
and <A href="list2.htm">Listing 2</a>
present <I>IoctlBase,</I> the IOCTL base class. <I>enum</I> blocks in <I>IoctlBase</I> list all IOCTL subfunctions and minor codes. Function <I>int21_44h</I> invokes the specified IOCTL subfunction via <I>intdosx.</I> Protected <I>REGS</I> and <I>SREGS</I> objects facilitate access to <I>int21_44h</I> (and <I>intdosx)</I> by derived classes. <I>int21_44h</I> sets <I>_dos_error</I> and calls the virtual function <I>IoctlError</I> if it detects a DOS error (by inspecting the returned carry flag). You can override <I>IoctlError</I> in any derived class to provide customized error handling.<P>
The <I>IoctlBase</I> constructor determines the MS-DOS version and places it in a form allowing direct version comparisons. Switching the high and low bytes obtained from DOS puts the major version number in the most significant position for greater/less than comparisons. The classes I present here do not prevent access to member functions based on the DOS version. You may want to add access restrictions to these classes to take best advantage of IOCTL's wide variety of version-specific services.<P>
<h4><FONT COLOR="#000080"><A name="01B2_00F1">Handle-based IOCTL<A name="01B2_00F1"></FONT></h4></P>
<A href="list3.htm">Listing 3</a>
presents the <I>IoctlHandle</I> class definition. You can use <I>IoctlHandle</I> objects to access either character device drivers or files. The inclusion of files in this context might seem inconsistent in that device drivers for files don't exist. However, because both character devices and files require handle access, they're grouped into one category here.<P>
As I mentioned earlier, I designed the IOCTL classes to provide constructor error recovery through special initialization functions. The static function <I>IoctlHandle::Init</I> (<A href="list4.htm">Listing 4</a>)
 returns a pointer to an <I>IoctlHandle</I> object, guaranteed to be correctly initialized, or your memory back. If <I>Init</I> detects incorrect object initialization, it deletes the new object and returns <I>NULL.</I> Using such a class initializer requires you to allocate new objects from the heap via the operator <I>new;</I> you can't allocate <I>IoctlHandle</I> objects on the stack. Similarly, you must explicitly deallocate <I>IoctlHandle</I> objects using the <I>delete</I> operator.<P>
Note also that <I>IoctlHandle::Init</I> is overloaded. You can pass <I>Init</I> either an existing handle (even a pre-opened, standard handle such as <I>stdprn,</I> but be careful of redirection) or a pathname that specifies the file or device to open. In either case, <I>Init</I> calls the appropriate constructor (also overloaded) to do the actual initialization. The constructor sets the internal data member <I>_handle</I> to -1 if you passed it an invalid handle or pathname. If successful, it assigns the validated handle to <I>_handle</I> (the "current handle"). <I>IoctlHandle</I> member functions use <I>_handle</I> as an argument to the corresponding IOCTL service. When the constructor returns, <I>Init</I> checks for an invalid handle and proceeds as outlined earlier.<P>
The constructor <I>IoctlHandle::IoctlHandle</I> also reads the handle information word from DOS and assigns it to the internal data member <I>_info. IoctlHandle</I> uses<I> _info</I> mainly for small bit manipulator functions, declared inline. Although using <I>_info</I> probably makes negligible difference in terms of execution time, it seems less awkward than rereading the handle information word each time from DOS.<P>
<h4><FONT COLOR="#000080"><A name="01B2_00F2">Extending <B><I>IoctlHandle</I><A name="01B2_00F2"></B></FONT></h4></P>
You can initialize <I>IoctlHandle</I> objects using either file or device handles. However, some member functions are valid only for file handles and others only for device handles. As originally designed, the class offered little protection, other than function (error) return codes, against someone attempting to use the wrong member functions (for example, passing IOCTL data to or from a device driver when the <I>IoctlHandle</I> object was initialized with a file handle). Even though return codes provided a workable solution, I wanted to provide superior error protection by preventing errors of this type in the first place, instead of dealing with them after the fact.<P>
To implement this concept, I removed all file- and device-specific member functions from <I>IoctlHandle</I>. That left <I>IoctlHandle</I> with functions that you can safely call using either file or device handles. I placed the remaining functions into two new classes, <I>charHandle</I> and <I>fileHandle</I>, deriving both from <I>IoctlHandle</I>.<P>
Class <I>charHandle</I> (<A href="list5.htm">Listing 5</a>
and <A href="list6.htm">Listing 6</a>)
 restricts <I>IoctlHandle</I> so that you can create new objects only by passing <I>charHandle::Init</I> a valid character device name. The private non-member function <I>getcat</I> attempts to match the device name argument you supplied with a pre-initialized table of valid device types. Object initialization fails if <I>getcat</I> finds no match, <I>_handle</I> refers to a file, or if the parent <I>IoctlHandle</I> constructor fails for any reason. If successful, the constructor assigns the correct device category to <I>_cat</I>. Member functions can use <I>_cat</I> when accessing any of the Generic IOCTL functions and thus also disregard errors arising from invalid device types.<P>
In analogous fashion, class <I>fileHandle</I> (<A href="list7.htm">Listing 7</a>
and <A href="list8.htm">Listing 8</a>)
 confines <I>IoctlHandle</I> objects to valid file handles. It also uses overloaded initializers so that you can create new objects using either path/file names or pre-opened file handles. Both versions of <I>fileHandle::Init</I> fail if the device bit is set in the handle information word. Effectively limiting user access to a class means that you can trap certain errors up front, instead of leaving this to member functions.<P>
<h4><FONT COLOR="#000080"><A name="01B2_00F3">Code Demonstration<A name="01B2_00F3"></FONT></h4></P>
<A href="list9.htm">Listing 9</a>
presents a simple file print utility that demonstrates the use of both the <I>charHandle</I> and <I>fileHandle</I> classes. You can use <I>FilePrint</I> objects in an application to print files in the background while the user does something else in the foreground. Note that <I>FilePrint</I> does not inherit any of the IOCTL classes, but simply initializes pointers to them when you attach an output device and submit a file to print. <I>FilePrint</I> doesn't need an internal view of <I>charHandle</I> or <I>fileHandle</I>. It utilizes the services they provide to open and validate the output device. It also ensures that the file you want to print is really a file and not a character device.<P>
<h4>Text References</FONT></h4></P>
<a name="1"></a>1     Burk, Ron. "Practical C++: Constructors that Fail," <I>Windows/DOS Developer's Journal</I>, August 1993, pp. 29-34.<P>
<a name="2"></a>2     Microsoft Corp. MS-DOS <I>Programmer's Reference. 2nd ed., Version 6.0</I>. Microsoft Press, Redmond, WA.<P>

<h4><a href="../../../source/1994/nov94/nelson.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
