

<HTML>
<HEAD>

<TITLE>November 1994/CUG Product Focus</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">CUG Product Focus<A name="01DD_00FB"><A name="01DD_00FB"></font></h2><P>
<h3 align="center"><A name="01DD_0000"><A name="01DD_0000">AISEARCH &#151; C++ Search Class Library</h3><P>
<h3 align="center"><font color="#800000">Victor R. Volkman</font></h3><hr><blockquote><P>
<P><i><A name="01DD_0000"><A name="01DD_0000">Victor R. Volkman received a BS in Computer Science from Michigan Technological University. He has been a frequent contributor to C/C++ Users Journal since 1987. He is currently employed as Senior Analyst at H.C.I.A. of Ann Arbor, Michigan. He can be reached by dial-in at the HAL 900 BBS (313) 663-4173 or by Usenet mail to <I>sysop@hal9k.com.</I></i></P><P>
<I>This article is abstracted from documentation written by Peter Bouthoorn </I><I>(</I>peter@icce.rug.nl, peter@freedom.nmsu. edu<I>)</I>,<I> the developer of AISEARCH.</I><P>
<h4><FONT COLOR="#000080"><A name="01DD_00FC">Introduction<A name="01DD_00FC"></FONT></h4></P>
Solving problems is a basic human activity. AI research has shown that computer programs solve many problems at least as easy as we do. Writing a problem-solving program requires an exact description of the problem, in a form that can be translated into a computer program. This article presents AISEARCH, a C++ library that helps programmers write problem-solving programs. AISEARCH was briefly describe in "CUG New Releases," <I>CUJ</I>, July, 1994. It is available from the CUG Library as CUG Volume 412.<P>
The AISEARCH library contains a number of search algorithms that may be used to solve a wide variety of problems. The purpose of the library is to enable the programmer to concentrate on the <I>representation</I> of the problem, not the implementation of a particular search algorithm. As a side benefit, the library encourages standardization by declaring a number of functions <I>virtual</I>, thus forcing the programmer to actively attend to their implementation.<P>
<h4><FONT COLOR="#000080"><A name="01DD_00FD">Problem Representation and Search Techniques<A name="01DD_00FD"></FONT></h4></P>
Two common techniques used for problem representation are the state space representation and problem reduction. This section describes the former, but both techniques are discussed at more length in the manual, included with CUG Volume 412.<P>
As a sample problem, consider the 8-puzzle. The 8-puzzle consists of eight numbered, movable tiles set in a 3 X 3 frame. One of the cells of the frame is always empty, which makes it possible to move the tiles.<P>
A sample 8-puzzle is shown in the figure below. Consider the problem of transforming the first configuration into the second one, the goal.<P>
<pre><B>The 8-puzzle</B></pre><P>
<pre>2 1 6     1 2 3
4 0 8 --&gt; 8 0 4
7 5 3     7 6 5</pre>
Solving this puzzle involves trying out various moves, producing new configurations until the goal is reached. More formally, solving this sort of problem is a process that starts with an <I>initial</I> configuration, and progresses toward the <I>goal</I> configuration by the application of <I>operators.</I><P>
An operator transforms one configuration into another. In the case of the 8-puzzle it is most natural to think of four such operators, each corresponding to moving the empty tile: move empty tile left, move empty tile right, move empty tile up, move empty tile down.<P>
The preceding description defines the problem-solving process in terms of a <I>state space search.</I> In a state space search the object is to reach a certain goal <I>state</I> (configuration), having started in an initial state, As it moves from an initial state to the goal, a problem such as the 8-puzzle can be in a finite number of possible configurations. All of these configurations together, i.e., <I>all possible configurations</I>, make up the <I>state space</I>. Defining the state space explicitly by enumerating all states is usually impossible; fortunately, in most cases providing rules specifying how each state can be derived from another will define the state space implicitly. For most problems the state space is so large that it would be impossible to explore the entire space, but often this is not needed, because finding one solution to a problem will be enough &#151; i.e., one path leading from the start state to the goal state. Finding this one path usually entails not an <I>exhaustive</I> search, but can be accomplished by searching only a portion of the state space. The problem of course is, which portion?<P>
In addition to selecting a portion of state space to search, the would-be problem solver must also specify a search direction. A search may proceed in two directions: if it moves forward from the start state, it is called <I>forward reasoning</I>. If the search begins with the goal as the start state and moves backward (often just as viable a strategy), it is called <I>backward reasoning</I>. These two techniques can be combined, resulting in a <I>bidirectional search</I>: it proceeds forward from the start and backward from the goal simultaneously, until the two paths meet somewhere in between. Choosing the right technique can make a big difference in the efficiency of the search.<P>
<h4><FONT COLOR="#000080"><A name="01DD_00FE">Generating Search Paths with Trees and Graphs<A name="01DD_00FE"></FONT></h4></P>
To perform a systematic search of state space, a control strategy is needed that decides which operator to apply next during the search. These strategies may commonly be represented with <I>trees</I>: construct a tree with the initial state as its root, next generate all the offspring of the root by applying all of the applicable operators to the initial state, next for every leaf node generate its successors by applying all of the applicable operators, etc. When these steps are performed, a structure such as displayed in <A href="fig1.htm">Figure 1</a>
will arise. In this representation every leaf node corresponds to a state, with the root node representing the initial state. Each operator application is represented by a connection between two nodes.<P>
Trees are a special case of a structure called a <I>graph</I>. A tree is a graph each of whose nodes has a unique parent (except for the root node, which has no parent). As every node in a tree only has one parent, there can only be one path leading to the node. In a graph, however, nodes usually have more than one parent, meaning that a given node may be part of several paths. This distinction is important, because traversing a graph as though it were merely a tree could cause the same node to be expanded more than once, which would be duplicating efforts.<P>
To avoid duplication of effort, additional bookkeeping is necessary: instead of traversing a tree, the search algorithm traverses a <I>directed graph</I>. Every time a node is generated the algorithm examines the set of nodes generated so far to see if this node is already part of the graph. Nodes that are already part of the graph are ignored; only new nodes are added to the graph (for exceptions to this rule see the documentation included with the code). This strategy also solves a related problem: if the search algorithm did not check whether a node had been generated before, it would very likely end up in a <I>cycle</I>, in which the same set of nodes is generated over and over again. For instance, by applying operator 'move empty tile left,' then 'move empty tile right,' then 'move empty tile left' etc. to the 8-puzzle, the problem-solving process would go on producing the same nodes without end. Checking for the presence of nodes beforehand avoids this problem.<P>
<h4><FONT COLOR="#000080"><A name="01DD_00FF">Control Strategies<A name="01DD_00FF"></FONT></h4></P>
The last section mentioned that a control strategy is needed to decide which operator to apply next when traversing a search tree. Two basic strategies are the <I>depth-first</I> and <I>breadth-first</I> search. The first strategy searches one entire branch of the tree before expanding the next branch, expanding the most recently generated node first. By contrast, a breadth-first search expands nodes in the order in which they are generated, which means that all nodes are expanded on the same level in different branches, before proceeding to the nodes in the next level.<P>
Another search technique is the <I>uniform-cost</I> search, which is used to find the optimum solution to a problem. This technique is required when, for instance, finding the shortest route between two cities. In this case it is not sufficient just to find any route &#151; only the shortest (the optimum solution) will do. To guarantee that the optimum solution (also called the cheapest path) will be found the algorithm associates a cost with every node in the search tree. These costs enable the algorithm to select the cheapest nodes so far for expansion. Instead of expanding paths of equal length (like the breadth-first method), the uniform-cost search technique expands paths of equal cost. The cost associated with a node consists of the cost associated with its parent plus the cost of getting from the parent to the node. The function used to compute this cost is usually called g(n).<P>
<h4><FONT COLOR="#000080"><A name="01DD_0100">Improving the Search Process<A name="01DD_0100"></FONT></h4></P>
All of the methods described so far are called <I>blind-search procedures</I> because they do not use any specific information about the problem to be solved, i.e, the search process just continues until it happens on a solution. To improve the efficiency of the search it should be directed in some way toward the goal. An alogrithm may perform a more intelligent search by applying a <I>heuristic</I> (roughly, a rule-of-thumb) that guides the search to promising areas. The best-first search technique, also called the <I>A</I>* <I>algorithm</I> is one such technique, which calls a special <I>heuristic function</I>. This function gives an estimate of how far a node is removed from the goal node. The search algorithm uses this information to select nodes that have good heuristic values, i.e, nodes that are (or at least seem to be) closest to the goal. This heuristic function f(n) is the sum of two components: g(n), and h(n). Function g(n) is the function described earlier; function h(n) is an estimate of the additional cost of getting from the current node to a goal state. Put differently, h(n) is the function in which the real heuristic knowledge is embedded. Using function f(n), the algorithm selects the most promising of the nodes that have so far been generated but not expanded.<P>
<h4><FONT COLOR="#000080"><A name="01DD_0101">The Search Class Library<A name="01DD_0101"></FONT></h4></P>
Before describing details of the AISEARCH library, this article will address a troubling question: why use C++ to solve an AI-type problem when so many specialized AI programming languages are available? One reason is simply to satisfy curiousity &#151; the creators of AISEARCH wanted to know how much more effort would be required to use a lower-level programming language (compared to languages like Prolog) to program for this type of problem. C++ seemed excellent for this investigation because it is based on C, a third-generation programming language, and also because it follows the object-oriented paradigm. But the main reason for using C++ is that it supports <I>inheritance</I>. This feature enables the programmer to easily make use of existing software when developing new applications. Combined with C++'s ability to define <I>virtual</I> functions, inheritance makes it possible to design foundation classes that are of no use in themselves, but that can be easily extended for real applications.<P>
The preceding discussion demonstrated that problems can be solved using standard techniques, such as the state-space representation and search. AISEARCH enables the programmer to easily incorporate these standard techniques into an application when designing problem-solving software. AISEARCH offers these standard techniques in the form of foundation classes. Each class implements a particular search algorithm while leaving open the exact nature of the problem to be solved. Using these classes the programmers can concentrate on the representation of the problem at hand without having to worry about how the problem has to be solved. This sort of freedom is also offered by declarative languages, such as Prolog; but unlike Prolog, AISEARCH does not restrict the programmer to a fixed search method. (Prolog implements depth-first seach only.)<P>
<h4><FONT COLOR="#000080"><A name="01DD_0102">Using the Library<A name="01DD_0102"></FONT></h4></P>
The search algorithms that the library supports can be divided into three groups: uni-directional (this is normal search), bidirectional, and AND/OR-search (search routines related to problem reduction). AISEARCH implements these three kinds of search techniques as three base classes, which should never be used for direct derivation. The programmer sees only the classes derived from these base classes, and these derived classes implement the actual search algorithms:<P>
<UL><li>Depth-first search, both tree search and graph search</li>
<li>Breadth-first search, idem.</li>
<li>Uniform-cost search, idem.</li>
<li>Best-first search</li>
<li>Bi-directional depth-first search, idem.</li>
<li>Bi-directional breadth-first search, idem.</li>
<li>AND/OR depth-first search, tree search only</li>
<li>AND/OR breadth-first search, tree search only</li></UL>
To make use of any of these algorithms the programmer designs a new class and derives this class from the desired search class, as in<P>
<pre>class PUZZLE_: public DEPTH_GRAPH
// select depth first
{
   ...
};</pre>
The names of the search classes correspond to the names of the search techniques, graph and tree search being differentiated by a different "extension," <I>_GRAPH</I>_and_<I>TREE_</I>respectively.<P>
Determining the search algorithm is only one part of the problem-solving process. What's left is developing the problem representation. The programmer puts together this representation by using class <I>NODE_</I> or one of its derivatives. Class <I>NODE_</I> specifies a general structure that is to be processed by different search classes. (Note that some search classes must be used in combination with a derivative of class <I>NODE_</I> rather than with <I>NODE_</I> itself, see manual.) The programmer turns the problem representation into a class that is derived from class <I>NODE_</I> (or from one of its derivatives, depending on the search class that is used), like this:<P>
<pre>class PNODE_: public NODE_{ ..... };</pre>
Of course there is more to using the search class library than just deriving from the classes in the library. The program must exchange information wwith these classes. This occurs in two ways: through constractors, and through functions that have been declared <I>virtual </I>in the libray. Every class derived from one of the search classes must pass this search class the start node and goal node of the problem to be solved, and the number of operators that may be applied to each node. For example, to solve an 8-puzzle problem using the depth-first algorithm, a class <I>PUZZLE_</I> might have the following constructor:<P>
<pre>PUZZLE_::PUZZLE_(PNODE_ *start, PNODE_ *goal )
   :DEPTH_GRAPH_(start, goal, 4)
{  // pass start node, goal node and number of
}  // operators to DEPTH_GRAPH_'s constructor</pre>
The second way of passing information comes into play when search classes containing virtual functions are used. Class <I>BEST</I>_, an implementation of the A* algorithm, has two virtual functions: <I>compute_g( )</I> and <I>compute_h( )</I>, which form the framework for computing the heuristic value of a node. The library declares these functions <I>virtual</I> because the heuristic function described in the earlier section is problem-dependent; the functions must be implemented by the programmer, who has knowledge of the problem.<P>
Class <I>NODE</I>_ also has a number of virtual functions that must be instantiated by the programmer. One of the most important is <I>do_operator</I>, used for expanding a node. <I>do_operator's</I> definition appears as follows:<P>
<pre>NODE_ *do_operator(int) const
// apply operator n and
// return new node or NULL</pre>
The integer passed to <I>do_operator</I> tells the function which operator must be applied. If the operator can be applied <I>do_operator</I> returns the node resulting from the operator application; if not, it returns a null.<P>
Some problems, however, do not have a fixed number of operators at each node. For example, in the route-finding problem, there generally will be a variable number of roads leading from one city to other cities. In this case it would be easier to apply all the operators (if they can be called that) at once and return the resulting new nodes together. Such is the operation of function <I>expand</I>, which returns a linked list of all node successors:<P>
<pre>NODE_ *expand(int) const
// expand node and return all of
// its successors in a linked list</pre>
AISEARCH contains a couple of other virtual functions like these. All of them are explained in the manual included with the code. Implementing these functions is mandatory (some have been declared pure <I>virtual</I>) because without them many of the routines in the library will not work. As noted in the introduction these functions also help standardize the development of the problem representation &#151; developing the representation is like filling in the necessary gaps.<P>
<h4><FONT COLOR="#000080"><A name="01DD_0103">Acknowledgements<A name="01DD_0103"></FONT></h4></P>
Peter Bouthourn wishes to thank Erik Tjong Kim Sang (<I>erik@let.rug.ul</I>) for his help and encouragement in writing the document on which this article is based.<P>
<h4><FONT COLOR="#000080"><A name="01DD_0104">Bibliography<A name="01DD_0104"></FONT></h4></P>
Winston, P.H., <I>Artificial Intelligence,</I> (2nd ed.). London: Addison-Wesley, 1984.<P>
Barr, A., Feigenbaum, E.A. <I>The Handbook of Artificial Intelligence. </I>Los Altos: Kaufmann, 1983.<P>
Nilsson, N.J. <I>Problem Solving Methods in Artificial Intelligence</I>. New York: McGraw-Hill, 1971.<P>
Nilsson, N.J. <I>Principles of Artificial Intelligence</I>. Los Altos: Kaufmann, 1986.<P>
Knuth, D.E. <I>The Art of Computer Programming</I>, (2nd ed.). London: Addison-Wesley, 1979.<P>
Pearl, J. <I>Heuristics: Intelligent Strategies for Computer Problem Solving</I>. London: Addison-Wesley, 1984.<P>
Rich, E. <I>Artificial Intelligence</I>, New York: McGraw-Hill, 1983.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
