

<HTML>
<HEAD>

<TITLE>November 1994/The C9X Charter</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">The C9X Charter<A name="01B7_00ED"><A name="01B7_00ED"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="01B7_0000"><A name="01B7_0000">Rex Jaeschke</font></h3><hr><blockquote><P>
<P><i><A name="01B7_0000"><A name="01B7_0000">Rex Jaeschke is an independent computer consultant, author, and seminar leader. He is chair of the ANSI C committee X3J11. Readers may contact Rex at 2051 Swans Neck Way, Reston, VA 22091 or via UUCP at rex@aussie.com.</i></P><P>
<h4><FONT COLOR="#000080"><A name="01B7_00EE">Introduction<A name="01B7_00EE"></FONT></h4></P>
At the December 1993 WG14/X3J11 meeting in Kona, Hawaii, there was general agreement that we should start thinking about the next version of the C Standard. I accepted an action item to draft a revision charter, the result of which is this paper. The intention of this document is to present a statement of principles and a plan of attack. It does not identify any technical issues, since those are immaterial at this stage.<P>
Although we are not yet required to begin work on a revised standard, there is much happening that can or does influence Standard C directly. Examples are the evolution of C++ (and object-oriented programming in general), the numerical extensions being proposed by X3J11, internationalization, advancements in character-set standardization, and cross-language standards and bindings.<P>
<h4><FONT COLOR="#000080"><A name="01B7_00EF">Original Principles<A name="01B7_00EF"></FONT></h4></P>
Before we embark on a revision of the C Standard, it is useful to reflect on the charter of the original drafting committee. According to the original Rational Document in the section entitled <I>Purpose:</I><P>
The work of the Committee was in large part a balancing act. The Committee has tried to improve portability while retaining the definition of certain features of C as machine-dependent. It attempted to incorporate valuable new ideas without disrupting the basic structure and fabric of the language. It tried to develop a clear and consistent language without invalidating existing programs. All of the goals were important and each decision was weighed in the light of sometimes contradictory requirements in an attempt to reach a workable compromise.<P>
In specifying a standard language, the Committee used several guiding principles, the most important of which are:<P>
1. <I>Existing code is important, existing implementations are not.</I> A large body of C code exists of considerable commercial value. Every attempt has been made to ensure that the bulk of this code will be acceptable to any implementation conforming to the Standard. The Committee did not want to force most programmers to modify their C programs just to have them accepted by a conforming translator.<P>
On the other hand, no one implementation was held up as the exemplar by which to define C. It is assumed that all existing implementations must change somewhat to conform to the Standard.<P>
2. <I>C code can be portable.</I> Although the C language was originally born with the UNIX operating system on the DEC PDP-11, it has since been implemented on a wide variety of computers and operating systems. It has also seen considerable use in cross-compilation of code for embedded systems to be executed in a freestanding environment. The Committee has attempted to specify the language and the library to be as widely implementable as possible, while recognizing that a system must meet certain minimum criteria to be considered a viable host or target for the language.<P>
3. <I>C code can be non-portable.</I> Although it strove to give programmers the opportunity to write truly portable programs, the Committee did not want to force programmers into writing portably, to preclude the use of C as a "high-level assembler;" the ability to write machine-specific code is one of the strengths of C. It is this principle which largely motivates drawing the distinction between strictly conforming program and conforming program.<P>
4. <I>Avoid "quiet changes."</I> Any change to widespread practice altering the meaning of existing code causes problems. Changes that cause code to be so ill-formed as to require diagnostic messages are at least easy to detect. As much as seemed possible consistent with its other goals, the Committee has avoided changes that quietly alter one valid program to another with different semantics, that cause a working program to work differently without notice. In important places where this principle is violated, the Rationale points out a <I>quiet change.</I><P>
5. <I>A standard is a treaty between implementor and programmer</I>. Some numerical limits have been added to the Standard to give both implementors and programmers a better understanding of what must be provided by an implementation, of what can be expected and depended upon to exist. These limits are presented as minimum maxima (i.e., lower limits placed on the values of upper limits specified by an implementation) with the understanding that any implementor is at liberty to provide higher limits than the Standard mandates. Any program that takes advantage of these more tolerant limits is not strictly conforming, however, since other implementations are at liberty to enforce the mandated limits.<P>
<I>6. Keep the spirit of C.</I> The Committee kept as a major goal to preserve the traditional spirit of C. There are many facets of the spirit of C, but the essence is a community sentiment of the underlying principles upon which the C language is based. Some of the facets of the spirit of C can be summarized in phrases like<P>
<pre> a)     Trust the programmer.
 b)     Don't prevent the programmer from doing what needs to be done.
 c)     Keep the language small and simple.
 d)     Provide only one way to do an operation.
 e)     Make it fast, even if it is not guaranteed to be portable.</pre>
The last proverb needs a little explanation. The potential for efficient code generation is one of the most important strengths of C. To help ensure that no code explosion occurs for what appears to be a very simple operation, many operations are defined to be how the target machine's hardware does it rather than by a general abstract rule. An example of this willingness to live with what the machine does can be seen in the rules that govern the widening of <I>char</I> objects for use in expressions. Whether the values of <I>char</I> objects widen to signed or unsigned quantities typically depends on which byte operation is more efficient on the target machine.<P>
One of the goals of the Committee was to avoid interfering with the ability of translators to generate compact, efficient code. In several cases the Committee has introduced features to improve the possible efficiency of the generated code; for instance, floating point operations may be performed in single-precision if both operands are <I>float</I> rather than <I>double.</I><P>
<h4><FONT COLOR="#000080"><A name="01B7_00F0">Additional Principles<A name="01B7_00F0"></FONT></h4></P>
At the July 1994 WG14 meeting in Tokyo, Japan, the original principles were re-endorsed and the following new ones were added:<P>
7. <I>Support international programming</I>. During the initial standardization process, support for internationalization was something of an afterthought. Now that internationalization has proved to be an important topic, it should have equal visibility with other topics. As a result, all revision proposals submitted shall be reviewed with regard to their impact on internationalization as well as for other technical merit.<P>
8. <I>Codify existing practice to address evident deficiencies.</I> We should accept only those concepts that have some prior art. Unless some proposed new feature addresses an evident deficiency that is actually felt by more than a few C programmers, we should entertain no new inventions.<P>
9. <I>Minimize incompatibilities with C90 (ISO/IEC 9899-1990).</I> It should be possible for existing C implementations to gradually migrate to future conformance, rather than requiring a replacement of the environment. It should also be possible for the vast majority of existing conforming C programs to run unchanged.<P>
10. <I>Minimize incompatibilities with C</I>++. We recognize the need for a clear and defensible plan with regard to how we intend to address the compatibility issue with C++. We endorse the principle of maintaining the <I>largest common subset</I> clearly and from the outset. Such a principle should satisfy the requirement to maximize overlap of the languages while maintaining a distinction between them and allowing them to evolve separately.<P>
Regarding our relationship with C++, we are content to let C++ be the "big" and ambitious language. While we may well embrace some features of C++, it is not our intention that C become C++.<P>
11. <I>Maintain conceptual simplicity.</I> We prefer an economy of concepts that do the job. We should identify the issues and prescribe the minimal amount of machinery that will solve them. We recognize the importance of being able to describe and teach new concepts in a straightforward and concise manner.<P>
<h4><FONT COLOR="#000080"><A name="01B7_00F1">Observations and Influences<A name="01B7_00F1"></FONT></h4></P>
During the revision process, it will be important to consider the following observations:<P>
1. There has been a very positive reception of the C Standard from both the user and vendor communities.<P>
2. The C Standard is not considered to be broken. Rather, the revision is needed to track emerging and/or changing technologies and internationalization requirements.<P>
3. Most users of Standard C view it as a general-purpose high-level language. While "higher level" constructs can be added, they should be done so only if they don't contradict the basic principles.<P>
4. There are a good number of useful suggestions to be found from the public comments and defect report processing.<P>
Areas to which we shall look when revising C include:<P>
1. Amendment 1 to the C Standard.<P>
2. All Technical Corrigenda and Records of Response.<P>
3. Future directions in the current C Standard.<P>
4. Features currently labeled obsolescent.<P>
5. Cross-language standards groups work: language-independent arithmetic (WG11), POSIX (WG15), internationalization (WG20), X/Open, bindings such as GKS, and parallel processing.<P>
6. The evolution of C++ (WG21).<P>
7. The evolution of other languages, particularly with regard to interlanguage communication issues.<P>
8. Other papers and proposals from member delegations, such as the numerical extensions Technical Report being proposed by X3J11.<P>
9. Other comments from the public at large.<P>
10. Other prior art.<P>
<h4><FONT COLOR="#000080"><A name="01B7_00F2">Submissions<A name="01B7_00F2"></FONT></h4></P>
Without a set of acceptance criteria, judging any technical proposal becomes a highly subjective, and definitely emotional, exercise. It also wastes a lot of time and energy. Therefore, we encourage submittors to keep all the guiding principles in mind when making submissions.<P>
We shall provide guidelines for the submission of proposals. Each submission shall contain a cover page containing responses to a number of questions and further summary information enabling the essence of a submission to be distilled simply by reading that cover. The information requested will include such things as: title, author, author affiliation, date, document number, abstract, proposal category (e.g., editorial, correction, new feature), prior art, and target audience. Proposals that are not directly linked must be submitted separately, each with their own document number and cover page.<P>
Submissions must be sponsored in the same way as defect reports; that is, either by the Convener of WG14, WG14 itself, or by a WG14 national member body. This provides a filtering process and allows submissions to be rejected early in the process if they violate the revision principles. It also allows substantially incomplete or disjoint proposals to be returned for further refinement.<P>
<h4><FONT COLOR="#000080"><A name="01B7_00F3">Documentation and Scheduling<A name="01B7_00F3"></FONT></h4></P>
A Rationale document will be maintained and an editor will be appointed.<P>
An editor for the revised C Standard will be appointed. The initial job of the editor will be to integrate Amendment 1 and Technical Corrigenda into a single base document against which we can work when considering and/or preparing technical papers, as well as in handling current and future defect reports.<P>
The milestones for the revision process are:<P>
1.     CD Registration &#151; December 1996<P>
2.     CD Ballot &#151; December 1997<P>
3.     DIS Ballot &#151; December 1998<P>
This schedule allows for the formal adoption of a revised standard by the end of 1999.<P>
The purpose of this schedule is twofold:<P>
1. To provide the public with a reasonably accurate idea of when a revised C Standard is likely to appear.<P>
2. To keep the revision process focused.<P>
[At the risk of stimulating an avalanche of "enhancements" to the C Standard, the two committees will soon make available the submission form described above. The form will be approved at the December 1994 WG14/X3J11 meeting in Dallas, Texas. Some readers will doubtless note that I, as Converter of WG14, have the authority to sponsor submissions. Please also note that I reserve the right to be whimsical in doing so. If you want sponsorship with clout, contact your national standards body. For example, the US organization responsible for C is X3J11. Rex Jaeschke is Chair. &#151; pjp]<P>
</BLOCKQUOTE>
</BODY>
</HTML>
