<HTML>
<HEAD>

<TITLE>February 1990/Object-Oriented Programming As A Programming Style</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Object-Oriented Programming As A Programming Style<A name="005D_0031"><A name="005D_0031"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="005D_0000"><A name="005D_0000">Eric White</font></h3><hr><blockquote><P>
<P><i><A name="005D_0000"><A name="005D_0000">Eric White is a software engineer at Advanced Programming Institute, Ltd. He is working on a character-based version of XVT. XVT is a common programming interface with implementations for various window systems, including Macintosh, Microsoft Windows, Presentation Manager, OSF/Motif, and character based on UNIX and MS-DOS. He can be reached at API at (303) 443-4223.</i></P><P>
Object-oriented programming is a programming style that can be used in many languages, including C and C++. Some programmers think that C++ gives them the ability to do object-oriented programming. This isn't accurate -- C programmers can already do object-oriented programming. I will demonstrate by showing two identically structured object-oriented programs, one in C and the other in C++.<P>
Even though one can do object-oriented programming in C, C++ offers several advantages: C++ supplies syntactic support for object-oriented programming and C++ provides type checking where not possible in C.<P>
I am assuming the reader has already read one of the numerous magazine articles that introduce object-oriented programming. A good article is "Mapping Object Oriented Concepts Into C++ Language Facilities", CUJ July '89 by Tsvi BarDavid. If you already know C, an example of object-oriented programming in C can clarify exactly what is goes on in object-oriented programming. Once you understand the C example, the identical example in C++ can make learning C++ easier. You can even imagine how the code generated by a C++ translator looks.<P>
<h4><FONT COLOR="#000080"><A name="005D_0032">The Example<A name="005D_0032"></FONT></h4></P>
I'll develop the comparison using a graphical application that could be the beginnings of a drawing program such as Mac Draw. This example is constructed with four classes of objects: <I>graph_obj</I>, <I>circle</I>, <I>square</I>, and <I>double_circle</I>. Three instructions can be given to any one of these objects:</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<UL><li><I>init</I>, which takes as arguments the initial position and size of the object. <I>init</I> initializes the object, then draws it.</FONT></FONT></FONT></FONT></li>
<li><I>move</I>, which draws the object in black, modifies the position, then draws it in white. <I>move</I> takes a change in the <I>y</I> and <I>x</I> coordinates as arguments.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></li>
<li><I>draw</I>, used by <I>init</I> and <I>move</I>. draw takes a color as an argument.</FONT></FONT></FONT></FONT></FONT></FONT></li></UL>
<h4><FONT COLOR="#000080"><A name="005D_0033">The Listings<A name="005D_0033"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
is the pseudo-code for the example. The code in <A href="list2.htm">Listing 2</a>
(<I>obj.h</I>) and <A href="list3.htm">Listing 3</a>
(<I>obj.c</I>) facilitates object-oriented programming in C, allowing the creation of classes, methods, objects, and implementing inheritance. <A href="list4.htm">Listing 4</a>
(<I>drawc.c</I>) and <A href="list5.htm">Listing 5</a>
(<I>drawcxx.cxx</I>) are two examples of object-oriented code in C and C++ respectively. They perform identically.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
In the pseudo-code, you can see:<P>
<UL><li>We derive classes <I>circle</I> and <I>square</I> from class <I>graph_obj</I>.</FONT></FONT></FONT></FONT></FONT></FONT></li>
<li>We derive class <I>double_circle</I> from class <I>circle</I>.</FONT></FONT></FONT></FONT></li>
<li>All classes inherit the method <I>move</I> from class <I>graph_obj</I>. If method <I>move</I> needs to be invoked for an object of class <I>circle</I>, then method <I>move</I> of class <I>graph_obj</I> is actually the function called. We are able to reuse the <I>move</I> method for every class in this example.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></li>
<li>Class <I>double_circle</I> inherits the method <I>init</I> from class <I>circle</I>.</FONT></FONT></FONT></FONT></FONT></FONT></li>
<li>Class <I>double_circle</I> overrides the method <I>draw</I> from class <I>circle</I>. If method <I>draw</I> needs to be invoked for an object of class <I>double_circle</I>, then the method is not inherited from the super-class.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></li></UL>
For portability, I isolate the graphics functions in a utility module. <A href="list6.htm">Listing 6</a>
(<I>utility.h</I>) is the interface to the utility module. <A href="list7.htm">Listing 7</a>
(<I>utility.c</I>) contains <I>fatal()</I> and the graphical functions. The utility module is compiled and linked with either the C or C++ code. The isolation also makes it easier to compare the two object-oriented examples.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="005D_0034">Object-Oriented Programming In C<A name="005D_0034"></FONT></h4></P>
This system implements classes, methods, objects, inheritance, and messages. The entire module that facilitates object-oriented programming is less than 90 lines of code.<P>
I'll start with a simple data abstraction mechanism, then develop it into a system that supports classes, inheritance, and messages.<P>
The most natural means of creating an object and associating methods with it is to put pointers to the methods (pointers to functions) in a structure along with the data. A structure for an instance of a circle might look like this:<P>
<pre>struct {
    int y;
    int x;
    int radius;
    void (*init)();
    void (*draw)();
    void (*move)();
} circle;</pre>
This implements an object that knows how to initialize itself, draw itself, and move itself. The implementation could vary for different types (such as a double circle). However, we might get tired of setting up the methods every time we create a new instance of a circle. A solution is to design another structure (called a <I>class</I>) that contains the pointers to the functions, and place only a pointer to the class in each object. With this technique we may create a class once, then create several objects and have them point to that class.</FONT></FONT><P>
To make the <I>class</I> structure more generic, we define an array of pointers to functions, and by convention, define the methods as an index into this array. The code now looks like</FONT></FONT><P>
<pre>/* defines for methods */
#define INIT 0
#define DRAW 1
#define MOVE 2

struct class {
    int nbr_methods;
    void (**method)();
};

typedef struct class CLASS;

struct {
    CLASS *class;
    int y;
    int x;
    int radius; }
circle;</pre>
When creating a class, we need to initialize the array of pointers to functions after allocating memory for it. If the method is implemented in the class itself, then the pointer is set to the function address. If the method is inherited from the super-class, then the pointer is loaded from the super-class.<P>
To make an object more generic, we'll take the definition of the data out of the object and replace it with a pointer to the data. Space for the data is allocated when the object is created and freed when the object is no longer needed. <A href="list2.htm">Listing 2</a>
contains the final definitions of structures for <I>class</I> and <I>object</I>.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="005D_0035">Classes<A name="005D_0035"></FONT></h4></P>
To define a class:<P>
<UL><li>Define a structure to hold the information about the class. (<A href="list6.htm">Listing 6</a>,
 lines 15-18)</li>
<li>Write the methods (the functions associated with the class). An example is the <I>DRAW</I> method for class <I>circle</I>. (<A href="list6.htm">Listing 6</a>,
 lines 69-81)</FONT></FONT></FONT></FONT></li>
<li>Declare a structure of type <I>class</I>. (<A href="list6.htm">Listing 6</a>,
 line 143)</FONT></FONT></li>
<li>Call <I>new_class()</I>, which loads the pointers to the inherited methods from the super-class. It also saves the size of memory needed for each object in the class. (<A href="list6.htm">Listing 6</a>,
 line 160)</FONT></FONT></li>
<li>Call <I>reg_method()</I> to register each method that we want to implement in the class being created. Registering a method means storing a pointer to a function in the array of pointers to functions. <I>reg_method()</I> shouldn't be called for methods inherited from the super-class. (<A href="list6.htm">Listing 6</a>,
 lines 161-162)</FONT></FONT></FONT></FONT></li></UL>
<h4><FONT COLOR="#000080"><A name="005D_0036">Methods<A name="005D_0036"></FONT></h4></P>
A method is a function written specifically to go with the class. In this example, methods don't return a value.<P>
All methods should be aware that <I>obj-&gt;data</I> is a pointer to the data allocated on the heap. For a particular class, this data is of an assumed structure type. By casting <I>obj-&gt;data</I> to a pointer to a structure, the method can access the object data correctly.</FONT></FONT></FONT></FONT><P>
All methods receive the argument <I>arg_ptr</I>, which can be used with the macro <I>va_arg()</I> if there are arguments to the method. See your documentation on <I>stdarg.h.</I></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="005D_0037">Objects<A name="005D_0037"></FONT></h4></P>
The structure that holds what we need to know about an object is:<P>
<pre>typedef struct {
    void *data; 
    CLASS *class;
} OBJECT;</pre>
To create and use an object:<P>
<UL><li>Declare a structure of type <I>OBJECT</I>. (<A href="list6.htm">Listing 6</a>,
 line 148)</FONT></FONT></li>
<li>Call the function <I>new_object()</I>, which registers a class with the object and allocates memory for the object. (<A href="list6.htm">Listing 6</a>,
 line 174)</FONT></FONT></li>
<li>Send messages to the object. With the graphical objects in the example, the first message that we want to send is the <I>INIT</I> message. (<A href="list6.htm">Listing 6</a>,
 line 175). After that, we can send <I>MOVE</I> or <I>DRAW</I> messages. (<A href="list6.htm">Listing 6</a>,
 line 186)</FONT></FONT></FONT></FONT></FONT></FONT></li>
<li>When done with the object, we call <I>free_object ()</I>, which frees the allocated memory. (<A href="list6.htm">Listing 6</a>,
 line 191)</FONT></FONT></li></UL>
<h4><FONT COLOR="#000080"><A name="005D_0038">Inheritance<A name="005D_0038"></FONT></h4></P>
Inheritance of methods is demonstrated here. <I>circle</I> inherits <I>MOVE</I> from class <I>graph_obj</I>. <I>double_circle</I> inherits <I>INIT</I> and <I>MOVE</I> from its super-classes.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
I implement inheritance of data structures by having a sub-class allocate more memory than the super-class. The sub-class data consists of the parent-class data followed by the data specific to the subclass.<P>
<h4><FONT COLOR="#000080"><A name="005D_0039">Messages<A name="005D_0039"></FONT></h4></P>
There is a distinction between a message and a method. A message gets sent to an object, and then something decides which method to invoke. Invoking a method means that the function that is part of the class is called. In C++, the translator decides which method to invoke. In the system implemented in C, the function <I>message()</I> (<A href="list3.htm">Listing 3</a>)
 decides, based on the class of the object.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="005D_003A">Summary Of OOP In C<A name="005D_003A"></FONT></h4></P>
One disadvantage of doing object-oriented programming in C is that there is no function prototyping. We have no idea what the arguments to a method are when we declare the pointers to functions in the class structure. Programmers are responsible for sending the correct parameters to a message.<P>
Another disadvantage is that when writing methods, the programmer must access the data in the object correctly. The pointer to the data in the object structure must be cast as a pointer to the correct structure type.<P>
<h4><FONT COLOR="#000080"><A name="005D_003B">Object-Oriented Programming In C++<A name="005D_003B"></FONT></h4></P>
The C++ example also demonstrates classes, methods, objects, inheritance, and messages.<P>
I'll explain a small subset of the syntax of C++, only what is essential to do object-oriented programming. There are many features of C++ that have nothing to do with object-oriented programming, and the object-oriented programming part of C++ is elaborate, with useful but nonessential features. The subset is:<P>
<UL><li>Definition of a class, with and without a super-class.</li>
<li>Definition of a method.</li>
<li>Declaration of an object.</li>
<li>Sending a message to an object.</li></UL>
<h4><FONT COLOR="#000080"><A name="005D_003C">Classes<A name="005D_003C"></FONT></h4></P>
The three essential pieces of a class are:<P>
<UL><li>The data structure of the class.</li>
<li>The super-class if there is one.</li>
<li>The methods.</li></UL>
The definition of a class in C++ looks like:<P>
<pre>class graph_obj {
public:
    int y;
    int x;
    void init(int y, int x);
    void move(int y, int x);
    virtual void draw(int color){};
};</pre>
<I>y</I> and <I>x</I> are the data that will be contained in an object of class <I>graph_obj.</I> To define methods, you put the function prototype for the methods in the definition of the class.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The class <I>graph_obj</I> doesn't have a super-class. When defining a class where there is a super-class, you follow the name of the class by a colon (<I>:</I>), the keyword <I>public</I>, and the name of the super-class. For example:</FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>class circle : public graph_obj {
public:
    int radius;
    void init(int y, int x, int
radius);
    void draw(int color);
};</pre>
Members of a class may be private or public. For simplicity's sake, all members of all classes in this example are public. I'm not attempting to do data-hiding in this example. Hiding data is a separate (and important) issue, but is beyond the scope of this article. The keyword <I>public</I> before the name of the super-class means that all the public members of the super-class are public members of the sub-class.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="005D_003D">Methods<A name="005D_003D"></FONT></h4></P>
The definition of a method looks similar to that of a function. To define the name of the function, you follow the class name with the scope resolution operator :: and the name of the method. For example, the <I>draw</I> method for class circle would look like this:</FONT></FONT><P>
<pre>void circle::draw(int color)
{
    /* code to draw a circle */
    ...
}</pre>
Here is an important note about coding a method. A hidden argument to every method is the object. When a method gets invoked for a particular object, by definition you get access to that object. You can access the members of that object just by using the names of the members.<P>
Methods are invoked much as functions are called in C. Sometimes, when writing code for a method, we want to force a method to be invoked for a super-class, and the class for which we are writing the method has a method of the same name as the one in the super-class that we want to invoke. In this case, we can use the scope resolution operator (<I>::</I>) and force the method to be invoked for the super-class. For the <I>init</I> method for class <I>circle</I>, to invoke the <I>init</I> method for class <I>graph_obj</I>, we specify the name of the class, followed by the scope resolution operator, followed by the name of the method.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Sometimes the method to invoke at run time can't be determined because a particular section of code could be operating on many types of objects. In C++, code such as this must be operating on objects of a certain class, or of a sub-class of that class. If you declare a method of a class highest in the class hierarchy <I>virtual</I>, C++ will wait until run time to make the decision of which method to invoke, and will invoke the correct method for the object being operated on. To do this, C++ puts something in the object that indicates which class it is. Resolution of the method to invoke at run time is called late binding.</FONT></FONT><P>
This is useful when you send messages to pointers to objects, where the pointer could point to one of several classes of objects. It's also useful in a method that serves a class and its subclasses. <I>draw</I> is <I>virtual</I> because the method <I>move</I> (which uses the method <I>draw</I>) in class <I>graph_obj</I> also serves classes <I>circle</I>,<I> double_circle</I> and <I>square</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
In C++, each class can have two special methods: the constructor and destructor. Essentially the constructor is called automatically when an object comes into scope, and the destructor is called when an object goes out of scope. For example, if you declare an automatic object at the start of a function, the constructor is called at the time of declaration, and the destructor is called before the function returns to its calling function.<P>
Constructors and destructors are not essential to object-oriented programming. In other systems, programmers make a method specifically for initializing an object when they need one, then send that message to the object after creating it. In the C++ example that accompanies this article, I don't use the built-in constructors and destructors. In both the C and C++ examples, I have a method that initializes the values of the graphical object. I call this method <I>INIT</I>.</FONT></FONT><P>
In the C example, I use a function that allocates memory for the object before use and frees the memory after use. These functions aren't defined as part of a class and should not be confused with methods.<P>
<h4><FONT COLOR="#000080"><A name="005D_003E">Objects<A name="005D_003E"></FONT></h4></P>
An object declaration looks like a declaration of something for which there is a <I>typedef</I> in C. A declaration of an object of class <I>circle</I> looks like:</FONT></FONT></FONT></FONT><P>
<pre>circle c1;</pre>
In the graphics example, immediately after declaring a graphical object the <I>init</I> message is sent to the new object. This gives the object its starting position and size, and draws it on the screen. <A href="list7.htm">Listing 7</a>,
 line 99 shows initialization of a circle at position (40, 40), with a radius of 20.</FONT></FONT><P>
After sending the <I>init</I> message, we can send a <I>move</I> message to the object, causing it to move on the screen. (<A href="list7.htm">Listing 7</a>,
 line 103-105).</FONT></FONT></FONT></FONT><P>
In the C example, we use a pointer in an object to point to the data specific to that instance of the object. <I>new_object()</I> allocates that data on the heap, and the function <I>free_obj ()</I> frees it.</FONT></FONT></FONT></FONT><P>
In contrast, the C++ translator actually creates a structure that contains the data. In our example, this structure is an automatic structure. Space for it gets deallocated when <I>main()</I> returns. We don't need to free any data on the heap as we needed to do in the C example.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="005D_003F">Inheritance<A name="005D_003F"></FONT></h4></P>
Just as in the C example, the C++ example demonstrates inheritance of methods. <I>double_circle</I> inherits <I>init</I> and <I>move</I> from class <I>circle</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="005D_0040">Messages<A name="005D_0040"></FONT></h4></P>
Sending a message in C looks like:<P>
<pre>message(&amp;c1, MOVE, 1, 1);</pre>
Sending a message in C++ looks like:<P>
<pre>c1.move(1, 1);</pre>
We specify the same essential elements in both cases. They are:<P>
<UL><li>The object (c1)</li>
<li>The message (<I>MOVE</I> or <I>move</I>)</FONT></FONT></FONT></FONT></li>
<li>The number of pixels to move in the <I>y</I> and <I>x</I> direction.</FONT></FONT></FONT></FONT></li></UL>
<h4><FONT COLOR="#000080"><A name="005D_0041">Summary Of OOP In C++<A name="005D_0041"></FONT></h4></P>
Data hiding and modularity are important issues in C++ as in other languages. I am not addressing these issues and have put the entire program in one source file. I want to focus on the object-oriented aspect and keep it simple.<P>
Often in C++, when a message is sent to an object of a known type, the compiler resolves the particular method to invoke at compilation time. This is called early binding. In contrast, the function <I>message()</I> in the C scheme presented here resolves the issue of which method to invoke at run time. This is called late binding.</FONT></FONT><P>
Because the C methodology always does late binding, a little more code must always be executed at run time. The C code may be a bit slower than the code generated by the C++ translator. However, when using virtual functions, I believe that the speed of sending a message in C is comparable to C++.<P>
C++ inherits many of the characteristics of C. In C++, you have the ability to corrupt memory in the same ways that you can corrupt memory in C. This causes temporal and referential non-localization of bugs. C++ offers the same beneficial characteristics of C such as speed, compactness, and the possibility of portability.<P>
<h4><FONT COLOR="#000080"><A name="005D_0042">Portability<A name="005D_0042"></FONT></h4></P>
The C code is quite portable and runs on:<P>
<UL><li>Microsoft C v5.1</li>
<li>Microsoft Quick C v2.0</li>
<li>Zortech C compiler</li></UL>
The C++ code runs on:<P>
<UL><li>Zortech C++ compiler</li>
<li>Glockenspiel C++ translator using the Microsoft C compiler v5.1.</li></UL>
The graphics code works on CGA, EGA, Hercules and VGA.<P>
The utility module can use either the graphics library that accompanies Microsoft C v5.0 or the graphics library that comes with the Zortech C++ compiler.<P>
If you are using the Microsoft graphics library and Hercules graphics, before you can run these programs you need to run MSHERC.COM.<P>
The Zortech graphics library has its origin at the lower-left corner. Microsoft has its origin at the upper-left corner. Also, because pixels are not square, neither the Zortech nor the Microsoft libraries create perfectly round circles. Because this article is focusing on object-oriented techniques and not on graphical techniques, I didn't address any of these problems.<P>
<h4><FONT COLOR="#000080"><A name="005D_0043">Exercises<A name="005D_0043"></FONT></h4></P>
A few valuable exercises might be:<P>
<UL><li>Make a new class such as a diamond.</li>
<li>Make a new method such as expand or contract that will change the size of an object.</li>
<li>Adapt this system to another graphical system.</li></UL>
<h4><FONT COLOR="#000080"><A name="005D_0044">Acknowledgements<A name="005D_0044"></FONT></h4></P>
I thank Marc Rochkind and Tom Cargill, who taught me much of what I know about object-oriented programming.<P>
<h4><a href="../../../source/1990/feb90/white.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
