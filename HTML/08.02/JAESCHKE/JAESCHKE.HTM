<HTML>
<HEAD>

<TITLE>February 1990/Doctor C's Pointers</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Doctor C's Pointers &reg;<A name="0065_0038"><A name="0065_0038"></font></h2><P>
<h3 align="center"><A name="0065_0000"><A name="0065_0000">Header Design And Management</h3><P>
<h3 align="center"><font color="#800000">Rex Jaeschke</font></h3><hr><blockquote><P>
<P><i><A name="0065_0000"><A name="0065_0000">Rex Jaeschke is an independent computer consultant, author and seminar leader. He participates in both ANSI and ISO C Standards meetings and is the editor of The Journal of C Language Translation, a quarterly publication aimed at implementers of C language translation tools. Readers are encouraged to submit column topics and suggestions to Rex at 2051 Swans Neck Way, Reston, VA, 22091 or via UUCP at uunet!aussie!rex.</i></P><P>
All too often, programs just "happen." There is little if any serious design done, and programmers "design on the fly", using an approach I call stepwise refinement. That is, you code a bit and test it then iteratively refine it till it's somewhere close to what you think you want. And after you have hard-coded the same macro definitions and function declarations in ten different places you think perhaps it would be a good idea to create a header instead. However, this either doesn't get done or it's done at the local level to solve just the particular problem in the code you are currently working on. For the most part, I find people program defensively.<P>
Designing and managing headers is an integral part of a C project design. It <I>must</I> be done before <I>any</I> code is written to ensure that the design is consistent, can be managed easily, and that a high degree of quality assurance can result. The lack of properly designed headers is a likely recipe for added development, debugging, and maintenance time, as well as significantly reduced reliability.<P>
There are many aspects to designing headers. In this article I will look at those I've recognized. However, before I begin, a definition of the term header is in order. I think you all know what a header is but for the purposes of this discussion, I will consider a header to be a collection of declarations that can be shared across multiple source files via the <I>#include</I> preprocessing directive. And while a header is typically represented as a source code file on disk, it need not exist as such. For example, a header might actually be built into the compiler (at least the standard ones like <I>math.h</I> could be) or it could be compiled into some binary form that the preprocessor can more easily or efficiently handle. The specific representation details are left to the implementer's choice and will not be further discussed here. As such, I prefer to use the term header rather than header file or include file since the last two names imply a file representation. Whatever term you use, be consistent.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0065_0039">Header Categories<A name="0065_0039"></FONT></h4></P>
There are four categories into which headers can be classified: standard, system, library, and application.<P>
A standard header is one of the 15 defined by ANSI C, such as <I>stdio.h</I>, <I>math.h</I>, and <I>string.h</I>. ANSI requires you to include standard headers using the notation <I>#include &lt;header.h&gt;</I>. Do so even if <I>#include "header.h</I><I>"</I> appears to work for them. A standard header is stored in some special place such that it can be accessed from all places in which a source file can be compiled.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
A system header is one supplied by the compiler vendor that can be used to interface to and/or exploit the host hardware and/or operating system. Examples on MS-DOS systems include <I>bios.h</I> and <I>dos.h</I>; on VAX/VMS, headers <I>rms.h</I>, <I>rab.h</I>, and <I>fab.h</I> are used to access the RMS file system; and on UNIX, the special set <I>sys</I><I>\*.h</I> is provided. An implementer can provide as many system headers as he needs. VAX C, for example, comes with about 200. Since system headers are useful to all applications, they are typically stored in the same place as standard headers.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
A library header is one provided with a third-party library such as a windows, graphics, or statistical package. Again, a product may include many headers and you may use a number of different libraries in the same application. Library headers are also universally shareable and will likely reside with standard and system headers.<P>
An application header is one you design for a particular application and as such, it should be located in a place separate from headers in the other three categories. It is possible, however, that over the course of designing an application, you build a header that is useful beyond the life of the current system. This header then, should really be treated as a miscellaneous library header. If each programmer on the project develops his own private miscellaneous headers naming conflicts can easily arise, so you must ensure that private headers are not used.<P>
During testing stages of a project, it can be very tempting to provide a quick (and often dirty) fix to a given problem by simply changing a header and recompiling the offending source module. However, this can cause other nasty side-effects later on when the system as a whole is rebuilt. Also, you must never, never, ever even think of changing a standard, system, or library header; these are sacred. For example, you might discover you need macros called <I>TRUE</I> and <I>FALSE</I> in several modules and since <I>stdio.h</I> is included in all of them, why not simply add definitions for these macros to that header? Afterall, it can't hurt any existing uses of these headers, can it? Apart from reflecting bad style when you next (re)install the compiler, these changes are lost. One solution to this is to make all headers, including application headers that have been moved to production, read-only. That way, if you should ever try to change or overwrite them you are reminded of the seriousness of such an action.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0065_003A">Header Names<A name="0065_003A"></FONT></h4></P>
ANSI C requires the standard header names to be written in lower case. Do so even if your file system is case insensitive (as is the case with MS-DOS and VAX/VMS.) In fact, ANSI does not require that filenames of the form <I>header.h</I> be supported by your file system. The compiler must accept <I>#include &lt;stdio.h&gt;</I>, but is allowed to map the period or any other part of that header name to other characters.</FONT></FONT></FONT></FONT><P>
The convention of naming headers with a <I>.h</I> suffix is exactly that, a convention and need not be followed by user-written headers. Certainly, it's a useful default convention if you have no good reason to do otherwise.</FONT></FONT><P>
If you wish to port code, keep in mind that the length of significance, case distinction, and format of filename (assuming a header is a file), are all implementation-defined.<P>
It is generally considered bad style to specify device and or directory information in a header name. Considering that almost all compilers provide compile-time options and/or environment variables to specify an <I>include</I> search path, I see no reason to unduly reduce your flexibility options.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0065_003B">Header Contents<A name="0065_003B"></FONT></h4></P>
Just what should go in a header and how big should headers be? It is relatively easy to answer the "what." If something cannot be shared, it does not belong in a header. For the record, candidates for inclusion in a header are: macros, <I>typedefs</I>, templates for structures, unions, and enumerations, and function prototypes, <I>extern</I> data declarations, and preprocessing directives. Placing anything else in a header needs careful scrutiny. In particular, including executable code that is not inside a macro definition is very bad style.</FONT></FONT></FONT></FONT><P>
My rule of thumb is to put all related stuff together in one header. However, if that makes for a very large header <I>and</I> the contents can easily be broken into logical subsets, then I prefer each subset be in its own header. It's useful to give such headers names with the same prefix so you can easily determine they are related. The only difference here is whether the preprocessor has to process one big header instead of just those parts it needs. Don't get too hung up on worrying how much work the preprocessor has to do unnecessarily since that's what CPU cycles are for. In fact, in the extreme case where you put each declaration in its own header, the preprocessor won't need to do any extra work, except for opening and closing all those headers.<P>
It's quite likely that, while most things will fit neatly into related groups each in a header, some miscellaneous bits will be left over. About the only way to handle these reasonably is a miscellaneous header. ANSI C has one of these, called <I>stddef.h</I>. Whatever organization you chose, everything that can be shared should be shared. That is, you should make sure that all macros, function prototypes, etc., are part of some header and <I>not</I> hard-coded in source files directly.</FONT></FONT><P>
Each header should be self-contained. If one header refers to something in another header, the first should directly include the second. Forcing the programmer to know and remember the order in which related headers need be included is burdensome and unnecessary.<P>
<h4><FONT COLOR="#000080"><A name="0065_003C">Protecting Header Contents<A name="0065_003C"></FONT></h4></P>
It is very likely that in some source modules you will include the same header multiple times, once directly and one or more times indirectly via other headers. Since everything in a header is supposed to be shareable, there should be no problem in processing the same header multiple times except the extra work of preprocessing. Right? Well, that's not quite true. Specifically, if the same <I>typedef</I> or structure, union, or enumeration template definition is seen more than once, the compiler produces an error so they must be somehow protected. The best way to achieve this is to place a conditional compilation protective wrapper around the whole header as follows:</FONT></FONT><P>
<pre>/* header local.h */
#ifndef LOCAL_H
#define LOCAL_H
...
#endif</pre>
I prefer to use a macro spelled in upper case the same as the header, along with a suffix of <I>_</I><I>H</I>. This naming convention is easy to understand and is very unlikely to be used for other macros elsewhere in the set of headers. Using something like <I>LOCAL</I> could easily be used as a different macro elsewhere, leading to confusion.</FONT></FONT></FONT></FONT><P>
Since the standard headers can also be included multiple times and some of them contain <I>typedefs</I> and structure templates, these too must be protected. Check those provided with your compiler to see if they indeed are protected. The only difference between your wrapper and that used by the standard headers is that you must not begin your private macro name with an underscore while they must, since that's the implementer's namespace.</FONT></FONT><P>
It is preferable to have each thing defined in one, and only one, header. However, for various reasons it may be desirable to duplicate something in multiple headers. The problem here is to make sure that all of those headers containing duplicates can be included at the same time. For example, consider the case of having a <I>typedef</I> for <I>count</I> in two headers as in <A href="list1.htm">Listing 1</a>.
</FONT></FONT></FONT></FONT><P>
You should also check your standard headers for this kind of protection since <I>size_t</I>, the type of the <I>sizeof</I> operator, is required to be <I>typedef</I>ed in five of them. Note that ANSI C places strict rules on whether a standard header can include another standard header. For example, most identifiers defined in a standard header are only "reserved" if their parent header is included. For example, if you don't include one of the six standard headers that define <I>NULL</I>, you are perfectly safe in defining your own identifier <I>NULL</I> even though it would be bad style. So, if <I>assert</I> includes <I>stdio.h</I>, all the names in <I>stdio.h</I> would become defined as well, even though they are not defined in <I>assert.h</I>. And while <I>assert.h </I>could contain <I>#undefs</I> to remove these, there is no way for it to remove any <I>typedefs</I> or template definitions.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Many mainstream compilers claiming ANSI conformance or claiming to be tracking the ANSI standard break this rule. As such, they are <I>not</I> ANSI-conforming. Check your standard headers for this.<P>
<h4><FONT COLOR="#000080"><A name="0065_003D">Conditional Inclusion<A name="0065_003D"></FONT></h4></P>
There are a number of ways to conditionally include headers as necessary. Perhaps the best is to conditionally compile a subset of <I>#include</I> directives inside a header, based on the existence or value of a macro defined using a compiler option. That is, the compilation path is specified outside all source modules. This way, you can trigger any possible conditional compilation path from as few as one macro.</FONT></FONT><P>
You also have the ANSI invention of <I>#include macro</I> where macro must expand to a header name of the form &lt;...&gt; or "...". You also can use the stringize and token pasting preprocessor operators <I>#</I> and <I>##</I> respectively, to construct a macro that is to expand to a header name.</FONT></FONT></FONT></FONT></FONT></FONT><P>
I have also found that it is a good idea to remove as many preprocessing directives as possible from source modules into headers. In particular, I find conditional compilation directives in source code to be most distracting, especially when there are more that two compilation paths. The aim is to isolate such dependencies into headers so you can forget about them and get on with the business of implementing or maintaining the application. An example of this strategy follows:<P>
<pre>#if TARGET == 1
  fp = fopen("DBAO:[direct]master.date", "r");
#else
  fp = fopen("A:\direct\master.date", "r");
#endif</pre>
This can be implemented in a much clearer way by abstracting the filename into a header as in <A href="list2.htm">Listing 2</a>.
<P>
<h4><FONT COLOR="#000080"><A name="0065_003E">Planning For Debugging And Maintenance<A name="0065_003E"></FONT></h4></P>
People who don't design programs are unlikely to plan for debugging and maintenance. They probably don't even write a shopping list for that matter. Unfortunately, there are lots of these people programming, many of them in C. It is very naive and probably irresponsible to believe that with a non-trivial program, debugging will be a mere formality and that you will always be around to maintain the code.<P>
Over the years I have found it a useful idea to include a header called something like <I>debug.h</I> into <I>every</I> source file I write when working on a non-trivial project. If the header is empty, that's fine. However, it makes it very easy to add or change that header's contents and recompile all or part of the system for testing. Since you have one header included everywhere, it is trivially easy to make powerful changes and to experiment. And the cost of having this flexibility is practically nothing, if you cater for it at the beginning.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0065_003F">Concatenating Headers<A name="0065_003F"></FONT></h4></P>
There are always people who try to stretch a language's capabilities to the extreme. For example, they place part of a source file in one header and the rest in another and include them both to form a valid source module. Cute, but very bad style.<P>
Let's look at just what can and cannot be split across multiple source modules, and therefore across multiple headers. A source module must contain complete tokens. That is, a source token cannot be split across two files. Specifically, the notation of backslash/new-line continuation cannot be used in the last line of a source file. Likewise, a comment cannot span two files.<P>
With string literal concatenation now supported by ANSI, you could have a string in one file concatenated with a string in another, but that would require the strings to be outside a macro definition and I have already said that's very bad style. You could also split a structure template definition across multiple files, but I see no benefit.<P>
One thing not immediately obvious in ANSI C is that each matching set of <I>#if/endif</I> and corresponding <I>#elif</I> and <I>#else</I> directives <I>must</I> be contained within the same source file. That is, the <I>#if</I> and matching <I>#endif</I> directives must be in the same source file.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0065_0040">Conclusion<A name="0065_0040"></FONT></h4></P>
I have addressed many issues here most of which have arisen from my own experiences. I am sure there are others that could be added. For the most part, I find header design to be simply a matter of common sense once you know and understand the tools the language and preprocessor provide. But then again, I find that to be pretty much the solution to a vast number of problems. It's sad that common sense is not all that common.<P>

<h4><a href="../../../source/1990/feb90/jaeschke.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
