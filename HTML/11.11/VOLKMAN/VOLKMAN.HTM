

<HTML>
<HEAD>

<TITLE>November 1993/CUG New Releases</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">CUG New Releases<A name="0329_0119"><A name="0329_0119"></font></h2><P>
<h3 align="center"><A name="0329_0000"><A name="0329_0000">BCC Coroutines, TDE, Lost Algorithms, and Anthony's Tools</h3><P>
<h3 align="center"><font color="#800000">Victor R. Volkman</font></h3><hr><blockquote><P>
<P><i><A name="0329_0000"><A name="0329_0000">Victor R. Volkman received a BS in Computer Science from Michigan Technological University. He has been a frequent contributor to The C Users Journal since 1987. He is currently employed as Senior Analyst at H.C.I.A. of Ann Arbor, Michigan. He can be reached by dial-in at the HAL 9000 BBS (313) 663-4173 or by Usenet mail to sysop@hal9k.com.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0329_011A">Introduction<A name="0329_011A"></FONT></h4></P>
The C Users Group Library continues to attract the finest shareware, freeware, and public domain source code. This month's latest additions to the Library come from various parts of the globe: from Michigan to Georgia in the U.S., a volume from Ontario, and one volume from the U.K. The authors vary as much as the geography: from sole proprietors to authors in collaboration. However, all these packages have one thing in common: each package is immediately available from the C Users Group Library and includes full source code in C and C++.<P>
This month, I'll introduce four new programming tools:<P>
<UL><li>BCC+ Coroutines (CUG #385): C++ classes for multithreading and TSRs</li>
<li>Thomson-Davis Editor (CUG #386): multi-window text/binary file editor</li>
<li>C/C++ Lost Algorithms (CUG #387): classic data structures revisited</li>
<li>Anthony's Tools (CUG #388): Editor, Make, Grep, and Stdcurses</li></UL>
<h4><FONT COLOR="#000080"><A name="0329_011B">BCC+ Coroutine: CUG #385<A name="0329_011B"></FONT></h4></P>
From John English, at the University of Brighton (England), comes a trilogy of highly useful class libraries for Borland C++. The TSR class presents a framework for writing memory-resident DOS programs (TSRs). The DOSThread class presents a framework for writing DOS applications consisting of multiple "threads" in a self-contained, preemptive multitasker. The Coroutine class presents a cooperative non-premptive framework for sharing the CPU. Version 1.00 (March 1993) of all three BCC+ class libraries is now available in the CUG library volume #385.<P>
After more than a decade of MS-DOS, resident programs remain as tricky as ever to design and implement properly. If anything, writing Terminate and Stay Resident Programs (TSRs) becomes more complex with every new version of MS-DOS, Windows, and other environments. The TSR class helps make development of resident programs an attainable goal for Borland C++ programs. Applications developed with TSR class require an 80286 (or better) and DOS version 3.1 (or later) on the target machine. Building them requires Borland C++ version 3.0 (or later).<P>
You can activate TSRs produced from this class with a specific key (the "hotkey"), or after a specified number of timer ticks (the "timeslice"), or a combination of both. You must supply a function <I>main</I> in your application class to be invoked whenever the TSR is awakened. The member function <I>run</I> makes the TSR resident. The member function <I>loaded</I> tells whether an instance of the TSR is already resident. The member function <I>unload</I> can then remove it. A foreground copy can also communicate with a resident copy using the functions <I>request</I> and <I>respond.</I> Each TSR must be given a unique name up to 32 characters long.<P>
Even today's most advanced version of MS-DOS remains a single-threaded operating system. Many of the functions in its published interrupt API are non-reentrant. However, the DOSThread class lets you create multithreaded DOS applications with ease. Like the aforementioned TSR class, the DOSThread class requires a <I>main</I> function which gets invoked by the member function <I>run</I>.<P>
Once started, each thread runs in a single timer tick (55 ms) interval before being preempted by the scheduler. Intervals can be set for any integral number of ticks by the <I>timeslice</I> member function. Alternately, you can disable scheduling, thus providing non-preemptive multitasking. Threads can put themselves to sleep with the <I>wait</I> member function, yield control with the <I>pause</I> member function, and kill any thread with the <I>terminate</I> member function. The extra classes <I>DOSMonitor</I> and <I>DOSMonitorQueue</I> provide monitor classes for inter-task communication. A "monitor" contains data structures which can be accessed by several threads.<P>
The Coroutine class is similar to the DOSThread class except that it is always a cooperative multitasker. The Coroutine class has some elements in common with the TSR and DOSThread classes. Once again, the Coroutine class requires a <I>main</I> function which gets invoked by the member function <I>run</I>. Since coroutines are non-preemptive by definition, the other member function needed is <I>pause</I> to yield control. Synchronization is unnecessary because coroutines never interrupt each other.<P>
<h4><FONT COLOR="#000080"><A name="0329_011C">Thomson-Davis Editor: CUG #386<A name="0329_011C"></FONT></h4></P>
The Thomson-Davis Editor, as provided by Frank Davis (Tifton, GA), is a multi-file/multi-window binary and text file editor written for IBM PCs and close compatibles. The Thomson-Davis Editor (TDE) works well with batch files, binary files, text files, and various computer language source code files. TDE can handle any size of file and any number of windows that fit in conventional DOS memory. Davis' most recent improvement is support for regular expressions in searching text and selecting files for editing. TDE version 3.0 (June 1993) is now available as CUG library volume #386.<P>
The TDE compiles under Microsoft C versions 5.1 through 7.0, as well as QuickC version 2.5. TDE also supports Borland C version 3.1. You can use the same makefile with either Microsoft <I>nmake</I> or Borland <I>make</I> utilities. Assembly language portions will build with Microsoft MASM 5.1 through 6.0, Quick Assembler, or Borland Turbo Assembler. The CUG library distribution also includes a complete compiled and linked TDE.EXE.<P>
The TDE includes more than 800K of C source code plus two small modules in assembly language (totalling 26k). The TDE source code itself is remarkably well documented. Each function includes a detailed header describing the parameters and purpose of the function. Best of all, TDE provides an incredible amount of detail in bibliographic references to algorithms employed. For example, the <I>sort.c</I> module provides precise references to all of C.A.R. Hoare's original work on QuickSort (1961), plus embellishments by Knuth and Sedgewick. Overall, the references remain current and even include information accurately reflecting changes in MS-DOS 6.0.<P>
Since the TDE has been officially released into the public domain, you may use and distribute it freely. There is no copyright, no fee for use, no licensing, and no registration. This editor is not user supported, corporate sponsored, or government subsidized &#151; it is sustained and maintained solely by Frank Davis.<P>
<h4><FONT COLOR="#000080"><A name="0329_011D">C/C++ lost Algorithms: CUG #387<A name="0329_011D"></FONT></h4></P>
The C/C++ Lost Algorithms, by John Tal (Rochester, MI), releases handy implementations of textbook classic algorithms into the public domain. He implements these algorithms twice (once in C and again in C++), focusing primarily on link lists, binary trees, stacks, fifo queues, and heaps (priority queues). He places secondary importance on algorithms for shell sort, file merging, multi-tasking and process scheduling, virtual memory management, file-based process communication, graph/network job management, and data encryption. The algorithms (as released in Fall 1992) are immediately available under a single-volume distribution as CUG #387.<P>
Tal expresses concern that many of the world's best and most efficient algorithms have been carelessly disregarded in the wake of faster computers with more memory. He points out that it will <I>always</I> make sense to make the best use of any computing resource.<P>
The C/C++ Lost Algorithms have been tested on a variety of platforms including both DOS, OS/2, and Unix workstations. Each algorithm set includes complete documentation in the form of a Unix-style "man" page. The C++ implementation include general porting notes and Borland Turbo C++ .PRJ makefiles. As an added bonus, Tal also includes implementations of Unix utilities <I>binsrch</I> (binary search on flat file), <I>cat, db</I> (dump bytes), <I>split, tail</I>, and <I>wc</I> (word count).<P>
<h4><FONT COLOR="#000080"><A name="0329_011E">Anthony's Tools: CUG #388<A name="0329_011E"></FONT></h4></P>
Anthony C. Howe (Waterloo, Ontario) presents his award-winning Editor, Make, Grep, and Stdscr Curses tools. Anthony's Tools have won the International Obfuscated C Code Contest (IOCCC) for Best Utility in 1990, 1992, and 1993 respectively. For those who are unfamiliar with the Code Contest, the IOCCC competition pits C programmers against each other to see who can produce the most unreadable and obscure code that compiles and runs. Fortunately, Howe has included both the obfuscated and readable source versions of each utility. He has listed both versions of all tools as public domain, except for the readable version of Anthony's Editor, which remains freeware. All of Anthony's Tools are available on CUG volume #388.<P>
Anthony's Editor appears in both its obfuscated 1991 award-winning form and its readable July 1993 version. Both versions will compile and run on PCs and Unix workstations. You can modify a configuration file in the 1993 version of Anthony's Editor (AE) to specify a modal (vi-style) or modeless (EMACS-style) user interface. The configuration file also presents the key mapping for each internal command. Thus, you can customize AE to your preferences or support any conceivable terminal. AE can edit arbitrarily long lines of text and assumes tabstops every eight characters. AE includes cut, copy, and paste operations with blocks of text. It also implements a single-level undo command in the cut and paste buffer. The AE macro facility allows one keystroke to feed other keystrokes into the buffer and execute them. AE does not provide any searching or replacing operations.<P>
Anthony's Make provides most of the functionality required of <I>make</I> utilities under POSIX.2 draft standard 11.2. Indeed, the judges of the IOCCC were so impressed with Anthony's Make that they jokingly recommended lobbying the IEEE for an obfuscated POSIX subcommittee. Anthony's Make (AM) has been tested with the GNU C Compiler (GCC) under SunOs, Sozobon C on Atari ST, Borland Turbo C on PCs, and Interactive UNIX System V/386 release 3.2. On the PC, the AM executable is less than 18K in size! AM supports many of the constructs you've come to expect in makefiles including macros, multiple targets and dependencies, comments, and more.<P>
Anthony's Grep provides most of the POSIX.2 functionality for <I>grep</I> utilities. You can build Anthony's Grep (AG) on the same platforms and compilers as AM, and you can use an additional compiler, WatCom C, on the PC. AG supports a useful subset of POSIX.2 Extended Regular Expressions (ERE). It has a recursive ERE parser/compiler that generates an NFA railroad. AG uses lazy NFA-to-DFA evaluation to improve performance speed. AG is both useful and useable for a variety of applications.<P>
Anthony's Stdscr Curses is the only tool which is limited to PC platforms. Howe calls it quick and dirty because it assumes that only Stdscr is used and therefore goes directly to BIOS rather than waiting for a refresh. Unlike the other modules, Stdscr Curses doesn't include formal documentation, so you need to have a working knowledge of Unix curses to make use of this tool.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
