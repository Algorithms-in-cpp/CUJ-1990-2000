

<HTML>
<HEAD>

<TITLE>November 1993/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="0333_0120"><A name="0333_0120"></font></h2><hr>
<BLOCKQUOTE>
<A name="0333_0000"><A name="0333_0000">Dear Mr. Plauger,<P>
I like your <I>Journal,</I> although C proved not to be the lingua franca for my specialization, Computational Linguistics. However, I like reading about computer programming and the programs you publish are a joy to read to me. I was surprised to read the anouncement this month on the cover "Natural Language Processing" and jumped into Mr. Suereth's article "A Natural Language Processor." And frankly stated, it turned out to be a disappointment to me. I am afraid, the editorial board is lacking expertise in the field of computational linguistics. Let me describe briefly the reasons for my disappointment.<P>
The main reason is the discrepancy between the written text and the computer program in Mr. Suereth's article. In fact, the article does not describe the program and the notions used in the article do not match the notions in the linguistic field. It would be great if sentences could be described as "the input transaction record" with the words as "fields" and the dictionary as "a master file of word information." Unfortunately, that is impossible. NLP is not the equivalent of database processing, as I hope to make clear to you. Equally it is a simplification to conceive the semantic component of NLP as Mr. Suereth seems to do: "The meaing is derived from a combination of information in the input sentence, the dictionary, and program code." Well, do not programming humans not understand natural language? The term transformational grammar and phrase structure grammar are vital to the professional computational linguist, although they are not the sole theoretical framework for NLP. Those terms, however, have a different meaning from the ones used by Mr. Suereth. The kernel of transformational grammar is the notion of "deep structure," an abstract representation of the meaning of natural language utterances. Mr. Suereth seems to use "transformational" in the normal way for programmers as "data transformation." Because the deep structure of transformational grammar really is abstract, the TG model could hardly be made operable on computers. Also the term "phrase structure" is used in a non-linguistic way by Mr. Suereth. Phrase structure grammar is often used for the syntatic component of NLP. It describes the syntactic structure of a sentence.<P>
Mr. Suereth writes about "phrase structures," and seems not to know that a sentence only has one syntactical structure defined as the structure of the phrases in the sentence. This phrase structure is not what Mr. Suereth seems to think it is: For the sentence "Sue is going to the store" he describes "The underlying structure" as: "name-auxilary verb-preposition-determiner-noun." In phrase structure terminology, however, the structure of this sentence would be defined like this, if I take brackets-notation:<P>
<pre>(S(NP(N(Sue))VP(V(is going))
    NP(PRP(to))(DET(the))(N(store)))))</pre>
Normally in phrase structure grammar the sentence structure is visualized as a tree, because that is easier to understand for humans. Mr. Suereth does not define the structure of the sentence, he defines the linear sequence of the word classes in the sentence. The program is not operating on the structure of the sentences in his database; the program merely maps the linear sequence of word classes to arrays. Mr. Suereth can do this because he knows in advance what type of sentences he will operate on. Therefore, the program only works for this type of word class sequences, if and only if there are no ambiguities in them.<P>
Even when the sentences are non-sense the program will work: If you write: "Jim is going in (on/ to) the jump" or "The house is on (in/ to) the jump" the program will not complain and what is more it can only be repaired by ad hoc measures. This holds for all the problems that will come up. In other words: this program cannot be expanded as Mr. Suereth thinks it can. The program is useful for applications where the programmer knows in advance all sentences. The claim that the program can be expanded to a reader of books only holds if Mr. Suereth can prove that he knows in advance all sentences in all books. This kind of "natural language processor" normally is delivered with computer games. The authors, however, present this part of their programs with a bit more of modesty, not as natural language processors.<P>
By the way, much more is already possible if it comes to natural language processing and natural language understanding, than can be concluded from your articles on NLP in the April issue. Your article would be up to date in 1975, but that is beyond the scope of this letter.<P>
With kind regards,<P>
Dr. M. Boot<br>
Rubensln. 40<br>
3723 BR Bilthoven<br>
The Netherlands<P>
<I>We were happy to present Mr. Suereth's offerings as a modest attempt at parsing a simple grammar and vocabulary. Those who know little about the field seemed to enjoy reading the code. Those who know a lot were disappointed. I guess the one thing I would do different in future is have the author better emphasize the modesty of his/her goals in any area that might be haunted by experts. </I>&#151;<I> pjp</I><P>
Dear P.J. Plauger:<P>
I have just read your article on Large Character Set Functions in the June 1993 issue of <I>The C Users Journal</I>. The section entitled "<I>&lt;stdlib.h&gt;</I> revisited" states that the functions <I>strtod, strtol</I>, and <I>strtoul</I> convert arithmetic representations to text strings, as do their new wide-char analogs. There is also some discussion of "the characters they generate."<P>
I'm sure you meant to say that these functions convert the other way, i.e. strings to arithmetic representation, and that they don't generate strings, just read them. But I just wanted to check with you to make sure that I wasn't missing something.<P>
Thanks for providing these informative articles. I'm looking forward the next one in the series.<P>
<I>uunet!sol.metaware.com!marka ()</I><P>
<I>It's the way you said. If I said it the other way, I misspoke. Thanks for pointing out the error. </I>&#151;<I> pjp</I><P>
Dear P.J. Plauger<P>
I have a problem. I figure if ANYONE knows a workaround, it would be you.<P>
I am writing code by hand that will interface with code produced by an application generator. If the persons running the application generator change structure sizes on me, my code can bomb. Well, if it has to be rewritten, it has to be, but I'm trying to avoid having 20,000 copies of this application duplicated and shipped to users &#151; and then finding out there is a problem.<P>
When I was working with Borland C, I could use<P>
<pre>#if sizeof (structurename) != 132
#error
#endif</pre>
and it worked fine. However, this project is being done in Microsoft C, and they do not have this extension to the ANSI standard.<P>
It wouldn't help, however, even if it DID happen to be ANSI. I'm not dealing with standards &#151; I'm dealing with a real-world compiler, dealing with a real-world problem, and trying to figure out another way to generate an error at compile time so that I don't generate errors at run time.<P>
Any suggestions on how I might accomplish this?<P>
Stephen Thomas<br>
CompuServe, Inc. Columbus OH<br>
614-793-3121<br>
CIS: 70004, 1473]<br>
<I>stevet@csi.compuserve.com</I><P>
<I>Try:</I><P>
<pre>static char junk[sizeof (structurename)
                  != 132 ? 0 : 1];</pre>
<I>It's Standard C that should generate a diagnostic if the structure has the wrong size. If the code compiles, you waste a byte of storage. </I>&#151;<I> pjp</I><P>
Dear Dr. Plauger,<P>
Thanks for a fine editing job at the <I>C User's Journal</I>.<P>
The recent focus of your column, Standard C, on E extensions proposed for non-English character sets is timely. You are raising the awarenes of the C/C++ programming community to the needs of computer users in non-English speaking countries at a time when a strong trend toward the internationalization of business markets is in progress and gaining strength. My impression is that American developers need to play catchup in meeting the needs of potential customers that don't speak English.<P>
The thrust of the extensions to C you are describing in your column are absolutely crucial to meeting the language needs of European, Asian, and Latin American business partners. These character set provisions, though, are by no means the whole story. A few examples:<P>
<UL><li>Hebrew and Arabic both use non-Latin alphabets, but both languages are read right to left, except for the numbers and quotes in other languages like English or French.</li>
<li>Most code I've seen contains things like:</li><P>
<pre>if(!(map=makebitmap(64)))
printf("Can't make bitmap\n");</pre>
The problem with this is that the error message is a string imbedded in the code in English. The only way to translate to another language is to find all such statements and change the code.<P>
<li>Similar translation considerations apply to screens and help text files.</li>
<li>Some countries, Belgium and Switzerland to name a couple, have a need for a user interface allowing the user to choose from any of several languages in use there. In mulltiuser implementations in countries like this, the system should be able to "speak" more than one language.</li></UL>
And so it goes. I don't want to make a long story continuous, but I believe the C Users Journal could provide a very useful service by publishing articles or perhaps a column showing your readers how to make their software products competitive in a global market.<P>
Sincerely,<P>
Harry Philips<br>
Intrnet: <I>hkp@tdkt.kksys.com</I><br>
Fido: 1:292/36.4<P>
<I>Your points are well taken. You should know, however, that even the current C Standard permits</I> *printf* <I>to display right to left, or bottom to top, if the implementation so chooses. That doesn't solve the problem of mixed directions, but it's a step in the right direction. So too is ISO 10646, a character encoding that subsumes all the character sets of the world. So too is the locale machinery introduced with Standard C and embellished in POSIX. It provides for multiple cultures even within a country, selectable at run time.</I><P>
<I>Still we know that isolating and translating messages can be an important part of internationalizing code. We will continue to run articles on this and related topics as we get good submissions. </I>&#151;<I> pjp</I><P>
Dear P.J. Plauger,<P>
Your report on WG14 progress (in <I>C User's Journal</I>, May 1993 Vol 11, No. 5) is much appreciated. This new interface goes a long way toward allowing i18n code to be both correct and portable.<P>
It seems to us that there is one essential feature still missing, however: The interface provides a way to get a wide char from a FILE, which is good, but it is still impossible to "get" from any other source of bytes.<P>
Why does this matter? For one thing, wide string i/o could then be added by users on top of existing implementations of iostream, until vendors support it themselves. (C++ is good at things like this.) In any case, there are many other sources of bytes besides FILE.<P>
What does this essential feature look like? Typically you need characters to read up to a delimiter, and then push it back. (This delimiter may be restricted to USASCII if the byte source itself only allows one byte of pushback.) To read a character at a time, you need to be able to tell how many bytes are in the character to come, with no more information than a peek at its first byte.<P>
So to support this feature, we need a function that takes one byte (and maybe ignores it) and a shift state (ditto), and returns the number of bytes in the character it heads. Note that this is not the same thing as <I>mblen</I> or <I>mbrlen</I>, as I understand them.<P>
Of course this function has already been implemented in some systems (notably Sun's) under the name <I>euclen</I>.<P>
Nathan Myers<br>
Rogue Wave Software<br>
<I>myersn@roguewave.com</I><P>
<I>I didn't make clear that you can also read and convert wide characters from a multibyte string in memory, by using sprintf or vsprintf in wide-character mode. I will soon have C++ iostreams built atop this machinery, available for public consumption, so you'll be able to do similar things in C++.</I><P>
<I>UNIX systems tend to favor shiftless multibyte encodings such as EUC, which also have other nice properties. I'm not convinced, however, that all multibyte encodings determine the number of bytes in a character from the shift state and the first byte of the sequence. Thus, working in memory with</I> mblen <I>or</I> mbrlen <I>is more robust. The latter should parse an arbitrary string if you let it look at no more than</I> MB_OUR_MAX <I>bytes at a time. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
In your last column 'Standard C' you write that functions from <I>&lt;ctype.h&gt; </I>should be used religiously. Of course I share this view, but I think programmers are sometime unaware of the pitfalls. Consider the following code fragment that may run flawless before using an internationalized version of the <I>isalnum</I> function:<P>
<pre>int c;
... read c from somewhere ...
if (isalnum(c))
   ...
else if (c == '|')
   ...</pre>
If there is now an internationalized version of this program and the programmer thinks it would be a good idea to call <I>setlocale(LC_ALL,"")</I> in <I>main</I> so that the user may select his preferences dynamically, the program can fail, e.g. if the user selects the German variant of seven bit ASCII, as in this case | will be recognized as letter. The problem is not at all theoretical but the reason why <I>yacc</I> rejects working grammars in some internationalized versions of UNIX System V.<P>
To summarize:<P>
1)     Using functions from <I>&lt;ctype.h&gt;</I> is always a good idea;<P>
2)     witching away from the default "C"-locale in <I>main</I> should not be done blindly;<P>
3)     If a programs mixes calls to character classification functions with comparisons against explicit character constants, it is a strong indication that more thought is necessary to produce a working internationalized version. Best Regards,<P>
Martin Weitzel<P>
<I>You have stated the issues beautifully. I absolutely agree. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger:<P>
I am writing to suggest you refrain from using the phrase "voted out" because it is confusing. You used it in this month's Standard C column (<I>CUJ</I>, April 1993), saying that "WG14 finally voted out an amendment to the C Standard". At first blush, I thought this was similar to a politician being voted out of office (i.e., the vote failed). Upon reading the rest of the paragraph, however, I realized that the vote passed (similar to "hammering out" an amendment). I think I have a fairly good command of the English language, but I am always confused by this phrase so I would ask that you try to avoid it in the future.<P>
Thank you, as always, for an excellent publication and column, both of which are (otherwise) very clear and concise.<P>
Ken Van Camp<br>
<I>&lt;cp486a!kvancamp@cpmail.att.com&gt;</I><br>
AT&amp;T Consumer Products Division<br>
5 Wood Hollow Road Room 1H36<br>
Parsippany, NJ 07054<br>
(201)581-4513 &#151; voice<P>
<I>Point well taken. </I>&#151;<I> pjp</I><P>
</BLOCKQUOTE>
</BODY>
</HTML>
