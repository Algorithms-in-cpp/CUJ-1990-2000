

<HTML>
<HEAD>

<TITLE>November 1993/Dynamic Two-Dimensional Arrays</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Dynamic Two-Dimensional Arrays<A name="031B_010F"><A name="031B_010F"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="031B_0000"><A name="031B_0000">P.J. LaBrocca</font></h3><hr><blockquote><P>
<P><i><A name="031B_0000"><A name="031B_0000">Pat LaBrocca is the author of ReCalc(TM), a set of rational expression calculators that never give answers (well, almost never), and run identically on PCs, Macintoshes and Apples. He has a BS and MA in Chemistry and teaches computer science at Peter Rouget Middle School 88 in Brooklyn, NY. You can contact him at plabrocc@nycenet.edu.</i></P><P>
The size of declared arrays in C is fixed at compile time. If you declare an array in C, you must ensure that it is big enough to hold the maximum number of elements that the program will need to store. As a result, unused memory is often tied up during a large portion of the program's execution. Therefore, a useful feature to add to C is the ability to allocate and deallocate two-dimensional (2-D) arrays as needed. Naturally, you would prefer the feature to handle all the details, and work in a convenient way. In this article I develop a function that lets you allocate 2-D arrays at run time. When they are no longer needed, they can be removed by calling the standard library function <I>free</I>.<P>
I start by examining some characteristics of regular 2-D arrays to determine those features I'd like my dynamic arrays to have. Starting with these characteristics is important because I want my dynamic arrays to work just like conventional arrays, and when they can't, I'd like to be aware of the differences. I present a function, <I>dyn2darray</I>, that allocates 2-D arrays dynamically. Finally, I present several examples of allocating arrays, and use a macro, <I>Dyn2dArray</I>, in a demonstration program, MAGIC.EXE, which solves arbitrary magic square puzzles. I also present a program to push <I>Dyn2dArray</I> to its limit.<P>
<h4><FONT COLOR="#000080"><A name="031B_0110">Two-Dimensional Arrays in C<A name="031B_0110"></FONT></h4></P>
When you declare a two-dimensional (2-D) array, <I>A</I>, in C, such as:<P>
<pre>int A[5][4];</pre>
you specify 1) a type for the array elements, 2) the number of dimensions, and 3) the number of items in each dimension. The type of <I>A</I> is <I>array </I>of<I> arrays of ints.</I><P>
The numbers in the brackets are called repetition counts. They must evaluate to constant expressions, that is, their values must be fixed at compile time. This need for fixed repetition counts is the restriction I want to eliminate. The first repetition count specifies the number of rows in the array. The second specifies the number of columns (the length of a row). The number of elements in a 2-D array is the number of rows times the number of columns, which is often referred to as the array's rank. The size of an array in bytes, then, is its rank times the size of an element. Array <I>A</I>'s rank is 20, and its size is 40 (assuming <I>sizeof( int ) == 2</I>). You determine the size of an array by applying the <I>sizeof</I> operator to the array's name. In my example, <I>sizeof( A )</I> yields 40.<P>
The first repetition count is required in the definition of an array. It is used to calculate how much memory needs to be allotted for the array elements. It isn't used again by the C compiler. It may be omitted from subsequent declarations. The second repetition count is always required. It is used to evaluate expressions like <I>A [1] [2]</I>.<P>
2-D arrays are set up row by row, progressing from lower to higher contiguous memory locations. Even though the elements are stored sequentially, we usually think of them as being arranged in a rectangular grid or matrix. When the array elements are accessed in the order they appear in memory, the right subscript varies fastest. Sometimes this layout is referred to as row-major order.<P>
In an expression, an array name is converted to a pointer. It has the type of the first item of the array. In the previous example, A is a pointer to an <I>array of four ints. A[i]</I> is a pointer to <I>int</I> &#151; in this case, the first element of the <I>i</I>th row. Finally, <I>A[i][j]</I> is an <I>int</I> whose value is stored at the <I>j</I>th position in the <I>i</I>th row.<P>
Arrays or pointers followed by numbers in brackets are subscript expressions. (The subscript operator is the pair of brackets.) When C expands a subscript expression it uses pointer arithmetic. Pointer arithmetic involves the automatic scaling of integral values to the size of the pointed-to type. For example, if <I>p</I> is a pointer to <I>int</I>, then in the expression<P>
<pre>p = p + 3</pre>
six (i.e.,<I> 3 * sizeof( int ))</I> is added to the value of <I>p</I>; in other words, the new value of <I>p</I> points three <I>ints</I> beyond the original value. The value of a subscript expression is either another array or pointer, or an object of the type specified in the declaration.<P>
The value of the <I>int</I> stored at, say, <I>A[2][3] </I>is<P>
<pre>*( *(A + 2) + 3 )</pre>
The pointer arithmetic C performs goes like this: <I>A</I> is converted to a pointer to an <I>array of four ints</I>. The integral value two is multiplied by the size of an <I>array of four ints (4 * sizeof( int )) </I>and added to <I>A</I>. The subexpression <I>(A + 2)</I> is a pointer to the third <I>array of four ints. *(A + 2)</I> is a <I>pointer to int</I>. Three multiplied by <I>sizeof( int )</I> is added to this pointer, resulting in a pointer to the fourth <I>int</I> element, <I>( *(A + 2) + 3 )</I>. Finally, dereferencing this last pointer yields the <I>int</I> value stored in the fourth position of the third row. Later I use these steps to build a 2-D array from pointers.<P>
To pass a 2-D array to a function, it must be declared as a parameter, as in:<P>
<pre>void func1( int ap[][4] ) { ... }</pre>
or, equivalently,<P>
<pre>void func2( int (*ap)[4]) { ... }</pre>
In either case, <I>ap</I> is a pointer variable, not an array. Since no new storage is allocated for the array by the function definition, the first repetition count is optional. The second repetition count is required for evaluating subscript expressions. <I>func1</I> and <I>func2</I> can take array arguments with any number of rows, but each row must have four columns.<P>
<h4><FONT COLOR="#000080"><A name="031B_0111">2-D Arrays Using Pointers<A name="031B_0111"></FONT></h4></P>
What is the pointer equivalent of a 2-D array? Since array names are converted to pointers in expressions, the pointer equivalent must have the same type. As I previously discussed, arrays are converted to pointers to the first object in the array. In my example, the equivalent pointer is a <I>pointer to an array of four ints</I>. You declare such a pointer by writing<P>
<pre>int (*ap) [4];</pre>
The parentheses are necessary. Without them <I>ap</I> is an array of four <I>pointers</I> <I>to</I> <I>int</I>. The bracketed <I>4</I> tells C how long a row is, the piece of information that C uses to adjust <I>ap</I> by the right amount when expanding subscript expressions. The statement<P>
<pre>ap = A;</pre>
points <I>ap</I> at the first row of <I>A</I>. After the assignment, <I>ap</I> may be subscripted exactly as if it had been declared as an array. In fact, the major difference between <I>A</I> and <I>ap</I> in most expressions is that <I>ap</I> is a variable and <I>A</I> becomes a constant address.<P>
If, instead of assigning an array address to <I>ap</I>, I use <I>malloc</I> to allocate the same amount of memory, and assign that address to <I>ap</I>:<P>
<pre>ap = malloc( ... );</pre>
then an expression like<P>
<pre>ap[2][1] = 4</pre>
works fine. <I>ap</I> isn't the pointer I want, though, because the number in the declaration still has to be a constant expression at compile-time.<P>
In the expansion of the subscript expression above, the dereferencing operator is applied twice. The two dereference operations lead me to try to use a pointer to a pointer, such as:<P>
<pre>int **p;</pre>
The compiler issues a warning if I try<P>
<pre>p = A;   /* compiler warning */</pre>
because <I>p</I> and <I>A</I> have different types. Using <I>malloc</I>, I can assign a block of memory to <I>p</I>, as I did above:<P>
<pre>p = malloc( ... );</pre>
and C will let me subscript <I>p</I> once or twice.<P>
Unfortunately, subscripting <I>p</I> yields garbage. Referring again to the expansion of the subscript expression above, reveals why. C interprets <I>p[i] as *(p + i).</I> What pointer is being dereferenced? No pointer! <I>(p + i)</I> is a location within the area where the array's elements are supposed to be. Why does it work for <I>A</I> but not for <I>p</I>? It doesn't work for <I>p</I> because arrays and pointers are not the same. C treats arrays in a special way. Information about arrays is retained internally by C; pointers don't have access to such information, even when they are assigned the address of a conventional array. So, to manage my own arrays, I need to set up and keep track of the pointers C expects to find when expanding subscript expressions.<P>
From the previous discussion, you can see that <I>p[0]</I> is interpreted as a pointer to the first array of <I>ints, p[1]</I> as a pointer to the second array of <I>ints</I>, and so on, for each of the five rows of my example. I need to allocate storage for five <I>pointers to int.</I> If I assign the start of this block of memory to <I>p</I>, as in<P>
<pre>p = malloc( ... );</pre>
I get a warning (in C++) because I'm assigning a <I>void *</I> to an <I>int</I> **, but I can suppress the warning with a cast. Now <I>p[0], p[1], ..., p[n]</I> reference void-pointer-sized portions of allocated memory.<P>
In this block of memory I store the pointers C needs to evaluate subscript expressions like <I>p[2][3]</I>. These pointers are the addresses of each of the rows of the array. First, though, I have to allocate some memory for them to point at. This time I need a block that is the actual size of the array.<P>
<pre>p[0] = malloc( ... )</pre>
Then I calculate offsets into this memory that correspond to the start of each row and assign their addresses to the pointers in the first block of memory. To summarize, I have a <I>pointer to pointer to int, p,</I> that points to an array of <I>pointers to int</I>; each of these <I>pointers to int, p[i]</I>, refers to the first element of an array of ints, <I>p[i][0]</I>.<P>
What happens when I write <I>p[2][3]</I> now? Since <I>p</I> is an <I>int</I> **, C allows me to subscript it twice. <I>(p + 2)</I> is now a location in memory that I allocated, and where I stored the address of the third row of my dynamic array. If I follow the steps above for expanding subscript expression I get<P>
<pre><I>*(*p </I>+<I> 2) </I>+<I> 3 )</I></pre>
This expression works for my pointer to pointer because I carefully calculated and assigned addresses in just the sequence C uses to expand subscript expressions. For conventional arrays the intermediate pointers are implied. What I've done is manage them explicitly. Now I am ready to present my function.<P>
<h4><FONT COLOR="#000080"><A name="031B_0112">Allocation and Memory Layout<A name="031B_0112"></FONT></h4></P>
My dynamic array allocation function is called <I>dyn2darray</I>. It returns a<I> pointer to pointer to void (void **)</I>. I pass it the number of rows and columns I want, and the size of one element. The function declaration appears as:<P>
<pre>void **dyn2darray( unsigned row, unsigned col, unsigned el_size )</pre>
This declaration contains the same information I would give the compiler in a normal array definition, although it is in a somewhat different form. Later, I'll use a preprocessor macro to make it prettier.<P>
Instead of allocating separate blocks of memory for the pointers and the array elements, I allocate just one block, and use the block as a mixed data structure. The memory block consists of an array of pointers followed by an array of elements. I also add a feature to my dynamic arrays to make them a little more convenient to use. A disadvantage of conventional arrays as they are typically defined is that they don't carry any size information. When the program passes such an array to a function,<P>
<pre>void f( int array[][5] ) { ... }</pre>
the program must specify the length of the array's rows in the function's declaration. To avoid this limitation, I allocate a few extra bytes and store the number of rows and columns with the array. <A href="fig1.htm">Figure 1</a>
shows the memory layout of my dynamic arrays.<P>
<h4><FONT COLOR="#000080"><A name="031B_0113">How dyn2darray Works<A name="031B_0113"></FONT></h4></P>
<I>dyn2darray</I> is shown in <A href="list1.htm">Listing 1</a>.
 In the call to <I>calloc</I>, I allocate storage for the pointers, for the array elements, and two <I>unsigned ints</I> to hold the repetition counts. I compute the storage requirements for each of these components and sum them together to form the first argument to <I>calloc</I>. The second argument to <I>calloc</I> is <I>size of (char)</I>, which is guaranteed to be <I>1</I> specifies the size of a basic allocation unit, while the first specifies how many units to allocate. Therefore, I am simulating the allocation of an array of bytes, though I intend to use the memory as a mixed data structure. This practice might present a portability problem because of differing storage boundary requirements; however, as <I>dyn2darray</I> is defined, I need make only one call to <I>calloc</I>, and have one relatively neat package to deal with.<P>
<I>void **arr</I> receives the pointer returned from <I>calloc</I>. I check whether the allocation succeeds and return <I>NULL</I> if it doesn't. This allocation technique parallels the behavior of the <I>malloc</I> group of functions. I use <I>calloc</I> because I want to zero the arrays; it's easy to switch to <I>malloc</I> if the situation warrants it.<P>
I make <I>p</I> point just past the array of pointers in the memory block by assigning it the sum of two values: the start address of the block, <I>arr</I>, and the size of the array of pointers, <I>row * sizeof( void * )</I>. The cast on <I>arr</I> is necessary to defeat the scaling process which would be applied by normal pointer arithmetic. I want to store the number of rows and columns just before the actual array elements (so they're easy to find and out of the way). First I cast <I>p</I> to a pointer to <I>unsigned</I>, then store <I>row</I> to the memory block through the recast pointer. Second, to move <I>p</I> past the newly stored value of <I>row</I> I add <I>sizeof( unsigned )</I> to <I>p</I>. (A cast is not necessary here because <I>p</I> is a <I>pointer to char</I> &#151; there is no pointer arithmetic to contend with.) I repeat these two steps to store <I>col</I>. Both the numbers of rows and columns are now tucked away in <I>arr</I> as <I>unsigned ints</I>, and <I>p</I> points to the first byte of memory that will hold the array elements.<P>
Next, the <I>for</I> loop assigns the addresses of each row of elements to the corresponding pointer, <I>arr[c]</I>. The offset added to <I>p</I> is the length, in bytes, of a row, <I>(col * el_size)</I>, times the row number, <I>c</I>. The last step is to return <I>arr</I>, which points to the whole structure.<P>
<h4><FONT COLOR="#000080"><A name="031B_0114">Using Dyn2dArray<A name="031B_0114"></FONT></h4></P>
The header file DYN2DARR.H (<A href="list2.htm">Listing 2</a>)
 contains the prototype for <I>dyn2darray</I> and several macros. Include the header when you want to allocate dynamic two-dimensional (D2D) arrays.<P>
In the source file, start by declaring pointers to pointers for each D2D array you want. Here are some examples.<P>
<pre>/*           D2D arrays of ...  */
double **DDa;        /* double */
double * **DDap;     /* pointers-to-double */
typedef struct S 
  { ... } SS;
struct S **Sa;       /* struct S */
SS **Sal;            /* typedef SS */
struct S * **Sap     /* pointers-to-struct S */</pre>
I make calling <I>dyn2darray</I> a little easier by wrapping it in a macro, <I>Dyn2dArray</I>. The macro automatically calculates the size of the array elements. Using it allows you to write the type name directly in the function call. For a D2D array of <I>double</I> write<P>
<pre>DDa = Dyn2dArray( 3, 8, double );</pre>
and for a D2D array of <I>pointers to</I> <I>double</I><P>
<pre>DDap = Dyn2dArray( 4,7,double * );</pre>
Setting one of the asterisks a little off from the other two in the declaration looks just odd enough to remind you you're doing something different. (Don't accidentally fix it.) You can create D2D arrays for fundamental, aggregate, and user-defined types, as I have shown in the preceding sample declarations. Remember to check for a <I>NULL</I> return value. After allocating the D2D array, you can forget that you're using a <I>pointer to pointer</I>; you use it like a regular array, with a couple of exceptions (explained later). When you're done with the array, you can reuse the array name for a different size array by calling the standard library function <I>free</I>, and then allocating a new D2D array with <I>Dyn2dArray</I>. For an example see TEST.C in <A href="list4.htm">Listing 4</a>.
<P>
<h4><FONT COLOR="#000080"><A name="031B_0115">Passing D2D Arrays<A name="031B_0115"></FONT></h4></P>
To pass D2D arrays to a function, declare the function's argument as a <I>pointer to pointer</I> to the array element's type. For example,<P>
<pre>void f( int **d ) { ... }</pre>
can be passed any D2D array of <I>ints</I>.<P>
<h4><FONT COLOR="#000080"><A name="031B_0116">Other Useful Macros<A name="031B_0116"></FONT></h4></P>
The macro <I>Dyn2dRows</I> returns the number of rows in the array. It finds the first array element, backs up by four bytes, and accesses an <I>unsigned int</I>. <I>A[0]</I> is the <I>address</I> of the first byte of the element array. The cast to <I>unsigned</I> * scales the 2 to <I>sizeof( unsigned * )</I> and, more important, causes the dereference operator to treat its operand as an <I>unsigned int</I>, rather than as an element of the type specified in the original declaration. Similarly, <I>Dyn2dCols</I> returns the number of columns. <I>Dyn2dRows</I> and <I>Dyn2dCols</I> save you the trouble of having to pass the number of rows and columns to functions.<P>
<h4><FONT COLOR="#000080"><A name="031B_0117">Some Cautions<A name="031B_0117"></FONT></h4></P>
The names of D2D arrays are variables. You can change them by assignment, or by applying the increment or decrement operators. (By contrast, C generates an error if you try to do the same to a conventional array.) But if you don't preserve the original pointer to the array you'll be unable to access the array or <I>free</I> it properly when you're done with it.<P>
For conventional arrays, <I>sizeof( A )</I> yields the size of the whole array. But D2D array names are pointer variables; you don't have direct access to the size of the whole array. The formula,<P>
<pre>Dyn2dRows( A ) * Dyn2dCols( A ) *
sizeof( **A )</pre>
yields the number of bytes required by the array elements, but not the total size of the D2D array. If you need the size of the whole D2D array you can write a macro; the information you need is in the source code.<P>
<A href="tab1.htm">Table 1</a>
contains a comparison of the characteristics of a regular two-dimensional array and a D2D array.<P>
<h4><FONT COLOR="#000080"><A name="031B_0118">Magic Squares<A name="031B_0118"></FONT></h4></P>
Pointers are often used to access an array's elements sequentially because they're so convenient to increment and decrement. Subscripting is usually more convenient when you need to access elements out of order. The demonstration program, MAGIC.C (See <A href="list3.htm">Listing 3</a>)
 uses D2D arrays to hold the solutions to magic square puzzles. The algorithm hops around the array as it decides where to place numbers.<P>
MAGIC.EXE takes an odd positive integer, <I>n</I>, as a command-line argument, which it interprets as the length of one side of a magic square. MAGIC.EXE then inserts the numbers from <I>1</I> to <I>n * n</I>, in the square's cells, so that each row, column, and diagonal adds up to the same number. MAGIC.EXE prints the solution to the screen, along with the "magic" total.<P>
Magic number puzzles are good examples of when D2D arrays come in handy. (I've also used D2D arrays for multiplying matrices, evaluating determinants, and determining LCDs and GCDs.) Progressing to more challenging puzzles requires larger and larger arrays to hold the solutions.<P>
MAGIC.EXE starts by allocating a D2D array of <I>ints</I>, <I>arr</I>, one cell wider and longer than requested. This extra space allows <I>magic</I> to move off the magic square but stay within the bounds of the array. The function <I>magic</I> solves the puzzle. <I>magic</I> takes a <I>pointer to pointer to int</I> as a parameter.<P>
The solution to a magic square is as follows. Put <I>1</I> in the middle cell of the top row. Move up and to the left one box. If you run off the top or side of the magic square, wrap around to the corresponding cell on the opposite side of the square. If you arrive at an empty cell, put the next number from the sequence <I>1 .. n * n</I> in the cell. If the cell already contains a number, move one cell right and down, and then down another cell. Put the next number from the sequence in this cell and then continue up and left, depositing the next number in each cell until you run out of cells (or patience).<P>
In <I>magic</I>, <I>count</I> keeps track of which number in the sequence it has reached. <I>r</I> starts as <I>1</I>, for the first row, and <I>c</I> starts as <I>(size + 1) / 2,</I> for the middle cell of the row. <I>mag[r][c]</I> gets <I>count.</I> To move up and left, decrement <I>r</I> and <I>c</I>. If <I>mag[r][c]</I> doesn't equal zero (there's a number there already), or if both <I>r</I> and <I>c</I> equal zero (a special case, you're in the upper left hand corner of the square), move back a column, ++<I>c</I>, and down two rows, <I>r += 2</I>. Otherwise, if <I>r </I>or <I>c</I> equal zero, wrap around by setting <I>r</I> or <I>c</I> to size. Finally, put <I>count</I> in <I>mag[r][c]</I> and go to the top of the loop.<P>
<I>show_mag</I> prints the solution to the screen making use of some of the features I built into my D2D arrays. Since <I>show_mag</I> accepts a <I>pointer to pointer to int</I>, any size array can be passed to it. <I>Dyn2dRows</I> and <I>Dyn2dCols</I> are used for the limits in the two <I>for</I> loops. You don't have to worry about limits because the D2D arrays carry their bounds with them. <I>show_mag</I> also totals up the "magic" number and displays it.<P>
The call to <I>free</I> isn't necessary in MAGIC.EXE, since the program ends, but it demonstrates how a D2D array is cleaned up.<P>
TEST. C (See <A href="list4.htm">Listing 4</a>)
 is a torture test for D2D arrays. (It's also torture to watch it run.) It allocates and <I>frees</I> lots of D2D arrays, and checks for leaky memory.<P>
The outer loop varies the first repetition count from one to nine, and the next loop varies the second repetition count from ten to one. This produces a complete set of D2D arrays, with every combination of repetition counts possible up to the value of <I>high</I>. Increase <I>high</I> to add further stress to the system.<P>
For each set of repetition counts, a D2D array of structures and pointers to structures is allocated. If an allocation fails, an error message is displayed and the program halts. You can examine the last couple of lines to see the condition that caused the failure. To force a failure, increase any variable that causes an increase in the amount of memory requested. (If you remove the comment from the <I>array</I> of <I>double</I> variable in the structure declaration you'll succeed in failing.)<P>
The first pair of inner loops assigns a value to the <I>double</I> member, <I>dd</I>, of each D2D array element. It's helpful to assign the sum of the loop indices to the current element, because then you always know what its value should be. Said another way, an element's value will equal the sum of its subscripts. This technique has the further advantage of producing a distinctive pattern when printed out in row-major order.<P>
The next pair of loops assigns the addresses of the structures in <I>d</I>, to the pointers to structures in <I>pd</I>. The final pair of loops prints values accessed through the pointers in <I>pd</I> to the screen. If the sum of the loop indices ever does not equal the value stored in the corresponding element, the program halts.<P>
Once the program has written to and read all of the elements, it releases both of the D2D arrays by calls to <I>free</I>.<P>
The amount of memory available after freeing the D2D arrays should be constant while the program runs. To check this I make two calls to <I>_memmax</I> per pair of repetition counts. <I>_memmax</I> is a nonstandard function in the Microsoft C run-time library. It returns the size of the largest contiguous memory block available from the <I>near</I> heap. The first call is made while no D2D arrays are allocated. The return values should be the same for each iteration. (The difference between the first and second call is because of overhead incurred with the first call to <I>calloc</I>.) After allocating a D2D array <I>_memmax</I> returns a smaller number, whose size varies with the magnitude of the product of the repetition counts.<P>
<h4><FONT COLOR="#000080"><A name="031B_0119">Compiling<A name="031B_0119"></FONT></h4></P>
<A href="list5.htm">Listing 5</a>
contains a MAKEFILE for Microsoft's NMAKE.EXE. It should work with other versions of <I>make</I> with few or no changes. I've compiled various versions of <I>DYN2DARR.C</I> with Microsoft C 6.x, C/C++ 7.0, and Visual C++ 1.0, with the C/C++ compilers from Zortech and Borland, and Symantec THINK C 5.0 for Macintosh.<P>
<h4><FONT COLOR="#000080"><A name="031B_011A">Conclusion<A name="031B_011A"></FONT></h4></P>
You can dynamically allocate 2-D arrays in C; it just takes a little extra work. I have presented a way to dynamically allocate 2-D arrays, pass them to functions, and use them in a program. Once you get past the preliminaries, you may find that these arrays behave much like their more conventional counterparts in C.<P>

<h4><a href="../../../source/1993/nov93/labrocca.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
