

<HTML>
<HEAD>

<TITLE>February 1995/Standard C/C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Standard C/C++<A name="0050_0026"><A name="0050_0026"></font></h2><P>
<h3 align="center"><A name="0050_0000"><A name="0050_0000">Implementing &lt;strstream&gt;</h3><P>
<h3 align="center"><font color="#800000">P.J. Plauger</font></h3><hr><blockquote><P>
<P><i><A name="0050_0000"><A name="0050_0000">P.J. Plauger is senior editor of C/C++ Users Journal. He is convener of the ISO C standards committee, WG14, and active, on the C++ Committee, WG21. His latest books are The Draft Standard C++ Library, and Programming on Purpose (three volumes), all published by Prentice-Hall. You can reach him at pjp@plauger.com.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0050_0027">Introduction<A name="0050_0027"></FONT></h4></P>
I introduced the header <I>&lt;strstream&gt;</I> last month and showed a variety of ways to use the classes it defines. (See "Standard C/C++: The Header <I>&lt;strstream&gt;," </I><I>CUJ</I>, January 1995.) Among other things, it defines the class <I>istrstream</I>, which is derived from istream to help you extract from a character sequence stored in memory. Thus, you can write code like:<P>
<pre>   istrstream strin("1 4 7 2 5 8 0
                  3 6 9");
   int i;
   while (strin &gt;&gt; i)
          try_button(i);</pre>
to "read" a constant string just as if it were a file.<P>
Similarly, class <I>ostrstream</I> is derived from <I>ostream</I> to help you insert into a character sequence stored in memory. You can construct a string as if writing to a file, for example, then read it later with an <I>istrstream</I> object controlling the same stream buffer, as above. For the special magic involved, both make use of the stream buffer class <I>strstreambuf</I>. As with all stream buffers, it is derived from <I>streambuf</I>, in this case to manage such in-memory character sequences. (See "Standard C/C++: The Header <I>&lt;streambuf&gt;," </I><I>CUJ</I>, June 1994.)<P>
The net effect is that the classes defined in <I>&lt;strstream&gt;</I> let you read and write these character sequences with exactly the same machinery you use to read and write external files in C++. You can, of course, perform much the same operations with the Standard C library functions <I>sprintf</I> and <I>sscanf,</I> declared in <I>&lt;stdio.h&gt;.</I> But those older functions require you to use different notation for reading and writing in-memory character sequences rather than external files. And they don't work with the inserter and extractor machinery of C++. The classes defined in <I>&lt;strstream&gt;</I> offer an obvious notational advantage, as well as better information hiding.<P>
My goal this month is to show you one way to implement these classes. It is part of the implementation I have been presenting for the past year, which is based on the draft C++ Standard going into the March 1994 meeting of WG21/X3J16. That in turn was based heavily on the existing header <I>&lt;strstream.h&gt;</I> which is still widely used as part of the iostreams package of library classes. If you know current C++ practice, much of what you see here will be familiar territory.<P>
In more recent drafts of the C++ Standard, many headers have been "templatized." The Standard C++ library now defines general templates that describe iostreams operations for an arbitrary "character" type <I>T</I>. To reproduce the existing functionality, the library instantiates these general templates for <I>T</I> defined as type <I>char.</I> The net result is much the same, but the machinery &#151; and the notation &#151; is now far more elaborate.<P>
The header <I>&lt;strstream&gt;</I> has most recently been exempted from this treatment. The committee favors its newly minted header <I>&lt;sstream&gt;</I>, which does much the same thing as <I>&lt;strstream&gt;</I> but works with templatized strings of arbitrary character types. (I discuss the <I>char</I> version of the newer header next month.) The older header is retained, in the interest of preserving existing code, but as a sort of second-class citizen. For all its idiosyncracies, I personally find it a handy way to fiddle with small sequences of type <I>char</I>. So what you see here is still quite useful. And it is still destined to be part of the final Standard C++ library.<P>
<h4><FONT COLOR="#000080"><A name="0050_0028">The Header File<A name="0050_0028"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
shows the header file that implements <I>strstream</I>. I've discussed some of the peculiar notation in past columns, but I've also made a few changes as compilers evolve. Briefly:<P>
<UL><li>The macro <I>_BITMASK</I> defines a "bitmask" type. (See "Standard C/C++: The Header <I>&lt;ios&gt;</I>," <I>CUJ</I>, May 1994.) It expands differently depending on whether the translator supports overloading on enumerated types, a fairly recent addition to the C++ language. I later discovered a need to defer the definitions of the overloaded functions, for bitmask types nested inside classes as is the case here. Thus, the macro <I>_BITMASK_OPS</I> supplies these deferred definitions.</li>
<li>The type <I>bool</I> has even more recently been added to the C++ language. It represents the true/false value of a test expression, such as a comparison operator. Until recently, I provided the typedef <I>_Bool</I> as a placeholder. But since some translators now supply this type, I've brought my code more up to date. (For older translators, <I>bool</I> is a defined type, not a keyword.)</li>
<li>The macro <I>_HAS_SIGNED_CHAR</I> expands to a nonzero value for translators that treat <I>char</I> and <I>signed char</I> as distinct types. All translators are supposed to, but many still do not.</li></UL>
I have added to the header two macros to specify in one place two values that are judgement calls. Both deal with the number of characters to allocate when creating or extending a character sequence:<P>
<UL><li><I>_ALSIZE</I>, the initial number of bytes to allocate, absent any hints to the contrary (currently 512)</li>
<li><I>_MlNSIZE</I>, the minimum number of additional bytes to allocate when extending a sequence (currently 32)</li></UL>
You may well have reasons to alter either or both of these values, based on what you know about storage size and granularity on a given implementation.<P>
The bitmask type <I>_Strstate</I>, defined within the class <I>strstreambuf</I>, describes the internal state of such an object. Much of the state information is spelled out in detail by the draft C++ Standard. I have added, however, the element <I>_Noread</I>, which is not used by the classes defined in <I>&lt;strstream&gt;</I>. Adding it here greatly simplifies the implementation of the classes defined in <I>&lt;sstream&gt;</I> (next month). The meaning of each of the <I>_Strstate</I> elements is:<P>
<UL><li><I>_Allocated</I>, set when the character sequence has been allocated</li>
<li><I>_Constant</I>, set when the character sequence is not to permit insertions</li>
<li><I>_Dynamic</I>, set when the character sequence can grow on demand</li>
<li><I>_Frozen</I>, set when the character sequence has been frozen (should not be deleted by the destructor)</li>
<li><I>_Noread</I>, set when the character sequence is not to permit extractions (is write only)</li></UL>
I developed the protected secret member function <I>strstreambuf::_Init</I> as a way to handle all possible constructors, including those for class <I>stringbuf</I>, defined in the header <I>&lt;sstream&gt;</I>. Similarly, the protected secret member function <I>strstreambuf::_Tidy</I> does all the work of the destructor. It is also used to advantage in class <I>stringbuf</I>. (See the discussion of <A href="list2.htm">Listing 2</a>,
 below.)<P>
Most of the objects stored within a <I>strstreambuf</I> object are what you might expect. <I>_Strmode</I> holds the state information. <I>Alsize</I> holds the current allocated sequence length. <I>_Palloc</I> and <I>_Pfree</I> point at the functions that allocate and free storage, if they are specified when the object is constructed.<P>
But there are also two additional private member objects. Each solves a different problem in managing accesses to the controlled character sequence. <I>_Penadsave</I> stores the end pointer for the output sequence while the stream buffer is frozen. (See the discussion of <A href="list4.htm">Listing 4</a>,
 below.) <I>_Seekhigh</I> stores the highest defined offset encountered so far within the character sequence. The code updates its stored value in several places when that value must be made exact.<P>
<h4><FONT COLOR="#000080"><A name="0050_0029">Workhorse Functions<A name="0050_0029"></FONT></h4></P>
<A href="list2.htm">Listing 2</a>
shows the file strstrea.c. It defines three of the functions you are likely to need any time you declare an object of class <I>strstreambuf</I> &#151; its destructor, <I>_Init</I>, and <I>_Tidy</I>. Two of the three functions are straightforward, but <I>_Init</I> warrants a bit of study. It selects among multiple forms of initialization by an intricate analysis of its arguments:<P>
<UL><li>If <I>gp</I> (the "get" pointer) is a null pointer, then <I>n</I> (the size argument) is a suggested initial allocation size.</li>
<li>Otherwise, if <I>mode</I> has the bit <I>_Dynamic</I> set, then the initial character sequence is copied from one controlled by a <I>string</I> object. The function copies <I>n</I> characters beginning at <I>gp</I>. The calling <I>string</I> constructor can independently inhibit insertions (<I>_Constant</I>) and/or extractions (<I>_Norend</I>).</li>
<li>Otherwise, the character sequence resides in an existing character array beginning at <I>gp</I>. If <I>n</I> is less than zero, the sequence is assumed to be arbitrarily large (<I>INT_MAX</I> characters). If <I>n</I> is zero, the array is assumed to contain a null-terminated string, which defines the character sequence. If <I>n</I> is greater than zero, it is taken as the length of the character sequence. The function defines an output stream only if <I>pp</I> (the "put" pointer) is not a null pointer and lies within the character sequence.</li></UL>
Be warned that this code is extremely fragile. Partly, it reflects the complexities of the numerous <I>strstreambuf</I> constructors (which I described last month). Partly, it is made larger by the inclusion of support for <I>stringbuf</I> constructors. But the code also enforces delicate <I>streambuf</I> semantics that are hard to spell out in detail. Tinker cautiously.<P>
<A href="list3.htm">Listing 3</a>
shows the file strstpro.c. It defines three functions that override <I>streambuf</I> virtual member functions to insert and extract characters &#151; <I>overflow, pbackfail</I>, and <I>underflow</I>. The inherited definition of <I>uflow</I> is adequate, so no override occurs here. (See "Standard C/C++: The Header <I>&lt;streambuf&gt;</I>," <I>CUJ</I>, June 1994.) Once again, two of the three functions are straightforward. Only <I>overflow</I> demands closer study.<P>
It is the business of <I>overflow</I> to "make a write position available," then insert the argument character into it. If the write position is already available, or if none can be made available, the function has an easy job of it. The hard part comes when the function must extend, or initially create, storage for the character sequence. It must then determine the size of any existing sequence (<I>osize</I>) and the desired new size (<I>nsize</I>). Then it can try to allocate the new storage, copy over any existing sequence, and free an existing sequence that was also allocated. Finally, it must determine new settings for the <I>streambuf</I> pointers, using some very finicky arithmetic.<P>
<h4><FONT COLOR="#000080"><A name="0050_002A">Other Functions<A name="0050_002A"></FONT></h4></P>
<A href="list4.htm">Listing 4</a>
shows the file strstfre.c, which defines the member function <I>strstreambuf::freeze</I>. Here is where the addition of the member object <I>strstreambuf::_Pendsave</I> saves the day. A frozen buffer must not permit insertions, but that is not an easy thing to prevent. The <I>streambuf</I> public member functions won't look past the pointers themselves if they indicate that a write position is available. So the trick is to make the output stream appear empty for a frozen stream buffer by jiggering the end pointer. <I>_Pendsave</I> stores the proper value for later restoration, should the stream buffer be unfrozen.<P>
<A href="list5.htm">Listing 5</a>
shows the file strstpos.c. It defines the two functions that override <I>streambuf</I> virtual member functions to alter the stream position &#151; <I>seekoff</I> and <I>seekpos</I>. The often critical value in both functions is the member object <I>strstrambuf::_Seekhigh</I>. It is updated as needed to reflect the current "end," or high-water mark, of the character sequence. That value determines offsets relative to the end (way equals <I>ios::end</I>), as well as an upper bound for valid stream offsets. The logic of both functions is otherwise simple but tedious.<P>
And that concludes the source code for class <I>strstreambuf</I>. The two remaining classes defined in <I>&lt;strstream&gt;</I> are derived from the classes <I>istream</I> and <I>ostream</I> to assist in controlling inmemory character streams. I described how to use both <I>istrstream</I> and <I>ostrstream</I> last month. As you can see from <A href="list1.htm">Listing 1</a>,
 most of the member functions are small and hence defined as inline.<P>
<A href="list6.htm">Listing 6</a>
shows the file <I>istrstre.c.</I> It defines the destructor for class <I>istrstream</I>, which is the only member function not defined inline within the class. And <A href="list7.htm">Listing 7</a>
shows the file <I>ostrstre.c</I>. It defines the destructor, and a moderately messy constructor, for class <I>ostrstream</I>. I put the constructor here mostly to hide the call to the function <I>strlen</I>, declared in <I>&lt;string.h&gt;</I>. It is not permissible to include the C header that declares it in <I>&lt;strstream&gt;</I> and I didn't want to make up a version of the function with a secret name. Again this is the only source code for member functions of class <I>ostrstream</I> not defined inline within the class.<P>
While there are a few tricky spots in the implementation of the stream buffer, most of the code that implements the header <I>&lt;strstream&gt;</I> is small and straightforward. You will find much the same story when we visit other specialized stream buffers derived from class <I>streambuf</I> and its brethren. It is a tribute to the basic design of iostreams that this is so.<P>
<I>This article is excerpted in part from P.J. Plauger, The Draft Standard C++ Library, (Englewood Cliffs, N.J.: Prentice-Hall, 1995).</I><P>

<h4><a href="../../../source/1995/feb95/pjp.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
