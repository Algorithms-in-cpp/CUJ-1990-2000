

<HTML>
<HEAD>

<TITLE>February 1995/Using Associative Arrays</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Using Associative Arrays<A name="0046_0020"><A name="0046_0020"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0046_0000"><A name="0046_0000">Michael McClung</font></h3><hr><blockquote><P>
<P><i><A name="0046_0000"><A name="0046_0000">Michael McClung is a senior staff engineer at Intecom Inc. He worked as a software contractor for 8 years before reentering the corporate work force. He received his Master of Science in Computer Science from the University of California at Lawrence Livermore Laboratory. His main interests include real-time systems, software development processes, and object-oriented programming. He can be reached at 214-447-8060 or mm@intecom.com.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0046_0021">Introduction<A name="0046_0021"></FONT></h4></P>
Associative arrays are well known in the software community. They are built into some languages such as AWK, Perl, and Smalltalk (as the data dictionary), and it is not unusual to find them in C++ class libraries since the language supports them well. You can easily find references to them by browsing through programming books. Yet, in my experience, associative arrays are not commonly used in C programming environments. This article defines associative arrays, shows where they can be useful, and presents an implementation in C.<P>
<h4><FONT COLOR="#000080"><A name="0046_0022">Defining Associative Arrays<A name="0046_0022"></FONT></h4></P>
Interpretations may vary, but in this context the term <I>associative array</I> refers to an array that takes a user-defined type as an array index. Viewing all arrays as mapping functions, a conventional array is a function that maps only from an integer index to another type. For example<P>
<I>a[5]= 19.58</I> maps the integer <I>5</I> to the floating point number <I>19.58.</I><P>
<I>b[7]= "twelve"</I> maps the integer <I>7</I> to the string <I>"twelve".</I><P>
<I>c[9]='D'</I> maps the integer <I>9</I> to the char <I>'D'.</I><P>
Associative arrays remove the restriction of integer indexes, allowing arbitrary data types to directly map to other types, as in the following:<P>
<I>a["first"] = 19.59</I> maps the string <I>"first"</I> to the floating point number <I>19.58.</I><P>
<I>b[1.21]="twelve"</I> maps the floating point number <I>1.21</I> to the string <I>"twelve"</I>.<P>
<I>c[employee_rec]=&amp;d_rec</I> maps the structure <I>employee_rec</I> to the record pointer <I>&amp;d_rec.</I><P>
The sparse array exemplifies another type of mapping problem that lends itself well to associative arrays. Suppose several points must be identified in a 10,000-meter cube. The simplest model is a three-dimensional array with each dimension ranging from zero to 10,000. Allocation of a conventional linear array far exceeds available memory. With an associative array, which does not depend on linear storage, the memory requirements are much smaller. The following code, using the associative array <I>CUBEPOINT</I>, requires only the locations used, one for each assignment.<P>
<pre>CUBEPOINT(1,123,1564)=TRUE;
CUBEPOINT(100,256,5647)=TRUE;
CUBEPOINT(1000,6123,9156)=TRUE;</pre>
Associative arrays are an abstraction, not a particular data structure or algorithm, since many different implementations are possible.<P>
<h4><FONT COLOR="#000080"><A name="0046_0023">Design Requirements<A name="0046_0023"></FONT></h4></P>
Since there are lots of ways to implement associative arrays, I've established some criteria to narrow down the choices. In this section I describe these criteria, which are efficiency, a generic implementation, and an intuitive interface.<P>
<h4><FONT COLOR="#000080"><A name="0046_0024">An Efficient Algorithm<A name="0046_0024"></FONT></h4></P>
The algorithm must be efficient in both execution speed and memory usage. Two primary criteria are efficient insertions of new elements and fast searches for existing elements. In addition, I want neither the amount of storable data nor the form to be strictly limited. Two excellent algorithms in terms of efficiency are AVL trees and hashing. AVL trees, which maintain a balanced search tree, provide the best memory handling characteristics. Hashing, which usually involves a simpler algorithm, provides a search speed hard to match. In this article, I present a design that uses hashing, mainly because its ease of implementation makes the example code more clear.<P>
<h4><FONT COLOR="#000080"><A name="0046_0025">A Generic Implementation<A name="0046_0025"></FONT></h4></P>
A practical implementation must be generic in the sense that a single module must handle arbitrary user-defined types and array sizes. I accomplish this in two ways. First, the definition of each array is self-contained in an array identifier. This encapsulation of the complete definition by an identifier allows independent arrays to coexist. Second, I categorize the index for each array definition as either a string type or raw binary type. Knowing how to read, compare, and copy only these two types, I can implement a generic hash algorithm. The user specifies a key's type (string or binary) when the array is created.<P>
<h4><FONT COLOR="#000080"><A name="0046_0026">An Intuitive Interface<A name="0046_0026"></FONT></h4></P>
Associative array access should resemble conventional array access as much as possible to ease use and improve readability. The lack of language support for generic functions and operator overloading exacerbates the problem of creating a good interface. In part, I sidestep the interface requirement by pushing some of the responsibility onto the user. Wrapping the access function with a user macro provides a respectable, albeit inelegant, associative array interface.<P>
Ideally, an associative array of file descriptor pointers, each indexed by file name, would be accessed as follows:<P>
<pre>fd["filexy"]=filedesc;</pre>
Because C does not support this extension, the actual interface is more formidable:<P>
<pre>*((FILE **)aa_addr(fd,"filexy")=filedesc;</pre>
However, by adding a macro wrapper, users can approximate the look of conventional arrays:<P>
<pre>#define FD(n) (*((FILE **)aa_addr(fd.n))
. . . .
FD("filexy")=filedesc;</pre>
Since the compiler's preprocessor does not allow dynamic macro generation, the user must define an access macro for each array definition. I explain these macros further in the examples.<P>
<h4><FONT COLOR="#000080"><A name="0046_0027">The Code<A name="0046_0027"></FONT></h4></P>
Two source files contain the associative array code. <A href="list1.htm">Listing 1</a>
shows the header file that must be included by the application. This file defines the associative array structure, declares each entry point, and provides macro definitions. The second file contains the module's source, which must be compiled and linked with the application. Throughout the description of the source, I use the term <I>key</I> to refer to the array index.<P>
<A href="list2.htm">Listing 2</a>
through <A href="list7.htm">Listing 7</a>
break the module's source into functional parts, each separately explained below. For publication I have kept in-line documentation to a minimum, but the accompanying text should clarify the purpose of each code section.<P>
<h4><FONT COLOR="#000080"><A name="0046_0028">Part 1: The Module Header<A name="0046_0028"></FONT></h4></P>
<A href="list2.htm">Listing 2</a>
shows the module's header file, which defines macros and makes declarations for the rest of the module.<P>
<h4><FONT COLOR="#000080"><A name="0046_0029">Part 2: Creating the Array<A name="0046_0029"></FONT></h4></P>
The <I>aa_create</I> function in <A href="list3.htm">Listing 3</a>
creates an associative array. Creating an array entails allocating a structure (<I>aa</I>), loading the structure with all values describing the array characteristics, and returning the structure pointer. The calling function must save the structure pointer as an identifier for all other operations on the array. The caller should treat the identifier as an abstract data type, never directly accessing the structure. If an error occurs during creation, <I>aa_create</I> returns a null identifier.<P>
The identifier structure, <I>AA</I>, contains eight fields that make up a complete definition. <I>type</I> indicates whether the key is a string type or binary type. (This distinction is required since string operations, like compare and copy, are different from binary memory operations.) <I>key_size</I> gives the key's size in bytes. The <I>key_size</I> parameter is meaningful only with binary keys since string sizes are automatically determined with the <I>strlen</I> function. <I>data_size</I> specifies the maximum size in bytes of each array <I>element</I>. Two internal tables of pointers, <I>keys</I> and <I>data</I>, point respectively to a key and its corresponding data element; these two tables maintain the actual contents of the associative array. <I>max_elements</I> indicates the size of the <I>keys</I> and <I>data</I> tables, the maximum number of elements the array can hold, barring memory limitations. The last field, <I>hash_function</I>, points to the hash function that operates on the key to produce the hash value. This field, usually not user-defined, is discussed further in Part 4.<P>
Shown at the end of <A href="list3.htm">Listing 3</a>
is the <I>prime_size</I> function used by <I>aa_create</I> and later by <I>aa_resize</I>. This function forces the array size to be prime to improve the efficiency of the hash algorithm (see Part 4).<P>
<h4><FONT COLOR="#000080"><A name="0046_002A">Part 3: Accessing the Array<A name="0046_002A"></FONT></h4></P>
Once an associative array has been created with <I>aa_create</I>, programs can index it with the <I>aa_addr</I> function in <A href="list4.htm">Listing 4</a>.
 <I>aa_addr</I> takes two parameters: an associative array identifier and a key. The key indexes the associative array to find the corresponding data element. When the data element is found, <I>aa_addr</I> returns its address to the calling function, which can directly store into or retrieve from the data area.<P>
Since <I>aa_addr</I> adds new keys to the associative array, it also monitors the amount of free space left. If the array becomes too full &#151; 75 percent in the current implementation &#151; this function dynamically expands the size by 50 percent. Maintaining a sufficient number of empty slots in the array's hash tables insures an efficient search. I chose 75 percent as the critical number since studies show a rapid degradation in efficiency as the table load approaches 80 percent <a href="#1">[1]</a>. Other hash algorithms have better behavior when approaching capacity, but at a tradeoff of other factors, such as complexity. Part 6 describes the function that changes the array size.<P>
After checking the array size, <I>aa_addr</I> calls <I>hashindex</I> to find the index corresponding to the specified key. Once found, the same index offsets into both the keys table and data table. If the keys table already contains the sought after key, <I>aa_addr</I> returns the corresponding data address, completing the function. If the key is not in the table, <I>aa_addr</I> must allocate memory, save the key, and then return the data address. Saving the key guarantees the same data address is returned for future accesses with identical keys.<P>
<h4><FONT COLOR="#000080"><A name="0046_002B">Part 4: Hashing the Keys<A name="0046_002B"></FONT></h4></P>
The whole module pivots on the <I>hashindex</I> function shown in the second part of <A href="list5.htm">Listing 5</a>.
 This function, along with the subordinate function, <I>hash_function</I>, implements the hash algorithm. This particular hash implementation is called Double Hashing with Linear Probe. (See the sidebar <a href="sidebar1.htm">"Common Hashing Techniques"</a> for an overview of hashing techniques.)<P>
<I>hashindex</I> calls the hash function for the starting search location. <I>hashindex</I> then continues its search until it finds either a match for the input key or an empty slot. (An empty slot indicates the key is not in the table.) When the <I>hashindex</I> makes comparisons for matching keys it must consider whether a binary or string key is used (i.e., whether to use <I>memcmp</I> or <I>strcmp</I>). If the search was not successful on the first attempt, <I>hashindex</I> makes a second call to the hash function using a different size parameter to give the effect of a different hash calculation. If its search is still not successful, <I>hashindex</I> continues with a linear search until it finds either a matching key or an empty slot. On success, <I>hashindex</I> returns the index of the matching or empty slot.<P>
A good hash function is critical to the efficiency of the hash algorithm. Unless the caller defines a custom hash function when the array is created, the program will use <I>hash_function</I> by default. The user may wish to define a custom hash function for one of two reasons. The first reason is for speed, since the function can be optimized for the specific key type. The second and most critical reason is to handle non-continuous keys. A non-continous key is a key that contains sections of non-data bytes.<P>
An example of a non-continuous key is a record structure with multiple character strings; the data after each string's terminator is undefined, leaving gaps in the key. A more subtle example is a complex key type that the compiler breaks up to fit on word boundaries. This behavior is compiler dependent and should be checked if in doubt. (Dumping memory with the debugger is an easy way.) A non-continuous key can corrupt the calculation of the hash value by introducting random data. If the key is not guaranteed to be continuous, the caller must either provide a custom hash function or initialize the key before use. A custom function can bypass any compiler dependencies since it knows the structure of the key. Setting the complete key to zeros (as with <I>memset(key, 0, sizeof(key))</I> also resolves the problem by initializing any memory gaps to a consistent value.<P>
<I>hash_function</I> works well on both binary and string keys. The implementation sacrifices some clarity for the sake of efficiency since this function more than any other affects the speed of the module.<P>
<I>hash_function</I> builds a shift table the first time it is invoked. The shift table helps guarantee that similar keys, such as "x-coordinate" and "y-coordinate," do not produce similar hash values. <I>hash_function</I> uses static table initialization since the size must be large enough to eliminate error checking in the hash calculation.<P>
Two <I>for</I> loops calculate the hash value, the first for string keys and second for binary keys. Each loop takes the exclusive-OR of all bytes in the key, with each byte first being modified by a shift value. Only bytes up to the null terminator are used for string keys. The aim of both loops is to minimize machine cycles while getting a good hash number.<P>
The last and essential part of creating the hash value is performing division with the modulo operator. Division completes the randomization of the hash number and bounds it to the size of the hash table. This is where a prime table size pays off; taking the modulo of a prime number gives a much better hash distribution.<P>
<h4><FONT COLOR="#000080"><A name="0046_002C">Part 5: Retrieving the Keys<A name="0046_002C"></FONT></h4></P>
<I>aa_keys</I>, in <A href="list6.htm">Listing 6</a>,
 returns all keys in an associative array. Because associative array indexes are not ordered, this function must provide a means of sequentially visiting every element in the array. The array identifier is the input parameter for <I>aa_keys</I>; it outputs an array of key pointers and the array's size. The output array is allocated dynamically so it must be freed by the caller, but individual key pointers should be considered constants since they point into the hash table. The keys are gathered by walking through every entry in the keys table. If the entry contains a valid key, neither null nor deleted, its pointer is saved in the output array.<P>
<h4><FONT COLOR="#000080"><A name="0046_002D">Part 6: Resizing the Array<A name="0046_002D"></FONT></h4></P>
<I>aa_resize</I>, shown in <A href="list7.htm">Listing 7</a>,
 expands or shrinks the size of the associative array. <I>aa_resize</I> is a module entry point and is also called internally from <I>aa_addr</I> when the array becomes too full. My original implementation of this module did not allow the array size to be changed, but I found myself wasting memory for worst-case allocations. The user still has the option of avoiding the resize overhead by allocating a large enough array at creation time.<P>
No short-cut exists to change the size of a hash table since the size is an integral part of the hash function. When a hash table is resized, <I>aa_resize</I> must allocate complete new tables and rehash every valid key in the old table to a new index location. <I>aa_resize</I> moves the key and associated data pointers to the new locations in the new tables. If the new tables cannot be allocated or the requested size is too small, the function fails.<P>
<h4><FONT COLOR="#000080"><A name="0046_002E">Part 7: Deleting and Testing Elements<A name="0046_002E"></FONT></h4></P>
<A href="list8.htm">Listing 8</a>
contains two functions: <I>aa_delete</I> removes an element from the array, and <I>aa_defined</I> tests if a key is already in the array.<P>
<I>aa_delete</I> takes two parameters, the array definition and the key to be deleted. The deletion frees both the key and the data memory. A flag, <I>DELETED_KEY</I>, is stored in the key pointer to prevent the slot from being reused. The pointer cannot appear empty since <I>hashindex</I> assumes the search is complete when an empty slot is found. If multiple keys hashed to the same index as the deleted key, those keys stored after the one deleted would never be reached since an empty slot would be found first. This aspect of key deletion is inherent to the hashing algorithm used.<P>
<I>aa_defined</I> returns a true value if the specified key is already stored in the array. Users should call <I>aa_defined</I> to find out if the key they're looking for is in the table. The application should never examine the data returned from <I>aa_addr</I> to determine if a key is contained in the array, since <I>aa_addr</I> always adds new keys to the array.<P>
<h4><FONT COLOR="#000080"><A name="0046_002F">Examples<A name="0046_002F"></FONT></h4></P>
<A href="list9.htm">Listing 9</a>
and <A href="list10.htm">Listing 10</a>
show two complete programs. These programs link with the associative array module and standard libraries, but are otherwise self contained. The first program counts the frequency of words read from standard input and prints a frequency list. The second program shows an associative array implementation of a sparse array.<P>
The user-defined macros, <I>WORD_COUNT</I> and <I>SPARSE</I>, simplify access to the arrays. A simple rule to follow when creating these macros is to cast the return value of <I>aa_addr</I> to a pointer to the array's data type and encase this expression with the dereference operator. Dereferencing the returned address allows the macros to be transparently used with nearly all operators. The user may optionally use the macro, <I>AA_ACCESS</I>, to create the access macro. <I>AA_ACCESS</I> is defined for this purpose in the header file.<P>
<h4><FONT COLOR="#000080"><A name="0046_0030">Conclusion<A name="0046_0030"></FONT></h4></P>
Associative arrays are a general purpose abstraction fitting a wide range of problems. Effectively incorporating higher abstractions into our programming solutions provides a path to lower cost and complexity. A few examples have shown that associative arrays do simplify programs. My own use of associative arrays has expanded as I've grown more aware of the range of possibilities.<P>
I have used associative arrays in applications ranging from development tools running in batch mode to production code in real-time systems. Conventional arrays access data elements only through integer indexes, but associative arrays allow arbitrary types, such as strings, to index the array. This seemingly small but powerful addition in capability has made associative arrays a mainstay in many of my solutions to programming problems.<P>
<h4><FONT COLOR="#000080"><A name="0046_0031">Bibliography<A name="0046_0031"></FONT></h4></P>
<a name="1"></a>[1]</a>     Knuth, Donald E. <I>The Art of Computer Programming, Volume 3: Sorting and Searching</I>. Addison-Wesley, 1973.<P>

<h4><a href="../../../source/1995/feb95/mcclung.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
