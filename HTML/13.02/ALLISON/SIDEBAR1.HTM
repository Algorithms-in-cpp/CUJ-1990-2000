<HTML><HEAD><TITLE>February 1995/Code Capsules/Sidebar</TITLE></HEAD><BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">Character Sets</FONT></h3><hr>
<BLOCKQUOTE>
A <I>script</I> is a set of symbols used to convey textual information. There are over 30 major scripts in the world. Some scripts, such as Roman and Cyrillic, serve many languages. World scripts can be categorized according to the hierarchy in <A href="fig1.htm">Figure 1</a>.
<P>
Most scripts are <I>alphabetic.</I> The Han script used by Chinese, Japanese, and Korean, however, is an <I>ideographic</I> (or more accurately, <I>logographic</I>) script. Each Han character represents an object or concept &#151; these languages have no notion of words composed of letters from an alphabet.<P>
A <I>character set</I> is a collection of text symbols with an associated numerical encoding. The ASCII character set with which most of us are familiar maps the letters and numerals used in our culture to integers in the range [32, 126], with special control codes filling out the 7-bit range [0, 127]. As the 'A' in the acronym suggests, this is strictly an American standard. Moreover, this standard only specifies half of the 256 code points available in a single 8-bit byte.<P>
There are a number of extended ASCII character sets that fill the upper range [128, 255] with graphics characters, accented letters, or non-Roman characters. Since 256 code points are not enough to cover even the Roman alphabets in use today, there are five separate, single-byte standards for applications that use Roman characters (see <A href="fig2.htm">Figure 2</a>)
.<P>
The obvious disadvantage of single-byte character sets is the difficulty of processing data from distinct regions, such as Greek and Hebrew, in a single application. Single-byte encoding is wholly unfit for Chinese, Japanese, and Korean, since there are thousands of Han characters.<P>
One way to increase the number of characters in a single encoding is to map characters to more than one byte. A <I>multibyte</I> character set maps a character to a variable-length sequence of one or more byte values. In one popular encoding scheme, if the most significant bit of a byte is zero, the character it represents is standard ASCII; if not, that byte and the next form a 16-bit code for a local character.<P>
Multibyte encodings are storage efficient since they have no unused bytes, but they require special algorithms to compute indices into a string, or to find string length, since characters are represented as a variable number of bytes. To overcome string indexing problems, Standard C defines functions that process multibyte characters, and that convert multibyte strings into <I>wide-character</I> strings (i.e., strings of <I>wchar_t</I>, usually two-byte characters). Unfortunately, these multi-byte and wide-character functions are commonly available only on XPG4-compliant UNIX platforms and Japanese platforms. The recently approved Amendment 1 to the C Standard defines many additional functions for processing seqences of mutli byte and wide characters, and should entice U.S. vendors to step out of their cultural comfort zone.<P>
<h4>Code Pages</FONT></h4></P>
Since standard ASCII consists of only 128 code points, there are 128 more waiting to be used in an eight-bit character encoding. It has been common practice to populate the upper 128 codes with characters suitable for local use. The combination of values 128-255 together with ASCII is called a <I>code page</I> under MS-DOS. The default code page for the IBM PC in the United States and much of Europe (#437) includes some box-drawing and other graphics characters, and Roman characters with diacritical marks. Other MS-DOS code pages include:<P>
863 Canadian-French<P>
850 Multi-Lingual (Latin-1)<P>
865 Nordic<P>
860 Portuguese<P>
852 Slavic (Latin-2)<P>
Non-U.S. versions of MS-DOS define other code pages. You can switch between code pages in MS-DOS applications, but not in U.S. Microsoft Windows (except in a DOS window). Only one code page remains active for Windows-hosted applications throughout an entire Windows session. Different versions of Windows have code pages appropriate for their region. For example, Windows-J for Japan uses a code page based on Shift-JIS. Windows 95 (a.k.a. Chicago) will support full code-page switching.<P>
Since code pages use code points in the range [128, 255], it is important to avoid depending on or modifying the high-bit value in any byte of your program's data. A program that follows this discipline is called <I>8-bit clean</I>.<P>
<h4>Character Set Standards</FONT></h4></P>
Seven-bit ASCII is the world's most widely-used character set. ISO 646 is essentially ASCII with a few codes subject to localization. For example, the currency symbol, code point 0x24, is '$' only in the United States, and is allowed to "float" to adhere to local conventions. ISO 646 is sometimes called the <I>portable character set</I> (PCS) and is the standard alphabet for programming languages.<P>
ISO 8859 is a standard that takes advantage of all 256 single-byte code points to define nine eight-bit mappings, to nine selected alphabets (see <A href="fig2.htm">Figure 2</a>)
. Each of these mappings retains ISO 646 as a subset, hence they differ mainly in the upper 128 code points. Some of these mappings are the basis for MS-DOS code pages.<P>
There is no official ISO standard for multibyte character sets in the Far East. However, each region of the Far East has its own local (national) standards. PC-industry standards, based on national standards, are also in common use in the Far East. Examples include Eten, Big Five, and Shift JIS.<P>
<h4>ISO 1O646</FONT></h4></P>
To simplify the development of internationalized applications, ISO developed the <I>Universal Multiple-Octet Coded Character Set</I> (ISO 10646), to accommodate all characters from all significant modern languages in a single encoding. An <I>octet</I> is a contiguous, ordered collection of eight bits, which is a <I>byte</I> on most systems. ISO 10646 allows for 2,147,483,648 (231) characters, although only 34,168 have been defined. It is organized into 128 groups, each group containing 256 planes of 65,536 characters each (256 rows x 256 columns.<P>
Any one of the 231 characters can be addressed by four octets, representing respectively the group, plane, row, and column of its location in the four-dimensional space. Consequently, ISO 10646 is a 32-bit character encoding. ASCII code points are a subset of ISO 10646 &#151; you just add leading zeroes to fill out 32 bits. For example, the encoding for the letter 'a' is <I>00000061</I> hexadecimal (i.e., Group 0, Plane 0, Row 0, Column 0x61).<P>
Plane 0 of Group 0 is the only one of the 32,768 planes that has been populated to date. It is called the <I>Basic Multi-Lingual Plane</I> (BMP). ISO 10646 allows conforming implementations to be BMP-based, i.e., requiring only two octets, representing the row and column within the BMP. The full four-octet form of encoding is called UCS-4, and the two-octet form UCS-2. Under UCS-2, therefore, the hexadecimal encoding for the letter 'a' is 0061 (Row 0, Column 0x61). Row 0 of the BMP is essentially ISO 8859-1 (Latin-l) with the U.S. dollar sign as the currency symbol.<P>
ISO 10646 also defines <I>combining</I> characters, such as non-spacing diacritics. In conforming applications, combining characters always follow the base character that they modify. The UCS-2 encoding for , then, consists of two 16-bit integers: 0061 0301 (0301 is called the <I>non-spacing acute</I>). For compatibility with existing character sets, there is also a single UCS-2 code point for  (00e1).<P>
For the most part, only Roman characters have such dual representations. Some non-Roman languages, such as Arabic, Hindi, and Thai, also require the use of combining characters. ISO-10646 specifies three levels of conformance for tools and applications:<P>
Level 1  combining characters not allowed<P>
Level 2  combining characters allowed for Arabic, Hebrew, and Indic scripts only<P>
Level 3  combining characters allowed with no restrictions<P>
<h4>Unicode</FONT></h4></P>
Unicode is a 16-bit encoding scheme that supports most modern written languages. It began independently of ISO 10646, but with Unicode version 1.1, it is now a subset of 10646 (to be precise, it is UCS-2, Level 3). Unicode also defines mapping tables to translate Unicode characters to and from most national and international character set standards.<P>
Some applications should readily convert to Unicode. Since ASCII is a subset, it is only necessary to change narrow (eight-bit) characters to wide characters. In C and C++, this means replacing <I>char</I> declarations with <I>wchar_t</I>. Some other character sets, such as Thai and Hangul, appear in the same relative order within Unicode, so you just need to add or subtract a fixed offset. Converting Han characters requires a lookup table.<P>
Vendors are now beginning to support Unicode, and tools are available at both the operating system and API levels. Tools supporting the 32-bit encodings of ISO 10646 are not expected for many years &#151; especially since no planes beyond the BMP have been populated.<P>
<h4>Bibliography</FONT></h4></P>
"UCS Coexistence/Migration," <I>X/Open Internal Report</I>, Doc. No. SC22/WG20 N252, 1993.<P>
<I>The Unicode Standard</I>. The Unicode Consortium, Addison-Wesley, 1991.<P>
Katzner, Kenneth. <I>The Languages of the World</I>. 1986.<P>
Martin, Sandra. "Internationalization Explored," <I>UniForum</I>, 1992.<P>
Plauger, P. J., "Large Character Sets for C," <I>Dr. Dobb's Journal</I>, August 1992.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
