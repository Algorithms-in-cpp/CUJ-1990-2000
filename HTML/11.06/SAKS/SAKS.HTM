

<HTML>
<HEAD>

<TITLE>June 1993/Stepping Up To C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Stepping Up To C++<A name="01A8_009A"><A name="01A8_009A"></font></h2><P>
<h3 align="center"><A name="01A8_0000"><A name="01A8_0000">Recent Language Extensions to C++</h3><P>
<h3 align="center"><font color="#800000">Dan Saks</font></h3><hr><blockquote><P>
<P><i><A name="01A8_0000"><A name="01A8_0000">Dan Saks is the founder and principal of Saks &amp; Associates, which offers consulting and training in C ++ and C. He is secretary of the ANSI and ISO C++ committees. Dan is coauthor of C++ Programming Guidelines, and codeveloper of the Plum Hall Validation Suite for C++ (both with Thomas Plum). You can reach him at 393 Leander Dr., Springfield OH, 45504-4906, by phone at (513) 324-3601, or electronically at <I>dsaks@wittenberg.edu.</I></i></P><P>
As part of the <I>C Users Journal's</I> expanding coverage of C++, I'll be writing periodic reports on the progress of the C++ standard. This is the first such report.<P>
For the last three years, I've been writing these reports for <I>The C++ Report.</I> Over that time, the standards committee added several extensions to the C++ language. This article summarizes most of those extensions.<P>
ANSI (the American National Standards Institute) chartered technical committee X3J16 way back in late 1989 to write a US standard for the C++ programming language. X3J16 started working in early 1990, and has been meeting three times a year ever since.<P>
About a year later, JTC1, the joint technical committee of ISO (the International Standards Organization) and IEC (the International Electrotechnical Commission) chartered SC22/WG21 to produce an international C++ standard. WG21 has joined X3J16 for all of its meetings since the summer of 1991. I refer to the joint C++ committee as WG21+X3J16.<P>
I'm reluctant to predict when the standard will be complete. Formal approval is at least three years away. But the essential features of the language and libraries should be pretty stable much sooner than that.<P>
As you may have noticed from the brief biography below, I'm the secretary of both the ANSI and ISO C++ standards committees. I try to remain detached when I talk about the committees, but I will occasionally lapse into talking about the joint committee as "we." <P>
<h4><FONT COLOR="#000080"><A name="01A8_009B">Where We Started<A name="01A8_009B"></FONT></h4></P>
Language standards often start from one or more base documents. That is, rather than write the standard from scratch, the committee adopts an existing written description of the language and libraries as the first draft. The committee then spends years refining that draft. These refinements include: <P>
<UL><li>reconciling inconsistent statements</li>
<li>improving the precision of the words</li>
<li>adding missing features</li></UL>
X3J16 selected two base documents:<P>
<UL><li>the AT&amp;T C++ 2.1 <I>Product Reference Manual</I> (the <I>PRM</I>)</li>
<li>the C standard</li></UL>
C++, like C, began at AT&amp;T Bell Labs. AT&amp;T started distributing a C++ compiler called <I>cfront</I> in the mid-1980s. The 2.1 <I>PRM</I> describes the language more or less as AT&amp;T had implemented it by early 1990.<P>
Most C++ programmers know the <I>PRM as the Annotated</I> <I>C</I>++ <I>Reference Manual</I>, or <I>ARM (</I>Ellis and Stroustrup 1990). The<I> ARM</I> includes the text of the <I>PRM</I> along with annotations and commentary that elaborate the language description, explain many language design decisions and suggest implementation techniques. However, AT&amp;T (which holds the copyrights to both the<I> PRM</I> and the <I>ARM</I>) only granted the C++ committee the right to use the <I>PRM</I>, so the current draft of the standard does not include the annotations and commentary.<P>
The committee's first decisions brought the Working Paper closer to the <I>ARM</I>. The <I>ARM</I> includes chapters on templates and exception handling. <I>cfront</I> 2.1 did not include these features, so the <I>PRM</I>, and hence the base document, only had empty place holders for those chapters. The committee added these chapters to the Working Paper during its first year, so for all practical purposes, it's fair to say that the <I>ARM</I> is the base document.<P>
X3J16 selected the ANSI C Standard as its second base document in the hope of minimizing unnecessary differences between C++ and C. I think some of us on the committee expected that, whenever C++ and C share a feature, the C++ standard would use the same, or nearly the same, wording as the C Standard. But to date, the C++ draft still employs wording that is closer to the <I>ARM</I>, even when describing features from C.<P>
By the way, the politically correct term for the C++ draft is not the "draft," but the "Working Paper." The Working Paper won't be a draft until the committee submits it for public review. The first public review is at least a year away. <P>
<h4><FONT COLOR="#000080"><A name="01A8_009C">Committee Groups<A name="01A8_009C"></FONT></h4></P>
The joint committee conducts most of its technical work in smaller ad hoc groups. These groups are:<P>
<UL><li>C Compatibility &#151; This group compares the C++ Working Paper with the C Standard and makes recommendations for reconciling their differences.</li>
<li>Core Language &#151; This group resolves ambiguities and inconsistencies in the core features of the language as specified by the <I>PRM</I>. This group recently divided into smaller groups: the "hard" core group tackles the broader issues that take many meetings to resolve, and the "soft" core group addresses a numerous collection of smaller issues.</li>
<li>Environments &#151; This group focuses on requirements for the translation environment (including the preprocessor and linker) and the execution environment (including program startup, execution, and termination).</li>
<li>Extensions &#151; This group evaluates proposals to add new language features to C++. It makes recommendations for accepting some and provides rationale for rejecting others. (WG21+X3J16 considers templates and exceptions to be extensions.)</li>
<li>Libraries &#151; This group drafts the specification of standard library components, including <I>iostreams</I> and the C++ version of the Standard C library.</li>
<li>Syntax &#151; This group recommends refinements to the formal C++ grammar to make the language more precise and easier to parse. </li></UL>
<h4><FONT COLOR="#000080"><A name="01A8_009D">The New Stuff<A name="01A8_009D"></FONT></h4></P>
In addition to templates and exception handling, the committee added a few other new features to C++:<P>
<UL><li>support for European translation environments</li>
<li><I>wchar_t</I> as a keyword and a distinct type</li>
<li>operator overloading for enumeration types</li>
<li>overloading of <I>new</I> and <I>delete</I> operators for arrays</li>
<li>relaxed restrictions on the return types for virtual functions</li>
<li>runtime type identification</li></UL>
None of these features is universally available. Of the MS-DOS compilers I own, only three provide templates (Borland, Comeau, and MetaWare), and only one supports overloading on enumerations (Microsoft).<P>
I will briefly summarize these extensions here, and cover them in detail in future columns. <P>
<h4><FONT COLOR="#000080"><A name="01A8_009E">Templates<A name="01A8_009E"></FONT></h4></P>
Templates come in two flavors: function templates and class templates. A function template defines a family of overloaded functions employing the same algorithm, but applied to operands of different types. For example, <P>
<pre>template &lt;class T&gt;
inline T abs(T x)
   {
   return x &gt;= 0 ? x : -x;
   }</pre>
defines a template for the absolute value function <I>abs</I>.<P>
The template itself doesn't generate any object code. Rather, the translator instantiates (creates) an <I>abs</I> function for a particular parameter type the first time you call <I>abs</I> with an argument of that type. For instance, if you call <I>abs(i)</I> for <I>int i</I>, the translator creates a definition for <I>abs(int)</I> as if you had defined <P>
<pre>inline int abs(int x)
   {
   return x &gt;= 0 ? x : -x;
   }</pre>
If you later call <I>abs(f)</I> for <I>float f,</I> the translator instantiates<P>
<pre>inline float abs(float x)
   {
   return x &gt;= 0 ? x : -x;
   }</pre>
Class templates provide a similar facility for classes. For example, in my recent columns on dynamic arrays (<I>CUJ</I>, November 1992) and <I>operator[]</I> (<I>CUJ</I>, January 1993), I wrote a class for a dynamic array containing elements of type <I>float.</I> A version of the <I>float_array</I> class definition appears in <A href="list1.htm">Listing 1</a>.
 Rather than rewrite the class for each different element type, you can write a single class template for a dynamic array with an arbitrary element type. The template appears in <A href="list2.htm">Listing 2</a>.
 Using that template, <P>
<pre>array&lt;int&gt; ai (n);</pre>
declares a dynamic array with <I>n int </I>elements, and<P>
<pre>typedef array&lt;float&gt; float_array;</pre>
defines type <I>float_array</I> as an instance of the class template.<P>
<h4><FONT COLOR="#000080"><A name="01A8_009F">Exception Handling<A name="01A8_009F"></FONT></h4></P>
Exception handling provides an orderly way to respond to disruptive events that occur during program execution. C++ exception handlers can handle synchronous, rather than asynchronous, events. Synchronous events are the kinds of problems you can detect by conditional expressions (as in an <I>if</I> statement or the argumentto a call on the <I>assert</I> macro). For example, <P>
<pre>p = new T;
if (p == 0)
   // you're out of memory</pre>
An asynchronous event is one triggered by an external event, like a device interrupt or a hardware fault. The standard header &lt;<I>signal.h</I>&gt; defines the C library facilities for handling asynchronous events.<P>
<A href="list3.htm">Listing 3</a>
sketches a simple exception handler. C++ reserves three new keywords for the syntax of exception handling: <I>try</I><I>,</I><I> catch</I>, and <I>throw</I>. A <I>try</I>-block is a compound-statement (a sequence of statements enclosed in brackets) followed by a sequence of one or more handlers, also known as <I>catch</I> clauses. The handlers "catch" exceptions "thrown" by <I>throw</I> expressions executed in the compound-statement or in functions called from within the compound-statement.<P>
Each <I>catch</I> clause in a <I>try</I>-block handles an exception of a different type. The exception-handling mechanism matches the type of the expression in the <I>throw</I> expression with the formal arguments in the <I>catch</I> clauses. Throwing an exception terminates the block throwing the expression and transfers control to the chosen <I>catch</I> clause. In addition, throwing an exception "unwinds" the runtime stack. That is, it terminates all active functions invoked from the <I>try</I>-block and deallocates their local variables.<P>
For example, function <I>h</I> in <A href="list3.htm">Listing 3</a>
contains a <I>try</I><I>-</I>block that calls function <I>g</I>. If <I>g</I> detects a problem, it throws an exception of type <I>XXX</I> which is caught by the third <I>catch</I> clause in <I>h</I>. Otherwise, <I>g</I> calls <I>f. f</I> may throw an exception of type <I>int,</I> which will be caught by the first <I>catch</I> clause in <I>h</I>. <P>
Some of you may have noticed that exception-handling behaves much like the Standard C functions <I>setjmp</I> and <I>longjmp.</I> The key difference is that throwing an exception invokes destructors for local objects as it unwinds the stack on the way back to the <I>catch</I> clause, whereas <I>longjmp</I> merely discards intervening stack frames as it returns to the <I>setjmp</I> point. <I>longjmp</I> works in C++ as long as it never terminates a function with local variables that have destructors. <P>
<h4><FONT COLOR="#000080"><A name="01A8_00A0">A European Representation for C++<A name="01A8_00A0"></FONT></h4></P>
WG14 (ISO C) recently approved a normative addendum to the ISO C standard. (See P. J. Plauger's "Formal Changes to C," <I>CUJ,</I> April 1993). The addendum includes a proposal from the Danish delegation to add a way for programmers to write C programs using only the invariant ISO 646 characters. <P>
This need arose because C uses the US ASCII character set as its alphabet. ASCII is the US national variant of the ISO 646 standard character set. Some or all of the ASCII characters <I>[] </I>{ } | ^ ~aren't available in non-US variants of ISO 646. Other national variants of ISO 646 replace some of these characters with native language characters, making C programs a bit harder to write and read. <P>
The normative addendum to the C Standard corrects the problem by adding new spellings as alternates for tokens that use ASCII-specific  characters. The new spellings only use characters from the invariant ISO 646 character set.<P>
Recognizing that C++ shared this problem with C, the C++ committee also adopted a set of alternate spellings. However, C++ adopted a slightly  different set. <A href="tab1.htm">Table 1</a>
lists the C and C++ alternatives, noting the differences. At one time the sets were the same, but they got out of sync. I believe the  committees will try to reconcile the differences. <P>
In C, the alternate spellings that are identifiers (everything from <I>bitand</I> on down in <A href="tab1.htm">Table 1</a>)
 are macros defined in the new standard header <I>&lt;iso646. h&gt;.</I> In C++, these new spellings are keywords (reserved for all uses by the language). C++ also provides <I>&lt;iso646.h&gt;</I> for compatibility with C, but on many C++ implementations, it might just be empty. <P>
<h4><FONT COLOR="#000080"><A name="01A8_00A1"><I>wchar_t</I><B> as a Keyword<A name="01A8_00A1"></B></FONT></h4></P>
Standard C provides wide characters and multibyte strings so that C programmers can manipulate very large character sets, like Japanese Kanji. Several headers in the Standard C library define <I>wchar_t</I> as the wide character type. <I>wchar_t</I> must be an integral type sufficiently large to represent all character codes in the largest character set among the supported locales. <P>
Defining <I>wchar_t</I> as a <I>typedef</I> poses a problem for C++. Members of the libraries group wanted to be able to overload functions with arguments of type <I>wchar_t</I>, such as <P>
<pre>int foo(int);
int foo(wchar_t);</pre>
In particular, they wanted to be able to overload the output operators<P>
<pre>ostream &amp;operator&lt;&lt; (ostream &amp;os, char c);
ostream &amp;operator&lt;&lt; (ostream &amp;os, int i);
ostream &amp;operator&lt;&lt; (ostream &amp;os, wchar_t w);</pre>
so that given<P>
<pre>int i;
wchar_t w;</pre>
the expression<P>
<pre>cout &lt;&lt; i;</pre>
displays <I>i</I> as an <I>int,</I> and<P>
<pre>cout &lt;&lt; W;</pre>
displays <I>w</I> in its proper graphic representation. The problem is that, if <I>wchar_t</I> is a <I>typedef</I>, it is indistinguishable from at least one of the other integral types. In C+ +, a <I>typedef</I> is not a distinct type; it is an alias for another type. If the library defines <P>
<pre>typedef wchar_t int;</pre>
then<P>
<pre>ostream &amp;operator&lt;&lt;(ostream &amp;os, int i);
ostream &amp;operator&lt;&lt;(ostream &amp;os, wchar_t w);</pre>
are the same function. That function will (most likely) display objects of type <I>wchar_t</I> as numbers.<P>
Thus, WG21+X3J16 made <I>wchar_t</I> a new keyword in C++ representing a distinct type. <I>wchar_t</I> is still represented the same way as one of the standard integral types (meaning it has the same size, alignment requirements, and "signedness" as one of the integral types), but it is now a distinct type for the purposes of overload resolution. <P>
<h4><FONT COLOR="#000080"><A name="01A8_00A2">Operator Overloading for Enumerations<A name="01A8_00A2"></FONT></h4></P>
In C, enumerations are integral types. The <I>ARM</I> also states that enumerations are integral types in C++. However, the current C++ Working Paper says that "Enumerations are not integral, but they can be promoted to <I>signed</I> and <I>unsigned ints</I>." Thus, Standard C code such as <P>
<pre>enum color { RED, WHITE, BLUE };
enum color c = 0;</pre>
is no longer C+ +. (I don't think this is any great loss; it was always poor style.) An assignment like<P>
<pre>int n = BLUE;</pre>
which is valid C, is still valid C++.<P>
This change introduces a more serious incompatibility with C: the predefined arithmetic operators, most notably ++, no longer apply to enumerations. Therefore, a loop such as <P>
<pre>for (c = RED; c &lt;= BLUE; ++c)</pre>
no longer compiles as C++. (This is a loss because it can be good style.) The present wording of the Working Paper doesn't seem to allow <P>
<pre>c &lt;= BLUE</pre>
But I believe it is, in fact, allowed because both operands promote to <I>int</I>.<P>
WG21+X3J16 reduced the trauma of this incompatibility by extending C++ to permit overloading on enumerations. For example, you can write the <I>for</I> loop above by defining<P>
<pre>inline color &amp;operator++(color &amp;c)
   {
   return c = color(c + 1);
   }</pre>
as the prefix form of ++ for objects of type <I>color.</I><P>
<h4><FONT COLOR="#000080"><A name="01A8_00A3">Overloading <B><I>new</I></B> and <B><I>delete</I></B> for Arrays<A name="01A8_00A3"></FONT></h4></P>
In C, you allocate dynamic memory using the standard library functions <I>malloc (</I>or<I> calloc </I>or<I> realloc),</I> and you deallocate memory by calling <I>free</I>. In C++, you use the <I>new</I> and <I>delete</I> operators instead. <P>
Both <I>malloc</I> and <I>new</I> allocate memory, but <I>new</I> also applies a constructor to the storage if the allocated object has a class type with a constructor. That is, if <I>X</I> is a class with a constructor <P>
<pre>p = new X;</pre>
allocates and constructs an <I>X</I> object, but<P>
<pre>p = (X *)malloc(sizeof(X));</pre>
merely allocates storage and leaves the object unconstructed. Similarly, both <I>free</I> and <I>delete</I> deallocate storage, but only <I>delete</I> applies a destructor (if any) to the object just before deallocating it. <P>
Each C++ environment provides a default implementation for the <I>new</I> and <I>delete</I> operators. However, if this general-purpose allocator isn't right for your application, you can write you own versions of <I>new</I> and <I>delete.</I> For example, <P>
<pre>void *operator new(size_t n)
   {
   ...
   }</pre>
defines a replacement allocation function, so that calling the <I>new</I> operator calls this allocator instead of the system-supplied allocator. Similarly<P>
<pre>void operator delete(void *p)
   {
   ...
   }</pre>
defines a replacement deallocator for use by the <I>delete</I> operator.<P>
C++ not only lets you replace the global dynamic memory allocator, but even lets you define a different allocator for each class. That is,<P>
<pre>class Y
   {
public:
   void *operator new(size_t);
   void operator delete(void *p);
   ...
   };</pre>
defines class <I>Y</I> with its own special-purpose versions of <I>new</I> and <I>delete</I>. A call such as<P>
<pre>q = new Y;</pre>
allocates memory using <I>Y::operator new,</I> rather than the global operator <I>new,</I> and<P>
<pre>delete q;</pre>
deallocates memory using <I>Y::operator delete</I>. Those classes that do not define their own <I>new</I> and <I>delete</I> use the global operators.<P>
The <I>ARM</I> states that, even for a class <I>Y</I> that defines its own operator <I>new,</I> allocating an array of <I>Y</I> objects always uses the global operator <I>new.</I> That is,<P>
<pre>q = new Y[n];</pre>
ignores <I>Y::operator new</I> and uses <I>::operator new. </I>Consequently, deleting that array using<P>
<pre>delete [] q;</pre>
ignores <I>Y::operator delete </I>and uses <I>::operator delete</I>.<P>
The committee recently extended C++ to provide a separate set of dynamic memory management functions for arrays of objects:<P>
<pre>void *operator new[](size_t n);
void operator delete[](void *p);</pre>
With this extension,<P>
<pre>p : new X[m];</pre>
allocates memory using operator <I>new[]</I> instead of operator <I>new</I>, and<P>
<pre>delete [] p;</pre>
uses operator <I>delete[]</I> instead of operator <I>delete</I>.<P>
You can even define operators <I>new[] </I>and <I>delete[]</I> for an individual class, such as<P>
<pre>class Y
   {
public:
   void *operator new(size_t);
   void *operator new[] (size_t);
   void operator delete(void *p);
   void operator delete[](void *p);
   ...
   };</pre>
so that<P>
<pre>q = new Y[n];</pre>
uses <I>Y::operator new[]</I> instead of <I>Y::operator new</I>.<P>
<h4><FONT COLOR="#000080"><A name="01A8_00A4">Enhanced OOP Support<A name="01A8_00A4"></FONT></h4></P>
The standards committee enhanced object-oriented programming (OOP) in C++ by<P>
<UL><li>relaxing restrictions on the return types for virtual functions</li>
<li>adding runtime type identification</li></UL>
C++ supports OOP by providing inheritance and virtual functions. I described inheritance in a recent two-part tutorial ("Inheritance, Part 1," <I>CUJ</I>, March 1993 and "Inheritance, Part 2," <I>CUJ</I>, May 1993). I will explain virtual functions, and these extensions, in future columns.<P>
<h4>Reference</FONT></h4></P>
Ellis, Margaret A. and Stroustrup, Bjarne. 1990. <I>The Annotated</I> C++ <I>Reference Manual</I>. Reading, MA: Addison-Wesley. <P>

<h4><a href="../../../source/1993/jun93/saks.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
