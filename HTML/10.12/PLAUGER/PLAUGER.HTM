


<HTML>
<HEAD>

<TITLE>December 1992/Standard C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Standard C<A name="02B2_0138"><A name="02B2_0138"></font></h2><P>
<h3 align="center"><A name="02B2_0000"><A name="02B2_0000">Searching Strings</h3><P>
<h3 align="center"><font color="#800000">P.J. Plauger</font></h3><hr><blockquote><P>
<P><i><A name="02B2_0000"><A name="02B2_0000">P.J. Plauger editor of The C User Journal. He is secretary of the ANSI C standards committee, X3J11, and convenor of the ISO C standards committee, WG14. His latest books are The Standard C Library, published by Prentice-Hall, and ANSI and ISO Standard C &lt;with Jim Brodie), published by Microsoft Press. You can reach him at pjp@lauger.com,</i></P><P>
<h4><FONT COLOR="#000080"><A name="02B2_0139">Introduction<A name="02B2_0139"></FONT></h4></P>
For the last two months, I have been discussing the header <I>&lt;string.h&gt;</I>. (See <I>Standard C, CUJ</I> Oct. and Nov. 1992.) So far, I have discussed the functions that copy, concatenate, and compare strings (plus a few others). This month, I discuss the last or the functions declared in <I>&lt;string.h&gt;</I> &#151; those that help you search strings in various ways.<P>
These functions are powerful and widely used. They are probably more widely used than the functions that concatenate and copy strings. You may have trouble guessing the name of the search function you need in the Stand- ard C library, but it is probably there. At least you can usually find a search function that comes close enough to meet your needs.<P>
<h4><FONT COLOR="#000080"><A name="02B2_013A">What the C Standard Says<A name="02B2_013A"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_013B">7.11.5 Search functions<A name="02B2_013B"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_013C">7.11.5.1 The <B><I>memchr</I></B> function<A name="02B2_013C"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_013D">Synopsis<A name="02B2_013D"></FONT></h4></P>
<pre>#include &lt;string.h&gt;
void *memchr(const void *s, int c, size_t n);</pre>
<h4><FONT COLOR="#000080"><A name="02B2_013E">Description<A name="02B2_013E"></FONT></h4></P>
The <I>memchr</I> function locates the first occurrence of <I>c</I> (converted to an <I>unsigned char</I>) in the initial <I>n</I> characters (each interpreted as <I>unsigned</I> char) of the object pointed to by <I>s</I>.<P>
<h4><FONT COLOR="#000080"><A name="02B2_013F">Returns<A name="02B2_013F"></FONT></h4></P>
The <I>memchr</I> function returns a pointer to the located character, or a null pointer if the character does not occur in the object.<P>
<h4><FONT COLOR="#000080"><A name="02B2_0140">7.11.5.2 The <B><I>strchr</I></B> function<A name="02B2_0140"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_0141">Synopsis<A name="02B2_0141"></FONT></h4></P>
<pre>#include &lt;string.h&gt;
char *strchr(const char *s, int c);</pre>
<h4><FONT COLOR="#000080"><A name="02B2_0142">Description<A name="02B2_0142"></FONT></h4></P>
The <I>strchr</I> function locates the first occurrence of <I>c</I> (converted to a <I>char)</I> in the string pointed to by <I>s</I>. The terminating null character is considered to be part of the string.<P>
<h4><FONT COLOR="#000080"><A name="02B2_0143">Returns<A name="02B2_0143"></FONT></h4></P>
The <I>strchr</I> function returns a pointer to the located character, or a null pointer if the character does not occur in the string.<P>
<h4><FONT COLOR="#000080"><A name="02B2_0144">7.11.5.3 The <B><I>strcspn</I></B> function<A name="02B2_0144"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_0145">Synopsis<A name="02B2_0145"></FONT></h4></P>
<pre>#include &lt;string.h&gt;
size_t strcspn(const char *s1, const char *s2);</pre>
<h4><FONT COLOR="#000080"><A name="02B2_0146">Description<A name="02B2_0146"></FONT></h4></P>
The <I>strcspn</I> function computes the length of the maximum initial segment of the string pointed to by <I>s1</I> which consists entirely of characters <I>not</I> from the string pointed to by <I>s2</I>.<P>
<h4><FONT COLOR="#000080"><A name="02B2_0147">Returns<A name="02B2_0147"></FONT></h4></P>
The <I>strcspn</I> function returns the length of the segment.<P>
<h4><FONT COLOR="#000080"><A name="02B2_0148">7.11.5.4 The <B><I>strpbrk</I></B> function<A name="02B2_0148"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_0149">Synopsis<A name="02B2_0149"></FONT></h4></P>
<pre>#include &lt;string.h&gt;
char *strpbrk(const char *s1, const char *s2);</pre>
<h4><FONT COLOR="#000080"><A name="02B2_014A">Description<A name="02B2_014A"></FONT></h4></P>
The <I>strpbrk</I> function locates the first occurrence in the string pointed to by <I>s1</I> of any character from the string pointed to by <I>s2</I>.<P>
<h4><FONT COLOR="#000080"><A name="02B2_014B">Returns<A name="02B2_014B"></FONT></h4></P>
The <I>strpbrk</I> function returns a pointer to the character, or a null pointer if no character from<I> s2 </I>occurs in <I>s1</I>.<P>
<h4><FONT COLOR="#000080"><A name="02B2_014C">7.11.5.5 The <B><I>strrchr</I></B> function<A name="02B2_014C"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_014D">Synopsis<A name="02B2_014D"></FONT></h4></P>
<pre>#include &lt;string.h&gt;
char *strrchr(const char *s, int c);</pre>
<h4><FONT COLOR="#000080"><A name="02B2_014E">Description<A name="02B2_014E"></FONT></h4></P>
The <I>strrchr</I> function locates the last occurrence of <I>c</I> (converted to a <I>char</I>) in the string pointed to by <I>s</I>. The terminating null character is considered to be part of the string.<P>
<h4><FONT COLOR="#000080"><A name="02B2_014F">Returns<A name="02B2_014F"></FONT></h4></P>
The <I>strrchr</I> function returns a pointer to the character, or a null pointer if <I>c</I> does not occur in the string.<P>
<h4><FONT COLOR="#000080"><A name="02B2_0150">7.11.5.6 The <B><I>strspn</I></B> function<A name="02B2_0150"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_0151">Synopsis<A name="02B2_0151"></FONT></h4></P>
<pre>#include &lt;string.h&gt;
size_t strspn(const char *s1, const char *s2);</pre>
<h4><FONT COLOR="#000080"><A name="02B2_0152">Description<A name="02B2_0152"></FONT></h4></P>
The <I>strspn</I> function computes the length of the maximum initial segment of the string pointed to by <I>s1</I> which consists entirely of characters from the string pointed to by <I>s2</I>.<P>
<h4><FONT COLOR="#000080"><A name="02B2_0153">Returns<A name="02B2_0153"></FONT></h4></P>
The <I>strspn</I> function returns the length of the segment.<P>
<h4><FONT COLOR="#000080"><A name="02B2_0154">7.11.5.7 The <B><I>strstr</I></B> function<A name="02B2_0154"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_0155">Synopsis<A name="02B2_0155"></FONT></h4></P>
<pre>#include &lt;string.h&gt;
char *strstr(const char *s1, const char *s2);</pre>
<h4><FONT COLOR="#000080"><A name="02B2_0156">Description<A name="02B2_0156"></FONT></h4></P>
The <I>strstr</I> function locates the first occurrence in the string pointed to by <I>s1</I> of the sequence of characters (excluding the terminating null character) in the string pointed to by <I>s2.</I><P>
<h4><FONT COLOR="#000080"><A name="02B2_0157">Returns<A name="02B2_0157"></FONT></h4></P>
<I>The strstr</I> function returns a pointer to the located string, or a null pointer if the string is not found. If <I>s2</I> points to a string with zero length, the function returns <I>s1</I>.<P>
<h4><FONT COLOR="#000080"><A name="02B2_0158">7.11.5.8 The <B><I>strtok</I></B> function<A name="02B2_0158"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02B2_0159">Synopsis<A name="02B2_0159"></FONT></h4></P>
<pre>#include &lt;string.h&gt;
char *strtok(char *s1, const char *s2);</pre>
<h4><FONT COLOR="#000080"><A name="02B2_015A">Description<A name="02B2_015A"></FONT></h4></P>
A sequence of calls to the <I>strtok</I> function breaks the string pointed to by <I>s1</I> into a sequence of tokens, each of which is delimited by a character from the string pointed to by <I>s2</I>. The first call in the sequence has <I>s1</I> as its first argument, and is followed by calls with a null pointer as their first argument. The separator string pointed to by <I>s2</I> may be different from call to call.<P>
The first call in the sequence searches the string pointed to by <I>s1</I> for the first character that is <I>not</I> contained in the current separator string pointed to by <I>s2</I>. If no such character is found, then there are no tokens in the string pointed to by <I>s1</I> and the <I>strtok</I> function returns a null pointer. If such a character is found, it is the start of the first token.<P>
The <I>strtok</I> function then searches from there for a character that <I>is</I> contained in the current separator string. If no such character is found, the current token extends to the end of the string pointed to by <I>s1</I>, and subsequent searches for a token will return a null pointer. If such a character is found, it is overwritten by a null character, which terminates the current token. The <I>strtok</I> function saves a pointer to the following character, from which the next search for a token will start.<P>
Each subsequent call, with a null pointer as the value of the first argument, starts searching from the saved pointer and behaves as described above.<P>
The implementation shall behave as if no library function calls the <I>strtok</I> function.<P>
<h4><FONT COLOR="#000080"><A name="02B2_015B">Returns<A name="02B2_015B"></FONT></h4></P>
The <I>strtok</I> function returns a pointer to the first character of a token, or a null pointer if there is no token.<P>
<h4><FONT COLOR="#000080"><A name="02B2_015C">Example<A name="02B2_015C"></FONT></h4></P>
<pre>#include &lt;string.h&gt;
static char str[] = "?a???b,,,#c";
char *t;

t = strtok(str, "?");   /* t points to the token "a" */
t = strtok(NULL, ",");  /* t points to the token "??b" */
t = strtok(NULL, "#,"); /* t points to the token "c" */
t = strtok(NULL, "?");  /* t is a null pointer */</pre>
<h4><FONT COLOR="#000080"><A name="02B2_015D">Using the Search Functions<A name="02B2_015D"></FONT></h4></P>
<I>memchr</I> &#151; Use this function to locate the first occurrence (the one having the lowest subscript) of a character in a character sequence of known length. The function type casts the first (string pointer) argument to <I>pointer to unsigned char</I>. It also type casts the second (search character) argument to <I>unsigned char</I>. That ensures that an argument expression of any character type behaves sensibly and predictably. A search failure returns a null pointer, however. Be sure to test the return value before you try to use it to access storage. Also note that the return value has type <I>pointer to void</I>. You can assign the value to a character pointer but you can't use it to access storage unless you first type cast it to some character pointer type.<P>
<I>strchr</I> &#151; Use this function to locate the first occurrence (the one having the lowest subscript) of a character in a null-terminated string. The function type casts the second (search character) argument to <I>char</I>. That ensures that an argument expression of any character type behaves sensibly and predictably. A search failure returns a null pointer, however. Be sure to test the return value before you try to use it to access storage. Note that the call <I>strchr(s, '\0')</I> returns a pointer to the terminating null. See also <I>strcspn, strpbrk</I>, and <I>strrchr</I>, described below.<P>
<I>strcspn</I> &#151; You can think of <I>strcspn</I> as a companion to <I>strchr</I> that matches any of a set of characters instead of just one. That makes it similar to <I>strpbrk</I> as well. Note, however, that <I>strcspn</I> returns an <I>index</I> into the string instead of a pointer to an element. If it finds no match, it returns the index of the terminating null instead of a null pointer. Thus, you may find that the call <I>strcspn(s, "a")</I>, for example, is more convenient than either <I>strchr(s, 'a') or strpbrk(s, "a")</I>.<P>
<I>strpbrk</I> &#151; You can think of <I>strpbrk</I> as a companion to <I>strchr</I> that matches any of a set of characters instead of just one. That makes it similar to <I>strcspn</I> as well. Note, however, that <I>strcspn</I> returns an <I>index</I> into the string instead of a pointer to an element. If it finds no match, it returns the index of the terminating null instead of a null pointer. Thus, you may find that the call <I>strcspn(s, "abc")</I>, for example, is more convenient than <I>strpbrk(s, "abc")</I>.<P>
<I>strrchr</I> &#151; Use this function to locate the last occurrence (the one having the highest subscript) of a character in a null-terminated string. The function type casts the second (search character) argument to <I>char</I>. That ensures that an argument expression of any character type behaves sensibly and predictably. A search failure returns a null pointer, however. Be sure to test the return value before you try to use it to access storage. Note that the call <I>strrchr(s,  '\0')</I> returns a pointer to the terminating null. See also <I>strchr, strcspn</I>, and <I>strpbrk</I>, described above.<P>
<I>strspn</I> &#151; You can think of <I>strspn</I> as the complement to <I>strcspn</I>. It searches for a character that matches <I>none</I> of the elements in a set of characters instead of <I>any</I> one of them. <I>strspn</I> also returns an index into the string or, if it finds no match, the index of the terminating null. Thus, the call <I>strspn(s, "abc")</I>, for example, finds the longest possible <I>span</I> of characters from the set <I>"abc"</I>.<P>
<I>strstr</I> &#151; You write <I>strstr(s1, s2)</I> to locate the first occurrence of the substring <I>s2</I> in the string <I>s1</I>. A successful search returns a pointer to the <I>start</I> of the substring within <I>s1</I>. Note that a search failure returns a null pointer.<P>
<I>strtok</I> &#151; This is an intricate function designed to help you parse a null-terminated string into tokens. You specify the set of <I>separator</I> characters. Sequences of one or more separators occur between tokens. Such sequences can also occur before the first token and after the last. <I>strtok</I> maintains an internal memory of where it left off parsing a string. Hence, you can process only one string at a time using <I>strtok</I>. Here, for example, is a code sequence that calls the function <I>word</I> for each "word" in the string <I>line</I>. The code sequence defines a word as the longest possible sequence of characters not containing "white-space" &#151; defined here as a space, horizontal tab, or newline:<P>
<pre>#include &lt;string.h&gt;
char *s;
for (s=line; (s=strtok(s," \t\n"))!=NULL;s=NULL)
   word(s);</pre>
The first call to <I>strtok</I> has a first argument that is not a null pointer. That starts the scan at the beginning of <I>line</I>. Subsequent calls replace this argument with <I>NULL</I> to continue the scan. If the return value on any call is not a null pointer, it points to a null-terminated string containing no separators. Note that <I>strtok</I> stores null characters in the string starting at <I>line</I> Be sure that this storage is writable and need not be preserved for future processing.<P>
You can specify a different set of separators on each call to <I>strtok</I> that processes a given string, by the way.<P>
<h4><FONT COLOR="#000080"><A name="02B2_015E">Implementing the Search Functions<A name="02B2_015E"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
shows the file <I>memchr.c</I>. The major concern of function <I>memchr</I> is to get various types right. You must assign both the pointer and the character arguments to dynamic data objects with different types. That lets you compare the array elements as type <I>unsigned char</I> correctly and efficiently. I wrote the <I>(void *)</I> type cast in the <I>return</I> expression for clarity, not out of necessity.<P>
<A href="list2.htm">Listing 2</a>
shows the file <I>strchr.c</I>. The function <I>strchr</I> is the simplest of these functions. It is the obvious analog of <I>memchr</I>.<P>
<A href="list3.htm">Listing 3</a>, <A href="list4.htm">Listing 4</a>, and
<A href="list5.htm">Listing 5</a>
show the files <I>strcspn.c</I>, <I>strpbrk.c</I>, and <I>strspn.c</I>, respectively. Both <I>strcspn</I> and <I>strpbrk</I> perform the same function. Only the return values differ. The function <I>strspn</I> is the complement of <I>strcspn</I>.<P>
<A href="list6.htm">Listing 6</a>
shows the file <I>strrchr.c</I>. The function <I>strrchr</I> is a useful complement to <I>strchr</I>. It memorizes the pointer to the rightmost occurrence (if any) in <I>sc</I>. The type cast in the <I>return</I> statement is necessary, in this case, because <I>sc</I> points to a constant type.<P>
<A href="list7.htm">Listing 7</a>
shows the file <I>strstr.c</I>. The function <I>strstr</I> calls <I>strchr</I> to find the first character of the string <I>s2</I> within the string <I>s1</I>. Only then does it tool up to check whether the rest of <I>s2</I> matches a substring in <I>s1</I>. The function treats an empty string <I>s2</I> as a special case. It matches the implicit empty string at the start of <I>s1</I>.<P>
<A href="list8.htm">Listing 8</a>
shows the file <I>strtok.c</I>. The function <I>strtok</I> is the last and the messiest of the seven string-scanning functions. It doesn't look bad because it is written here in terms of <I>strspn</I> and <I>strpbrk</I>. It must contend, however, with writable static storage and multiple calls to process the same string. It is probably at least as hard to use correctly as to write correctly. When <I>strtok</I> is not actively scanning an argument string, it points at an empty string. That prevents at least some improper calls from causing the function to make invalid storage accesses. (The function is still at risk if storage is freed for a string that it is scanning.)<P>
<I>This article is excerpted in part from P.J. Plauger</I>, The Standard C Library, <I>(Englewood Cliffs, N.J.: Prentice-Hall, 1992)</I>.<P>

<h4><a href="../../../source/1992/dec92/plauger.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
