


<HTML>
<HEAD>

<TITLE>December 1992/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="02C4_0147"><A name="02C4_0147"></font></h2><hr>
<BLOCKQUOTE>
<A name="02C4_0000"><A name="02C4_0000">Dear Dr. Plauger,<P>
I must first congratulate the CUJ for being a source of ideas, questions, and answers that have been especially useful in the years leading up to standardization of the C language. I have found your recent book "The Standard C Library" very useful in exposing some of the traps in practical library construction with C.<P>
I have a question that deals with a part of the language of which I am a somewhat unsure. The following paragraphs contain the question and some justification for not treating the question as C esoterica.<P>
While leafing through a text on Standard C I was surprised to find in a section on incomplete types that there seemed to be an obligation to complete an incomplete type in the same scope as that type's introduction. Is this the case for struct and union types whose sole use is in the definition of a pointer <I>struct tag*</I>?<P>
The reason behind this question is that a pointer to an incomplete <I>struct</I> type being a complete type implements an opaque <I>private</I> type very nicely. All compilers I have used are quite happy with pointers to incomplete <I>struct</I> types which are never completed and give useful diagnostics when trying to dereference such pointers or assign between pointers of different incomplete <I>struct</I> types.<P>
In various articles <I>void*</I> pointers have been used to implement opaque types &#151; unfortunately, while <I>void*</I> pointers hide the structure of the storage they reference, all <I>void*</I> pointers are assignment compatible with all other non function pointers, giving no type safety at all (e.g., to a compiler <I>stdin</I> would be an acceptable <I>LIST</I> object).<P>
I have found the practical rewards of not exporting implementation details have included: one header file serving a number of tailored implementations stored in separate libraries that can be bound at link time and the ability to alter the representation of an implementation in response to changes in storage requirements, etc. There are costs in efficiency but these can usually be recouped in the tuning phase when the implementation can be exported and a selection of access functions converted to macros inlined.<P>
Yours sincerely<P>
J Sainsbury<br>
1 Meranti St<br>
Crestmead Q4132<br>
Australia<br>
+61 7 200 9007<P>
<I>You don't necessarily have to complete an incomplete type. If you do, however, you must do so in the same scope. </I>&#151;<I> pjp</I><P>
Dear Mr. Williams,<P>
A few days ago I read your article "A Console Stream Class for Borland C++" in <I>The C Users Journal</I>.<P>
The problem you commented on in it is interesting to me because a couple of months ago I had to solve the same problem &#151; using both stream I/O and Borland's console I/O. After reading through your article I found out that I had used the same approach but slightly different implementation.<P>
My implementation of a console-oriented stream-output class is shown in Listing 1. [Listings omitted due to lack of room. You can get them with the monthly code disk for this issue &#151; pjp] I have not defined the <I>do_sputn</I> method but defined the constructor to make the <I>ConioBuffer</I> class unbuffered. In this case, the overflow method called for each character. The defined method overflow prints the character using console-oriented function putch.<P>
Listing 2 [also omitted &#151; pjp] shows the approach I have used to interface the stream output to a window class.<P>
I would be grateful to have your comments about this as well as about other problems concerning programming in C++. In general, it is difficult for me to have more information and to discuss such problems in this country.<P>
Yours sincerely,<P>
Stefan Ganev (Mr)<br>
PO Box 560,<br>
Bourgas 8001,<br>
Bulgaria<P>
Al Williams responds:<P>
<I>Thanks for your interest in the console stream class. You are correct</I> &#151; <I>as usual there is more than one way to solve this problem. Your method is perfectly correct. There is at least one more, equally valid approach. You don't have to define an overflow method. The default method simply calls </I>do_sputn<I> for each character.</I><P>
<I>I elected to write both functions so I could illustrate their use. In practice, many streams do need buffering</I> &#151; <I>I wanted to show the most illustrative case.</I><P>
<I>You might be interested to know, more about the console stream class will appear in a future C Users Journal (probably in the November issue). This time, I'll add manipulators to the class so you can write </I><I>things like: cout&lt; &lt;go_xy(1,1)&lt; "Hello";.</I><P>
<I>Again, thanks for your interest, and good luck in your programming endeavors.</I><P>
<I>Regards,</I><P>
Al Williams<br>
310 Ivy Glen Court<br>
League City, TX 77573<P>
Dear Mr. Plauger,<P>
I'm confused by the description of va_list in your book <I>The Standard C Library</I>.<P>
Under arg.h (pg. 210) there is a warning about using the same <I>va_list ap</I> in two called functions, but under .h (pg. 259), the example for vfprintf() does exactly that.<P>
Is the example in error? Could you provide an example of when special care for the <I>va_list ap</I> is required?<P>
Please feel free to use my question for the C Users' Journal, if you feel it appropriate.<P>
Thank you for your help,<P>
Brett Wuth<br>
3510 44St SW<br>
Calgary<br>
Alberta<br>
T3E 3R9<br>
CANADA<br>
Tel: +1 403 242-0848<P>
<I>In this particular case, the value of ap is reinitialized by invoking the macro </I>va_start<I> between calls. That's why it works properly. Otherwise, you're correct to be concerned. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
I hope this is your prefered e-mail address for this type of question. In the test program <I>TSTDIO2.c</I> from your book, <I>The Standard C Library</I>, I think I have found a bug.<P>
Is it not necessary to add the line as I have, to make sure that the temporary file is closed, and thus renamable?<P>
Thanks for your help,<P>
Brett Wuth<br>
3510 44St SW<br>
Calgary<br>
Alberta<br>
T3E 3R9<br>
CANADA<br>
Tel: +1 403 242-0848<P>
<I>You're right in the general case. It turns out that UNIX and DOS let you get away with this, which explains my blind spot. Thanks for the fix (included on the monthly code disk for this issue). </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
I enjoyed reading the article by William Smith in the May 1992 issue entitled "Number Crunching in C." I would like to make three comments on the article.<P>
First, the main technique that Mr. Smith uses to speed up his matrix inversion (storing pointers to rows of the matrix to allow swapping of pointers instead of swapping of actual rows) can be implemented in many languages. In FORTRAN, the rows of matrix coefficients could be stored in a singly-dimensioned vector, with an integer vector storing offsets (pointers) to the coefficient data.<P>
Secondly, the timing ratios from the examples presented would have been more informative if the runtimes for matrices of dimension <I>nxn</I> requiring 0 pivots and <I>n</I> pivots had been compared. This would give a better indication of the resources used by swapping rows. I also would have like to have seen timing ratios for matrices up 100X100.<P>
Thirdly, it would be interesting to compare run times for a FORTRAN program using the C-pointer technique to the C program.<P>
Sincerely,<P>
Ron Bondy<br>
Simulation Sciences Inc.<br>
3033 South Parker Road<br>
4th Floor<br>
Aurora, CO 80014<P>
William Smith responds:<P>
<I>Thank you for your comments. The difference in speed between the FORTRAN-style C and the optimized C is mainly due to the replacement of many individual element exchanges with a single pointer exchange. This reduces the amount of physical memory that must be copied. As the matrix size increases this difference is significant. I have found that I cannot count on a compiler to do this optimization. Elimination of indirection is a minor optimization compared to the elimination of element exchange operations. I try to depend more on the optimizer between my ears than the optimization capabilities of the particular compiler I happen to be using. The article was meant to inspire and encourage the use of C-specific language features when translating to or improving numerical analysis code in C.</I><P>
<I>Sincerely,</I><P>
W. Smith<br>
Engineering Manager<br>
Montana Software<br>
P.O. Box 663<br>
Bozeman, MT 59771-0663<br>
(406) 586-2984<P>
Dear Mr. Plauger,<P>
I am writing in response to letters in the March and July <I>CUJ</I>, regarding single-character keyboard entry on a VAX. I too experienced this problem. After trying <I>getch</I> and several functions in the curses library, I finally discovered the <I>SMG$</I> library functions. The code fragments below may help someone avoid this pain in the future.<P>
To initialize the keyboard,<P>
<pre>#include &lt;smgdef.h&gt;

int kb_id;

SMG$CREATE_VIRTUAL_KEYBOARD (&amp;kb_id);</pre>
And to read one character,<P>
<pre>int getraw(void)
   {
   short termcode;

   SMG$READ_KEYSTROKE(&amp;kb_id, &amp;termcode)
   return (termcode);
   }</pre>
This function returns special keys (such as the cursor keys, PgUp, Delete, etc.) as values 256 and above. This is a terminal-independent way of reading special keys on a VAX.<P>
In my personal opinion, DEC doesn't believe in C. Their C libraries are woefully inadequate. One indicator of this is the fact that it <I>should</I> be possible to read a single character using curses functions, but it <I>is not</I> possible (as far as I have determined). Many other important operating-system functions cannot be called directly from C programs; the programmer is forced to wave wands, sacrifice small animals, and convert arguments and return values into arcane structures, in order to placate the gods of VMS. Luckily for us, DEC documentation devotes most of a full page to explaining the necessary conversions.<P>
I have enclosed the source code for a program I wrote for VMS, called BROW. (Available on the code disk only.) It is a file-browser modeled after Vernon D. Buerg's very popular LIST utility. BROW uses the SMG$ library to read the keyboard and paint the screen. I am releasing it to CUJ for publication or any other use.<P>
Sincerely,<P>
Robert D. Bybee<br>
5011 Brougham Court<br>
Stone Mountain, GA 30087<br>
(404) 498-3556<P>
<I>I don't know whether DEC believes in C, but I know they believe in a variety of programming languages. I too have found myself doing extra work to convince VMS to do things from a C point of view. </I>&#151;<I> pjp</I><P>
Dear PJP:<P>
On page 59 inn the June issue of <I>The C Users Journal</I> you commented that the X3J11 considered defining a set of screen-control functions. I happen to think that such a thing is an excellent idea. If one does not try to support everybody with such a set of functions I think it can be carried off successfully.<P>
I would propose to support those who have a need to maintain the same program on different machines with roughly the same interface for all. Since terminals differ a lot in how they handle user interaction I would propose to use forms as the common way of handling non-stream terminal I/O. I would start out with a simplified version of the GET/READ model found in xBase languages such as FoxPro 2, dBase IV and Clipper plus some cursor movements. Portability would only be assured for the simplest use of the forms. The cursor movement would only be portable when done in "batch mode". I think it would be possible to fit in windowing without stretching things too far.<P>
One would need to define a set of core facilities that will always be present and then to allow the program to inquire about the optional facilities. Currently I favour the set of functions to consist of one function represented by the following prototype:<P>
<pre>conStat conio(consoleDescriptor conD, conCmd cmd, conPar *params)</pre>
There should be no problem in using the API to support hardcopy devices. People who want complete control should not try to use this facility. (You can ask for a scroll bar, but you are not likely to be able to specify that it should be a Motif style scroll bar.)<P>
In order to avoid having to support all sorts of devices in one library it would be convenient to use the X Window model and create a protocol for communication between application and the program that controls the screen. (I call that program the termio manager.) The protocol would be a variable resolution sort of thing. The termio manager will only tell the application things it needs to know. (You tell the termio manager what you want to know.) This reduces communication overhead. If the protocol were done right one can assume that other languages/tools/applications would use it. By the way, the termio manager is not supposed to be a window manager, it will run under and use the window manager.<P>
On an IBM PC or compatible it would mean that if the termio server is implemented as an MS-DOS driver it would allow an MS-DOS program to look like a native MS Windows/ Presentation manager application when using it from an GUI (if a GUI version of the termio manager was available).<P>
It would also be possible for many programs to work together as a whole. For example, when replacing a built-in editor in a windowing product one could expect the editor to fit in. There are a lot of things that need to be put down in writing until this becomes the preferred way of doing things.<P>
Much of this probably intrudes well into what the Object Management Group considers their domain. Especially the bit where the termio manager request a computer to start up a specific program with itself controlling the display.<P>
I enjoy reading your columns. It is quite strange to read about an American who happens to be aware of other character sets than seven-bit ASCII.<P>
Greetings,<P>
Tarjei T. Jensen<br>
tarjeij@ulrik.uio.no<P>
<I>Nice to hear from Norway. Your proposal for a screen output standard shows how many details need to be worked out. Still, it's basically a good idea. By the time the C Standard is ready for revision, we may all have a better idea how to add screen support. Sorry I had to omit from your letter your proposed extensions to C. We didn't have the space. </I>&#151;<I> pjp</I><P>

<h4><a href="../../../source/1992/dec92/letters.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
