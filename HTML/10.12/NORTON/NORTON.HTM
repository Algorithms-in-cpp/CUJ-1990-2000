


<HTML>
<HEAD>

<TITLE>December 1992/Windows Device Drivers</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Device Control</FONT></H2>

<hr><h2 align="center"><font color="#800000">Windows Device Drivers<A name="029E_012E"><A name="029E_012E"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="029E_0000"><A name="029E_0000">Daniel A. Norton</font></h3><hr><blockquote><P>
<P><i><A name="029E_0000"><A name="029E_0000">Daniel A. Norton has translated the most technical aspects of Windows programming into meaningful explanations in his new book, Writing Windows Device Drivers. He is the principal consultant for Cherry Hill Software, a firm that helps companies enter into and become expert in all aspects of Windows and Windows NT development. You can contact him through CompuServe at 76050,2204.</i></P><P>
Device drivers are typically the most critical part of computer software. Ironically, they are also the most arcane and hidden part of software development. Device drivers for Microsoft Windows are no exception. If you have ever written a normal Windows application, you know that it requires a number of hidden techniques in order to get an application working reliably. As a subset of Windows applications, Windows device drivers follow this rule closely. In this article, I illustrate a working device driver that accesses I/O ports and processes interrupts, and a virtual device driver (VxD) that simulates hardware. I'll presume that you have a basic understanding of Windows programming including dynamic link libraries (DLLs).<P>
<h4><FONT COLOR="#000080"><A name="029E_012F">The Device<A name="029E_012F"></FONT></h4></P>
The example device is not some piece of hardware that I developed to illustrate how to write a Windows device driver. Rather, it is a virtual device implemented entirely in software. The example code only works with the virtual device I have defined when running Windows in 386 Enhanced mode and while my virtual device driver (VxD) is installed. I will describe the source code for this device in more detail later. For now you need to know that the device has two ports: a status port and a control port, both at the same address. <A href="fig1.htm">Figure 1</a>
illustrates the bits used in the status port. Bit 2 indicates that a device error has occurred, bit 1 indicates that an interrupt request is pending, and bit 0 indicates that the device is busy. Bit 7 indicates that the device is present. The device always presents a zero bit here. If the device is not installed or is inaccessible, this bit will appear as a one.<P>
<A href="fig2.htm">Figure 2</a>
illustrates the bits used in the control port. Bit 1 indicates to the device that the CPU is finished processing an interrupt. Bit 0 indicates to the device that it can begin I/O processing. (For now, don't worry about what the device actually does. Instead, focus on how to write a device driver for such a device that provides hardware interrupts.)<P>
<h4><FONT COLOR="#000080"><A name="029E_0130">An MS-DOS Device Driver<A name="029E_0130"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
shows <I>dostest.asm</I>, a normal MS-DOS device driver that talks to the device. Though simple and small it contains the salient components of a device driver that processes interrupts.<P>
The device driver starts by checking the high bit of the status port to confirm that the device is present. Next, it hooks the MS-DOS interrupt vector for interrupt 11. The driver saves the previous value stored in this vector so that it can replace the value when the program exits.<P>
The device driver then prompts the user to <I>Start</I> or <I>Quit</I>. If the user presses <I>S</I>, the program begins I/O transfer. When the user presses <I>Q</I>, the program disables the device, restores the interrupt vector, and exits.<P>
To start I/O, the MS-DOS driver first unmasks the programmable interrupt controller (PIC) for the device's interrupt level (11 in this example). Next, the driver starts device I/O by writing a 1 into bit 0 of the device control port. Since interrupts are enabled, the interrupt service routine (ISR) will take control when the device interrupts.<P>
When the device interrupts, the ISR first acknowledges the interrupt by sending an EOI to the device (writing a 1 to bit 1 of the device control port) and to the PIC. If the program is in the process of exiting, the ISR is done. Otherwise, the ISR re- initiates I/O transfer by writing a 1 into bit 0 of the device control port. Thus, this interrupt service routine restarts I/O whenever an interrupt occurs so that the device is continuously performing input/output. In addition to continuing I/O, the ISR increments a count (<I>dwCount1</I>) each time it processes an interrupt.<P>
While I/O is in progress, the program watches the interrupt count, displays a dot (".") for each completed I/O transfer, and continues to scan the keyboard to see if the user wants to stop transfer.<P>
To end the program, the user presses <I>Q.</I> The program sets a flag that tells the ISR to stop processing. Once I/O stops, the program masks the interrupt level at the PIC and restores the interrupt vector.<P>
<h4><FONT COLOR="#000080"><A name="029E_0131">A Windows Device Driver<A name="029E_0131"></FONT></h4></P>
The extremely trivial MS-DOS device driver just described is substantially more difficult to implement in Windows. When writing a Windows device driver that handles interrupts, you need to use a different architecture than used with an MS-DOS driver. Specifically, you need to isolate the interrupt handling component from the application component. Instead of a single program handling both the ISR and the user interface as in MS-DOS, in Windows you must divide these functions up into separate program modules called a Dynamic Link Library (DLL) and an Application Program Interface (API).<P>
<h4><FONT COLOR="#000080"><A name="029E_0132">The Driver DLL<B><A name="029E_0132"></B></FONT></h4></P>
When writing Windows applications, you normally only concern yourself with two types of segments in a program module: <I>moveable</I> and <I>discardable</I>. Program data segments are moveable, that is, their linear addresses in memory may change as the Windows memory manager needs to organize memory. The selector and offset used to access a particular memory item remain fixed, but underneath the selector/offset scheme, Windows can move the actual data around in linear memory.<P>
Program-code segments are also moveable, but have the additional attribute of being discardable. Their contents may be discarded entirely and, when needed, read back from disk, because you cannot write to and/or modify the information in a program-code segment. If a segment happens to be discarded when called from elsewhere in a Windows program, the Windows memory manager will automatically access the disk and read in the (formerly) discarded segment.<P>
So how does this affect the code for an ISR? Since an interrupt can occur at any time, if you discarded the ISR code, you might have trouble loading it back in memory when an interrupt occurs. So instead, you declare the segment as <I>FIXED</I>, rather than <I>MOVEABLE</I> or <I>DISCARDABLE</I>. A <I>FIXED</I> segment will remain in a single location in linear memory and will not be discarded, even if it contains code. That way, if an interrupt occurs, the code will be available and ready to run.<P>
One not-so-well known fact about <I>FIXED</I> segments, however, is that Windows only honors <I>FIXED</I> segments that are declared in a DLL. A <I>FIXED</I> segment in a normal program module is treated as <I>MOVEABLE</I>. Thus, Windows will not allow you to put the ISR in a normal program module. Instead you must put it in a DLL.<P>
<A href="list2.htm">Listing 2</a>
shows <I>bogusa.asm</I>, the assembler source code for a DLL that contains an ISR that will run in the Windows environment. The routine <I>IntSvcRtn</I> looks very much like its MS-DOS counterpart. However, instead of just incrementing a count variable, this ISR also posts a Windows message to a queue. To avoid overflowing the queue, it only posts the message when it increments the counter variable <I>wCount</I> from zero to one. The program relies on the higher-level Windows program to reset <I>wCount</I> to zero after it has processed a message.<P>
This seems simple at first glance, but hooking the interrupt under Windows is not nearly as simple as it is under MS-DOS.<P>
<h4><FONT COLOR="#000080"><A name="029E_0133">The Driver API<B><A name="029E_0133"></B></FONT></h4></P>
In addition to a separate program module for the ISR (in the form of a Windows DLL), you also need a program module for the user interface, called the API. <A href="list3.htm">Listing 3</a>
contains a sample API called <I>bogus.h</I>. It contains four entry points into the DLL.<P>
<I>BogusCheck</I> simply checks for the presence of a device. It returns <I>TRUE</I> if it detects the device hardware (bit 7 of the status port) or <I>FALSE</I> if not.<P>
<I>BogusStart</I> and <I>BogusStop</I> start and stop the device. In addition, <I>BogusStart</I> enables interrupts and hooks the hardware interrupt, and <I>BogusStop</I> disables device interrupts and restores the hardware interrupt.<P>
<I>BogusGetEvent</I> returns the number of interrupts processed since the device was first started or since the last call to <I>BogusGetEvent</I>. (<I>BogusGetEvent</I> zeros the interrupt count each time it is called.)<P>
<h4><FONT COLOR="#000080"><A name="029E_0134">Interrupts in Windows Standard Mode<A name="029E_0134"></FONT></h4></P>
When writing a driver that might run in Windows standard mode, you must consider the possibility that an interrupt might occur with the processor running in real mode. Even if you run only Windows applications and not MS-DOS applications, the processor frequently switches between real and protected modes. Because Windows 3.1 is not an operating system, but, rather, a user-interface environment, it relies on its operating system (namely MS-DOS) to perform a number of basic functions, including file I/O.<P>
Therefore, while a Windows application performs MS-DOS file I/O with the processor in real mode, a device can interrupt the CPU. By default, if a DLL has hooked an interrupt, Windows would switch the CPU back to protected mode to process the interrupt and &#151; once the ISR is finished &#151; would switch the CPU back to real mode to continue MS-DOS processing.<P>
Although less of a concern with an 80386 CPU, switching the processor from protected mode to real mode on an 80286 processor creates tremendous overhead, requiring a controlled reset of the CPU and taking on the order of milliseconds to complete. If you need faster average response times, you must keep the processor from switching to protected mode when it receives an interrupt while the processor is in real mode.<P>
Hooking the protected-mode interrupt vector from a Windows DLL is trivial as illustrated in the <I>SetPMVector</I> routine in <A href="list4.htm">Listing 4</a>
(<I>bogus.c</I>). You hook the vector in the same way that you would in MS-DOS &#151; by simply calling the MS-DOS <I>setvector</I> function. Unlike the call from MS-DOS, however, in Windows you pass a selector and offset instead of a segment and offset. The Windows kernel takes care of everything, so you don't need to be concerned with this anomoly. You pass a normal selector and offset (the natural <I>far</I> pointer for Windows) and not a segment and offset (the natural <I>far</I> pointer for MS-DOS).<P>
As just mentioned, however, hooking the protected-mode interrupt vector is not enough. You must also hook the real-mode interrupt vector, a not-so-trivial task.<P>
<h4><FONT COLOR="#000080"><A name="029E_0135">The MS-DOS Protected Mode Interface<B><A name="029E_0135"></B></FONT></h4></P>
In order to hook a real-mode vector from protected-mode Windows code, you need to work with the MS-DOS Protected Mode Interface (DPMI). (The current version of DPMI is level 1.0, but Windows only fully implements level 0.9. A few 1.0 functions are implemented in Windows 3.1)<P>
The function <I>DPMI_SetRMVector</I> calls DPMI to set a real-mode vector. As you can see, the DPMI interfaces via registers (<I>AX</I> always contains the function code) and <I>INT31h</I>. I've included a high-level interface to this and other DPMI functions (available on the code disk or the online sources only) so that you can access the DPMI functions from C, and to isolate the assembly-language code in case you should happen to be using something other than a Microsoft C Compiler.<P>
The function <I>DPMI_AllocateRMCallback</I> calls DPMI to allocate a <I>callback</I>, an address that can be called from real mode that will transfer control to protected-mode code. For example, an MS-DOS TSR can call code in a Windows DLL through a callback.<P>
<I>DPMI_AllocateRMCallback</I> accepts two parameters: the address of the protected-mode code that will be called back and a register structure that is updated when the actual callback is made, so that the protected-mode code can examine the contents of the real-mode registers at the time of the callback.<P>
<I>DPMI_FreeRMCallback</I> frees all of the structures that were allocated as a result of the call to <I>DPMI_AllocateRMCallback. DPMI_FreeRMCallback</I> must be called after you no longer need the callback.<P>
<h4><FONT COLOR="#000080"><A name="029E_0136">The Real-Mode ISR<A name="029E_0136"></FONT></h4></P>
Although I mentioned that it is best to provide a separate real-mode ISR, in this example I'm not doing that. Instead, I am providing you with the routines you would need to implement it yourself from C. In fact, this example hooks the real-mode interrupts only to switch the CPU to protected mode to process this interrupt. This is the default behavior of Windows when the real mode interrupts are not hooked at all, so I am illustrating a few gyrations that have no effect, beyond the exercise of seeing how it all works.<P>
Look at the code for <I>BogusStart</I>. Essentially, it works as it would in MS-DOS. It saves the old interrupt value, hooks in the current value, and starts the device up. Instead of hooking just the protected-mode vector, however, it hooks both realand protected-mode vectors. In hooking the real-mode vector, it calls <I>AllocIntReflector</I> to point the real-mode interrupt vector to a callback which simply calls the protected-mode ISR. <I>BogusStart</I> starts the device the same in protected mode as it does in real mode. It unmasks the IRQ for the PIC, and starts up the device by writing a 1 to the <I>START</I> bit of the device-control port. Once an application calls this routine, interrupts are processed and messages are posted according to the ISR.<P>
<I>BogusStop</I> is trivial and simply turns off the device and undoes the hooks set up by <I>BogusStart</I>. All that is left is an application program to show us I/O activity.<P>
<h4><FONT COLOR="#000080"><A name="029E_0137">The WINTEST Application<B><A name="029E_0137"></B></FONT></h4></P>
The application that shows I/O activity, <I>wintest.c</I> (<A href="list5.htm">Listing 5</a>)
, consists primarily of a non-modal dialog box that continuously shows the number of interrupts processed since the program started.<P>
<I>MainDlgProc</I> calls BogusStart during <I>WM_INITDIALOG</I> processing, passing the window handle of the dialog box as the parameter. The ISR posts messages to this handle when the interrupt count changes from zero to one.<P>
<I>MainDlgProc</I> keeps a running total count of interrupts in <I>wCountTotal</I>. Whenever the dialog receives a <I>WM_COMMAND </I>message with <I>wParam</I> equal to <I>IDM_BOGUSEVENT</I>, the routine updates the total count displayed in the dialog box. Note that although the ISR only posts a message when the count changes from zero to one, it is possible (and quite likely) that a number of interrupts may be processed before the <I>WM_COMMAND</I> message is actually passed to the dialog procedure. The method shown here, where the ISR only posts the message at the first transition and <I>BogusCheck</I> clears the count, ensures an accurate count of the number of interrupts even if, at the application level, you are unable to keep up with each interrupt as it occurs.<P>
When running this program, you can watch the count of interrupts in the dialog box increase steadily, indicating the number of I/O operations performed.<P>
<h4><FONT COLOR="#000080"><A name="029E_0138">The Virtual Device Driver<A name="029E_0138"></FONT></h4></P>
The file <I>vxd2.asm</I> (<A href="list6.htm">Listing 6</a>
and <A href="list7.htm">Listing 7</a>)
 is the source code to the bogus device driver. Note that to build this driver you need the Microsoft Windows Device Driver Kit (DDK) because the code is written for the 32-bit assembler provided in the DDK (<I>MASM5</I>). The resultant module can be linked only with a DDK linker (<I>LINK386</I>) and a post-linkage utility (<I>ADDHDR</I>). In addition, this source code relies on a number of include files that are only included in the DDK.<P>
Besides the obligatory include files, typical VxDs begin with a <I>Declare_Virtual_Device</I> macro invocation which creates a data block that describes the virtual driver to the Windows kernel. This data block, in fact, is the only symbol exported from a VxD. All other entry points are derived from the data contained within. Among other things, this macro declares the name of the device, its initialization pecking order, and its entry points. It is possible for a VxD to service requests from real- and protected-mode applications. The entry points for such services are declared by this macro, too.<P>
<h4><FONT COLOR="#000080"><A name="029E_0139">Device Control Events<A name="029E_0139"></FONT></h4></P>
As Windows progresses through its various stages, from Windows initialization, through VM initialization, and so-forth, every installed VxD is called repeatedly, once for each phase. <a href="tab1.htm">Table 1</a>
lists the phases of Windows and the major events for which each VxD is called.<P>
This example VxD only processes the <I>Device_Init</I> control. It does this one to acquire and "virtualize" the I/O port and interrupt level 11. Normally a VxD would virtualize I/O ports and an interrupt corresponding to physical hardware. But in this case, the VxD can and does virtualize a port and interrupt that has no corresponding hardware attached.<P>
You call <I>Install_IO_Handler</I> to virtualize a single I/O port. Subsequently, whenever the specified I/O port is accessed from a VM, the Windows Virtual Machine Manager (VMM) calls back the VxD to allow the VxD to simulate the I/O access.<P>
You call <I>VPICD_Virtualize_IRQ</I> to virtualize the interrupt level. By doing this, you can simulate a hardware interrupt (IRQ 11 specifically) into a virtual machine.<P>
<h4><FONT COLOR="#000080"><A name="029E_013A">The "Bogus" Device<A name="029E_013A"></FONT></h4></P>
When the device's I/O port (141) is accessed by a VM (either in real or protected mode), the VM calls the VxD <I>Port_IO_Callback</I> routine (see <A href="list6.htm">Listing 6</a>)
. In that routine, the <I>Dispatch</I>_<I>Byte</I>_<I>IO</I> routine simplifies the many possible types of I/O access (<I>byte, word, dword, string</I>, etc.) into two, byte input and byte output.<P>
With this example device, byte input represents a read from the device status register. It simply returns a variable that it stores in memory.<P>
Byte output is a little more complicated, since it represents the actual activity of the device. Starting the device also starts a timer that calls back (to <I>TimeoutProc</I>) in 1/10 second and sets the BUSY status. If the output indicates an interrupt acknowledgement, it clears the virtual interrupt request by calling <I>VPICD_Clear_Int_Request</I> and clears the status in the status register.<P>
The callback to <I>TimeoutProc</I> represents the end of a device I/O operation at which time it simulates a hardware interrupt into the VM by calling <I>VPICD_Set_Int_Request</I> and clearing the device busy status. The device driver in <I>dostest</I> and <I>wintest</I> would typically process the interrupt by acknowledging it (sending EOI) and restarting the process all over again.<P>
Note the procedures <I>VxD2_VInt_Proc</I> and <I>VxD2_IRET_Proc</I>. These two procedures are referenced in the structure that was passed to <I>VPICD_Virtualize_IRQ</I>. They are called at the beginning and end of interrupt virtualization into a VM. All that they do is raise and restore the priority of the VM. This raises the priority of a VM that is processing this interrupt temporarily. In this way a VxD can control a VM's priority when it deems appropriate. (You generally want interrupt service in any VM to take priority over normal processing in other VMs.)<P>
<h4><FONT COLOR="#000080"><A name="029E_013B">Installing the VxD<A name="029E_013B"></FONT></h4></P>
Finally, once the VxD is built, before accessing it from a Windows program, you must add it as a <I>device=</I> line in the <I>[386Enh]</I> section of <I>system.ini</I>. Windows must be restarted to enable the VxD and the virtual device. After this, you can run and test the <I>wintest</I> and <I>dostest</I> applications.<P>
<h4><FONT COLOR="#000080"><A name="029E_013C">It Gets More Complicated<A name="029E_013C"></FONT></h4></P>
As complicated as Windows device drivers may now seem, there is a tremendous amount of power offered by normal and virtual Windows device drivers. To put the complexity of VxDs into perspective, however, consider how much more complex they must be on a MIPS machine running Windows NT and 80x86 emulator code to allow a MS-DOS virtual machine to run. But that's a topic for another article.<P>

<h4><a href="../../../source/1992/dec92/norton.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY>
</HTML>
