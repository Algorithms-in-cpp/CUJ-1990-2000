


<HTML>
<HEAD>

<TITLE>October 1991/Don't Blow Your Stack</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Debugging</FONT></H2>

<hr><h2 align="center"><font color="#800000">Don't Blow Your Stack<A name="0222_0116"><A name="0222_0116"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0222_0000"><A name="0222_0000">Jerzy Tomasik</font></h3><hr><blockquote><P>
<P><i><A name="0222_0000"><A name="0222_0000">Jerzy Tomasik is president of Effective Experimentation Experts, a firm that specializes in statistics and scientific programming. You may contact him at 159 Laurel Ave., Brea, CA 92621, or as <I>jtomasik</I> on telepath. His CompuServe ID is 70562,1372. </i></P><P>
If your programs never terminate with the run-time error "stack overflow" and never crash mysteriously, you may skip the rest of this article. Even if you have mastered the compiler and linker switches required to avert the dreaded "stack overflow" message, you may still be playing with fire. Though you may know the amount of stack space your own code takes, you can't be sure how much space is used by the library routines you've included, especially those third-party GUI libraries without the source code.<P>
Despite the proliferation of C books and magazines, stack management has not received the coverage necessary for programmers who come to C without experience in assembly language. The only book I know that covers the topic fairly well is <I>Compiler Design in C</I> by Allen Holub. Even this text is a little short of practical solutions for everyday programming problems. <P>
The few, simple functions that I'll present in this article have allowed me to trim the stack to the absolute minimum, without any guesswork. The "high-water marking" of the stack requires only two function calls. Even better, you can set up the functions to report the amount of unused stack every time your program terminates.<P>
<h4><FONT COLOR="#000080"><A name="0222_0117">Memory Organization Of C Programs<A name="0222_0117"></FONT></h4></P>
Before you can solve your stack problems, you need a good understanding of the memory organization in a typical C program. Begin by examining <I>MEMORG.C</I> in <A href="list1.htm">Listing 1</a>.
 Compiling this program under Microsoft C using<P>
<pre>cl /Fs /Fm /AS memorg.c</pre>
produces <I>MEMORG.LST</I> and <I>MEMORG.MAP</I> in addition to the <I>MEMORG.OBJ</I> and <I>MEMORG.EXE</I> files. The information that tells what the compiler decides to do with different variables is placed at the end of the .<I>LST</I> file. For example, the compiler calculated the size of <I>str1</I> (an initialized variable) to be 28 bytes. The compiler computed the file's total data size, however, as 114 bytes. The discrepancy can be found in the five <I>printf</I> format strings. The compiler places each <I>printf</I>'s 17-byte string in the static data segment. Bear in mind that these 114 bytes become embedded in your executable program.<P>
Since <I>str2</I> has not been initialized to anything explicitly, the compiler has no reason to store it as part of the executable file. During load time, however, 2048 bytes will be filled with zeros and reserved for <I>str2</I>. For historical reasons this is called a <I>BSS</I> (for Block Starting with Symbol) area. Finally, <I>str3</I>, though unititialized like <I>str2</I>, has not been placed in the <I>BSS</I> segment. In fact, <I>str3</I> is not part of any of the segments listed at the end of the .<I>LST</I> file. <I>str3</I> has been declared with the <I>static</I> keyword.<P>
A variable declared as <I>static</I> maintains its value between function calls because the compiler puts it in a fixed place in memory for the duration of the program, This location does not change between different calls to the same function. What may be less known is that the keyword <I>static</I> also makes the variable visible only within the source file in which it has been declared. This explains why you sometimes see the line<P>
<pre>#define PRIVATE static</pre>
to improve the readability of source code.<P>
In simple terms, the <I>static</I> keyword tells the compiler everything it must know about a variable. Since a C compiler works with only one source file at a time, it cannot resolve physical placement of global variables, but a variable declared <I>static</I> can only be accessed by the current source files. The compiler, then, is free to determine the placement of static data.<P>
Since <I>str2</I> is not <I>static</I>, but global by default, it is visible to other files. Only the linker has sufficient knowledge of all the modules comprising the entire program to resolve global variables; the compiler cannot. But near the end of <I>MEMORG.MAP</I> (<A href="list3.htm">Listing 3</a>)
 are <I>01200H</I> bytes named <I>c_common</I>, placed in the <I>BSS</I> class. <I>str3</I> (4096 or <I>1000H</I> bytes) ends up here, in addition to <I>200H</I> bytes allocated for the C start-up code and libraries.<P>
<h4><FONT COLOR="#000080"><A name="0222_0118">Local Symbols<A name="0222_0118"></FONT></h4></P>
Immediately following the ending brace of <I>main</I> in <A href="list2.htm">Listing 2</a>,
 you'll find a list of Local Symbols. Notice that the variables are listed only by name and offset. The offset is relative to the current stack pointer (<I>SP</I>), which is resolved when the routine is executed. (<I>MEMORG</I> has only one function. More complex programs would contain local symbols for each function.)<P>
The compiler places the local (auto) variables on the stack as needed. If a given function can be called from different points in the program, more likely than not the value of <I>SP</I> will be different at these points and local variables will occupy different physical space. Also, the compiler does not zero out the stack space at the end of a function call. So the values of local variables are not only <I>not</I> maintained between function calls, but are practically guaranteed to contain garbage. This also explains why variables declared inside a function cannot be accessed from outside the function &#151; other functions cannot use a fixed address to access them.<P>
<h4><FONT COLOR="#000080"><A name="0222_0119">Passing Arguments<A name="0222_0119"></FONT></h4></P>
The compiler also uses the stack as a "scratch pad." C passes function arguments by value, meaning that the arguments' values must be copied to a place that both the calling and the called routine can agree upon. In C this is the stack. Program <I>FUNC_ARG.C</I> in <A href="list4.htm">Listing 4</a>
illustrates stack usage during function calls. Again I compiled with the <I>/Fs</I> switch to generate the compiler listing shown in <A href="list5.htm">Listing 5</a>.
<P>
The only difference between the two functions <I>by_value</I> and <I>by_address</I> is how the <I>big_struct</I> argument is passed. <I>by_value</I> copies the entire structure (1024 or <I>400H</I> bytes) onto the stack, while <I>by_address</I> only copies the structure's address (two bytes in small memory model). If you compare the offsets of <I>dummy</I> in these two functions, you will find a difference of 1022 bytes. It is easy to see why passing a large variable's address is more desirable than copying the variable itself. In fact, <I>FUNC_ARG.EXE</I> will not run with the default stack size of the Microsoft C compiler.<P>
Up to this point, I haven't mentioned the effects on the stack created by allocating memory dynamically. In <A href="list1.htm">Listing 1</a>,
 the variable <I>heap_str</I> is allocated at run-time. A call to the library function <I>malloc</I> allocates 512 bytes from the heap, which are later released with a call to <I>free</I>. From <I>MEMORG.LST</I> you can see that h<I>eap_str</I> takes up only two bytes of stack space. This size is in sharp contrast to <I>auto_str</I>, which occupies 512 bytes of stack space.<P>
Don't forget that the space claimed by <I>malloc</I> remains in use until it is <I>free</I>d. You can return the address of an allocated buffer from a function (this is exactly how the <I>strdup</I> function works), but returning the address of a stack-based variable can and will lead to the most frustrating C bugs. (Remember, storage on the stack gets recycled after the function terminates).<P>
<h4><FONT COLOR="#000080"><A name="0222_011A">High-Water Marking The Stack<A name="0222_011A"></FONT></h4></P>
Even if you had the patience to examine each <I>.LST</I> file of your real-life application, you could not look at the libraries that come without the source. In addition, the number of times a recursive function will be called frequently depends on data (for example in <I>qsort</I>). In such cases you would have to analyze the algorithm to predict stack usage at run-time.<P>
What I have shown you so far is only the background you need for dealing with stack problems, and guidelines for coding that will make the problems less likely. Now I'll develop tools to measure exactly how much stack space a program has used, even after calling third-party library routines.<P>
The principle of marking the stack at its "highest" level is very simple. You simply write a known byte pattern over the entire allocated stack area at program initialization, and then determine the last place where the program overwrote the pattern. The actual implementation is not only compiler specific, but is different for each memory model. (You'll need to compile <I>CHCKSTCK.C</I> for the memory model you use.) Since I use only Microsoft C and Turbo C, the package supports only these two compilers. See <A href="list6.htm">Listing 6</a>.
<P>
Fortunately, using the package is considerably simpler than understanding its internals. I have included a trivial program <I>TESTSTCK.C</I> (<A href="list7.htm">Listing 7</a>)
 to demonstrate how to use the two functions <I>spray_stack</I> and <I>unused_stack</I>. Although you are not required to call <I>spray_stack</I> at the beginning of the program, it is prudent to do so, since any stack problems prior to calling <I>spray_stack</I> may escape your attention. In fact, you can call <I>spray_stack</I> more than once in order to collect stack usage data for different parts of the program. Note that you can call the complementary function, <I>unused_stack</I>, at any point to pinpoint the stack hogs.<P>
<h4><FONT COLOR="#000080"><A name="0222_011B">Implementing <B><I>spray_stack</I><A name="0222_011B"></B></FONT></h4></P>
The Microsoft C compiler (more correctly the startup code) defines a global variable called <I>end</I>, the address of which points to the end of the data segment. <I>end</I> also coincides with the bottom of the stack segment. If the stack pointer ever dips below the location of <I>end</I>, your program is almost certainly destined to crash! <I>spray_stack</I> uses <I>end</I> to determine the bottom of the stack.<P>
Microsoft C has a unique feature &#151; the library routine <I>stackavail</I> returns the amount of free stack space. <I>spray_stack</I> therefore uses this function to determine the number of bytes of the stack to mark. The variable <I>end</I> and the function <I>stackavail</I> make implementing the Microsoft-compatible version simple. (This has little relation to the question of which compiler is better.) <I>spray_stack</I> only has to find the address of <I>end</I> (bottom of the stack) and the size of the free stack:<P>
<pre>stack_top = stackavail 0 + &amp;end</pre>
in order to mark to the top with the signature byte. The function <I>unused_stack</I> finds the bottom of the stack and walks the stack until it finds something other than the signature byte. At this point, we know how many bytes of the stack were left unused.<P>
Turbo C startup code contains a global variable <I>_stklen</I> that you normally initialize inside your code to override the default stack size. The Turbo C version of <I>spray_stack</I> uses this variable to determine the size of the stack. Turbo C provides a very convenient access to 80x86 registers via predefined variables (register name prepended with an underscore). This allows us to find the current stack pointer (<I>SP</I>) simply as <I>_SP</I>. Although this method is extremely non-portable, it's a blessing when you need it. Note that I extensively use compiler-predefined symbols for the memory model.<P>
If you need to port these routines to another compiler, I'll briefly mention that you can always find (approximately) the current stack pointer under any C compiler. Remember that <I>auto</I> variables are placed on the stack. So look at the following code fragment: <P>
<pre>unsigned short *get_SP(void)
{
unsigned short sp;
return( &amp;sp );
}</pre>
This function returns the current stack pointer with an accuracy of a few bytes, depending on the details of the implementation. Note that you can use the same method to observe the stack during debugging. I routinely open the register window in both Turbo Debugger and CodeView. Keeping an eye on <I>SP</I> will let you know which functions use inordinate amounts of the stack. You can also open a "dump" window to watch the bottom of the stack. Any overwrites by errant pointers will be quickly noticed.<P>
One final implementation detail is that by registering <I>unused_stack</I> with the <I>atexit</I> handler, you can get the stack usage report every time your program terminates. You can also check for an environment variable and report only if the variable is set. Your final product can thereby contain your stack checking routines and help you in on-the-phone trouble-shooting. My current application includes a hot-key to display a window with current <I>SP</I> and stack-usage information.<P>
<h4><FONT COLOR="#000080"><A name="0222_011C">Conclusion<A name="0222_011C"></FONT></h4></P>
There are different ways to implement and use <I>spray_stack</I> and <I>unused_stack</I>. If you are a skilled assembly-language programmer, you may want to modify your compiler's startup code to make the functions an integral part of your development environment, though doing so would make the code even more non-portable. You would probably have to modify it for each new release of the compiler. I have used my implementation through upgrades of both compilers and haven't had to make any modifications. I believe this arrangement strikes a balance of simplicity, maintainability and resistance to minor changes between compiler versions.<P>

<h4><a href="../../../source/1991/oct91/tomasik.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
