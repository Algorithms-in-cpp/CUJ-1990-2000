

<HTML>
<HEAD>

<TITLE>September 1995/Quick MS-Windows Dialog Design</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Windows Programming</FONT></H2>

<hr><h2 align="center"><font color="#800000">Quick MS-Windows Dialog Design<A name="012E_00B7"><A name="012E_00B7"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="012E_0000"><A name="012E_0000">Adrian Barbu</font></h3><hr><blockquote><P>
<P><i><A name="012E_0000"><A name="012E_0000">Adrian Barbu has an M.S. in software engineering and is a project manager at Goto Informatique, a French software company specializing in communication software. He can be reached via e-mail at ab@goto. fr.</i></P><P>
<h4><FONT COLOR="#000080"><A name="012E_00B8">Introduction<A name="012E_00B8"></FONT></h4></P>
I've found that, one way or another, dialog design and coding make up some of the most expensive parts of MS-Windows programming. If a programmer wants to do fast development, he will have to marry his program to a heavy application framework, taking in several hundreds of kilobytes of code, and losing lots of design liberty in the bargain. On the other hand, programming without a framework requires repetitive dialog procedure design, with hopelessly boring code to move data back and forth between program variables and dialog controls. I finally got so tired of both approaches that I rolled my sleeves up to see if I could come up with something better. The result is a C++ class library <I>(QUICKDLG)</I>, providing access to string, boolean, or enumeration data, and capable of presenting it in an MS-Windows 3.1x dialog box for user interaction.<P>
The library's presentation layer works as a run-time interpreter of a dialog's description, responding to both resource text and embedded resource "code" for control type (captions, styles, positions, sizes, etc.) to produce dialog behaviors (such as initializing controls and data checks). This approach enables features that no resource editor I know of supports directly as of this writing: tabbed dialogs, and relief from text length problems in software internationalization. Also, this solution delivers tiny code size, ease of use, and design freedom for the rest of the surrounding application. For those of you in a hurry to find out whether this story is worth reading, <A href="list1.htm">Listing 1</a>
shows the description of a fairly complex dialog box, while <A href="fig1.htm">Figure 1</a>
displays a one-tab portion of the result, as displayed by <I>QUICKDLG</I>.<P>
Since full source code for <I>QUICKDLG</I> is available on this month's code disk and online sources, this article focuses on concepts and design decisions.<P>
<h4><FONT COLOR="#000080"><A name="012E_00B9">An Associative Memory<A name="012E_00B9"></FONT></h4></P>
<A href="list2.htm">Listing 2</a>
shows all you need to know about <I>QUICKDLG</I> to use it in your C++ code. The abstract class <I>ASSOCMEM</I> functions as a data manager, grouping related pieces of information together eventually to be shown on screen as a dialog. These pieces of data are either strings or integer values, which <I>ASSOCMEM</I> stores and retrieves using a unique access key passed as the first parameter of the <I>get</I> and <I>set</I> primitives. For example:<P>
<pre>ASSOCMEM *pM;
BOOL bBold = pM-&gt;get("f_bold", 0);
//... pM-&gt;set("f_face", "Swiss");</pre>
Of course, <I>ASSOCMEM</I> is no more than a placeholder class with a pure virtual interface, so if you want to instantiate an object you must instantiate one from <I>ASSOCMEM</I>'s descendant class, <I>SHOWDATA</I>:<P>
<pre>SHOWDATA FontMemory   ("CFG.INI", "FontInfo");</pre>
You might still want to access that object through an <I>ASSOCMEM</I> pointer, however. In the short term use of such a pointer will enable you to use two less header files in compiling the client modules. In the long run, telling one piece of code no more than necessary about another might prevent a maintenance nightmare in a large project.<P>
In addition to providing persistence, <I>SHOWDATA</I> can display data in and bring up a fully operational dialog box. This is the job of member function <I>SHOWDATA::modalDlg</I>, which uses its string arguments to locate the text of the dialog description to be loaded and interpreted. Once the text is interpreted, control will return to application only after the dialog is shut down by the user. During interpretation the textual dialog description creates the links between data and controls in the dialog. For example, the line<P>
<pre>CHECK|VAR=f_bold|LABEL=&amp;Bold font</pre>
tells <I>SHOWDATA</I> that the dialog should contain a checkbox, linked to an integer variable accessed by the key <I>f_bold</I>, so that <I>gets</I> and <I>sets</I> may be performed on the variable. In a similar manner, a <I>RADIO</I> control with <I>R0</I> to <I>Rn</I> labels will retrieve and eventually store an integer value between zero and <I>n</I> for use as a C++ <I>enum</I> value.<P>
I want to point out two important aspects of using the <I>SHOWDATA</I> class. The first aspect is crucial to understanding the <I>QUICKDLG</I> approach: Since the dialog description is a piece of plain ASCII text interpreted at run time, the call<P>
<pre>FontMemory.modalDlg(hWnd, hInst, "DIALOGS.DLG", "FONTDLG");</pre>
will reflect any changes in <I>DIALOGS.DLG</I> immediately after a file save (say, from your text editor). Thus, <I>QUICKDLG</I> is its own prototyping tool, since it can't tell the difference between a real application run and some design-time test mode. In other words, all you need to design a dialog box is a text editor and a test tool featuring a <I>WinMain</I> with a <I>SHOWDATA</I> constructor and a <I>SHOWDATA::modalDlg</I> call like the one above.<P>
However, since you may feel uncomfortable about shipping a dialog description file along with your application, I've provided an alternative: Once dialog design is complete, simply put the line<P>
<pre>Dialogs TEXT DIALOGS.DLG</pre>
into your resource .RC file, then change the function call to read<P>
<pre>FontMemory.modalDlg(hWnd, hInst, "Dialogs", "FONTDLG", "TEXT");</pre>
This form of the call, with the optional fifth argument, causes <I>SHOWDATA</I> to obtain all the dialog data directly from the .EXE file. (This assumes you have compiled the .RC file into the .EXE at build time.) Using this call you need distribute only one .EXE file and no one will ever know you have betrayed your old resource editor.<P>
The second aspect of using <I>SHOWDATA</I> concerns the isolation of an application from <I>QUICKDLG'</I>s core code. Specifically, <I>SHOWDATA</I> contains a pointer to a class <I>MODALDLG</I> whose internals remain unknown to other parts of the code, including <I>SHOWDATA.HPP</I>. Since <I>MODALDLG'</I>s internals are hidden, the <I>QUICKDLG</I> library may be upgraded without recompiling the client modules of an application. This is what James Coplien <a href="#1">[1]</a> calls the letter-envelope idiom of C++. Now you know how to handle the envelope. The rest of the story is about the letter inside.<P>
<h4><FONT COLOR="#000080"><A name="012E_00BA">The Dialog Description Interpreter<A name="012E_00BA"></FONT></h4></P>
Several classes cooperate to read the dialog description into <I>QUICKDLG</I>. The main component is the class <I>DESCRIPT</I> (<A href="list3.htm">listing 3</a>)
, which retrieves parts of the <I>description unit</I> &#151; a string structured as a type followed by zero or more parameters:<P>
<pre>&lt;desc_type&gt;['|'&lt;param&gt;=&lt;value&gt;]</pre>
<I>DESCRIPT</I> is implemented as an enhancement of <I>STR</I>, a string class provided with concatenation, comparisons, letter case operations, whitespace discarding, and substring search. (Class <I>STR</I> is provided on this month's code disk; for more information also see "A C++ Class Generator," by Adrian Barbu, <I>CUJ</I>, July 1995.)<P>
<I>DESCRIPT</I> pays no attention to the order of parameters in the description unit; <I>QUICKDLG</I> will always ignore unknown elements of a dialog description. However, <I>DESCRIPT</I> may encounter an ordered structure, when it comes to what I call a multiple parameter. For example, the description of a radiobutton group (to speak Windowese) for a marital status might be:<P>
<pre>RADIO|VAR=MS|LABEL=Marital status|\
RO=Single|R1=Married|\
R2=Divorced|R3=&lt;Unknown&gt;</pre>
To deal with such situations I've created a helper class <I>MULTIPARAM.</I> Its constructor receives both a pointer to the <I>DESCRIPT </I>object and the invariant part of the parameter name. The <I>MULTIPARAM</I> object can then return the number of entries (via member function <I>no</I>) and retrieve a parameter value by index (via member functions <I>value</I>). As <I>DESCRIPT</I> deals with one string defining a single dialog header or a control, it relies upon a class called <I>LINEIN</I>, whose constructor loads the entire resource text input in one big gulp, regardless of its file or user resource origin. After construction, the <I>LINEIN </I>object works like an iterator over the resource text. With each iteration the object yields the next description unit, in search of the desired dialog (most resource texts will contain several dialog descriptions).<P>
Along the way, <I>LINEIN</I> also handles two low-level parsing jobs. The first is reforming long lines split with backslash and newline, exactly as the C/C++ preprocessor does for multi-line macros before expanding them. The second is eliminating comments, that is, lines with a semicolon for first non-white space character, like back in the assembler days. Finally, all description keywords recognized by <I>QUICKDLG</I> are gathered as public constant statics of a codeless class called <I>KW</I>.<P>
(Besides keeping the global name space clean, I think the qualification <I>KW:: </I>gives better readability. Pretty short to type, too.)<P>
<h4><FONT COLOR="#000080"><A name="012E_00BB">Dialog Geometry And Aggregate Controls<A name="012E_00BB"></FONT></h4></P>
Classes <I>MODALDLG</I> (<A href="list4.htm">listing 4</a>)
 and <I>CTL </I>(<A href="list5.htm">listing 5</a>)
 are the backbone of the <I>QUICKDLG</I> library. The first encapsulates all the aspects of dialog-as-usual mechanics. The second serves as an abstract base class for all the controls supported by <I>QUICKDLG</I>, as well as for the ones you might want to add in the future. <I>MODALDLG </I>lives two distinct lives, one before and one after creation of the dialog as an MS-Windows entity on screen. The same is true for class <I>CTL</I>. I call these two phases of existence <I>Before Creation</I> (BC) and <I>On-Screen.</I><P>
<h4><FONT COLOR="#000080"><A name="012E_00BC">Before Creation<A name="012E_00BC"></FONT></h4></P>
First I present a closer look at <I>MODALDLG</I> and<I> CTL</I> in the BC era. When MS-Windows puts up a dialog it pulls the dialog data out of a block of binary information, whether that block was loaded from compiled resources or created on-the-fly at run time (<I>QUICKDLG</I> will of course do the latter). This block consists of a dialog header followed by as many similar pieces of data to represent dialog items (static texts, edits, buttons, and so on). Incorrectly described as <I>struct</I>s in various documents, these aggregates of data do not appear in <I>WINDOWS.H</I>, and they couldn't possibly otherwise than in a comment, since data members inside may be longer, shorter or plainly nonexistent, according to dynamic values of upper members.<P>
To live with this unbelievable mess, I have defined true, fixed-size <I>struct</I>s <I>MODALDLG::DLGHEADER</I> and <I>CTL::DLGITEM</I>. I then use API calls after dialog creation to handle the variable parts &#151; e.g. <I>SetDlgItemText</I> for item captions. Even so, a second look at the structures will confirm that yes, they are hopelessly alignment dependant. Therefore you must always compile the <I>QUICKDLG</I> library with byte alignment code generation. This may be frustrating, but it has no adverse effect on the application.<P>
The greatest challenge of the <I>QUICKDLG </I>approach is filling the X and Y position and size fields in these structures, since no such geometric information exists in the initial description. To perform this task, <I>MODALDLG'</I>s constructor begins by initializing its <I>LINEIN _input</I> member to browse the text description. Then, as a new control is encountered, <I>MODALDLG::virtualCTLCtor </I>creates a <I>CTL</I>-derived object according to its <I>DESCRIPT</I> type. During its construction, this new object scans its <I>DESCRIPT</I> for all the information relevant to its geometry (namely its various labels), so as to compute the control's overall width and height in dialog units. Upon return, <I>MODALDLG </I>adjusts its own geometry accordingly, then asks the new control to append its <I>DLGITEM </I>data to the <I>BLOCKMEM _template</I> under construction. After encountering the last control, <I>MODALDLG </I>computes a horizontal band to accomodate the OK and CANCEL buttons, centered and sized according to their labels, then appends the two corresponding <I>DLGITEM</I>s to the memory block. <I>MODALDLG'</I>s own geometry is now completely determined, so its overall width and height can finally be poked into the beginning of the <I>_template</I> memory block.<P>
The whole process is quite precise because every text label undergoes a dummy write under life-sized font and screen conditions &#151; this determines its exact bound rectangle. The main danger of such automatic item placement is uncontrolled growth of the dialog on both X and Y axes. <I>QUICKDLG</I> has several ways to address this, sharing responsibilities between <I>MODALDLG</I> and <I>CTL</I>-derived controls. To begin with, <I>QUICKDLG</I> gives a more predictable Y-size to the radiobutton group (by far the greatest space waster) by fitting all its choices into a combo box. Even more effective, <I>MODALDLG</I> can add a Z axis to itself, enabling complex dialogs to specify tabbed groups of controls.<P>
<h4><FONT COLOR="#000080"><A name="012E_00BD">Tabbed Dialog Creation<A name="012E_00BD"></FONT></h4></P>
This is as good a time as any for me to digress briefly and talk about <I>MODALDLG</I>'s support for tabbed dialogs. <I>MODALDLG</I> keeps a table of planes <I>GRPXY _pGXY[]</I> according to the parameters <I>G0</I> to <I>Gn</I> specified in its <I>DESCRIPT</I> (if none, there will still be a <I>_pGXY[0]</I> holding all the controls). As it scans the input, <I>MODALDLG</I> signals the width and height of each new control to the corresponding plane, then puts the control and the group it belongs to in the table <I>GCTL _ctab[CTABSIZE]</I>. At display time all controls will be hidden but those belonging to the active plane. At the end of the process, <I>MODALDLG </I>takes the maximum width and height of all planes for its own overall dimensions.<P>
<h4><FONT COLOR="#000080"><A name="012E_00BE">On-Screen Behavior<A name="012E_00BE"></FONT></h4></P>
The on-screen life of <I>MODALDLG</I> and its controls is largely characterized by natural exchanges between grown-up objects, as opposed to the enslaving approach of the native MS-Windows dialog procedure. To make the dialog appear, <I>MODALDLG::run</I> calls the API primitive <I>DialogBoxIndirectParam</I>, where "Indirect" signifies use of the <I>_template</I> memory block rather than loading of a compiled dialog resource.<P>
As for "Param," well, it hints at our chance to make a C++-palatable entity out of something that originally isn't, the dialog procedure itself. Indeed, like any other callback function, the dialog procedure is a piece of code called by the system according to a prototype (a binary stack pattern, actually) buried deeply once and for all, which cannot accomodate a hidden <I>this</I> pointer. As a result, a callback function cannot be a member function of a C++ class. This is why the dialog procedure <I>_DlgProc</I> is a static function of the class <I>MODALDLG</I> (<A href="list4.htm">listing 4</a>)
. Its code must rely on the first argument, the window handle, to retrieve the actual <I>MODALDLG</I> object concerned.<P>
This little trick is possible because <I>DialogBoxIndirectParam</I> accepts an extra 32-bit value (a pointer to the calling <I>MODALDLG</I> instance) that the system will give back to the static dialog procedure with the first important message, <I>WM_INITDIALOG</I>. <I>QUICKDLG</I> doesn't get a second chance to link this C++ object address to the window handle, so upon receipt of <I>WM_INITDIALOG </I>it stores the pointer as two 16-bit properties of the window (the best we can do). From this point on, until the dialog is shut down, the inline function <I>HWIN2this</I> (<A href="list4.htm">listing 4</a>)
 reassembles the <I>MODALDLG</I> pointer out of the window handled before reacting to the received message.<P>
Receipt of <I>WM_INITDIALOG</I> is also the right time to initialize controls on screen, so the <I>MODALDLG</I> instance calls <I>CTL::initScreen </I>from all its controls to wake them up to their second, on-screen life. Since each control was given a pointer to the correct associative memory location upon creation, a burst of <I>SHOWDATA::get</I> will bring data on screen.<P>
So far so good, but C++ doesn't mean OOP yet. In native Windows, it is the dialog procedure that gets <I>WM_COMMAND </I>messages for anything significant happening to its controls: check state, list selections, edit typing, button clicks, you name it, it all goes to the dialog procedure. If you want a smarter edit control you must add code to the procedure of the dialog it belongs to. To circumvent this requirement, <I>MODALDLG</I> redispatches every such notification message to the corresponding <I>CTL</I>-derived object, using the control identifier as an index in the <I>GCTL _ctab[] </I>table:<P>
<pre>CTL* pCTL = _ctab[wId].ctl;
if(pCtl)
   pCtl-wm_command(wId, wNotif);</pre>
This technique leaves it up to the <I>CTL </I>object to react or not, according to the event in question and to the object's own degree of specialization (that is, inheritance).<P>
As an example of how this works, clicking the OK button causes two full scans of the<I> GCTL</I> table. The first scan polls each control via <I>CTL::isDataOk </I>to confirm that the control contains valid data. If any control answers no, <I>MODALDLG </I>brings its tabbed plane to foreground (if necessary) and sets input focus for correction. If all controls are okay, the second scan is a <I>CTL::saveData</I> broadcast, which will trigger the proper <I>SHOWDATA::set</I>.<P>
Finally, I have thrown two look-and-feel features into <I>MODALDLG</I>'s behavior which I find nice in the long run. The first is to use the dialog's <I>VAR </I>name as a <I>SHOWDATA </I>key to save the last visited tabbed group of controls. Bringing up the same group will help the end user feel familiar with the dialog next time he sees it on the screen. The second feature works inside the function <I>_thinFontJob</I>, to mark a difference between actual data (written in bold face, as in everyday MS-Windows dialogs) and label meta-information on statics and buttons (written in normal face). Take them as an apocryphal appendix to your favorite interface design guide. Or just comment them away.<P>
<h4><FONT COLOR="#000080"><A name="012E_00BF">Cooperative Dialog Design<A name="012E_00BF"></FONT></h4></P>
This <I>QUICKDLG</I> approach leaves a lot of responsibility to the dialog designer, which is only natural, as he is the one who is supposed to know what all those controls mean and how they relate to each other. However, <I>QUICKDLG</I> handles some of the more complicated layout tasks, providing tremendous relief. For example, <I>QUICKDLG</I> makes all decisions concerning X- and Y-axis layout of the controls. A <I>QUICKDLG</I> control generally amounts to more than a MS-Windows dialog item. For example, a <I>QUICKDLG</I> EDIT Control is made of two items, the edit zone and the static text explaining it. If both edit zone and text fit in one "line" of text no longer han half the width of the screen, the EDIT control's constructor will set overall width and height accordingly. If not, the constructor will align the edit zone below the static text. This sort of calculation takes place inside every aggregated control. (<I>MODALDLG </I>only asks for the verdicts using virtuals <I>CTL::duW()</I> and <I>CTL::duH().</I>)<P>
These policies work together for a globally satisfactory result on all the real life dialogs I tried. Obviously, <I>QUICKDLG </I>will never be able to use every square unit of your dialog as you can do yourself with a GUI resource editor. But there are times when such tools are best avoided. Some day your international sales manager may urge you to switch all your dialogs to German or Italian, something like "Verzeichnis for Herunterladen" or "Repertorio di telecaricamento," to fit in an item in place of "Download directory." That day you may find<I> QUICKDLG</I> (or some similar concept) simply invaluable.<P>
<h4>References</FONT></h4></P>
<a name="1"></a>[1] James Coplien. <I>Advanced C++ Programming Styles And Idioms</I> (Addison-Wesley, 1992).<P>
<a name="2"></a>[2] Paul DiLascia. <I>Windows</I>++, <I>Writing Reusable Windows Code In C</I>++ (Addison-Wesley, 1992).<P>

<h4><a href="../../../source/1995/sep95/barbu.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
