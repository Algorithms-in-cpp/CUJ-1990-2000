

<HTML>
<HEAD>

<TITLE>September 1995/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="0144_00C8"><A name="0144_00C8"></font></h2><hr>
<BLOCKQUOTE>
<A name="0144_0000"><A name="0144_0000">Dear Mr. Plauger,<P>
When I receive any new issue of the <I>CUJ</I> I usually open it at an arbitrary page. In the March issue the first thing I read was Bob Moore's complaint about your review of Anthony Porter's book <I>The Best C/C++ Tips Ever</I>. Let me assure you that I was more than pleased with your review and especially glad for the unequivocal words with which you started it. So I wish I had sent you this e-mail sooner.<P>
Being a reader of the <I>CUJ</I> for many years (in fact since long before the "U" appeared in its name), I think I know the moderate tone you usually chose when you verbalize criticism. I consider the idea there could be any connection between the two facts that you published some books at Prentice-Hall and Porter's book is published by McGraw-Hill to be silly, if not impertinent.<P>
I learned programming in C around 1981 (using K&amp;R-I), and as I'm teaching C for more than ten years now, I have some professional interest in books about this topic. So, every few months I spend some hours in a well-sorted book shop to see what's new. In the early 1980s there were so few new books that I bought practically all I could find and read them cover to cover, if only to decide if I could recommend them to the participants of my C courses.<P>
During the late 1980s I had to give up that habit, not only because it would have been too expensive to buy all that stuff but also because of lack to time to read it, even if only partially. But I continued my occasional 2-3 hour visits in book stores to glance through new books. The few I bought were mostly to get some up-to-date things on my book shelf (like K&amp;R-II, H&amp;S-II+III [Harbison and Steele &#151; pjp] ...) while ANSI C approached its final shape. My general feelings were that anything that could be written about C was already in some book, so why do people still write so many more books?<P>
In the early 1990s I followed the Usenet-discussions in <I>comp. lang.c,</I> and occasionally made contributions myself. By the helpful and friendly people there (Karl Heuer, Chris Torek, Henry Spencer, to name only a few I immediately remember from these days) my expertise in C got its final polish. I especially learned to rate the FAQ of <I>comp. lang.c</I> very high because of its sound mixture of low-and and high-level stuff. Steve Summit does a really admirable job in explaining things in a terse, yet not over-simplified way.<P>
Given that background, I'm surely not the "typical reader" to which new books on C are aimed, but my general impression if I visit a book store today is that most of the stuff is at best unneccessary, if not &#151; in direct comparison to some of the "classical" books " &#151; bad or even "dangerous" (as you clearly expressed it in your review). I can skim through almost any new book and it will typically be less than five minutes until I find something that wouldn't have survived if I had been in charge as technical editor. (In comparison, it's extremely hard to find such things in K&amp;R-II, though I'm aware of some weakness on pp. 119-120.)<P>
It's not that all the things I have to criticize are plain wrong. (Some are. I seem to have an especially sensitive eye for syntax errors in examples, which often are obviously not included from the source files but re-typed.) An example of what I typically spot are system dependencies not marked as such, say discussions on the behavior of character input with <I>getchar</I>, which may be true for the system the author uses but cannot be generalized. While the novice reader is given the impression the author knows a lot about C, to me it more reveals the author's limited experience and exposure to a number of different implementations and/or operating systems.<P>
As I know that one might be tempted to use on-line help and silently get lured into implementation-specific features, my "standard reference" (pun intended:-)) is the small book you wrote with Jim Brodie. (BTW: It may be misleading to some people that you choose Microsoft Press as publisher, because this book is as close to ANSI C and as far away from any MS-specific stuff as I can imagine.) I would urge every author of any C book which claims to deal with ANSI/ISO C to use this booklet as reference &#151; or at least to cross-check his or her examples with it.<P>
Failing more and more to find recommendable new books on C I finally began to doubt on my ability to accept other views than mine. I mean, could it be that the problem was more with myself than with the books? Maybe it's the growing indifference to other opinions and styles that some elder people develop? Well, I do not really <I>feel</I> old (I'm forty now), but maybe those are the first symptoms. So your review of <I>The Best C/C</I>++ <I>Tips Ever</I> was kind of a relief to me. I remembered having had a look into that book too and put it back onto the shelf <I>very</I> quickly. (To be honest, because I already disliked its "promising" title, my acceptance level was set a bit higher than usual &#151; and the more the book failed to reach it.)<P>
If I may express a wish for further book reviews in <I>CUJ</I>: Please continue to be explicit with criticism of bad books. It was reported to me that someone once wrote in <I>comp. lang.c</I>, "All the books on C you ever need are K&amp;R, H&amp;S, and the FAQ of this group." Though this sounds provocative (probably it was meant to be) and there certainly are other recommendable and useful books, I fear most of the new stuff is unnecessary and some is hardly worth the paper it is printed on.<P>
I suppose that not only the community of C users grows but also the number of authors who try to place their books as best they can. Currently the latter growth (books) seem to exceed the former, so many publishers and authors will have a hard time to get their share. Some obviously try to get attention by putting "marketing hype" in the title (best tips ever). Others simply update old books so that the buzz-word "C++" can show up in the title of the new edition &#151; and if you open the book you'll find mostly C stuff with a few C++ "add-ons," typically not "good" ones in the sense of supplying an idea of what OOP means. Sad as this is, I think we &#151; the "oldies" &#151; have some obligation to warn the newcomers about it. I appreciate that you did this in the January issue of the <I>CUJ</I>.<P>
Best regards and keep up your good work,<P>
Martin Weitzel<P>
Greetings:<P>
Re: Letters to the Editor, March 1995, Concerning <I>The Best C/C++ Tips Ever</I><P>
Excoriatus, exculpatus.<P>
I read with delight your reply to the mindless rantings of Bob Moore. The article at issue rendered a service to C/C++ users. That is what this is all about, isn't it?<P>
If the ruffled Mr. Moore wants to be helpful in the same way he could name names regarding the alleged buggy software. If he has the courage to identify it I'm sure you'd publish his article.<P>
Perhaps leaving unedited his thorny prose, once again.<P>
Sincerely,<P>
K.B. Williams<br>
Stillwater, Oklahoma<P>
<I>Okay, here goes. See letter following</I>. &#151; <I>pjp</I><P>
DR. P J. Plauger:<P>
Thanks for your chastisement in the March issue of <I>C/C</I>++ <I>Users Journal</I> as a response to the rudeness of my letter regarding your review of a programming book. Frankly, it's almost an honor to have been mentioned in any context by one of the computer giants of this age. Had you been a little more perceptive you might have characterized me as not just as a mud slinger, but an exceedingly ugly, short, fat, bald, ignorant mud slinging little troll who lives under a bridge near old Fort Tombechbie and rides a splay footed donkey to work. The donkey would probably have been insulted.<P>
Most people who have spent time in residence on planet earth and been involved in some form of programming would probably parse roughly the same level of significance and viability in the following two sequences of tokens: "(IBM) PC compatible" and K&amp;R (&amp;P)." While the latter sequence seemingly is just arriving, it exasperates me to no end that the former sequence is losing impact.<P>
I lament the passing of the IBM business ethic that we've all enjoyed for over a decade. With entrepreneurs coast to coast in this country and around the globe cloning every known item of IBM hardware, most of them also cloned the IBM business ethic, which was perhaps the best thing ever cloned. In my perception, at least, that ethic can be interpreted as meaning, "If a customer buys our products and adheres to the written terms of our warranties, then that customer will be entitled to all and complete benefits to be derived from IBMness." Even trolls.<P>
This is not a good time to be saying things like, "I feel sorry for Intel." or that "commerical compilers are hard to write," because it excuses chip makers to rush out with a more exotic species of bugs and compiler vendors to come streaking to market with a frillier bunch of Windows gadgets and no substance at all. The glossy page hype in most good trade journals such as this one won't tell you as much about these products as you could learn on the psychic hot line. Many of us need information about tools to work with code like that shown in <A href="list1.htm">Listing 1</a>.
<P>
To compile with Borland BCC.EXE version 2.0, use the command line,<P>
<pre>bcc-c-v-mm ticks1</pre>
To link this module with Tlink version 2.51, use the command line,<P>
<pre>tlink /v c0m +ticks1 +d2, ticks1,, cm emu</pre>
Using Borland 4.02, the command-line invocation of the compiler would be something like<P>
<pre>bcc +med.cfg ticks1</pre>
and linked also using the compiler invocation line<P>
<pre>bcc -v mm -Tde -1v -1s -1Tde ticks1.obj d2.obj</pre>
Since this letter is already getting too long, I won't include the configuration file used to compile the module using the medium model, etc., and can't legally, I suppose, include the professionally written assembly source code for d2.asm. It's an excellent, low-cost communications driver marketed by Opto 22 of Huntington Beach, CA and using it is as simple as typing,<P>
<pre>tasm /zi d2</pre>
since that's the only additional thing one must do. This code is useful for determining how fast one optomux rack of machine inputs can be read at 38.4 kbaud, using interrupt driven serial communications.<P>
Please bear in mind that while data acquisition and industrial control programs are simple by nature, this is probably the plainest program of its type that you'll ever see. While either version of Borland compiles, assembles and links these modules adequately, only 2.0 is adequate for debugging this homely offering. The reason that 4.02 runs amuck when the stand-alone debugger is used with this type program is that it will not touch an interrupt vector and that is something that must be done with any serious serial communication routine. Turbo debugger 4.0 can read interrupt vectors, but it will not (apparently) allow a program to change an interrupt vector.<P>
Anyone believing that this phenomenon may be peculiar to the commercial driver used by the listing above is cordially invited to play with interrupt vectors using Borland's own help example for <I>getvect</I> and <I>setvect</I>. Set break-points liberally throughout the program and trace, step, and run the program. Have fun, and most important be sure to have your system recovery apparatus available before you start. In fairness to Borland's 4.02 package, debugging around interrupt vectors is risky business, but I urge you to compare 4.02 with some of their earlier versions running the interrupt vector help example.<P>
<A href="list2.htm">Listing 2</a>
shows <I>getv</I> and <I>setv</I> functions, which are inline assembly replacements for the <I>getvect</I> and <I>setvect</I> functions in Borland's run time library. To experiment with the functions in the Borland help examples, one should add the prototype lines:<P>
<pre>void intterupt(*getv(int))(__CPPARGS);</pre>
and<P>
<pre>void setv(int, void interrupt(*3)(__CPPARGS));</pre>
after the preprocessor directives at the beginning of the file. The functions as listed should be appended to the end of the file from the help example. At this point the functions will be called almost as before with the library functions <I>getv(INTR)</I> and <I>setv(INTR, oldhandler).</I><P>
While I can make no claim that this coding change improves performance of the example,it seemingly is less likely to hang or otherwise run amuck, though I'll concede that almost any program involving interrupt service routines can be troublesome to debug. It seems unnecessarily troublesome that Turbo debugger 4.02 either loses sight of the interrupt vectors or just plain doesn't allow them to be changed when running any of the examples mentioned in this letter. While this modification has been tested on my computer and several others, it's a use-at-your-own-risk situation and I accept no responsibility for damages to any machines that might be incurred while using it.<P>
I can determine no difference in program functionality when compiling and linking with either 4.02 and 2.0 The 4.02 debugger is even useful for debugging real-time control programs, but it's also spooky and unpredictable around interrupts. Since I don't want the keyboard to lock out when a 1,200 horsepower motor gets locked in, I refuse to play this game.<P>
Borland C/C++ Version 2.0 was perhaps the best value ever offered to a programmer, including multiple compilers, tasm, tlink, a profiler, and resource kit, all of which were and are highly functional. My version of 2.0 is well backed, behind locked doors and will continue to be guarded by a troll curse until someone shows me something better. Regrettably, 4.02 with more Windows frills, less substance, and no stand-alone assembler is not better, and that is the very heart of my lamentations. The business ethics of our industry today do not have the quality of "IBMness."<P>
The intent of my previous letter was not to besmirch America's programmer, but to express the views hopefully expressed here. Also, would it be possible to have more industrial control articles like the excellent feature by Bob Stout in the March issue. If you've written a DOS-based compiler could you mention who markets it and its title. After reading the chapter on <I>&lt;signal.h&gt;</I> in your excellent book, <I>The Standard C Library</I>, I'm inclined to believe a compiler written by you wouldn't be as dependent on internal DOS functions as, for example, <I>getvect</I> and <I>setvect</I> in the examples mentioned above.<P>
Sincerely,<P>
Bob Moore<P>
<I>I'll interpret your letter as a kind of apology and clarification, and take both at face value. I interpret your remarks as saying, at least in part, that: 1 ) Borland's compilers and debuggers have gotten fancier, but have lost ground in areas that you care about; and 2) they don't handle debugging of real-time code nearly as well as you'd like. I can sympathize with both positions, but I see little evil in Borland's actions. It's a hurly burly out there, and I envy no compiler vendor who tries to guess what winds to favor.</I><P>
<I>I wrote most of the code for the Whitesmiths Ltd. compilers, including the 80X86 family and its DOS system interface library. It supported real-time programming fairly well </I>&#151;<I> our Unixcompatible operating system (Idris) was hosted by that compiler. But it had next to no support for debugging, and it's no longer commercially available. Sic transit gloria mundi. </I>&#151; <I>pjp</I><P>

<h4><a href="../../../source/1995/sep95/letters.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
