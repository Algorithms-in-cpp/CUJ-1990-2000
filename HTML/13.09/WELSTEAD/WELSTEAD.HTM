

<HTML>
<HEAD>

<TITLE>September 1995/Data Object List Dialog for Windows</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Windows Programming</FONT></H2>

<hr><h2 align="center"><font color="#800000">Data Object List Dialog for Windows<A name="0126_00B3"><A name="0126_00B3"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0126_0000"><A name="0126_0000">Steve Welstead</font></h3><hr><blockquote><P>
<P><i><A name="0126_0000"><A name="0126_0000">Steve Welstead is a staff scientist with COLSA Corporation in Huntsville, Alabama, and an adjunct associate professor of mathematics at the University of Alabama in Huntsville. He holds a Ph.D. degree in applied mathematics from Purdue University. He is the author of Neural Networks and Fuzzy Logic Applications in C/C++, published by John Wiley &amp; Sons, Inc., in 1994, and he contributed the article "Scrolling List Dialog for Scientific Programming" to the April, 1994, issue of C/C++ Users Journal. He is currently working on a book on fractal imaging techniques in C/C++ for Windows. The author can be reached at COLSA Corporation, 6726 Odyssey Drive, Huntsville, AL 35806, or at 71773.2253@compuserve.com.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0126_00B4">Introduction<A name="0126_00B4"></FONT></h4></P>
If you have tried writing your own code for Windows dialog boxes, then chances are that you have dealt with the issues of designing resources, identifying dialog controls with program variables, and writing callback procedures to define dialog box functionality. Even with today's "expert" and "wizard" application-building tools this process can be tedious. This article describes how to build a type of dialog, the data-object list dialog, that can replace large complex input dialogs. This allows you to rapidly develop prototype Windows programs without getting bogged down in the details of dialog design.<P>
The data-object list dialog is based on a small C++ class library of dialogs that includes simple dialogs for commonly used data types as well as a list dialog class. The list dialog manages a list of data objects. Each data object knows how to update its own value through an appropriate input dialog. For example, string data objects call up a text input dialog, while objects representing RGB color values summon the standard Windows dialog for choosing colors. Once you have made the initial investment in designing this list dialog, you can provide your programs with a user input interface simply by inserting objects into the list. You don't need to design separate resources or callback procedures for each new application. The C++ class structure hides the issues of resources, control identifiers, and callback procedures. In the final section of this article, I will show how to implement the data-object list dialog in a simple <I>WinMain</I> application example.<P>
The C++ code presented is compatible for compilation as both 16-bit and 32-bit Windows executables. You should be able to produce executables for Windows 3.1, Win32, Windows NT, and hopefully Windows 95. This code does not use any proprietary C++ Windows class libraries such as Borland's OWL library or Microsoft's MFC library, though you can implement the concepts in those libraries. I have compiled and run this code using both Borland C++ v3.1 and v4.5, as well as Symantec's new C++ v7.0 compiler.<P>
<h4><FONT COLOR="#000080"><A name="0126_00B5">The Object List<A name="0126_00B5"></FONT></h4></P>
The object list is a simple C++ class that manages an array of pointers to objects. It is similar to a collection class in a container class library. This is the class I use to manage the items in the data-object list box. <A href="list1.htm">Listing 1</a>
shows the header file CWOBJ.H, which defines this class. The code for the object-list class is straightforward. Due to space limitations, it is not listed here, but is available on this month's code disk and <I>CUJ</I> online sources.<P>
The array <I>the_list</I> stores the actual array of pointers. This array uses indexes one through <I>max_count</I> for its items rather than the usual C indexing starting with zero. The member function <I>insert_item</I> inserts a new object at the designated index using this convention, while the member function <I>at</I> returns the object at a given index value. It is important to note that the calling program supplies allocated objects for each item in <I>the_list</I>.<P>
Since <I>object_list</I> does not allocate these objects, it does not destroy them either. (The calling program may, and probably will, want to use these objects after the <I>object_list</I> is destroyed.) Thus, <I>delete_item</I> does not actually delete the object at the given index, it only rearranges the list to skip over that item. Similarly, the destructor for <I>object_list</I> does not destroy items in the list, it only deletes the allocated array <I>the_list</I>.<P>
<h4><FONT COLOR="#000080"><A name="0126_00B6">Data Objects<A name="0126_00B6"></FONT></h4></P>
File CWOBJ.H also defines the object types that the data-object list dialog displays and manipulates. The class <I>tdata_obj</I> defines the basic data-object type. Each data object contains a pointer to a value (<I>value_addr</I>), a description string (<I>descr_addr</I>), and an item number that indicates its position in an object list.<P>
From <I>tdata_obj</I>, I derive the class <I>ttyped_data_obj</I>, which includes information about what type of data the object represents and how to update that data. <A href="list2.htm">Listing 2</a>
shows the file CWDATOBJ.CPP with the code for this class.<P>
The job of a <I>ttyped_data_obj</I> object is to allow the user to update the value of the data that the object represents, and to provide a string display of a description of this data and its current value. The function <I>value_str</I> formats the data value into a string, and the function <I>build_display_str</I> appends the value string to the description string for that item. The resulting string is what appears in the data-object list box. For example, suppose in a graphics program you had a <I>COLOR_DATA</I> item called "Line Color," and the current RGB values for this item were 255, 0, and 0 (pure red). The function <I>build_display_str</I> would produce the string:<P>
<pre>"Line Color: RGB(255,0,0)"</pre>
for this item, and this is what would appear in the list box.<P>
The typed data object obtains updates for its data value through the member function <I>get_new_value</I>, which presents to the user a dialog that is appropriate for that particular data type. The following sections discuss these dialogs in more detail.<P>
<h4><FONT COLOR="#000080"><A name="0126_00B7">Dialog Classes<A name="0126_00B7"></FONT></h4></P>
At this point, I need to build some C++ classes that will define basic dialog behavior. If you are working with one of the Windows C++ libraries, such as Borland's OWL or Microsoft's MFC, you may want to substitute the basic dialog classes from one of those libraries. <A href="list3.htm">Listing 3</a>
shows the header file CWDLG.H for these classes, and <A href="list4.htm">Listing 4</a>
shows the file CWDLG.CPP, which contains the source code for the base class <I>tdialog</I> and the derived class <I>tinput_dialog</I>.<P>
C++ classes provide a convenient means for dealing with resource scripts and data-handling issues. The base class <I>tdialog</I> does not have a resource script associated with it since this dialog does not have any real functionality. However, it does provide a member variable which descendant classes can use to store their resource identifiers.<P>
Member variables can also store the data that the dialog box obtains from the user. This allows you to associate the data with the dialog and avoid the use of global variables. You also avoid having to use that mysterious "extra" Windows parameter with its requirements for locking and unlocking local data. You can pass data to the dialog class through its constructor, and obtain updated values from the class object after dialog execution.<P>
It is somewhat more difficult to elegantly hide the issue of callback functions. The callback function defines the behavior of the dialog box, that is, how it responds to user input and system messages. Ideally, this function would be a member function of the dialog class. The problem is that when the dialog box is created, you must pass the address of the callback function to the Windows function <I>DialogBox.</I> C++ does not allow the address of a member function to be passed as a parameter, since this address is not known until a particular class object is instantiated at run time. Even using the <I>this</I> pointer in front of a class member function to indicate a particular instantiation of the class is not sufficient for the C++ police. The callback function needs to be a stand-alone function whose definition is external to any C++ class.<P>
To address this problem, I define a callback function for each dialog class which is external to that class. I also define a global pointer to that class that represents a particular object instance of that class. The callback function uses this global pointer to call a specific instance of a member function which defines the behavior of this dialog class. <A href="list4.htm">Listing 4</a>
illustrates this approach in file CWDLG.CPP. The callback function for the base class <I>tdialog</I> is called <I>tdialog_proc</I>, and there is a global <I>tdialog</I> pointer called <I>this_dialog.</I> Member function <I>handle_message</I> determines the behavior of the dialog by defining how it responds to Windows messages. This is what should be the callback function. Thus, <I>tdialog_proc</I> calls a specific instantiation of <I>handle_message</I>, namely the one belonging to the global <I>tdialog</I> object that <I>this_tdialog</I> points to.<P>
It is important to consider when to set the value of the global pointer used in the callback function. Member function <I>exec_dialog</I> makes the call to Windows that actually executes the dialog. It is here that the global pointer <I>this_tdialog</I> is set to the <I>this</I> pointer for the current instantiation of the dialog class object. Note that you don't want to set this pointer in the constructor for the class since any derived type will override the initial setting and reset the value to its own <I>this</I> value. This will cause problems if you have more than one dialog executing at one time. Also, <I>exec_dialog</I> saves the current value of the global pointer before resetting it and restores this value when it is done, in case there are two dialogs of the same class executing at one time.<P>
The first descendant class of <I>tdialog</I> is <I>tinput_dialog</I>, which takes text input from the user. Note that this dialog, as well as all other derived dialog classes, has its own global pointer <I>(this_input_dialog</I> in this case) and its own callback procedure <I>(tinput_dialog_proc)</I> defined external to the C++ class. The member function <I>exec_dialog</I> calls this procedure in the same way as was the case for the <I>tdialog</I> class.<P>
The class <I>tinput_dialog</I> uses the resource script named <I>INPUT_DIALOG</I>, which defines a simple dialog box with a single edit control with the identifier <I>ID_DLG_INPUT</I>, a default "OK" button, and a "Cancel" button. Resource scripts are not listed here, but are included with this month's code disk and from <I>CUJ</I> on-line sources.<P>
<h4><FONT COLOR="#000080"><A name="0126_00B8">Dialogs<A name="0126_00B8"></FONT></h4></P>
To use a C++ class, you need to create a particular instance of the class. For our dialog classes, this can be accomplished with a function that calls the class constructor for the particular dialog class, then executes the dialog. This function also initializes the data presented to the user, and brings input from the user back to the calling program. When the dialog terminates, this function obtains the data from the dialog class and then deletes the dialog class instance. The calling program never has to be aware of the existence of the C++ class.<P>
<A href="list5.htm">Listing 5</a>
shows the header file CWDIALGS.H for the three dialog functions used in the example discussed here. These are the dialog functions which the <I>ttyped_data_obj</I> member function <I>get_new_value</I> calls when updating the object data values. The function <I>string_dialog</I> instantiates the <I>tinput_dialog</I> class, and obtains string input from the user. <A href="list6.htm">Listing 6</a>,
 file CWINPDLG.CPP, shows the code for this function. Recall that class <I>tinput_dialog</I> has the capability to override the dialog-window caption and edit-control caption. The function <I>string_dialog</I> supplies these captions, using string parameters <I>dlg_title</I> and <I>descr.</I><P>
The two other dialog functions whose definitions appear in <A href="list5.htm">Listing 5</a>,
 <I>get_file_name_dlg</I> and <I>get_rgb_color,</I> are actually not based upon C++ classes. Rather, they call Windows common dialogs. The function <I>get_file_name_dlg</I> fills the Windows-defined structure <I>OPENFILENAME </I>and calls the Windows common dialog function<I> GetOpenFileName.</I> The function <I>get_rgb_color</I> fills the Windows structure <I>CHOOSECOLOR</I> and calls the Windows common dialog <I>ChooseColor</I>. The use of these structures and dialogs is fairly standard. You should be able to find examples of their use in the documentation for your Windows software development environment. For that reason, the code for these dialogs is not listed here, but is included with the other code in this month's disk, in the file CWCOMDLG.CPP.<P>
<h4><FONT COLOR="#000080"><A name="0126_00B9">List Dialog<A name="0126_00B9"></FONT></h4></P>
The list dialog class <I>tlist_dialog</I> displays an object list by implementing a Windows list-box control in a dialog box. <A href="list7.htm">Listing 7</a>,
 file CWLSTDLG.CPP, shows the code for the class <I>tlist_dialog</I> and its descendant <I>tdata_list_dialog</I>. The items in the <I>object_list</I> may be strings, as in a standard Windows list box, or they may be more complex structure or class types. The list box displays string descriptions of these more general items. The <I>tlist_box_data</I> parameter sent to the <I>tlist_dialog</I> constructor contains the object list pointer <I>item_collection</I> as well as an integer indicating the currently selected item in the list. Note that this means that <I>tlist_dialog</I> does not instantiate, nor does it destroy, the object items in the list. This is because in many cases, such as the data-object list dialog discussed below, you want the list items to have a life beyond that of the list dialog.<P>
The member functions of <I>tlist_dialog</I> implement list-box functionality by sending messages to Windows. Member function <I>set_data</I> fills the list box with strings representing each item in the object list, using strings obtained from <I>get_item_string</I>. The key to modifying the basic behavior of <I>tlist_dialog</I> to handle objects more general than strings is to override <I>get_item_string</I>.<P>
<h4><FONT COLOR="#000080"><A name="0126_00BA">Data-Object List Dialog<A name="0126_00BA"></FONT></h4></P>
The descendant class <I>tdata_list_dialog</I> (CWLSTDLG.CPP, <A href="list7.htm">Listing 7</a>)
 manipulates a list of objects of type <I>ttyped_data_obj</I> (CWOBJ.H, <A href="list1.htm">Listing 1</a>)
, rather than simple strings. In this case, the derived version of <I>get_item_string</I> calls the <I>ttyped_data_obj</I> member function <I>get_display_str</I> to obtain the string that will appear in the list box. <A href="fig1.htm">Figure 1</a>
shows a data-object list dialog with some sample strings obtained from <I>get_display_str</I>. The <I>tlist_dialog</I> member function, without any modification, takes care of inserting these strings in the list box. This is a good example of how C++ classes can ease the job of Windows programming.<P>
The data-object list dialog responds to a double-click on an item in the list by providing the user with an opportunity to update the value of that item. Objects of the class <I>ttyped_data_obj</I> know how to update their own values through the member function <I>get_new_value</I>. This function presents the user with a dialog box appropriate for updating the value of the data object. Thus, for example, items of type <I>STR_DATA</I> will call the dialog function <I>string_dialog</I> to obtain an updated text string from the user, while items of type <I>PATH_DATA</I> will summon the standard Windows file-opening dialog. After the user enters the new value, the list box shows that new value in the display string for that item.<P>
All of this is accomplished by having the list box respond to a <I>LBN_DBLCLK</I> message in <I>respond_wm_command</I> with a call to the <I>ttyped_data_obj</I> member function <I>get_new_value</I>, and then calling its own member function <I>set_data</I>, which resets the list box contents using the newly derived version of <I>get_item_string</I>. Notice the use of a macro to handle the <I>LBN_DBLCLK</I> message. This is one of the messages that is handled differently in 16- and 32-bit Windows.<P>
<h4><FONT COLOR="#000080"><A name="0126_00BB">An Example<A name="0126_00BB"></FONT></h4></P>
To implement a data-object list dialog in a Windows application, you need to define the variables you wish to obtain from the user and associate these variables with an object list. It is convenient, though not necessary, to collect these variables into a single structure. <A href="list8.htm">Listing 8</a>
shows file TSSETLST.H, which defines the structure <I>setup_record</I> containing three variables representing the different data types that the list dialog developed here can address. The function <I>init_setup</I> initializes this structure, and <I>setup_to_collection</I> inserts the structure variables into an object list. The code for these functions is contained in the file TSSETLST.CPP, <A href="list9.htm">Listing 9</a>.
<P>
Note that <I>setup_to_collection</I> instantiates a new <I>ttyped_data_obj</I> object for each variable in the <I>setup_record</I> structure, then inserts these objects into the object list. This object list is the <I>item_collection</I> that is inserted in the list dialog. To use a data object list dialog in a different application, all you need to do is change the definitions of <I>setup_record</I> and <I>setup_to_collection</I> appropriately.<P>
File TSTMAIN.CPP (<A href="list10.htm">Listing 10</a>)
 contains the <I>WinMain</I> function code for this example, which produces the application window shown in <A href="fig2.htm">Figure 2</a>.
 The menus are defined in the resource file DLGTEST.RC, which also includes resource scripts for the dialogs. There are two menu choices: a "Dialog" submenu with a single option tied to the identifier <I>IDM_DIALOG</I> which summons the list dialog, and a "File" submenu whose single option "Exit" terminates the program.<P>
<I>WinMain</I> takes care of registering and creating the main application window, as well as the message loop code that runs the program. In addition, this example contains function calls to initialize the list-box data, as well as code for deleting allocations associated with the list box when the program terminates. You should be particularly careful about cleaning up your allocations in a Windows program, since they will live on beyond the end of your program.<P>
The Window callback function <I>WndProc</I> creates and executes a data-object list dialog in response to the menu command identified by <I>IDM_DIALOG</I>. When the dialog terminates, the latest information is displayed in the window, including a rectangle filled with the color designated by the latest value of <I>g_setup.rect_color</I>.<P>
<A href="tab1.htm">Table 1</a>
lists the files needed to build the executable for this example. For 16-bit compilations, use the large memory model. For 32-bit executables, be sure to define the constant <I>WIN_32</I> at the top of the file CWDLG.H (<A href="list3.htm">Listing 3</a>)
.<P>
As you can see, the data-object list dialog gives you a convenient way of getting information from the user into your Windows program with a minimum of development effort. This is handy for small programs you write for your own use, and for prototype versions of larger programs. When you're ready to go to a full production version, you can replace the list dialog with a fancy dialog built with one of those "app wizard" resource workshops.<P>

<h4><a href="../../../source/1995/sep95/welstead.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
