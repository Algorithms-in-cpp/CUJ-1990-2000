


<HTML>
<HEAD>

<TITLE>February 1992/Data Compression Using Huffman Coding</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Algorithms</FONT></H2>

<hr><h2 align="center"><font color="#800000">Data Compression Using Huffman Coding<A name="0063_0020"><A name="0063_0020"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0063_0000"><A name="0063_0000">Dwayne Phillips</font></h3><hr><blockquote><P>
<P><i><A name="0063_0000"><A name="0063_0000">Dwayne Phillips works as a computer and electronics engineer with the United States Department of Defense. He has a Ph.D. in electrical and computer engineering at Louisiana State University. His interests include computer vision, artificial intelligence, software engineering, and programming languages.</i></P><P>
One of the best known data compression schemes is Morse code. Morse code uses few dots and dashes for frequently occurring letters such as <I>e</I> and <I>t</I>, and more dots and dashes for infrequent letters such as <I>x</I> and <I>z</I>. Compare this scheme to the ASCII code which uses seven bits for all the letters and symbols. The ASCII code is clearly inferior when it comes to the length of a message.<P>
Huffman coding <a href="#ref1">[1]</a> uses an idea similar to Morse code. In Huffman coding, you represent frequently occurring characters with a small number of bits, and infrequent characters with a larger number of bits. We could always represent the character <I>t</I> by 01 instead of 1100001 (ASCII), <I>e</I> by 10 instead of 1100101 and so on. This would save space, but some files do not contain any <I>t</I>'s or <I>e</I>'s and these short codes could be used for other characters. Adaptive coding solves that problem. In adaptive coding, you examine a file, count the occurrences of each character, and create a code unique to that file.<P>
To compress a file using Huffman coding you (1) examine the file and count the occurrences of characters, (2) create a new code for the characters in the file, and (3) code the file using the new codes. To decompress a file, you (1) read the unique code for the file, (2) read the compressed file, and (3) decode the compressed file using the unique code. The trick in this process is creating the new code and packing and unpacking bits. The source code presented later will illustrate how to do that.<P>
Huffman coding attempts to create a minimum redundancy code, that minimizes the average number of bits per character. Let <I>N</I> = number of characters (256 for eight bit codes) and <I>P(i)</I> = probability of the <I>i</I>th character occurring. This yields equation 1.
<P>
Equation 1:<P>
<IMG SRC="equat1.gif"><P>
We let <I>L(i)</I> = number of bits to represent the ith character and we want to minimize the average number of bits needed to code a file as shown in equation 2.
<P>
Equation 2:<P>
 <IMG SRC="equat2.gif"><P>
There are two rules to follow when using Huffman coding. First, the code for each character must be unique. Second, there will be no start of code or end of code once the stream of bits begins. In ASCII you know when the code for each character starts because they are all seven bits long. When you've coded a file using Huffman coding, however, the codes for each character have different lengths (some are two bits, some three bits, and so on). If you have a start of code marker, you will waste space and defeat the purpose of data compression.<P>
In order to follow the second rule, you must abide by the first. This means that no code can be the prefix of another code. The code for each character must be unique. For example, if you represent an <I>a</I> by 01 and a <I>b</I> by 1, then the bit stream 011101101 can be decoded to <I>abbaba</I>. Now suppose we needed a code to represent <I>c</I>. We cannot represent <I>c</I> by 10 because the code for <I>b</I> (1) is a prefix of the code for <I>c</I> (10). In such a case, the stream 011101101 could either be <I>abcbcb</I> or <I>abbaba</I>. To correct this confusion, you could represent <I>a</I> by 01, <I>b</I> by 1, and <I>c</I> by 00. The prefix condition is not violated and there will not be any confusion when it's time to decompress the bit stream.<P>
There is one more derived rule for Huffman coding. The following equation states mathematically that the most frequently occurring characters will have shorter codes. If two characters occur with the same frequency, then their codes will be equal or differ only by one bit.<P>
<pre>if <I>P</I> <I>(a) </I><I> P (b) </I><I> P (c) then L (a) </I>&gt;=<I> L (D) </I>&gt;=<I> L</I></pre>
<A href="fig1.htm">Figure 1</a>
and <A href="fig2.htm">Figure 2</a>
illustrate the creation of Huffman codes. <A href="fig1.htm">Figure 1</a>
shows a simple example. Suppose there is a file containing 10 <I>as</I>, five <I>c</I>s, and three <I>b</I>s. <A href="fig1.htm">Figure 1</a>
shows the characters in the file arranged with the most frequent letter at the top and with the number of occurrences next to each character. You begin coding at the bottom with the least frequently occurring characters.<P>
You link characters <I>b</I> and <I>c</I> by adding their numbers of occurrences and connecting them with a line. You give the least occurring letter (<I>b</I>) a <I>1</I> bit and the most occurring letter (<I>c</I>) a <I>0</I> bit. In the next step you link letter <I>a</I> with the <I>bc</I> combination. You give the <I>bc</I> combination a <I>1</I> bit and the <I>a</I> a 0 bit. The codes for these characters are read backwards from right to left. The new code for <I>a</I> is 0. The new code for <I>b</I> is 11 and for <I>c</I> is 10.<P>
Now, if a part of the input file contained <I>abcaaaccb</I>, the coded bit stream would be 0-11-10-0-0-0-10-10-11. This required only 14 bits. The ASCII coding (seven bits per character) would require 63 bits. The entire file of 18 characters would only require 26 bits instead of 126 bits. The compressed coding requires only 26/126 = 20.6 percent as much space. (There is, however, the question of how to store the new code (<I>a</I>=0 <I>b</I>=11 <I>c</I>=10) at the front of the compressed file without taking too much space.) Notice that the most frequently occurring character, <I>a</I>, has the shortest code. Using equation 1
and equation 2,
 the average number of bits per character is 1.44 instead of 7 for ASCII.<P>
<A href="fig2.htm">Figure 2</a>
shows a more complicated example. The coding process begins at the bottom. Everything proceeds as before until you link <I>c</I> with the <I>def</I> combination. At this point both <I>a</I> (10) and <I>b</I> (8) occur less frequently than the <I>cdef</I> combination (12) so you must link <I>a</I> and <I>b</I>. After this you may link the <I>ab</I> combination with <I>cdef</I>. You read the new codes backwards from right to left and the result is shown at the bottom right of the figure. Again, using equations 1 and 2, the average number of bits per character is 2.46 instead of 7 for ASCII.<P>
Now let's look at some code listings. <A href="list1.htm">Listing 1</a>
shows the <I>include</I> file for the program. Note the three data structures. The first structure, <I>item_struct</I>, is used inside the program to create the new codes, code the characters in the input file, and decode the bit stream in the compressed file. This structure is easy to use inside the program, but is too long to store as the header to the compressed file. The second, <I>header_struct</I>, is the one stored as the header to the compressed file. It requires much less space than the <I>item_struct</I> and still holds enough information to allow the compressed file to be decompressed. This scheme enables you to experiment with different types of file headers to store with the compressed file. If you can create a shorter, more efficient file header, then you only need to change the conversion routines and the read and write routines. If you used only one structure for internal use and the file header, then you would need to change code throughout the program whenever you thought of a better file header. The third structure in <A href="list1.htm">Listing 1</a>
is the constant <I>CODE_LENGTH</I>. This gives the maximum number of bits you can use for a new code. This may not be big enough if you are compressing a large file that has some very infrequent characters. The more infrequent the character the longer its code. If you have problems with large files you may need to increase this to 24 or 32.<P>
<A href="list2.htm">Listing 2</a>
shows the main routine of the program and several other functions. The main routine interprets the command line and starts the compression or decompression process. The function <I>read_input_file_and_create_histogram</I> performs the first step of compression. It reads through the entire uncompressed file and records the number of occurrences of each character. This information will be passed to the functions in <A href="list3.htm">Listing 3</a>
which will then create the new code. This points out one of the disadvantages of Huffman coding. In Huffman coding you must read the file twice. The first time you count occurrences of characters and the second time you code the characters.<P>
Also shown in <A href="list2.htm">Listing 2</a>
are the functions <I>convert_short_to_long</I> and <I>convert_long_to_short</I>. These functions convert the long <I>item_struct</I> to the shorter <I>header_struct</I> discussed previously. If you create a better file header for the compressed file, then you need to change these two conversion functions.<P>
<A href="list3.htm">Listing 3</a>
shows the functions that perform the second step of compression. They take the number of occurrences of each character and create the new code for this particular file. The function <I>create_huffman_code</I> is the controlling routine for this process. It first sorts the <I>item_array</I> so the most frequent characters are at the "top" and the least frequent are at the "bottom" as in the examples of <A href="fig1.htm">Figure 1</a>
and <A href="fig2.htm">Figure 2</a>.
 Next, it disables the characters that do not occur in the input file. There is no need to process those characters. Finally, it goes into a while loop of linking or combining the two smallest items in the <I>item_array</I> until they are all linked. Most of the functions in <A href="list3.htm">Listing 3</a>
search the <I>item_array</I>, and find the characters to be linked.<P>
The key functions in <A href="list3.htm">Listing 3</a>
are <I>code_smallest_item</I> and <I>code_next_smallest_item</I>. They attach the <I>1</I>'s and <I>0</I>'s to the characters. The difficult part of this task is propagating the <I>1</I>'s and <I>0</I>'s to all the characters linked together. Notice in <A href="fig2.htm">Figure 2</a>
that when <I>cdef</I> was linked to <I>ab</I>, the <I>1</I> assigned to <I>c</I> propagated down to <I>d</I>, <I>e</I>, and <I>f</I>. At the end of <I>code_smallest_item</I> the program loops through the <I>item_array</I> looking for links to other characters. If it finds a link, it calls itself recursively using the link (<I>code_next_smallest_item</I> does the same operation). The function <I>combine_2_ smallest_items</I> created these links using the .<I>includes</I> part of the <I>item_array</I>.<P>
<A href="list4.htm">Listing 4</a>
shows the final step of compression. These functions use the new codes to code the input file into a compressed bit stream and write this to a file. The function <I>code_and_write_output_file</I> controls the process. It reads a character from the input file, uses the new code for that character to set bits in the output buffer, and writes the output buffer to the output file. One thing to watch in the output process is to wait until the bit stream in the output buffer is on a byte boundary before writing to the file. The last section of code in this function performs that task.<P>
The key functions in <A href="list4.htm">Listing 4</a>
are <I>code_byte, set_bit_to_1</I>, and <I>clear_bit_to_0</I>. The <I>code_byte</I> function looks at the character to code, finds its new code, and calls the other two functions to set the bits in the output buffer. The bit setting functions set or clear a particular bit in the output buffer. They use bit masks defined in the <I>include</I> file and bit-wise AND or bitwise OR the mask with a byte in the output buffer.<P>
<A href="list5.htm">Listing 5</a>
shows the code to decompress a file. Decompression is easier and quicker than compression. The new code already exists so you only need to reverse the last step of the compression process. The function <I>decode_compressed_file</I> controls the process. The first step is to read the new codes from the file header. This comprises a file read and then a call to <I>convert_short_to_long</I> to put the header into the <I>item_struct</I> format.<P>
The function <I>decode_file_and_write_output</I> performs the last two steps of the decompression process. It decodes the compressed bit stream and writes the characters to the output file. To decode the compressed bit stream you must look at the codes read from the file header and compare them one by one to the bit stream. Recall that the codes are all unique and the prefix condition must hold. Therefore, if you start at one end of the <I>item_struct</I> and compare each code to the first bits in the bit stream, you will find a match. The program uses two functions to do this. The function <I>convert_bits_to_char</I> looks at the bit stream and translates the <I>1</I> and <I>0</I> bits to ONE and ZERO character constants. The function <I>decode_bits</I> uses this stream of characters to search through the <I>item_struct</I>. This makes the comparisons easier because the <I>item_struct</I> holds the codes as characters. The <I>convert_bits_to_char</I> function examines each bit using a shift bit and compare operation. This requires less code than the set bit functions discussed earlier.<P>
The <I>decode_bits</I> function looks at the input bits, matches them to a code in the <I>item_struct</I>, and puts the decoded character in the output buffer. This operation requires searching through the <I>item_struct</I> until you find a code that matches the first bits in the bit stream. A <I>strncmp</I> performs the comparisons. When the <I>decode_bits</I> finds a match, it writes the decoded character to the output buffer.<P>
This process of reading compressed bits, matching the codes, and writing out the decoded characters continues until the compressed file is empty. At that time the decompression process is finished.<P>
There is always room for improvement in a program. The objective of this program is to compress files. The biggest place for reducing the size of the compressed file is in the file header. This must store the new codes for the characters in the original file. The <I>header_struct</I> shown in <A href="list1.htm">Listing 1</a>
contains 4,356 bytes. This can no doubt be smaller. One idea is to keep only those characters that occurred in the message instead of all 256. Another idea is to pack the codes into bits instead of characters. The program is designed to allow experiments in this area. The <I>item_struct</I> is used internally so you do not need to make code changes everywhere. When you are ready to try a new file header, change the conversion routines in <A href="list2.htm">Listing 2</a>
(<I>convert_long_to_short, convert_short_to_long</I>) and the write and read routines in <A href="list4.htm">Listing 4</a>
and <A href="list5.htm">Listing 5</a>,
 (<I>output_file_header</I>) and (<I>input_file_header</I>).<P>
<h4>Reference</FONT></h4></P>
<a name="ref1">1.</a>     Huffman, David, "A Method for the Construction of Minimum-Redundancy Codes," Proceedings of the IRE, Vol. 40, No. 9, pp. 1098-1101, 1952.<P>

<h4><a href="../../../source/1992/feb92/phillips.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
