


<HTML>
<HEAD>

<TITLE>February 1992/Nearest Neighbor Algorithm For Color Matching</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Algorithms</FONT></H2>

<hr><h2 align="center"><font color="#800000">Nearest Neighbor Algorithm For Color Matching<A name="0056_001C"><A name="0056_001C"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0056_0000"><A name="0056_0000">Geoffrey Probert</font></h3><hr><blockquote><P>
<P><i><A name="0056_0000"><A name="0056_0000">Geoffrey Probert has been programming in C for nine years. He currently works at Aztek Engineering. He can be reached at (303) 466-9710 or (303) 786-9100 ext. 144.</i></P><P>
A problem generally referred to as a nearest neighbor, or closest neighbor, problem begins with a fixed set of points whose locations are all known. When given a new point, you must find the nearest point in the original population to that new point. Most beginning programmer text books deal with the one-dimensional version of the nearest neighbor problem. They solve the problem by sorting the elements and then doing a binary search. Text books do <I>not</I> usually deal with the multi-dimensional version of this problem. This article will discuss an approach guaranteed to find the nearest neighbor to a point in a multi-dimensional space.<P>
<h4><FONT COLOR="#000080"><A name="0056_001D">The Problem<A name="0056_001D"></FONT></h4></P>
In my application, I needed to display an image on a VGA screen (640 pixels by 480 lines with 256 colors) that was originally 768 pixels by 512 lines with 256 colors. Since the palette for the original image already existed, it seemed best to keep that same palette. For each of the pixels in the VGA image, I computed the red, green, and blue values using bilinear interpolation as shown in <A href="fig1.htm">Figure 1</a>
(see "Resampling Methods for Image Manipulation" by Girish T. Hagan in the August 1991 issue of <I>C Users Journal</I>). After computing the red, green, and blue values, I needed to select the color from the palette that was the closest match to the computed values.<P>
The first approach to this problem is the brute force method. This involves computing the distance from each of the desired values to all of the available neighbors. If I am generating an image of 640 pixels by 480 lines with a palette of 256 colors, the distance must be calculated 78.6 million times. This takes a considerable amount of time even on a fast CPU and inspires the search for a faster algorithm. I approached this problem with an algorithm that limits the number of distance calculations and comparisons.<P>
The algorithm contains two parts. The first part initializes data and structures. It does this once before any searching for a nearest neighbor. The second part actually searches for the nearest neighbor for each new pixel being generated.<P>
<h4><FONT COLOR="#000080"><A name="0056_001E">Two-Dimensional Problem<A name="0056_001E"></FONT></h4></P>
To visualize the algorithm more easily, look at the two-dimensional problem first. In the preparation phase, I proceed just as in a one-dimensional problem. I sort all of the neighbors using just one of the dimensions, say X. Since I am sorting the neighbors, I must also bring along the values for the rest of the dimensions (Y in the two-dimensional case).<P>
The search phase is a two part process. First I must find the nearest neighbor using just the single dimension I originally sorted on, in this case X. This neighbor becomes the initial estimate. The program computes and stores the distance from this initial estimate to the real point as the shortest distance. Next, I begin to search to the left and to the right, in X, of the initial estimate. At each of these points the program computes the distance to the real point. If it is less than the shortest distance so far, then it becomes the new shortest distance. The trick is to end the search before searching all of the points. To do this, the program also computes the distance in the sorted dimension only (X). Once this distance is greater than the shortest distance for both the left and right sides, I know that no more points need to be looked at. The nearest neighbor corresponds to the point that had the shortest distance to the desired point.<P>
<h4><FONT COLOR="#000080"><A name="0056_001F">Two-Dimensional Example<A name="0056_001F"></FONT></h4></P>
The example in <A href="fig2.htm">Figure 2</a>
illustrates this concept. There are nine neighbors, each indicated by a dot. An X indicates the desired location at (6,2). Assume the sort along the X dimension has been done.<P>
The sort along the X dimension results in an initial estimate at the point (6,7). The distance to this point is 5, initially the shortest distance.<P>
The first point to be examined would be to the left of the initial estimate, at (5,5). The X distance is 1, which is less than the shortest distance, 5. Therefore I compute the distance, <I>sqrt(10)</I>, to this point. This is less than the shortest distance and therefore replaces the shortest distance.<P>
The next point to be examined is to the right of the initial estimate and is at (7,4). The X distance is 1, which is less than the shortest distance, <I>sqrt(10)</I>. Therefore I compute the distance, <I>sqrt(5),</I> to this point. This is less than the shortest distance and therefore replaces the shortest distance.<P>
The next point to be examined is to the left of the initial estimate and is at (4,5). The X distance is 2, which is less than the shortest distance, <I>sqrt(5)</I>. Therefore I compute the distance, <I>sqrt(13)</I>, to this point. This is greater than the shortest distance and therefore does not replace the shortest distance.<P>
The next point to be examined is to the right of the initial estimate and is at (8,5). The X distance is 2, which is less than the shortest distance, <I>sqrt(5)</I>. Therefore I compute the distance, <I>sqrt(13)</I>, to this point. This is greater than the shortest distance and therefore does not replace the shortest distance.<P>
The next point to be examined is to the left of the initial estimate and is at (3,4). The X distance is 3, which is greater than the shortest distance, <I>sqrt(5)</I>. Therefore I can quit searching to the left of the initial estimate.<P>
The next point to be examined is to the right of the initial estimate and is at (9,4). The X distance is 3, which is greater than the shortest distance, <I>sqrt(5)</I>. Therefore I can quit searching to the right of the initial estimate. I have finished searching to both the left and the right of the initial estimate, therefore the nearest neighbor has been found at (7,4) with a distance of <I>sqrt(5)</I>.<P>
<h4><FONT COLOR="#000080"><A name="0056_0020">Color Matching, Three Dimensions<A name="0056_0020"></FONT></h4></P>
In the application that I was working on, an image was being generated for display at 640 pixels by 480 lines by 256 colors. The palette was already present with the original image. The individual color values ranged from 0 to 255. These would later be scaled for the VGA palette which ranges from 0 to 63. The size of my arrays and structures were designed to handle the larger range of 0 to 255. I used the "red" dimension for my sort.<P>
<A href="list1.htm">Listing 1</a>
declares the global variables needed by the routines. In order to generate new pixels by interpolating from the original image, a copy of the original palette (<I>palo</I>) must be kept to have access to the original colors. The copy of the palette is named <I>pals</I>. It carries along the index of the original palette entry in <I>num</I>. This allows the original palette in the original order to be used for the new image. To speed things up, the square of the distance between points was computed rather than the actual distance.<P>
To speed up the acquisition of the initial estimate, another array was initialized during the preparation phase. Since there were only 256 possibly values in the sorted dimension, I generated an array named <I>redindex</I> that would immediately index into the sorted palette for the initial estimate.<P>
<A href="list2.htm">Listing 2</a>
details the initialization phase. The routine <I>sort_color</I> makes a copy of the original palette and uses <I>qsort</I> to sort on the red dimension. The routine <I>color_comp</I> is the comparison routine for <I>qsort</I>. After sorting <I>pals</I>, the program generates the indexing array <I>redindex</I>. To do this, it uses two indices, one to step through <I>redindex</I>, and the other to step through <I>pals</I>. It sets each value in <I>redindex</I> to the closest value there is in <I>pals</I>.<P>
<A href="list3.htm">Listing 3</a>
does the actual search for the nearest neighbor. It finds the initial estimate in <I>redindex</I> and computes the shortest distance for it. My search looks at one possibility on the left and then at a possibility on the right. The program computes the "red distance" followed by the real distance, if applicable. <A href="list3.htm">Listing 3</a>
also provides tests to make sure the search remains within the bounds of <I>pals</I>. The <I>dist</I> routine computes the square of the distance between a palette entry and the desired red, green, and blue values.<P>
<h4><FONT COLOR="#000080"><A name="0056_0021">Summary<A name="0056_0021"></FONT></h4></P>
This algorithm is over 45 times faster than the brute force method would be in my application. Stopping the search before all possible values were examined contributed the most to this increase in speed. Using <I>redindex</I> to get a quick initial estimate also contributed significantly.<P>
This algorithm should be applicable to any multidimensional nearest neighbor problem. One word of caution: if your data is clumped in one dimension and spread out in another, you should sort along the spread out dimension. This will speed up the search algorithm.<P>

<h4><a href="../../../source/1992/feb92/probert.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
