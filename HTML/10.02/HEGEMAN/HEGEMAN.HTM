


<HTML>
<HEAD>

<TITLE>February 1992/Arithmetic In Factorial-Base</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Arithmetic In Factorial-Base<A name="0075_0022"><A name="0075_0022"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0075_0000"><A name="0075_0000">Frederick W. Hegeman</font></h3><hr><blockquote><P>
<P><i><A name="0075_0000"><A name="0075_0000">Frederick Hegeman is an amateur programmer and<I></I> <I></I>computer language hobbyist. He can be reached at P.O.<I></I> <I></I>Box 2368, Rapid City, SD 57709, telephone (605)<I></I> <I></I>343-7014.</i></P><P>
C takes a machine-oriented approach to numbers; its arithmetic types are coupled to the physical architecture of the processor. Arithmetic operations on <I>int</I>s<I>, long</I>s, and <I>double</I>s use a compact representation and provide fast and well-defined performance. The cost is limits on the magnitude and accuracy of operands and results.<P>
Other languages take a less mechanical approach. Common Lisp supports <I>bignums</I>, integral values limited only by available memory, and ratios, rational values which allow exact computations by storing separate integral valued numerators and denominators (which can be <I>bignums</I>, of course).<P>
For C applications that need to operate beyond the restraints imposed by <I>float.h</I> and <I>limits.h</I>, similar types could be coded, but doing so would be a nightmare. What kind of code would be required to compare (4129181559/4294967296) to (449/467)? To multiply or divide them? Even worse, memory usage could grow without limit, up to the point where the program fails.<P>
Happily, there is a more practical approach that works within bounded memory and almost allows computation to unlimited magnitude and perfect accuracy.<P>
<h4><FONT COLOR="#000080"><A name="0075_0023">Factorial-Base Arithmetic<A name="0075_0023"></FONT></h4></P>
Any rational number can be represented exactly in a number system based, not on increasing powers of a particular number (e.g., 10<SUP>0</SUP>,10<SUP>1</SUP>, 10<SUP>2</SUP>, ...), but on the series of factorial numbers, (1!, 2!, 3!, ... ). Any integer in any static-base system can also be represented in factorial-base.<P>
The decimal integer <I>231</I> can be represented as 2x10<SUP>2</SUP>+3x10<SUP>1</SUP>+1x10<SUP>0</SUP> or as 1x5!+4x4!+2x3!+1x2!+1x1!. And any rational fraction has an exact representation in factorial-base, even if infinitely repeating in a static-base.<P>
The ratio 1/3 can be represented as<P>
<IMG SRC="equat1.gif"><P>
Whatever numbers a computer manipulates must be rational numbers. If I type in 3.1415926535897932384, I am not typing in p, but a rational approximation. I can't calculate the square root of 2; I can calculate a rational number than approximates it. Every operand that can be used, and every result that can be returned, is a rational number. I find it ironic that Georg Cantor, who discovered those computer incompatible values, the transfinite number, was also responsible for factorial-base representation. In Cantor's scheme every number that can be computed by machine can, given the resources, be computed exactly.<P>
The limiting resources of the factorial-base system are memory and the implementation language. The language is the most important factor. Time, in theory, is not a factor. Memory is the limiting factor only for very small systems such as micro controllers. In C, the limiting factor is related to the integer square root of <I>LONG_MAX</I>. Because ANSI conforming compilers are allowed generous amounts of slack, the limiting value may be one less than the quotient of <I>INT_MAX</I> divided by <I>sizeof(long)</I>. For a subset without <I>long</I>s, the limits are set by the integer square root of <I>INT_MAX</I>.<P>
<h4><FONT COLOR="#000080"><A name="0075_0024">Representing Factorial-Base Numbers In C<A name="0075_0024"></FONT></h4></P>
Factorial-base numbers have a natural representation in C as arrays of some signed integral type. Consider the representation of decimal <I>231</I> given previously. The value of each factorial place is an integer to be stored in a separate element of the array. Arrange things so that references begin at array[1], rather than at array[0], and the subscripts track the factorial places<P>
<pre>int factorial_integer[6] = {0,1,1,2,4,1};</pre>
Likewise for the ratio <I>1/3</I><P>
<pre>int factorial_fraction[4] = {0,0,0,2};</pre>
To represent the real number <I>231</I> + <I>1/3</I>, some scheme is needed to keep track of both parts. Declaring a <I>struct</I> with members to hold the separate arrays does so in a straightforward manner. However, since many subset compilers, and cross compilers, do not implement <I>struct</I>s and since the idea of a tiny controller limited to eight-bit "words" calculating to the limits of 10! and 1/10! has a certain charm, I chose to implement both parts in a single array, as illustrated in <A href="fig1.htm">Figure 1</a>.
<P>
The numbers are represented in a sign and magnitude scheme. The equivalent of 2's complement simply does not exist and since the subscript 0 is free, it holds the sign. The factorial-base integer follows. Each element of the integer portion will hold a maximum value equal to its subscript. If it ever happens that the value exceeds the subscript, the number can be rearranged so that it does not. Consider array element <I>2</I>, which represents <I>2!</I>. The maximum entry it should hold is <I>2</I>. The value of <I>2</I> at subscript <I>2</I> is <I>2*2!</I>. Suppose the entry at element <I>2</I> was <I>3</I> &#151; the value of <I>3</I> at subscript <I>2</I> would be <I>3*2!</I>. That is the definition of <I>3!</I>, and the number can be normalized by representing it in terms of <I>3!</I>. Note that it is not necessary to actually calculate the value of <I>3!</I>.<P>
Consider that the subscript <I>i</I> references the <I>i</I>th factorial "digit". What is the maximum value for <I>i</I>? Suppose the number is represented as an array of <I>int</I>s. The element <I>i</I> may have to temporarily contain the value of <I>(i+1)*i</I> before being normalized. This value must be representable as a positive <I>int</I>, and must not be allowed to suddenly turn negative, in order to propagate a carry value into the guard, <I>G</I>, and mark integer overflow. Since we are using <I>int</I>s<I>, (i+1)*i</I> cannot exceed <I>INT_MAX</I>. Assume <I>INT_MAX</I> is <I>32767</I> and the maximum value of <I>i</I> is <I>180</I>, or 1 less than the integer square root of <I>INT_MAX</I>.<P>
The rest of the array contains the factorial-base fraction. Consider it as a separate array beginning at <I>&amp;array[G]</I><I>.</I> The value of factorial place <I>1</I>, at subscript <I>G+1</I>, is some integer <I>x/1!</I>, which is the same as <I>x*1!</I>, which is the same as <I>x</I>. This subscript is referenced to propagate carrys and borrows from the fraction part to the integer part during normalization. Otherwise, the array value at subscript <I>G+1 is</I> <I>0</I>.<P>
The remaining array elements represent the fraction proper. Each element will hold a maximum value equal to 1 less than its subscript relative to <I>G</I>. The maximum subscript (relative to <I>G</I>) is 1 less than the integer square root of <I>INT_MAX</I>. Underflow, or loss of significance, spills into subscript <I>G2</I>.<P>
Now, assume the number is represented an array of <I>longs</I> and <I>LONG_MAX</I> is 2147483647. Most applications will not use up 46,339 factorial places. ANSI conforming compilers need only provide objects, including arrays, of up to 32,767 bytes and since each array element uses 4 bytes, arrays of at least 8,191 <I>longs</I> are presumably available.<P>
<h4><FONT COLOR="#000080"><A name="0075_0025"><I>facbase.c<A name="0075_0025"></I></FONT></h4></P>
Procedures and declarations for factorial-base numbers, the operations +, --, /, *, conversion to and from ASCII decimal, and support functions, are in <A href="list1.htm">Listing 1</a>.
 Since that code contains only simple macros and no <I>struct</I>s<I>, union</I>s<I>, long</I>s, or pointers to anything more exotic than <I>char</I>s and <I>int</I>s, it should compile under even the most rudimentary systems.<P>
Only two things might lead to trouble on a system. First, some subset compilers may not allow compile-time initialization of arrays and variables. In that case, a short routine will have to be written to do runtime initialization of the integer variable <I>nowarning</I> and the constant arrays<I> zero[]</I> and <I>one[]</I>. The second problem may be lack of stack space. Some of the routines can use prodigious amounts of stack. On systems that allot a fixed amount of memory for use as a program stack, it may be necessary to declare all or most of the temporary numbers as static arrays, rather than the default to auto.<P>
As described above, either integer or fractional parts can be adjusted freely up to about 180 factorial digits. The system is written for 100 factorial digits in both integer and fractional parts for the simple reason that the values of factorials in that range can be checked against the tables in the Chemical Rubber Co. <I>Standard Mathematical Tables</I>.<P>
If some of the code looks oddly familiar, it is because operations on factorial-base numbers built around arrays are almost exactly the same as binary operations on arrays of bits. Shifting left and right are different because they are done by overt multiplication and division, while binary operations shift left and right in order to multiply and divide quickly. The only routine that might seem totally unfamiliar is the normalization routine that cleans up after operations. The software must mimic normalization usually performed in silicon.<P>
In the absence of overflow or underflow, mathematic operations in factorial-base are exact. No rounding or truncation need ever be performed except when converting to a static-base on output. This code converts to decimal. To the limits of the system, the maximum error of any computation, no matter how large or how small the result, need never be greater than  .5 units in the last place <I>displayed</I>. The actual results can always be exact and no errors propagate through a series of calculations. (Rounding to nearest, as that implies, might not be as appropriate as rounding towards zero or always rounding towards  x. Note that the code provided truncates, rather than rounds.)<P>
Included at the end of <A href="list1.htm">Listing 1</a>
is code for a simple and slow RPN calculator program, which compiles when <I>DEBUG</I> is <I>#define</I>d. The calculator includes a routine to display a factorial-base number in factorial-base. Factorial-base integers are well-behaved but factorial-base fractions are confusing unless viewed as separate digits. Consider the infinite series for <I>e</I>:<P>

<IMG SRC="equat2.gif"><P>

The series can be coded directly into an array, normalized, and printed out. If the fraction is 100 factorial digits, it will print out correctly to 159 decimal places. On the other hand, .<I>000 000 000 000 000 000 000 000 1</I> will underflow; it only has an exact representation in 105 factorial digits. Note, though, how it prints in decimal after underflow. If the fraction is 180 factorial digits, the value of <I>e</I> prints out correctly to 333 decimal places, <I>1.0E</I>--<I>44</I> requires all 180 factorial digits and <I>1.0E</I>--<I>45</I> underflows.<P>
<h4><FONT COLOR="#000080"><A name="0075_0026">Conclusion<A name="0075_0026"></FONT></h4></P>
The factorial-base arithmetic is not practical for recalculation of a spreadsheet. But, for applications where accuracy is more important that speed, factorial-base arithmetic may be the answer. For programs that need to deal in exact fractions, factorial-base arithmetic is probably a good choice.<P>
Suppose you want both fast and accurate arithmetic. You have what you think are fast and simple algorithms that perform calculations correct to 20 decimal places. Or do they? How do you verify that? How do you debug your code? Don't dismiss factorial-base math out of hand as too slow for practical applications.<P>
<h4><FONT COLOR="#000080"><A name="0075_0027">Bibliography<A name="0075_0027"></FONT></h4></P>
Wayner, Peter. "Error-Free Fractions," <I>BYTE</I>, Vol. 13, No. 6, June, 1988, pp. 289-298. Presents a limited implementation in Pascal and cites a submission to CACM that has not yet appeared.<P>
The Chemical Rubber Co., <I>Standard Mathematical Tables</I>, 18th ed., Cleveland, OH, 1970. Later editions have slimmed down, but earlier ones like this contain exact values for factorials up to 20!<P>
Wozniak, Stephen. "The Impossible Dream: Computing e to 116,000 Places with a Personal Computer," <I>BYTE</I>, Vol. 6, No. 6, June, 1981, Pp. 392-407. Where else can you find the value of e printed out to 1,500 decimal places?<P>

<h4><a href="../../../source/1992/feb92/hegeman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
