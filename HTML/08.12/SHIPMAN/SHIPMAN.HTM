


<HTML>
<HEAD>

<TITLE>December 1990/Debugging With Two Monitors</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Device Control</FONT></H2>

<hr><h2 align="center"><font color="#800000">Debugging With Two Monitors<A name="0272_0162"><A name="0272_0162"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0272_0000"><A name="0272_0000">Art Shipman</font></h3><hr><blockquote><P>
<P><i><A name="0272_0000"><A name="0272_0000">Arthur Shipman is a computer consultant working in the upstate New York area. He has a B.A. in mathematics from Mt. St. Mary College. He writes in Assembler, BASIC, and C on MS-DOS machines. You can contact him at P.O. Box 390, Westbrookville, NY 12785.</i></P><P>
When I graduated from my Commodore 64 to an AT clone, the clone came with a monochrome monitor and an EGA card. I later upgraded to a Nanao Flexscan color monitor, leaving me with an unused monochrome monitor. So I picked up a second video card, and now have a dual-monitor system.<P>
For a long time my monochrome monitor sat idle and blank. Aside from Lotus 1-2-3, I found only two utilities that take advantage of a dual monitor system. (See the <A HREF="sidebar1.htm">"Utilities For A Second Monitor"</A> sidebar.) Then, as my C skills improved, I realized that I could easily exploit the second monitor for debugging my code. All I needed was a set of functions that would write directly to the second monitor.<P>
The self-contained file <I>mono.c</I> (<A href="list1.htm">Listing 1</a>)
 provides all the functions needed for constant feedback, status, and debugging reports on the monochrome monitor of an IBM-compatible while a program is running on the color screen. <I>mono.c</I> provides two functions comparable to standard C output functions: <I>mono(), </I>a variant of<I> puts()</I>, and <I>mprintf(), a printf()</I> to the mono monitor.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
I created these functions as debuggers, not as normal display functions. This is a no-frills package. You don't have the option to clear the mono display. You don't get to position the cursor prior to outputting text. And you can't use the mono as your primary monitor while sending debug reports to the color display.The advantage, however, is freedom from display formatting concerns. The functions are line-oriented, like <I>puts()</I>, sending the equivalent of a newline after every message printed.</FONT></FONT><P>
The <I>mono()</I> function contains two static variables that remember the current screen location on the monochrome monitor. The variable <I>segment</I> holds the base address at which the monochrome write starts. It is updated by one display line after every write. Before the write, <I>mono()</I> checks to see if segment still equals its original value. If so, then this is the first call to <I>mono()</I>, and the monochrome screen is cleared.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
One line on the display consists of 80 display locations, each interposed with an attribute byte &#151; a total of 160 bytes per display line. Since incrementing an address segment by one adds 16 to an absolute address, <I>mono()</I> adds only 10 to the segment for a jump of 160 bytes. Each time the segment increases by 10, <I>mono</I> sends an apparent newline to the display.</FONT></FONT></FONT></FONT><P>
After each mono write, <I>segment'</I>s value is increased. The value is then tested to see whether it is below the bottom line of the screen. If so, <I>mono</I> calls <I>scroll ()</I> and reduces the value of segment to the bottom line of the screen. <I>scroll()</I> is a static function, visible only from within the <I>mono.c</I> file. Thus, it won't conflict with any other function of the same name that you may have in your code. <I>scroll()</I> exists for internal use by the <I>mono()</I> function and cannot be called directly.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>mono()</I> is a debugging function. It offers a means to check your program as it runs, without interfering with the color display monitor your program is using. I use it simply to track function calls made within the code I'm debugging. Each new function I write begins with a call to <I>mono()</I>, passing the new function's own name as a parameter string. <I>mono()</I> dutifully reports the function's name on the mono monitor as the new function executes. This activity in no way interferes with the display on the primary monitor.</FONT></FONT></FONT></FONT></FONT></FONT><P>
I also use <I>mono()</I> to indicate which path has been taken through an <I>if-else</I> construct. It also works in <I>switch</I> statements, and both within and after loops of all kinds. However, <I>mono()</I> can only accept a string parameter. It won't produce an intelligible message that shows variable names and their values. <I>mprintf()</I> does that.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>mprintf()</I> uses C's variable argument macros to construct a string from the parameters you provide, which it then sends to <I>mono()</I>. <I>mprintf()</I> accepts parameters in the same form as the standard <I>printf()</I> function. <I>mprintf()</I> receives the format string and the list of variables, and calls <I>vsprintf()</I> to plug the variables into the string. A call to <I>mono()</I> then displays it.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Be aware that <I>mprintf()</I> as written allows only 100 bytes of string space. If <I>vsprintf</I> creates a longer string, memory will be overwritten. But you can even use these debugging functions to help you discover this memory overwrite. Inserting a second call to <I>mono </I>in <I>mprintf</I> will report the length of the string that <I>vsprintf</I> creates.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The file <I>mono.c</I> is self-contained. It includes all the <I>#includes</I> needed to compile properly. It was written and tested on Turbo C 1.5. To my knowledge, it uses only standard C. It compiles with no warnings and no errors in the TC integrated environment with options set to report all problems found.</FONT></FONT></FONT></FONT><P>
The file contains a <I>main()</I> function that I used for testing and developing these debugging routines. <I>main()</I>, however, is commented out by means of the <I>#if 0</I> and <I>#endif</I> preprocessor directives. Though not needed by the debugging routines, <I>main</I> provides examples of calls to the debugging routines to help you get started.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>

<h4><a href="../../../source/1990/dec90/shipman.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY></HTML>
