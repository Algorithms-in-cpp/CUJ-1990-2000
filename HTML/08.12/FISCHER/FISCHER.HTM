


<HTML>
<HEAD>

<TITLE>December 1990/State Machines In C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">State Machines In C<A name="028C_0170"><A name="028C_0170"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="028C_0000"><A name="028C_0000">Paul Fischer</font></h3><hr><blockquote><P>
<P><i><A name="028C_0000"><A name="028C_0000">Paul Fischer holds a B.S.C.S. from the University of Illinois at Champaign-Urbana. He is currently employed by Rockwell International as a software engineer.<I></I> <I></I>You may contact him at 6111 Pershing Ave., Downers Grove, IL 60516, (708)<I></I> <I></I>969-2610.</i></P><P>
State Machines are used in various applications involving rules, such as data link protocols, screen management, and device control. In simple applications, case statements are generally used, but in complex applications state tables have greater appeal. This article describes state machine implementation using state tables in C.<P>
<h4><FONT COLOR="#000080"><A name="028C_0171">Definition<A name="028C_0171"></FONT></h4></P>
A state machine is a relatively simple entity with a primitive memory and a set of rules. The memory provides the state machine with the knowledge of what it is doing right now. The set of rules defines how a state machine reacts to certain events. In essence, a state machine is a tool that allows programmed control over known but dynamic conditions.<P>
The following terms are used throughout this article:<P>
Device &#151; the instrument (either logical or physical) that the state machine is controlling. Some examples are a telephone line, a robot, and a data link protocol.<P>
State &#151; the current activity of the device. For example, a telephone line is ringing, a robot is off, a data link protocol is XOFFed.<P>
Event &#151; a stimulus introduced to the device that potentially changes its state. For example, the telephone line is answered, the robot's power button is pushed, a timeout occurs for the data link protocol.<P>
Transition &#151; a passage from one state to another. The direct result of the receipt of a valid event.<P>
State machines are then defined in terms of valid states, valid events for each state, and the transition from one state to another for each valid event. The benefits of a state machine increase with the complexity of the applica- tion. Over 20 states is complex. For the purposes of this article, however, I have created a simple example to illustrate the techniques involved.<P>
<h4><FONT COLOR="#000080"><A name="028C_0172">Example<A name="028C_0172"></FONT></h4></P>
The following example walks through a state machine for a video cassette recorder (VCR). It shows the definition of the operation of VCR through a state transition diagram, and how to transform the diagram into C.<P>
<A href="fig1.htm">Figure 1</a>
is the state transition diagram for the VCR, which shows the rules for how the VCR operates. The circles represent the valid states, (states are prefixed with an <I>S_</I>), and the arcs represent transitions. The event that caused the transition is a label on the arc, (events are prefixed with an <I>E</I>_).</FONT></FONT></FONT></FONT><P>
Consider the VCR in the state <I>S_OFF</I>. Only two events cause a transition to a new state: the <I>E_POWER</I> event causes the VCR to be placed in the <I>S_POWER</I> state; the <I>E_TAPE_IN</I> event automatically turns the power on and places the VCR in the <I>S_READY</I> state. A valid event does not necessarily cause a transition to a new state. For example, every state except <I>S_OFF</I> accepts an <I>E_CHAN_UP</I> and <I>E_CHAN_DOWN</I> event so that channel selection can occur. These events cause a transition to the same state.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Once the operation of the device has been described in terms of states, events, and transitions, the actual internal operation of the device becomes important. For example when the VCR moves to the <I>S_PLAY</I> state, some action is necessary to cause the tape to begin playing, and "PLAY" must be displayed on the VCR LED display. Another example would be to eject the tape on any transition to the <I>S_OFF</I> state. Actions such as these are taken during the transition and are implemented as a function call or list of function calls. All of these actions are added as the state transition diagram is transformed into a state table.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="028C_0173">State Table &#151; C Structures<A name="028C_0173"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
shows the <I>#defines</I> for all valid states and events and the structure definition of the state table. The four items necessary in the structure to define the state table are: the state, a valid event for that state, the next state to transition to for that event, and a list of functions to perform for the state/event combination. The structure <I>S_TABLE</I> defines each of these. Note that a fixed number of functions are set for the function list.</FONT></FONT></FONT></FONT><P>
Once the structure is in place, a fairly straightforward procedure is required to transform the diagram in <A href="fig1.htm">Figure 1</a>
into the state table in <A href="list2.htm">Listing 2</a>.
 For each state, you list the state, a valid event, the next state, and the set of functions to perform. The states are listed in numeric order in the state table, so reading the table is easy. For instance, the <I>S_PLAY</I> state has three valid events: <I>E_STOP</I>, <I>E_CHAN_UP</I>, and <I>E_CHAN_DOWN</I>. When these events are received, the functions in the corresponding function lists are executed, and the device transitions to the next state. Since this code is not going to actually run inside a VCR, the set of functions is limited &#151; display the new state, increment or decrement, and display the channel. If this were a real application, additional functions that caused playing and recording to begin would be referenced in the function list also.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="028C_0174">Table Driver<A name="028C_0174"></FONT></h4></P>
Once the table is defined, there must be some code to read the events and drive the operation of the VCR as specified in the state table. <A href="list3.htm">Listing 3</a>
shows the source for the driver, which accepts an event and a standard argument of type pointer to <I>ARG </I>(<I>ARG</I> is defined in <A href="list1.htm">Listing 1</a>)
. The <I>ARG</I> structure contains everything the state machine needs to store about itself. In this case, it is simply the current state of the VCR and a counter for channel selection. When the driver receives an event, it locates the current state in the state table, finds the event passed in, sets the next state, and executes the function list. All functions are passed the same standard argument <I>ARG</I>. If the event is not found, an error is noted. For the VCR, invalid events are ignored. Other devices may want to take some other type of action.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Also included is a function to read events. In general, events are read from some type of queue, be it hardware or software. Events for this program are read from standard I/O. Note that the current state and any other data required is initialized before the event loop begins.<P>
The last task is to write the functions contained in the function lists. Generally, these are small functions, each of which performs one task. When you implement a state table this way, the code provides an excellent, self-contained document for the operation of the device. <A href="list4.htm">Listing 4</a>
shows the three functions referenced in the state table.<P>
<h4><FONT COLOR="#000080"><A name="028C_0175">Alternative Organizations<A name="028C_0175"></FONT></h4></P>
The state table can be optimized for execution speed and memory allocation.<P>
You can improve performance by reducing the search times required each time an event occurs. Through a slight restructuring of the <I>S_TABLE</I> structure, the state can be used as a direct index into the state table. The <I>cur_state</I> field then appears only once, regardless of the number of events for that state. (It really doesn't need to appear at all since the array index can be used.) It is followed by a variable length event list. Then the driver can directly index to the current state upon each invocation. Another performance gain can be realized by placing the events for each state in "most likely to occur" order.</FONT></FONT></FONT></FONT><P>
You can add space savings and flexibility by removing the restriction on the number of functions in a function list. When this list is variable length, you gain two benefits. You no longer need to store <I>NULL</I> function pointers as padding, and there is no artificial restriction on the number of functions a state/event combination may have.</FONT></FONT><P>
As with most benefits, there are also costs to pay. To maintain readability of the state table with the previous suggestions, you will most likely have to process the state table or convert it from data to source. Simple initialized data cannot be used as in the original organization. Also, a different driver would have to be written to handle the different organization.<P>
<h4><FONT COLOR="#000080"><A name="028C_0176">Summary<A name="028C_0176"></FONT></h4></P>
For the right application, a state table approach can provide considerable benefits. Its combination of readability and extensibility lets you easily add features. For complex or multiple instance devices, organizing the source code as a mirror of the device's actual operation provides a versatile, straightforward, and efficient means of writing software.<P>

<h4><a href="../../../source/1990/dec90/fischer.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY></HTML>
