


<HTML>
<HEAD>

<TITLE>December 1990/Inter-Process Communication With Sockets</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Inter-Process Communication With Sockets<A name="028A_016E"><A name="028A_016E"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="028A_0000"><A name="028A_0000">Bryan Glennon</font></h3><hr><blockquote><P>
<P><i><A name="028A_0000"><A name="028A_0000">Bryan Glennon is president of BPG Consulting, Inc. He has been professionally involved in software engineering for the last nine years. His recent clients include Rockwell International, Ameritech Applied Technologies and McDonalds. He can be reached at P.O. Box 841, Bensenville, IL 60106, (708) 595-6059.</i></P><P>
Inter-Process Communication (IPC) allows one or more processes to share information. IPC methods include signals, semaphores, shared memory, pipes, and sockets. Some, such as signals and semaphores, convey only a little information, (such as whether an event has occurred). Shared memory allows several processes to read from and write to the same area of memory, to convey considerably more information. The processes must cooperate, however, to ensure that the shared memory is only accessed when it is in a "safe" state &#151; no updates are incomplete.<P>
Pipes connect two processes more safely. One process writes data into one end of the pipe, and the other reads data from the opposite end. Pipes, however, have one major disadvantage &#151; the two processes using the pipe must share a common ancestor.<P>
Sockets provide a communication link just like a pipe, but for processes with no common ancestor. Indeed, many versions of UNIX implement pipes by using a pair of sockets. Sockets allow separate processes to transfer information between them. The processes may be on the same or different processors.<P>
<h4><FONT COLOR="#000080"><A name="028A_016F">The Example Application<A name="028A_016F"></FONT></h4></P>
To demonstrate socket use, I will build a small time-tracking system. This system helps the user keep track of the time spent on various tasks. A back-end, or server process, reads events from a socket, and several front-end, or client processes, send events to the socket. Implementing such a system without using IPC is possible, but the IPC version has several advantages.<P>
In a multi-user environment, a single process (the server) handling all file access reduces the need for file or record locking in the application. The socket provides synchronization, which guarantees sequenced, reliable delivery of the messages (depending on the choice of socket types). Since the server and client process are not started by the same process (they share no common ancestor), sockets are a logical choice for the IPC mechanism. Also, by moving all of the file manipulations to the server, each client process can be smaller. All changes are localized to the server, which presents a consistent interface to all clients.<P>
The first example shows how processes running on the same processor can communicate through sockets. I then expand the example to show server and client processes on different hosts of a connected network.<P>
<h4><FONT COLOR="#000080"><A name="028A_0170">The Server Process<A name="028A_0170"></FONT></h4></P>
The server process waits for an event to arrive. Once an event arrives, it writes a record to the time entry file. <A href="list1.htm">Listing 1</a>
shows the structure of an event. All messages between the clients and the server consist of exactly one event. The event code in the <I>EVENT_TYPE</I> structure is set by the client process, based on the name under which it was invoked. <A href="list2.htm">Listing 2</a>
shows the code for the server process.</FONT></FONT><P>
First, the server must create the socket by calling <I>socket(domain, type, protocol)</I>. The socket's domain determines where the socket resides and where processes must be in order to access the socket. In <A href="list2.htm">Listing 2</a>,
 the socket is created with a domain of <I>AF_UNIX</I>, placing the socket in the UNIX domain. Only processes running on the same host as the server can access a UNIX domain socket. When the operating system creates the socket, it places an entry in the file system, just as when a file is created. When connections to the socket are made, both the server and the client processes use the full path name of the socket. Sockets may also be created in the Internet domain, which allows not only processes on the same processor to access the socket, but also processes on the same network. You can access sockets in the Internet domain by specifying the address of the host processor, and the port on the socket's host.</FONT></FONT></FONT></FONT><P>
The type parameter determines the socket type. In Sun OS, the valid socket types are <I>SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, </I>and<I> SOCK_SEQPACKET</I>. Stream sockets (<I>SOCK_STREAM</I>) provide reliable, two-way byte streams, and sequence is guaranteed when using stream type sockets. Stream-based sockets also support out-of-band (OOB) data. OOB data is announced to the receiving socket when it arrives, instead of being placed in the message queue. The receiving process must take special action to process this out-of-band data. When OOB data arrives, a signal (<I>SIGUGR</I>) is sent to the receiving process. When the process receives the signal, it can read the data, peek at the data, or ignore the data. Sending a message out-of-band is especially useful when sending an abort message that will cause the socket to cease processing any messages that could be in the socket.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Datagram sockets (<I>SOC_DGRM</I>) support connectionless, unreliable message transfer of fixed-length message packets. The service is unreliable because the client process does not have to establish a connection, via the <I>connect ()</I> call, before sending the message. Without this step, the system cannot guarantee that the message is delivered. Since the sender does not have to establish a connection, less overhead is involved with this type of socket, and there is no risk of failure due to an invalid address. Since delivery is not guaranteed, <I>DATAGRAM</I> type sockets are best used for non-critical message transfer, or when some other form of acknowledgment is used.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The remaining socket types are used for special purpose applications: <I>SOCK_SEQPACKET</I> socket types are not yet implemented; they are planned to provide sequenced, reliable, connection-based transfer of messages of a fixed maximum length. <I>SOCK_RAW</I> type sockets provide access to the underlying network protocol. In general, only someone with superuser permissions can use this socket type.</FONT></FONT></FONT></FONT><P>
The protocol argument allows the creator of the socket to specify which network transport protocol will be used. Implementation-dependent restrictions govern which protocol can be used with the various socket types and domains. A value of zero can be used for the protocol, which specifies that the default protocol associated with the type and domain should be used.<P>
The call to <I>socket()</I> returns a small, positive integer similar to a file descriptor. This number refers to the socket in future operations. If the call to <I>socket()</I> fails, it returns -1. The global variable <I>errno</I> will be set to indicate the error. Specific errors will vary from machine to machine, but common errors include: a protocol that is not supported, lack of permissions, or exceeding system limits for buffers or descriptors.</FONT></FONT></FONT></FONT></FONT></FONT><P>
After the server successfully creates the socket, it must associate the socket with an address. This process, called binding, is done by calling <I>bind(socket, address, length)</I>. The first argument is just the descriptor returned by calling <I>socket()</I>. The structure pointer passed as the second argument is first filled in by the caller. For sockets in the UNIX domain, the full path name of the socket is placed into the structure. A pointer to this structure is then passed to <I>bind()</I>. The third argument, the name length, is the size of the second argument, not the length of the string that represents that path name. Between the call to <I>socket()</I> and the call to <I>bind()</I>, the socket exists in the address space appropriate for the given domain, but it has no name associated with it. <I>bind()</I> returns zero on a successful call, or -1 for failure. As with all system calls, the global variable <I>errno</I> is set to the appropriate error code. Again, the specific errors will vary, but the call will fail if, for example: the descriptor does not refer to a socket, the specified address is already in use, or the address is invalid.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
When the server creates sockets in the UNIX domain, it must call <I>unlink()</I> to delete the file system entry once the socket is no longer needed.</FONT></FONT><P>
After binding a socket to an address, the server calls <I>listen(socket, count)</I>. This call establishes the number of simultaneous inbound connections that the socket will accept. It applies only to sockets of type <I>SOCK_STREAM</I> or <I>SOCK_SEQPACKET</I>. The socket parameter is the descriptor returned by the call to <I>socket()</I>. The count parameter specifies the maximum queue length of pending connections. If a request for connection arrives when the queue is full, the connection is denied, and <I>errno</I> is set to <I>ECONNREFUSED. listen()</I> returns a value of zero if successful, otherwise it returns -1. The call can fail for a number of reasons, including specifying a bad descriptor or a socket type other than <I>SOCK_STREAM</I> or <I>SOCK_SEQPACKET</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
After establishing the connection queue, the server calls <I>accept(socket,address, len)</I> to allow other processes to connect to the socket. The first parameter is a socket descriptor returned by socket. The second and third parameters provide the address of the connecting process, so two-way communication can be established. These parameters can be zero, in which case no information is returned, and two-way communication is not possible.</FONT></FONT><P>
<I>accept()</I> clones the socket represented by the first argument when a connection is made, allowing the original socket to continue to accept connections, while communication takes place over the cloned socket. Only <I>SOCK_STREAM</I> type sockets can use this mechanism. <I>accept()</I> returns a socket descriptor which is used for communication with the accepted socket. If the call fails, it returns -1. The call can fail for various reasons, including a bad descriptor or invalid (and non-null) pointers for the address and length parameters.</FONT></FONT></FONT></FONT></FONT></FONT><P>
After calling <I>accept()</I>, the server begins reading data from the returned socket descriptor using the standard system call <I>read()</I>. From here on, the descriptor can be read and processed like a normal file descriptor.</FONT></FONT></FONT></FONT><P>
The server will continue to run, waiting for connections at the <I>accept()</I> call. When it receives an event code of <I>SHUT_DOWN</I>, it closes the socket using the standard system call <I>close()</I>. It removes the file system entry by calling <I>unlink()</I>. The process cleans up the time entry file and exits.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="028A_0171">The Client Process<A name="028A_0171"></FONT></h4></P>
When a user wants to make a time accounting entry, he invokes the client process (or processes). There are several client processes, all of which run the same program. Under UNIX, client process names are all linked to the same program. Any of these names will invoke the program. When a child process is executed, the command name is passed as the first argument to the program. This name, (the variable <I>argv[0]</I> in the example client process) determines the event to be sent to the server. Multiple program instances could be used, each with a different name, though this would waste disk space.</FONT></FONT><P>
Once invoked, the client process builds the event message, locates the address of the server (using the agreed-upon name), sends the event, and exits. <A href="list3.htm">Listing 3</a>
shows the code for a simple client process.<P>
After evaluating <I>argv[0]</I> to determine the event type, the <I>EVENT_TYPE </I>structure <I>ev</I> is filled. The client process creates a socket in the same domain and of the same type used by the server process. The socket's address is then built, using the same parameters as the server process. The client then calls <I>connect()</I>. Since the socket has already been created, bound to an address and is accepting connections, the connection is allowed. At this point, the client uses the standard system call <I>write()</I> to write an event record to the socket. Once the write call returns, the client closes the socket and exits.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="028A_0172">Running Over A Network<A name="028A_0172"></FONT></h4></P>
You must make several minor modifications to allow the server and client processes to be on different hosts on a connected network. First, you must place the socket in the Internet domain <I>(AF_INET)</I>, not the UNIX domain. Sockets in the Internet domain have an Internet address contained in the <I>sockaddr</I> structure. Also, the clients must specify the name of the service and the machine on which it is running. In the example, this is hard-coded for simplicity, but in the real world, you could approach this in one of two ways. Either the service would be so widely needed and used that a well-known port number would be assigned, and possibly even an alias for the host on which the server ran (e.g., Port 64 on machine TimeHost). Or an entry would be made in a services database, from which the clients could retrieve the address of the server by using an OS provided call (such as <I>getservbyname</I> under SUN OS). <A href="list4.htm">Listing 4</a>
shows the server process with the network modifications.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The first change is in the type of the address structure. Instead of being a <I>struct sockaddr</I>, it is now a <I>struct sockaddr_in</I>. The call to <I>socket</I> specifies <I>AF_INET</I> as the domain, requesting that the socket be placed in the Internet domain. The address of the host (in this case, a machine called <I>utopia</I>) is retrieved using the <I>gethostbyname()</I> system call. This call returned a pointer (<I>hp</I>) to a host entry structure. This structure's address is copied into the socket's address structure. The call to <I>bind()</I> is made, and after the socket is bound to an address, the port number is printed out. The port number, if not specified, is set during the call to <I>bind()</I>. From this point on, the network version is the same as the earlier example.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The two function calls <I>htons()</I> and <I>ntohs()</I> convert the arguments from host byte-order to network byte-order and back.</FONT></FONT></FONT></FONT><P>
The client process contains similar modifications. For this example only, the port number returned when the server is started must be entered on the command line. <A href="list5.htm">Listing 5</a>
shows the main function of the client process with the changes for the network version.<P>
<h4><FONT COLOR="#000080"><A name="028A_0173">Summary<A name="028A_0173"></FONT></h4></P>
Sockets provide a generalized platform that discrete processes can use to share information. The delivery can be reliable (by the use of stream type sockets), or unreliable (by the use of datagrams). Processes on the same or on different processors can use sockets to share information. Sockets do not require processes to share a common ancestor, so they are useful whenever the processes that need to communicate have no common ancestor and reside on different processors. Most network services use socket pairs to communicate.<P>

<h4><a href="../../../source/1990/dec90/glennon.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY></HTML>
