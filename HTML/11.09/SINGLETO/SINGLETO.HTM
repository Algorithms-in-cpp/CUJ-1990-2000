

<HTML>
<HEAD>

<TITLE>September 1993/cout and cerr for Windows</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Windows Programming</FONT></H2>

<hr><h2 align="center"><font color="#800000">cout and cerr for Windows<A name="02AF_00D5"><A name="02AF_00D5"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="02AF_0000"><A name="02AF_0000">David Singleton, BA, MSc, CEng, MIEE</font></h3><hr><blockquote><P>
<P><i><A name="02AF_0000"><A name="02AF_0000">David Singleton is a Director and Principal Consultant with Singleton Systems Ltd, an independent computer systems consulting company. He has a BA in Physics and an MSc in Computer Science. He is a Chartered Engineer and a Member of the Institute of Electrical Engineers. He can be contacted at his home and business address: 30 The Albany, Sunset Avenue, Woodford Green, Essex, IG8 0TJ, England. His telephone number is +44-81-505-7996.</i></P><P>
<h4><FONT COLOR="#000080"><A name="02AF_00D6">Introduction<A name="02AF_00D6"></FONT></h4></P>
When developing C++ programs to run under MS-DOS, I frequently find it useful to insert writes to <I>cout</I> or <I>cerr</I> for debugging and trace purposes. For example:<P>
<pre>int some_variable;
...
// some code setting some_variable
...
cout &lt;&lt; "some_variable = "
   &lt;&lt; some_variable &lt;&lt; endl;
...</pre>
I could use the debugger, but I find that the <I>cout</I> approach is easier in quite a lot of cases. Once the code is working, I then remove these calls.<P>
However, this approach does not work when developing programs to work under Microsoft Windows. Due to its totally different approach to screen-based I/O, Windows does not inherently support the standard C++ iostream class variables <I>cin, cout, cerr</I>, or <I>clog</I>. (QuickWin does support standard C++ iostreams under Windows, but does not provide full Windows capability.) The alternatives I considered were:<P>
<UL><li>make more use of the debugger</li>
<li>call relevant Windows procedures whenever I want a <I>cout</I><I> </I>equivalent</li>
<li>implement <I>cout</I> and <I>cerr</I> under Windows</li></UL>
I decided that the first approach was too clumsy for my liking, and the second approach would involve too much work. I therefore implemented the third approach of providing <I>cout</I> and <I>cerr</I> under Windows.<P>
I felt that my Windows implementation of <I>cout</I> and <I>cerr</I> should provide a single, separate window to which the <I>cout/cerr</I> stream would be directed. It should be possible to keep more than a single, windowful of output, and it should be possible to scroll forwards and backwards through the output.<P>
My development environment for C++ uses Microsoft's C++ V7.0, together with the C++ Microsoft Foundation Classes (MFC) V1.00. Thus, the program described in the following sections uses classes derived from these MFC classes, described in full in the relevant Microsoft documentation (see References <a href="#1">1</a> and <a href="#2">2</a>).<P>
<h4><FONT COLOR="#000080"><A name="02AF_00D7">New Classes<A name="02AF_00D7"></FONT></h4></P>
I implemented the <I>cout/cerr</I> screen by deriving three classes and associated methods (C++ functions). The first class, <I>CStrWnd</I>, is a derivation of the standard Microsoft C++ Foundation Class <I>CMDIChildWnd</I>. This class supports an in-memory text buffer and the necessary user interface to scroll forwards and backwards through the text buffer. It has other, more general uses. This is why I implemented it separately from the second class, <I>ostreamWnd</I>.<P>
The class <I>ostreamWnd</I> is a derivation of <I>CStrWnd</I>, tailored to interface to the third new class, <I>winstreambuf</I>. This, latter class is a derivation of the standard Microsoft iostream class <I>streambuf</I>. If one wishes to implement new iostream features, then the recommended approach is usually to derive a new class from <I>streambuf</I> (see References <a href="#1">1</a> and <a href="#2">2</a>).<P>
<h4><FONT COLOR="#000080"><A name="02AF_00D8">The Class <B><I>CStrWnd</I><A name="02AF_00D8"></B></FONT></h4></P>
<A href="list1.htm">Listing 1</a>,
 the <I>CStrWnd</I> header, sets out the content of <I>CStrWnd</I>. The most important item in class <I>CStrWnd</I> is the <I>CStringArray</I> text_buffer. This holds the text that is to be displayed in the <I>cout</I> window. I chose a <I>CStringArray</I> to hold the text, as it provided all of the functionality that I needed for handling lines of text. Each line of text to be displayed is a separate <I>CString</I> in the array. <I>CStringArray</I> also provides all the functionality needed for adding new lines and deleting old lines (once the buffer is full). <I>text_buffer</I> is declared as a protected member, so that derived classes can access it directly.<P>
The constructor <I>CStrWnd::CStrWnd</I> loads the keyboard accelerator table for the window (required to allow multiple key combinations, such as Ctrl-Home and keyboard scrolling) and creates the window. Finally, the constructor initializes class variables and claims the input focus for the window.<P>
Four functions, <I>OnPaint, OnVScroll, OnHScroll</I>, and <I>OnKeyDown</I> handle the basic screen output and window scrolling. <I>SetVerticalScroll</I> assists vertical scrolling by calculating the position of the vertical scroll bar. Unlike all the other functions, it is declared as a private function, as it is only called by other <I>CStrWnd</I> functions. Four functions, <I>OnDocStart, OnDocEnd, OnLineRight,</I> and <I>OnLineLeft</I>, provide special handling for the keyboard cases Ctrl-Home, Ctrl-End, Ctrl-Right, and Ctrl-Left. Finally, <I>BufAddAtEnd</I> provides a simple interface for adding a line to the end of the screen buffer, and <I>UpdateScreen</I> provides a simple interface to derived classes to request a screen update, with the last line in <I>text_buffer</I> displayed on the screen.<P>
<I>CStrWnd</I> has five private variables, used for managing the displayed text. <A href="list1.htm">Listing 1</a>
describes these variables. <A href="list2.htm">Listing 2</a>
sets out the code for the <I>CStrWnd</I> functions. The following notes provide amplification of these functions.<P>
MFC provides a basic windows class <I>CWnd</I>. This includes the standard virtual functions <I>OnPaint, OnVScroll, OnHScroll</I>, and <I>OnKeyDown. CStrWnd</I> needs to override the definitions of these functions to handle window painting, and window scrolling via scroll bar controls and the keyboard.<P>
I designed <I>CStrWnd::OnPaint</I> for ease of coding and understanding rather than for efficiency. It therefore takes no account of which part of the window needs updating. If any part of the window needs updating, it repaints it all. This does result in a degree of flicker on the screen, particularly if the output is via <I>cerr</I> (which is unit buffered and thus causes a screen update after every insertion).<P>
<I>CStrWnd::OnPaint</I> contains the functionality required to output the text. First, it selects a fixed-pitch font (which I prefer for this sort of use. Then, it calculates the height of the window. As the window could have been resized, this must be done every time. <I>OnPaint</I> then works out where to put tab stops, if these appear in the text. I could have put the tab-stop code in the constructor <I>CStrWnd::CStrWnd,</I> so that it was only called once, on creation, but it was just as easy to put it in <I>OnPaint</I> and the overhead is fairly low. <I>OnPaint</I> then gets down to its main task of outputting each of the lines of text to appear in the window. Before each line is output, <I>OnPaint</I> passes it to <I>strdetab</I> to convert all tab characters to spaces. <A href="list3.htm">Listing 3</a>
and <A href="list4.htm">Listing 4</a>
describe the operation of <I>strdetab.</I> Finally, <I>OnPaint</I> sets the horizontal scroll bar, if necessary.<P>
<I>CStrWnd::OnVScroll</I> and <I>CStrWnd::OnHScroll</I> carry out scrolling of the window, either when called as a result of keyboard input or when called directly by Windows when the scroll bar controls are used. <I>CStrWnd::OnKeyDown</I> handles single-key keyboard scrolling inputs. It determines which key has been pressed and then calls <I>OnVScroll</I> or <I>OnHScroll</I> with the appropriate scrolling parameter.<P>
<h4><FONT COLOR="#000080"><A name="02AF_00D9">The Class <B><I>ostreamWnd</I><A name="02AF_00D9"></B></FONT></h4></P>
<I>ostreamWnd</I> is a derivation of <I>CStrWnd.</I> <A href="list5.htm">Listing 5</a>
shows the header file that sets out its content. <I>CStrWnd</I> provides the capability to output text from its buffer. <I>ostreamWnd</I> provides the complementary methods for entering text into the <I>CStrWnd</I> buffer.<P>
The constructor <I>ostreamWnd::ostreamWnd</I> sets the maximum size of the buffer and removes the option to close the window from its system menu. I did this to avoid any possible unpleasant side effects that might occur if the window was closed while <I>cout</I> and <I>cerr</I> were still open. As these streams are open for the life of the program, the window needs to have the same life. For this reason, I also define a null <I>OnClose</I> function, which prevents the window from being closed sooner than the end of the program.<P>
<I>ostreamWnd</I> has two functions, <I>SetBufferLines</I> and <I>PutText. SetBufferLines</I> provides a method of adjusting the number of lines of text in the buffer, although this example does not use it. <I>PutText</I> takes an array of text and appends it to the last <I>CString</I> in the buffer. Whenever it finds a newline character <I>'\n'</I>, it adds a new <I>CString</I> to the end of buffer, representing a new line to be output. After <I>PutText</I> has added all the text, it removes lines from the start of the buffer if the buffer contains more than the maximum permitted number of lines. <A href="list6.htm">Listing 6</a>
gives the code for <I>PutText</I>.<P>
<I>ostreamWnd::PutText</I> illustrates the benefits of using the MFC classes. By using <I>CStringArray</I> to hold the text buffer, I can temporarily allow the buffer to exceed its design limits perfectly safely (as when I am inserting the new text, but before I delete lines from the start), without having to worry about the code to manage this. <I>CStringArray</I> and <I>CString</I> do all the work for me. My productivity is enhanced. Further, by using <I>SetBufferLines</I> I could, in another program, change the number of lines in the text buffer dynamically.<P>
<h4><FONT COLOR="#000080"><A name="02AF_00DA">The Class <B><I>winstreambuf<A name="02AF_00DA"></B></I></FONT></h4></P>
As I mentioned earlier, the recommended method of extending the iostream classes (including <I>cout</I> and <I>cerr</I>) is to derive a new class from the standard <I>streambuf</I> class (see References <a href="#1">1</a> and <a href="#2">2</a>). <I>winstreambuf</I> is such a derivation.<P>
<A href="list7.htm">Listing 7</a>
sets out the definition of the class. It overrides three of the standard, pure virtual functions in <I>streambuf:sync, overflow</I>, and <I>underflow</I>. These functions must be overridden in any class derived from <I>streambuf. winstreambuf</I> provides two additional functions: <I>set_stream_window</I> and <I>reset_buffer</I>. <I>set_stream_window</I> provides a safe interface through which users can associate a window with a <I>winstreambuf</I> object. <I>reset_buffer</I> resets the buffer pointers provided by <I>streambuf. winstreambuf</I> also includes two data items. The iostream system uses <I>buffer</I> for buffering output, and <I>stream_window</I> points to the <I>ostreamWnd</I> to be used for output.<P>
The underlying iostream system calls <I>sync</I> whenever it wishes to flush the <I>winstreambuf</I> buffer. <I>sync</I> asks the associated <I>ostreamWnd</I> object to write the text to the window by calling its <I>PutText</I> function, then resets the buffer for future use.<P>
Similarly, the underlying iostream system calls <I>overflow</I> whenever the buffer is full. The operation of <I>overflow</I> is the same as that of <I>sync</I>, with the addition that it needs to handle the character that caused <I>overflow</I> to be called.<P>
<I>underflow</I> is never called here, as it is only used for input. Nevertheless, it must be defined since <I>streambuf</I> defines it as a pure virtual function. It always returns <I>EOF</I> to indicate that no characters are available for input.<P>
<A href="list8.htm">Listing 8</a>
gives the code for these functions.<P>
<h4><FONT COLOR="#000080"><A name="02AF_00DB">A Sample Program<A name="02AF_00DB"></FONT></h4></P>
The previous section has described the three classes that are needed to implement <I>cout</I> and <I>cerr</I> in a Windows environment. I will now describe the additional code which, together with the classes, makes a short program that demonstrates the use of <I>cout</I> and <I>cerr</I>. The remainder of the program consists of four files.<P>
First, <A href="list9.htm">Listing 9</a>
defines a number of resource constants used within the program, for Windows message passing and dialogue management. Second, <A href="list10.htm">Listing 10</a>
is the program resource file, which defines the menus and keyboard accelerator tables that the program uses. There are two menus, <I>Run</I> for running and exiting the program, and <I>About</I> to provide a standard "About" dialogue. The two accelerator tables support F2, for displaying text in the <I>cout/cerr</I> window, and other keys for scrolling the <I>cout/cerr</I> window. The file also calls up an icon, which I created, to represent the program on the Windows Program Manager window. You should use the Image Editor (supplied with the Microsoft Windows Software Development Kit) or an equivalent icon editor to create a suitable icon. Alternatively, you can delete the line. In this case, Program Manager will assign a default icon.<P>
<A href="list11.htm">Listing 11</a>
and <A href="list12.htm">Listing 12</a>
set out the program for testing the <I>cout/cerr</I> window. The standard method of creating an application with MFC is to start by deriving a class from <I>CWin-App</I>. I have derived <I>App</I> for this purpose. <I>InitInstance</I> carries out initialization, and <I>ExitInstance</I> cleans up on termination. <I>App</I> defines two <I>winstreambuf</I> pointers, <I>cerrbuf</I> and <I>coutbuf</I>. <I>InitInstance</I> assigns <I>winstreambuf</I> objects to them and assigns them to <I>cerr</I> and <I>cout. InitInstance</I> then creates a new <I>ostreamWnd</I> and uses <I>ostreamWnd::set_stream window</I> to connect <I>cerrbuf</I> and <I>coutbuf</I> to the new <I>ostreamWnd. cout</I> and <I>cerr</I> are now ready for use. <I>InitInstance</I> also includes some additional debugging code that I will come to later.<P>
A small word of warning at this point. You will notice that I do not declare <I>cout</I> and <I>cerr</I> at any time. This is because they are already declared in my copy of the standard include file <I>&lt;ostream.h&gt;</I> in a <I>#ifndef</I> block, which declares them unless the identifier <I>_WINDLL</I> is defined. I believe that this is (dare I say it) an error in <I>&lt;ostream.h&gt;</I>. It is possible that you may have a different version of <I>&lt;ostream.h&gt;</I> that uses the identifier <I>_WINDOWS</I> instead of <I>_WINDLL</I> in this <I>#ifndef</I> block. If this is the case, you will need to declare <I>cout</I> and <I>cerr</I> at global level in your program, as:<P>
<pre>ostream_withassign cout, cerr;</pre>
in <A href="list12.htm">Listing 12</a>,
 and make appropriate external declarations in other modules.<P>
<h4><FONT COLOR="#000080"><A name="02AF_00DC">Memory Leakage Detection<A name="02AF_00DC"></FONT></h4></P>
One very well known problem with most C and C++ programs is that of memory leakage. I decided to make use of the facilities provided by the MFC class <I>CMemoryState</I>. This class is only defined in the debug versions of the MFC libraries. Hence, all references to it need to be surrounded as in:<P>
<pre>#if defined (_DEBUG)</pre>
I declare three <I>CMemoryState</I> objects in <I>App. InitInstance</I> uses the first of these to take a memory snapshot during initialization. I take a second snapshot in <I>ExitInstance</I>, during close-down. I use the <I>CMemoryState::Difference</I> function to see whether there has been any memory leakage. If there has been leakage, then I use further <I>CMemoryState</I> functions to output details of the leakage. This has proved invaluable during development. To give me a simple alert, I set the program exit code to 100 (but only if it has not already been set to a non-zero value). If the exit code is not 100, then I do not need to worry about leakage.<P>
As <I>CMemoryState</I> normally puts its output to the AUX device when running under Windows, the simplest way of seeing the output is to run the program under CodeView for Windows. The exit code and any <I>CMemoryState</I> output appear in the command window. Reference <a href="#3">3</a>, supplied with Microsoft C++, provides further details on ensuring that the output is indeed directed to the CodeView command window. As <I>cout</I> and <I>cerr</I> are declared globally, it is necessary to carry out the manipulation of the associated <I>winstreambuf</I> objects outside the leakage detection loop. If this is not done, you get false alarms.<P>
<h4><FONT COLOR="#000080"><A name="02AF_00DD">Further Enhancements<A name="02AF_00DD"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02AF_00DE"><I>clog</I><A name="02AF_00DE"></FONT></h4></P>
<I>clog</I> is an additional output stream object. I would only need to add two or three lines to the <I>App</I> class to implement it.<P>
<h4><FONT COLOR="#000080"><A name="02AF_00DF">Output Alerting<A name="02AF_00DF"></FONT></h4></P>
It might be useful to have the <I>cout/cerr</I> window brought to the front of all of the windows used by the application, whenever output is written to the <I>cout/cerr</I> window. This would be a fairly simple change. <I>OnPaint</I> could make a call to <I>BringWindowToTop</I> to do this.<P>
<h4><FONT COLOR="#000080"><A name="02AF_00E0"><I>OnPaint</I><B> Improvements<A name="02AF_00E0"></B></FONT></h4></P>
As I noted above, <I>CStrWnd::OnPaint</I> is rather crude, in that it always repaints the entire window, regardless of what has actually changed. I would improve this so that only the parts of the window that had changed were updated. This would require changes to those routines that affected the screen in any way. Thus, I would need to change <I>OnPaint, OnHScroll, OnVScroll, OnDocStart,</I> and <I>OnDocEnd</I> among others. I would probably also need to change <I>ostreamWnd,</I> so that it signalled which line(s) it had changed. As they say in all the good text books, "This is left as an exercise for the reader." Good Luck.<P>
<h4>References</FONT></h4></P>
<a name="1">1.</a>     Microsoft Corp. Microsoft C/C++ Version 7.0 Class Libraries User's Guide.<P>
<a name="2">2.</a>     Microsoft Corp. Microsoft C/C++ Version 7.0 Class Libraries Reference.<P>
<a name="3">3.</a>     MFC TN007.TXT. File supplied with Microsoft C/C++.<P>
<h4><a href="list13.htm">Listing 13</a></h4>

<h4><a href="../../../source/1993/sep93/singleto.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
