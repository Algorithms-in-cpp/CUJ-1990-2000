


<HTML>
<HEAD>

<TITLE>March 1990/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="00C5_0062"><A name="00C5_0062"></font></h2><hr>
<BLOCKQUOTE>
<A name="00C5_0000"><A name="00C5_0000">Dear Mr. Ward,<P>
I am delighted to hear that you will be publishing every month now. While it may be possible to get too much of a good thing, one <I>C Users Journal</I> per month is still a long way from too much (perhaps your staff has a different view).<P>
There are two things in the November issue that cause me to write. First is Jay Martin Anderson's generally excellent overview of the IEEE-488 interface bus. Normally, using "HP-IB" and either "GPIB" or "IEEE-488" as synonyms causes no great confusion. However, I think that Prof. Anderson's article may be an exception to that rule. Let me provide the precise meaning of each term, and then indicate why I believe that the equivocation of these terms has presented a problem in his piece.<P>
"IEEE-488" is the generic way of identifying the standards document, "IEEE Standard Digital Interface for Programmable Instrumentation," produced by the IEEE. The designation "GPIB" (General Purpose Interface Bus) is the generic term for the interface bus. "HP-IB" (Hewlett-Packard Interface Bus) is a term used by Hewlett Packard to designate both the IEEE-488 electronic standard <I>and</I> HP's software protocol for using the interface.<P>
The most serious error in the article that comes from equating HP-IB with IEEE-488 is the assertion that "any instrument which claims adherence to the IEEE-488 standard must be able to respond to a serial poll." (page 29). In fact, the IEEE-488 standard specifies many allowable subsets of the full interface. Included among these are nine "Allowable Subsets to T Interface Function" (table 11 of the IEEE-488 standard.) "T" is the basic talker function. (There is a precisely analogous TE &#151; extended talker &#151; with the same nine subdivisions of that function). Of those allowable functions, five do not support serial polling. However, one is the degenerate case of no talker capability, TO. Obviously, any instrument that cannot talk cannot answer a serial poll. So, after acknowledging that it is legal for an IEEE device to not support talking at all, the more accurate picture is that half of the talker options that "adher[e] to the IEEE-488 standard" do not support serial polling. While it is true that HP-IB uses serial polling, there is no such requirement from the IEEE.<P>
I do not want to exaggerate the significance of Prof. Anderson having elided the HP-IB and the IEEE-488 specifications into one. In general, his article is an excellent introduction to the HP-IB. However, it is worth recognizing that it is not an introduction to the GPIB as such.<P>
The second thing in the November issue that I wanted to respond to was Jeff Saraiva's request in "Q?A!" for programming examples using the Microsoft C v5.1 compiler's graphics library. I am sending a copy of my FTGRAPH, which is a tool kit of FFT functions. It uses the MSC 5.1 graphics library for its screen output (MSC_GRPH.C is the source file). While it is not a particularly extensive graphics application, it does illustrate determining the graphics adapter at runtime, and scaling the output to the actual adapter's resolution. It also shows how to use both text and graphics with the graphics library. You may include it in the C Users Group library if you think that it is suitable. You should note, however, that the front-end (FTGRAPH.C) is quite ragged. The library routines have evolved over the last few years to meet my employer's needs, but the front-end was written on my own time as a way of providing a tool kit to accompany an article on FTs that I wrote for Intelligent Instruments and Computers. I think the library is a reasonably polished, professional product. The front-end is a good example of what you get for nothing. I include a reprint of the article, in case Mr. Saraiva is not familiar with the FT and what it can be used for. I hope it is not too trivial a graphics application to be useful to him.<P>
Sincerely,<P>
Tom Clune<br>
Eye Research Institute<br>
20 Staniford St.<br>
Boston, MA 02114<P>
<I>Thanks for the HPIB/IEEE 488 clarification. We have passed your graphics library on to Kenji for evaluation. We'll also pass a copy immediately to Saraiva. I think "How to determine adapter type at runtime" would be a good article by itself. Any authors? &#151;rlw</I><P>
Dear Robert,<P>
I just finished reading the Jan 1990 issue of <I>CUJ</I> (again, an excellent job, guys). I want to respond to one of your reader's (Dr. Whitaker of Boston, MA) requests for texts on "grep", "awk", "sed" and "tr" as well as to one of the articles which I found to be most interesting.<P>
First the texts.<P>
1. AT&amp;T UNIX Programmer's Manual Volume 4 titled <I>Document Preparation,</I> edited by Steven V Earhart, a CBS College Publishing by Holt, Rinehart and Winston (HRW), ISBN 0-03-011207-9<P>
2. AT&amp;T UNIX Programmer's Manual Volume 5 titled <I>Languages and Support Tools,</I> edited by Steven V. Earhart, a CBS College Publishing by Holt, Rinehart and Winston (HRW), ISBN 0-03-011204-4<P>
These two texts are probably the most complete descriptions of the utilities in question and describe everything you ever wanted (and never wanted) to know about them, complete with examples and option descriptions.<P>
The next text I would recommend is <I>UNIX Utilities</I> by R. S. Tare published by McGraw-Hill, ISBN 0-07-062884-X<P>
This book is a programmer's reference and makes some assumptions about how much the reader knows about programming in general. This book would probably not be a good teaching guide but it's a great reference.<P>
Lastly, I would recommend the following Bell Laboratories, technical memoranda.<P>
1. <I>SED &#151; A Non-interactive Text Editor</I>, by Lee E. McMahon, dated August 15, 1978.<P>
2. <I>AWK &#151; A Pattern Scanning and Processing Language</I>, by Alfred Aho, Brian Kernighan and Peter Weinberger, dated September 1, 1978.<P>
I realize that these two documents might be more difficult to get ahold of, but they are excellent user guides and no more than 10 pages.<P>
Next I would like to present an "addendum" to a very well written article entitled <I>UNIX 'termcap' Facility Improves Portability</I> by Ronald Florence. I realize that the article was about the 'termcap' facility but since he did mention the 'terminfo' facility, I wanted to present some additional information about it, to you. If after reading this letter you think that a more "in-depth" article or tutorial about it may be of interest to your readers, I would be more than happy to contribute.<P>
First let me say that none of this information applies to any UNIX versions prior to UNIX System v2 but I would strongly recommend upgrading to, at least, UNIX System v3 as soon as possible. The added security measures and bug fixes are well worth it! Well, back to the article.<P>
Mr. Florence stated in his article that "The termcap database is substantially easier to modify..." than the terminfo database. I must disagree with this statement. On most (if not all) UNIX systems that use 'termcap', the database can only be modified by the system administrator (or super user) and rightly so. If you, yourself, are not the super user, experimental (trial and error) modifications to terminal descriptions are impractical to say the least. With 'terminfo', the user is free to experiment with a terminal description that only he or she will use (at least until it's fully tested).<P>
In order to write a 'terminfo' terminal description, you will need at least the following: section 4 of the UNIX programmer's manual (TERMINFO(4)) and the technical reference for the particular terminal you wish to build a description for. Only with this information is it possible to write a terminal description.<P>
In order to use the "new" terminal description, it must be compiled using TIC(1M) the terminfo compiler. The procedure is simple, once the terminal description file is complete, just type<P>
<pre>tic filename</pre>
and this will create subdirectories (one for each unique terminal name in the first line, i.e., at386 makes directory "a", AT386 makes "A" and so on) and the compiled file is placed in the subdirectory under the terminal name and any appropriate links are made in the other subdirectories.<P>
In order to make use of this file, the user must define and export the environment variable TERMINFO equal to the directory under which the subdirectories were created. The user must also define and export the TERM variable equal to the appropriate terminal name.<P>
For example, in the users ".profile" file have the following:<P>
# (assuming "termdefs" contains the description file)<P>
<pre>TERMINFO=${HOME}/termdefs
TERM= at386
export TERM TERMINFO</pre>
Programs using "curses" and "terminfo" routines will check for the TERMINFO variable to be set first, before checking the standard terminal description database.<P>
Much of this information can be found in the various sections of the UNIX manuals and there are also several books (and memoranda) on the subject. For the convenience of your readers, I have enclosed a couple of sample listings for 'terminfo' descriptions.<P>
<A href="list1.htm">Listing 1</a>
is the 'terminfo' description supplied by most UNIX System V/386 vendors for the 80386 based IBM PC/AT console. It should be noted that the description supplied by most UNIX SysV/386 vendors is INCORRECT! The "xt" boolean (destructive tabs) should be removed as it will cause problems with programs like GNU Emacs and others.<P>
<A href="list2.htm">Listing 2</a>
is the same 'terminfo' description using the long C variable names listed in <I>&lt;term.h&gt;</I>. This is a much clearer example of the terminal description information.</FONT></FONT><P>
I hope you and/or your readers will find this information of some use. If you have any questions or wish to contact me, you can do so at the address or via e-mail at <I>uunet!rwbix!cci</I>.</FONT></FONT><P>
Sincerely,<P>
Bob Barrett<br>
Principal Consultant at CCI<br>
528 North Riverside Dr.<br>
Neptune, NJ 07753<P>
<I>I have always found termcap and curses to be the most difficult-to-learn parts of UNIX, mostly because the documentation is so scattered and patchy. In addition to your references, Kochan and Wood's book</I> "Topics In C Programming" <I>includes several little tidbits (like when to use </I><I>clearok()</I><I>) that I haven't found elsewhere, and Rochkind's</I> "Advanced C Programming for Displays" <I>includes good advice about using termcap directly and some interesting performance comparisons between new and old termcap and curses.&#151;rlw</I></FONT></FONT><P>
Dear Mr. Ward,<P>
I've started an interactive curses based program that calculates topological chemical indexes as suggested by an article in the <I>Scientific American Magazine</I> (Sept. 1986, p.43). A graphics editor for drawing organic structures using commands loosely named after those in emacs is called. The editor also uses a small library that includes standard subunits like benzene rings, steroids, etc. Structures can be named and saved. The drawing can be modified, renamed, and recalculated. Only the randic index calculator has been finished. I have considered converting the program into a filter that would pipe the index numbers to a statistical program to check for correlation with various chemical or biological activities. I know that various systems are used to translate standard chemical names into codes that are machine readable but I don't know which one is the de facto standard.<P>
My machine is a UNIX PC, PC 3700 (System v3.5 software) but I've avoided menus, windows, and the mouse in favor of portability. I wrote the program in standard K&amp;R C.<P>
I doubt that there is enough interest to add this package to the CUG standard distribution. Since there are so many design considerations, I would like to contact some chemists interested in this theoretical tool so that I could implement it to be useful for their academic use.<P>
Sincerely,<P>
Phil Karn, SR<br>
230 Division Ave.<br>
Lutherville, MD 21093<P>
Dear Mr. Ward:<P>
I am a recent subscriber to <I>The C Users Journal</I> and let me start by saying that I think you have a great publication. Here are some topics which I would enjoy reading about in future issues. Since I am an MS-DOS user, most of these topics are oriented towards that environment.<P>
<B>Video and printer drivers</B>. I would like for my programs to take advantage of the hardware capabilities of different printers and video cards. Both Microsoft Windows and Borland's BGI provide a method for doing this, but I would prefer to use my own code. What I would really like to see discussed is how to write device drivers which can be selected during the execution of a program.<P>
<B>OCR</B>. What are the current methods used to perform optical character recongition. I realize that this is too big a topic for extensive coverage, but an introductory tutorial would be very nice.<P>
<B>Speech Synthesis</B>. What can be done to add speech to programs? I realize that this is usually done with special hardware, but am curious as to what can be done with just a standard PC. It seems that the commercial game programs keep getting better and better sound using a standard computer.<P>
<B>Timing</B>. How can I write programs which are independent of the clock speed of the machine being run on. For some events, such as animation, the real time clock does not give enough precision to control the timing. The commercial games seem to have solved this problem as well.<P>
Lynn Akers, Jr.<br>
Akersoft, Inc.<br>
5600 Roswell Rd. Ste. 200B<br>
Atlanta, GA 30342<P>
<I>Talk about timing! Surely you'll notice the speech recognition article in this issue. Phyllis Lang wrote a story about "Improving Timing Resolution" which appeared in our May 1989 issue. I'm sure that story would address your timing needs. We have sold out of that issue, but can still supply a photo copy (for a small fee). Just call and ask for Phyllis Lang's story from Vol. 7, Issue 5. &#151;rlw</I><P>
Dear Ward Folks;<P>
Where do you buy your drugs? $28 for your magazine! Not a chance, if it costs so much to produce it why did you go to coated pages and a color cover? Leave me the old style, charge me less and maybe we can work something out.<P>
Best of luck (Ha!)<P>
Tom Brusehaver<br>
1505 Ensign Dr. #C<br>
Normal, IL 61761<P>
P.S. No one asked me if I wanted the format to change. I would have said NO!<P>
<I>In fact, the coated paper we are now using is less expensive than the offset stock we used to use. The change in price was designed to cover the additional issues. If $24 for eight was reasonable, I fail to understand why $28 for twelve isn't.</I><P>
<I>Frankly I don't think the price requires much defense. For $28 we deliver roughly 1500 pages of technical coverage. Even discounting non-editorial space you still get over 1000 pages of technical material. Have you priced any 300 page technical books lately? Have you bought a large pizza recently?</I><P>

<h4><a href="../../../source/1990/mar90/letters.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY>
</HTML>
