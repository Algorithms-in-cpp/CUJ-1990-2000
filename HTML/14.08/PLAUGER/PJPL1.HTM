



<HTML><HEAD>

<TITLE>August 1996/Standard C/C++/Listing 1</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<h4>Listing 1:	The header &lt;algorithm&gt;</h4>

<pre>

// algorithm standard header
#ifndef _ALGORITHM_
#define _ALGORITHM_
///namespace std {
template&lt;class InIt, class Fun&gt;
    Fun for_each(InIt first, InIt last, Fun op);
template&lt;class InIt, class OutIt&gt;
    OutIt copy(InIt first, InIt last, OutIt x);
template&lt;class BidIt1, class BidIt2&gt;
    BidIt2 copy_backward(BidIt1 first, BidIt1 last, BidIt2 x);
template&lt;class InIt1, class InIt2&gt;
    bool equal(InIt1 first, InIt1 last, InIt2 x);
template&lt;class InIt1, class InIt2, class Pred&gt;
    bool equal(InIt1 first, InIt1 last, InIt2 x, Pred pr);
template&lt;class FwdIt, class T&gt;
    void fill(FwdIt first, FwdIt last, const T&amp; x);
template&lt;class OutIt, class Size, class T&gt;
    void fill_n(OutIt first, Size n, const T&amp; x);
template&lt;class InIt1, class InIt2&gt;
    bool lexicographical_compare(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2);
template&lt;class InIt1, class InIt2, class Pred&gt;
    bool lexicographical_compare(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, Pred pr);
template&lt;class T&gt;
    const T&amp; max(const T&amp; x, const T&amp; y);
template&lt;class T, class Pred&gt;
    const T&amp; max(const T&amp; x, const T&amp; y, Pred pr);
template&lt;class T&gt;
    const T&amp; min(const T&amp; x, const T&amp; y);
template&lt;class T, class Pred&gt;
    const T&amp; min(const T&amp; x, const T&amp; y, Pred pr);
template&lt;class InIt1, class InIt2&gt;
    pair&lt;InIt1, InIt2&gt; mismatch(InIt1 first, InIt1 last, InIt2 x);
template&lt;class InIt1, class InIt2, class Pred&gt;
    pair&lt;InIt1, InIt2&gt;
        mismatch(InIt1 first, InIt1 last, InIt2 x, Pred pr);
template&lt;class T&gt;
    void swap(T&amp; x, T&amp; y);
template&lt;class InIt, class T&gt;
    InIt find(InIt first, InIt last, const T&amp; val);
template&lt;class InIt, class Pred&gt;
    InIt find_if(InIt first, InIt last, Pred pr);
template&lt;class FwdIt&gt;
    FwdIt adjacent_find(FwdIt first, FwdIt last);
template&lt;class FwdIt, class Pred&gt;
    FwdIt adjacent_find(FwdIt first, FwdIt last, Pred pr);
template&lt;class InIt, class T&gt;
    iterator_traits&lt;InIt&gt;::distance_type
        count(InIt first, InIt last, const T&amp; val);
template&lt;class InIt, class Pred&gt;
    iterator_traits&lt;InIt&gt;::distance_type
        count_if(InIt first, InIt last, Pred pr);
template&lt;class FwdIt1, class FwdIt2&gt;
    FwdIt1 search(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2);
template&lt;class FwdIt1, class FwdIt2, class Pred&gt;
    FwdIt1 search(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2, Pred pr);
template&lt;class FwdIt1, class FwdIt2&gt;
    FwdIt1 find_end(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2);
template&lt;class FwdIt1, class FwdIt2, class Pred&gt;
    FwdIt1 find_end(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2, Pred pr);
template&lt;class FwdIt1, class FwdIt2&gt;
    FwdIt1 find_first_of(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2);
template&lt;class FwdIt1, class FwdIt2, class Pred&gt;
    FwdIt1 find_first_of(FwdIt1 first1, FwdIt1 last1,
        FwdIt2 first2, FwdIt2 last2, Pred pr);
template&lt;class FwdIt1, class FwdIt2&gt;
    void iter_swap(FwdIt1 x, FwdIt2 y);
template&lt;class FwdIt1, class FwdIt2&gt;
    FwdIt2 swap_ranges(FwdIt1 first, FwdIt1 last, FwdIt2 x);
template&lt;class InIt, class OutIt, class Unop&gt;
    OutIt transform(InIt first, InIt last, OutIt x, Unop unop);
template&lt;class InIt1, class InIt2, class OutIt, class Bop&gt;
    OutIt transform(InIt1 first1, InIt1 last1, InIt2 first2,
        OutIt x, Bop op);
template&lt;class FwdIt, class T&gt;
    void replace(FwdIt first, FwdIt last,
        const T&amp; valo, const T&amp; valn);
template&lt;class FwdIt, class Pred, class T&gt;
    void replace_if(FwdIt first, FwdIt last, Pred pr,
        const T&amp; val);
template&lt;class InIt, class OutIt, class T&gt;
    OutIt replace_copy(InIt first, InIt last, OutIt x,
        const T&amp; valo, const T&amp; valn);
template&lt;class InIt, class OutIt, class Pred, class T&gt;
    OutIt replace_copy_if(InIt first, InIt last, OutIt x,
        Pred pr, const T&amp; val);
template&lt;class FwdIt, class Fun&gt;
    void generate(FwdIt first, FwdIt last, Fun fun);
template&lt;class OutIt, class Diff, class Fun&gt;
    void generate_n(OutIt first, Diff n, Fun fun);
template&lt;class FwdIt, class T&gt;
    FwdIt remove(FwdIt first, FwdIt last, const T&amp; val);
template&lt;class
FwdIt, class Pred&gt;
FwdIt remove_if(FwdIt first, FwdIt last, Pred pr);
template&lt;class InIt, class OutIt, class T&gt;
    OutIt remove_copy(InIt first, InIt last, OutIt x,
        const T&amp; val);
template&lt;class InIt, class OutIt, class Pred&gt;
    OutIt remove_copy_if(InIt first, InIt last, OutIt x, Pred pr);
template&lt;class FwdIt&gt;
    FwdIt unique(FwdIt first, FwdIt last);
template&lt;class FwdIt, class Pred&gt;
    FwdIt unique(FwdIt first, FwdIt last, Pred pr);
template&lt;class InIt, class OutIt&gt;
    OutIt unique_copy(InIt first, InIt last, OutIt x);
template&lt;class InIt, class OutIt, class Pred&gt;
    OutIt unique_copy(InIt first, InIt last, OutIt x, Pred pr);
template&lt;class BidIt&gt;
    void reverse(BidIt first, BidIt last);
template&lt;class BidIt, class OutIt&gt;
    OutIt reverse_copy(BidIt first, BidIt last, OutIt x);
template&lt;class FwdIt&gt;
    void rotate(FwdIt first, FwdIt mid, FwdIt last);
template&lt;class FwdIt, class OutIt&gt;
    OutIt rotate_copy(FwdIt first, FwdIt mid, FwdIt last, OutIt x);
template&lt;class RanIt&gt;
    void random_shuffle(RanIt first, RanIt last);
template&lt;class RanIt, class Ranf&gt;
    void random_shuffle(RanIt first, RanIt last, Ranf&amp; ranf);
template&lt;class BidIt, class Pred&gt;
    BidIt partition(BidIt first, BidIt last, Pred pr);
template&lt;class FwdIt, class Pred&gt;
    FwdIt stable_partition(FwdIt first, FwdIt last, Pred pr);
template&lt;class RanIt&gt;
    void sort(RanIt first, RanIt last);
template&lt;class RanIt&gt;
    void insertion_sort(RanIt first, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void sort(RanIt first, RanIt last, Pred pr);
template&lt;class RanIt, class Pred&gt;
    void insertion_sort(RanIt first, RanIt last, Pred pr);
template&lt;class BidIt&gt;
    void stable_sort(BidIt first, BidIt last);
template&lt;class RanIt&gt;
    void partial_sort(RanIt first, RanIt m, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void partial_sort(RanIt first, RanIt m, RanIt last, Pred pr);
template&lt;class InIt, class RanIt&gt;
    RanIt partial_sort_copy(InIt first1, InIt last1,
        RanIt first2, RanIt last2);
template&lt;class InIt, class RanIt, class Pred&gt;
    RanIt partial_sort_copy(InIt first1, InIt last1,
        RanIt first2, RanIt last2, Pred pr);
template&lt;class RanIt&gt;
    void nth_element(RanIt first, RanIt nth, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void nth_element(RanIt first, RanIt nth, RanIt last, Pred pr);
template&lt;class FwdIt, class T&gt;
    FwdIt lower_bound(FwdIt first, FwdIt last, const T&amp; val);
template&lt;class FwdIt, class T, class Pred&gt;
    FwdIt lower_bound(FwdIt first, FwdIt last,
        const T&amp; val, Pred pr);
template&lt;class FwdIt, class T&gt;
    FwdIt upper_bound(FwdIt first, FwdIt last, const T&amp; val);
template&lt;class FwdIt, class T, class Pred&gt;
    FwdIt upper_bound(FwdIt first, FwdIt last,
        const T&amp; val, Pred pr);
template&lt;class FwdIt, class T&gt;
    pair&lt;FwdIt, FwdIt&gt; equal_range(FwdIt first, FwdIt last,
        const T&amp; val);
template&lt;class FwdIt, class T, class Pred&gt;
    pair&lt;FwdIt, FwdIt&gt; equal_range(FwdIt first, FwdIt last,
        const T&amp; val, Pred pr);
template&lt;class FwdIt, class T&gt;
    bool binary_search(FwdIt first, FwdIt last, const T&amp; val);
template&lt;class FwdIt, class T, class Pred&gt;
    bool binary_search(FwdIt first, FwdIt last,
        const T&amp; val, Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt merge(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt,
    class Pred&gt;
    OutIt merge(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class BidIt&gt;
    void inplace_merge(BidIt first, BidIt mid, BidIt last);
template&lt;class BidIt, class Pred&gt;
    void inplace_merge(BidIt first, BidIt mid, BidIt last,
        Pred pr);
template&lt;class InIt1, class InIt2&gt;
    bool includes(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2);
template&lt;class InIt1, class InIt2, class Pred&gt;
    bool includes(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt set_union(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt,
    class Pred&gt;
    OutIt set_union(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt set_intersection(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt,
    class Pred&gt;
    OutIt set_intersection(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt set_difference(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt,
    class Pred&gt;
    OutIt set_difference(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class InIt1, class InIt2, class OutIt&gt;
    OutIt set_symmetric_difference(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x);
template&lt;class InIt1, class InIt2, class OutIt,
    class Pred&gt;
    OutIt set_symmetric_difference(InIt1 first1, InIt1 last1,
        InIt2 first2, InIt2 last2, OutIt x, Pred pr);
template&lt;class RanIt&gt;
    void push_heap(RanIt first, RanIt last);
template&lt;class RanIt&gt;
    void pop_heap(RanIt first, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void pop_heap(RanIt first, RanIt last, Pred pr);
template&lt;class RanIt&gt;
    void make_heap(RanIt first, RanIt last);
template&lt;class RanIt&gt;
    void sort_heap(RanIt first, RanIt last);
template&lt;class RanIt, class Pred&gt;
    void sort_heap(RanIt first, RanIt last, Pred pr);
template&lt;class FwdIt&gt;
    FwdIt max_element(FwdIt first, FwdIt last);
template&lt;class FwdIt, class Pred&gt;
    FwdIt max_element(FwdIt first, FwdIt last, Pred pr);
template&lt;class FwdIt&gt;
    FwdIt min_element(FwdIt first, FwdIt last);
template&lt;class FwdIt, class Pred&gt;
    FwdIt min_element(FwdIt first, FwdIt last, Pred pr);
template&lt;class BidIt&gt;
    bool next_permutation(BidIt first, BidIt last);
template&lt;class BidIt, class Pred&gt;
    bool next_permutation(BidIt first, BidIt last, Pred pr);
template&lt;class BidIt&gt;
    bool prev_permutation(BidIt first, BidIt last);
template&lt;class BidIt, class Pred&gt;
    bool prev_permutation(BidIt first, BidIt last, Pred pr)
///};    // end of namespace std
#endif /* _ALGORITHM_ */
    /* End of File */
</pre>
</body></html>
