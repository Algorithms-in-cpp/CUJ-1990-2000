


<HTML>
<HEAD>

<TITLE>October 1990/Developing A C Simulation Library</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Developing A C Simulation Library<A name="022D_0135"><A name="022D_0135"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="022D_0000"><A name="022D_0000">Richard Mustakos</font></h3><hr><blockquote><P>
<P><i><A name="022D_0000"><A name="022D_0000">Rich Mustakos has a B.S. in civil engineering from the Virginia Military Institute and currently works for MRJ, Inc. He has been an active programmer for 10 years and doing simulation modeling since 1983. You may reach him at 2404 Alsop Ct., Reston, VA 22091 or on CompuServ 76470,33.</i></P><P>
I recently was faced with writing a simulation project that would work on a multitasking operating system. I had not programmed under this particular operating system in over six years and was unfamiliar with the tools and system calls. This project was also under a tight deadline.<P>
Since I have been programming using Turbo C on MS-DOS systems, I decided the best approach would be to develop and debug the project on an MS-DOS system under Turbo C and port the code to the target system.<P>
To exploit the target system's multitasking features, I needed to emulate the system calls under MS-DOS. Once I had acquired enough information about the target system, I put together a short specification for the emulator and then coded it. <P>
After the emulator and the initial development of the project under MS-DOS, I ported the project to the target system (another long story in its own right). Once the port was running, I returned to the emulator and examined what I had written. <P>
The emulator's major thrust was to provide co-routine "process" control and timing capabilities, and inter-"process" communications links that mirrored the target system's calls.<P>
After examining the emulation software, I realized that the emulator very nearly constituted a discrete event simulation library. I then wrote a small requirements specification (see the sidebar <A HREF="sidebar1.htm">"Requirements Specification"</A>) and developed a simulation library.<P>
<h4><FONT COLOR="#000080"><A name="022D_0136">The Simulation Library<A name="022D_0136"></FONT></h4></P>
The simulation library consists of two header files and one code file. The first header file, <I>CSIM. H</I> (<A href="list1.htm">Listing 1</a>)
, is used by programmers in their simulations. It includes only those portions of the simulation library interface that must be visible to the programmer's project. </FONT></FONT><P>
The second header file, <I>CSIMINT. H </I>(<A href="list2.htm">Listing 2</a>)
 includes all of the internals for the simulation library and should not be <I>#include</I>d in the programmer's project. This header is <I>#include</I>d<I> </I>in the library code files. It includes the prototypes for all routines that are visible to the programmer, the routines and variables that are used exclusively inside the simulation library, and all structures and variables that are not visible to the programmer's project.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_0137">Data Structures<A name="022D_0137"></FONT></h4></P>
The<I> _simprocessT</I> structure (<A href="list2.htm">Listing 2</a>)
 holds all information pertaining to a process and connections between processes, including all pointers and general-purpose flag registers. Since the C specification does not ensure that all registers will be totally restored after a subroutine call, the entire register set must be stored, and then restored. The remaining fields <I>next</I> and <I>prev</I> are pointers to other <I>simprocess</I> structures; <I>init </I>records the process's level of initialization. <I>proc_id</I> is the process id number and is started sequentially from <I>1; kill_flag</I> notifies the task handler that this process is marked to be stopped, and <I>wait_flag </I>notifies it that the process is waiting on a post; <I>waitpost</I> is a pointer to a post and keeps track of which post the process is waiting for (<I>waitpost</I> is <I>NULL</I> if the process is not waiting); <I>start_time</I> is the time of the process's next action in <I>sim_system_time</I> units. The <I>_simprocessT</I> structure also serves as the basis for a process stack.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>_postT</I> structure (<A href="list2.htm">Listing 2</a>)
 is used for interprocess communications and to effect process synchronization. The structure contains pointers to other posts, its ID number, by which processes reference the post after it has been initialized, the post's name (which is used for initialization), a <I>void</I> pointer (<I>value</I>) that points to the memory to be passed in interprocess communications, and a pointer to an array of process pointers that keep track of all processes that are waiting for this post to be set.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_0138">Hidden Globals<A name="022D_0138"></FONT></h4></P>
The <I>processlist</I> instance is both the current process and <I>task_handler</I>'s link into the list of processes. <I>kbprocess</I> links to the process that handles keyboard activity. <I>totalprocs</I> holds the number of processes that have been produced, or produced and stopped. <I>old_vector</I> stores the old value of the interrupt vector that is being used for context switching, and which will be restored if an orderly exit is made. </FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Globals <I>init</I>,<I> glbl_sp</I>,<I> </I><I>glbl_ss</I>, <I>glbl_bp</I> and <I>glbl_fc</I> are used during initialization to store current register information, and to pass the routine to be used by the process to the task handler. <I>systimer</I> points to the memory location of the system clock. <I>postlist</I> points into the circular list of posts, and generally points to the last post to be used. <I>totalposts</I> records the number of posts that have been created in the system up to this point; there is no way to delete posts. </FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_0139">Control Routines<A name="022D_0139"></FONT></h4></P>
The system control routines include <I>install_handler</I>, <I>task_handler</I>, <I>sim_start</I>, <I>set_time_ratio</I> and <I>exit_processing</I> (<A href="list3.htm">Listing 3</a>)
. The routine <I>install_handler</I> installs the <I>task_handler</I> and saves the old interrupt vector for <I>exit_processing</I> to reinstall. It also tests to see if the installation was successful, though it can be fooled. If the <I>task_handler</I> was already installed, the routine will return an error.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The routine <I>task_handler</I> is the heart of the simulation system. It accomplishes context switching, context initialization and context destruction, checks for user input, updates system time, and determines which is the next process to gain control. Almost all of these functions are shaped by the method used for context switching, which uses the Turbo C concept of the <I>interrupt</I> routine type. Routines declared as <I>interrupt</I> type must be installed as interrupts, When the associated interrupt is invoked, all of the CPU registers will be saved on the stack (where the programmer can get to them and save them elsewhere if desired).</FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>task_handler</I> is a type <I>interrupt</I> routine which, when called through an interrupt, places all available register values on the stack, where they are accessible as local variables. These variables are used to fill the appropriate fields in the <I>_simprocessT</I> structure when switching out of a context. The same stack variables are overwritten with values from a process <I>_simprocessT</I> fields for a particular process when a different context becomes "current."</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
In several areas, I have chosen to err of the side of caution, creating some potential redundancies. For example, each process context has its own stack area, located in memory directly above <I>_simprocessT</I> structure for that process. When each process is started, the following occurs: the stack and base pointer fields in the process's structure and actual registers are initialized to the top of its stack, the <I>CS</I> (code segment) and <I>IP</I> (instruction pointer) fields are set to point to the routine specified for this process, all the registers are transferred out of the structure to the stack and an interrupt return instruction is executed. Keeping copies in both the structure and on the stack and replacing those on the stack before the interrupt return may be unnecessary, but makes me feel safer.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_013A">Context Initialization<A name="022D_013A"></FONT></h4></P>
The <I>task_handler</I> routine will initialize a context if called while the global <I>_sim_init_val</I> equals <I>1</I>. Three pre-conditions must be established before requesting a context initialization. First, <I>glbl_fc</I> should contain the address of the routine that will be run when this process starts running. Second, <I>processlist</I> should be set to the address of the <I>_simprocessT</I> structure that will contain information on this process. Finally, the stack pointer, stack segment and base pointer registers must point to the top of stack space for this process. After enforcing these conditions, the proper values are placed in the process's structure, the structure field <I>init</I> is set to <I>1</I>, and the <I>task_handler</I> returns control to the calling routine (<I>start_process</I>). This portion of initialization generally occurs before the simulation starts, but these actions will still be performed even if a process is created after the simulation starts.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The second part of initialization occurs once simulation has started. At this time, <I>_sim_init_val</I> is <I>0</I>, and the structure field <I>init</I> is <I>1</I>. These flags cause the <I>task_handler</I> to load the code segment and instruction pointer registers with values pulled out of the fields in the structure and the field <I>init</I> is set to <I>0</I>. After the interrupt return has completed, the process starts executing as though it were called from another routine. At this point the process is up and running on its own.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>stop_process</I> is called when a process must be destroyed. This routine finds the <I>_simprocessT</I> structure for the process to be stopped and sets the field <I>status.kill_flag</I> to <I>1</I>. After <I>stop_process</I> has changed the value of <I>status.kill_flag</I> for that process, the <I>task_handler</I> removes the offending process from the list of processes and frees its memory.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
At each transfer of control, <I>task_handler</I> looks for the next process to be given control. It can decide in one of three ways. If a key has been pressed, <I>task_handler</I> automatically passes control to the keyboard routine (assuming one has been designated with <I>start_kb_process</I>). If there are no pending keystrokes and <I>_sim_time_ratio</I> is <I>0</I>, <I>task_handler</I> will start the process with the lowest value of <I>start_time</I> and advances <I>_sim_system_time</I> to match <I>start_time</I>. If <I>_sim_time_ratio</I> is not <I>0</I>, the difference between now and the last time update is multiplied by <I>_sim_time_ratio</I> and added to <I>_sim_system_time</I>. The process (if any) with a <I>start_time</I> less than or equal to <I>_sim_system_time</I> becomes the current process, and <I>_sim_system_time</I> is set to <I>start_time</I>. If no process has a <I>start_time</I> less than or equal to <I>_sim_start_time</I>, <I>task_handler</I> continues to loop through the list of processes while actual system time goes by, updating <I>_sim_system_time</I> at the rate of <I>_sim_time_ratio</I> until a processes <I>start_time</I> is reached.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The last system control routines are <I>sim_start</I> and <I>exit_processing</I>.<I> sim_start</I> starts the actual simulation processes by setting the global variable <I>init</I> to <I>0</I>. An interrupt is then executed to start <I>task_handler</I>. The routine <I>exit_processing</I> cleans up after the simulation library and may additionally signal any errors on exit. To shut down the simulation system, the interrupt that was initially changed to hold the address of <I>task_handler</I> is returned to the value in <I>old_vector</I>. Finally, all the process and post memory structures are freed.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The process control routines are <I>start_kb_process</I>, <I>start_process</I> and <I>stop_process</I>. The major difference between the routines <I>start_kb_process</I> and <I>start_process</I> is that <I>start_kb_process</I> signals to <I>task_handler</I> that the process it is about to initialize is to be the designated keyboard handler. These routines ensure that the <I>task_handler</I> has been installed and allow it to perform the first level of initialization.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>start_kb_process</I> and the <I>start_process</I> routines call <I>getvect ( )</I> to determine if the <I>task_handler</I> has been installed. <I>getvect( )</I> checks that the address of the selected interrupt is the same as the address of <I>task_handler</I>. If the returned address is not the same as <I>task_handler</I>, then <I>install_handler</I> is called to install <I>task_handler</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
When <I>start_kb_process</I> and <I>start_process</I> set up a process, they allocate memory equal to the size of a <I>_simprocessT</I> structure plus a stack (sized in paragraphs). The address of the structure is normalized as it would be in a huge memory model program. The stack segment is set to the normalized segment address of the structure, and the stack and base pointers are set to the normalized offset address of the structure, plus the size of the stack in bytes, establishing the stack space as a unique piece of memory for each process.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The code segment and instruction pointer fields of the <I>_simprocessT</I> structure for the current process are set to point to the beginning of the routine to be used by the process. Next, the new structure is spliced into the <I>processlist</I>. Finally, these routines save the current stack and base pointers in global variables, set the actual stack and base pointers to the newly-created stack, call <I>task_handler</I> to initialize the process structure, and clean up the stack and base pointers from global variables.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>stop_process</I> is one of the simpler routines since <I>task_handler</I> performs the majority of the operations required to kill a process. <I>stop_process</I> merely finds the correct <I>_simprocessT</I> structure and sets the <I>status.kill_flag</I> to <I>1</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The routines <I>wait_until_time</I> and <I>wait_for_time</I> directly control timing of processes. <I>wait_until_time</I> determines the interval between the current time and the desired start time. If the interval is negative, <I>exit_processing</I> is called with an appropriate number. If the interval is positive, then <I>wait_until_time</I> calls <I>wait_for_time</I> to request the delay. <I>wait_for_time</I> determines the time to wake the process, sets the process's <I>start_time</I> and then executes an interrupt to <I>task_handler</I>. <I>task_handler</I> waits until <I>_sim_system_time</I> is equal to the process's start time before returning control to the process.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_013B">Communications And Synchronization<A name="022D_013B"></FONT></h4></P>
The final set of routines are those that perform interprocess communications and synchronization: <I>init_post</I>,<I> set_post</I>,<I> get_post</I> and <I>wait_post</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>init_post</I> can produce a new post or verify the existence of an old post. When called, <I>init_post</I> checks all existing posts to determine if the incoming string argument names an existing post. If so, the ID for the matching post is returned to the calling process. If no post exists for that name, a new post with initial values set to <I>NULL</I> is linked into the list of posts. The new post's ID number is returned to the calling routine.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>set_post</I> is more complicated than <I>init_post.set_post</I> searches the list of posts for one with the proper ID. If the candidate post is currently set, a zero time wait is performed, allowing a simultaneous read of the old value to occur. If the value is still set, the routine returns the ID of the post to signal the error. Otherwise, the value address is set to the address supplied by the user.</FONT></FONT></FONT></FONT><P>
If one or more processes are waiting for this post, the <I>status.wait_flag</I> field in the first waiting process structure is assigned <I>0</I>, notifying <I>task_handler</I> that the process has started. Additionally, any processes found waiting on this post are placed into the <I>NULL</I>-terminated array of process pointers linked to the <I>_postT</I> structure.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>get_post</I> searches the list of posts for one with the appropriate ID. If the matching post's value field is <I>NULL</I>, <I>get_post</I> returns <I>NULL</I>, signifying that the post is not set. Otherwise, <I>get_post</I> returns the address stored in <I>value</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>wait_post</I> functions much like <I>get_post</I>, but when <I>wait_post</I> encouters a <I>NULL</I> value field, it sets the process's <I>status.wait_flag</I> to <I>1</I>,<I> </I>signaling <I>task_handler</I> to ignore this process. The post's address is placed in the process structure's <I>waitpost</I> field, and the address of the process is placed in the <I>_postT</I>'s<I> waiting</I> array. <I>wait_post</I> then waits for the <I>value</I> field of the post to become something other than <I>NULL</I>. When this occurs, the post value is <I>NULL</I>ed and returned to the calling program. The process <I>status.wait_flag</I> is then set to <I>0</I> and normal processing continues.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_013C">Using the Library<A name="022D_013C"></FONT></h4></P>
The library's programming interface consists of visible routines declared in <I>CSIM.H.</I></FONT><P>
<pre>int start_kb_process (void
   (*func)(void),int stacksize);
int start_process (void
   (*func)(void), int stacksize);</pre>
Both routines initialize a process to start the routine <I>func</I>, with a stack that is 16 times <I>stacksize</I> bytes of memory <I>long</I>. The routine <I>start_kb_process</I> also<I> </I>attaches keyboard input to the process. Both routines can be called before or during a simulation run and allow processes to be spawned during the simulation.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>int set_time_ratio (float ratio);</pre>
This routine sets the simulation running speed to allow a maximum of <I>ratio</I> seconds of simulation time to occur during each second of real time. If the <I>ratio</I> is zero, the simulation will progress as fast as it can. This process may be called anytime before or during a simulation; its effects are immediate.</FONT></FONT></FONT></FONT><P>
<pre>void sim_start (void);</pre>
This routine starts the simulation, passing control out of the calling routine to the task handler. This routine should be called only once to start the simulation and does not return control to the<I> </I>calling routine.</FONT></FONT><P>
<pre>void exit_processing (int condition);</pre>
This routine stops the simulation. <I>exit_processing</I> cleans up the<I> </I>interrupt table and deallocates all process memory. This routine prints the value of <I>condition</I> to provide some debug<I> </I>information to the programmer. This routine can only be called once, but can be called anywhere in a program.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>void stop_process (int process_id);</pre>
This routine stops the process identified by <I>process_id</I>. This routine should only be called after a simulation has started. You can also stop a process by sending it a signal that tells it to stop itself.</FONT></FONT><P>
<pre>int wait_until_time
   (long unsigned starttime);</pre>
To delay until a particular simulation time is reached, a process should put<I> </I>itself to "sleep" by calling this routine with the "wakeup" time, <I>start_time</I>, in seconds. Control is passed to <I>task_handler</I> and the simulation<I> </I>continues. Generally, control will return to this routine when <I>CurrentTime</I> is equal to <I>start_time</I> for this process. This routine should only be called after <I>sim_start</I> has been called.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>int wait_for_time (float delaytime);</pre>
To stop for a certain, predetermined time, a process should call this routine with the delay time in seconds. Control passes to <I>task_handler</I> and is returned to the calling routine after <I>delaytime</I> seconds of simulation time have elapsed. This routine should only be called after <I>sim_start</I> has been called.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>int init_post  (char *postname);</pre>
This routine causes the system to check if a post with the name contained in <I>postname</I> exists. If the post does not exist, one is created and its ID is returned. If the post does exist, its ID is returned to the calling program. Control is always returned to the calling<I> </I>program with no change in simulation time. This routine may be called at any time.</FONT></FONT></FONT></FONT><P>
<pre>int set_post  (int post_id, void * pointer);</pre>
After a post has been initialized,<I> </I>information can be passed to other processes by calling <I>set_post</I>. The arguments are the integer ID of the required post and a pointer to a memory buffer. When called, <I>set_post</I> surrenders control of the system for zero time, allowing<I> </I>simultaneous events to occur. This routine returns <I>0</I> if successful, the ID of the post if the post has already been set, and the negative ID if the post was not found. This routine should only be called after <I>sim_start</I> has been called.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>void *get_post  (int post_id);</pre>
A process must call <I>get_post</I> to get<I> </I>information from a post identified as the argument <I>post_id</I>. If the post is not set, a <I>NULL</I> pointer is returned. If the post has been set, the pointer the post was set to is returned, and the post is reset. When this routine is called, control remains with the routine, and no simulation time passes. This routine should only be called after <I>sim_start</I> has been called.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>void *wait_post  (int post_id);</pre>
This routine can be used both to pass information and to synchronize<I> </I>processes. The argument <I>post_id</I> identifies the post to be checked. If the post has been set, control is returned<I> </I>immediately to the calling process. If the post is not set, control does not return to the calling process until another process sets the post this process is waiting for. If there is no post with that ID, the routine returns a <I>NULL</I> to the calling routine, otherwise the routine returns the pointer in the value field of the post, and this field is then reset to <I>NULL</I>. This routine should only be called after <I>sim_start</I> has been called.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_013D">An Example<A name="022D_013D"></FONT></h4></P>
Discrete event simulation can<I> </I>simulate a single queue, multi-server teller system (see <A href="list4.htm">Listing 4</a>)
. The routine<I> generator</I> sends customers into the<I> </I>simulation and the three copies of the process teller then service and release them.</FONT></FONT></FONT></FONT></FONT></FONT><P>
Using these routines requires knowledge of their internal structure (to keep from doing things that are 'bad'). All processes start with a stack that does not come from MS-DOS. The process should never finish with a normal exit. If a process is to be exited, it must kill itself and then wait for some period of time to allow the <I>task_handler</I> to delete it from memory. The system does not know when a simulation is over, so programmers should include a process that shuts down the simulation:</FONT></FONT><P>
<pre>void ender(void)
 {
 wait_for_time(8 _HOURS_);
 exit_processing(0);
 }</pre>
This process allows the simulation to run for up to eight hours and then stops it. If this process is started as the<I> </I>keyboard process, it will be awakened when a key is pressed, calling <I>exit_ processing</I> which shuts down the simulation system. The routine <I>generator </I>initializes a post for passing information to the other processes. The generator process then spends the rest of the simulation looping through a section of code that introduces a customer into the simulation, calls <I>set_post</I> to notify the teller processes of the customer's arrival and waits up to four and a half minutes before restarting the loop.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The teller process initializes the same post that the generator process<I> </I>initialized, giving the processes a way to communicate with each other. In<I> </I>particular, the teller processes will wait until they are notified that a customer has arrived by being sent the named<I> </I>signal <I>"Customers"</I>. After initializing this post, the routine goes into an endless loop where it spends the rest of the simulation either waiting for notification that a customer has entered the<I> </I>simulation, or serving the customers, an<I> </I>operation that takes at least four minutes but no more than 10 minutes. Whenever this process is given the named signal, it checks to see if any customers are still in the queue. If there are customers, the process sends the named signal so that another teller process will see it and serve the next customer.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The only portion of this simulation that I have not shown is the actual<I> </I>creation of the processes and the start of the simulation. In this section we declare and initialize the global variables<I> customers</I> and <I>tellers</I>, and set the<I> </I>simulation time ratio to 1,000:1, completing our general initialization. To initialize our processes, a generator, three <I>tellers</I> processes and an <I>ender</I> process are started. I have set the size of the stacks for all the processes to 64 paragraphs of memory, or one Kb of stack space per process. (A good rule of thumb is that if things act strange, increase the stack space. I analyze all the routines that are called to come up with an approximate stack size, and then add another <I>0x20</I> or <I>0x30</I> paragraphs to that size. Since the processes all have the same stack size, I only check to see if the last one returns an error. If there is not enough room for one of the earlier processes, there will not be enough room to generate the <I>ender</I> process.) To<I> </I>actually start the simulation, call <I>sim_start</I>. Although I have a <I>return</I> after that point in <I>main</I>, note that control never returns from <I>sim_start</I> to <I>main</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
I have included another demo routine, <I>grfcdemo.c</I> (<A href="list5.htm">Listing 5</a>)
. <I>grfcdemo.c</I> shows the library's ability to be integrated into a graphics environment.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_013E">Further Discussion<A name="022D_013E"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022D_013F">Resource Control and Contention<A name="022D_013F"></FONT></h4></P>
Resources are another area of simulation. A resource is any item in limited supply that is required by one or more processes but cannot be used by more than one process at the same time.<P>
Ideally, a resource can be requested by multiple processes at the same time, and actually delivered to a particular process based on some prioritization scheme, either FIFO or FIFO by priority, or whatever scheme is appropriate.<P>
A crude method of performing this scheme is to use <I>set_post</I> and <I>wait_post</I> inside another routine to allocate and deallocate resources from processes, and to use a global variable to track how many of the resources are available at any one time.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_0140">Swapping Processes Out of Memory<A name="022D_0140"></FONT></h4></P>
One of this system's limitations is that only as many<I> </I>processes may be active as can fit into memory. Having more active processes would be possible if the <I>_simprocessT</I> structure and the process stack could be transfered out of DOS memory, either onto disk or into expanded or extended memory.<I> </I>Swapping the structure out of MS-DOS memory risks corrupting the base and stack pointers and the stack segment pointer. This corruption would occur if the process were loaded into a different area of memory after a swap. This problem is not insurmountable, since the new register values could be calculated on the fly.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022D_0141">A Continuous Simulation Library<A name="022D_0141"></FONT></h4></P>
Continuous simulation is possible using this library. If each process sets its own step time and loops through updating itself and waiting for that amount of time, the same effect can be achieved as with true continuous modeling. An advantage of continuous simulation over continuous modeling is that each simulation process may set a different step time as<I> </I>required by the real-world process it is modeling, thereby<I> </I>reducing the overall CPU load while not degrading the resolution of the simulation. </FONT></FONT></FONT></FONT><P>

<h4>Sidebar: <A HREF="sidebar2.htm">Discrete Event Simultaion</A>

<h4><a href="../../../source/1990/oct90/mustakos.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
