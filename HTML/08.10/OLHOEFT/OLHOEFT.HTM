


<HTML>
<HEAD>

<TITLE>October 1990/Addressing Super VGA Modes From Protected Mode C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Addressing Super VGA Modes From Protected Mode C<A name="022B_0133"><A name="022B_0133"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="022B_0000"><A name="022B_0000">Gary R. Olhoeft</font></h3><hr><blockquote><P>
<P><i><A name="022B_0000"><A name="022B_0000">Gary R. Olhoeft has been programming digital computers since 1968. He has a BSEE, MSEE and PhD in physics. Inquiries about the complete libhpgl.lib extended graphics library may be addressed to Gary R. Olhoeft, P.O. Box 10870 Edgemont, Golden, CO 80401; Compuserve 76665,2021, or golhoeft on BIX.</i></P><P>
Many compilers lack support for the Super VGA modes available on some graphics cards. This article and the accompanying code explain the pixel-level addressing requirements of one card, the ATI VGA Wonder, in modes from EGA up to 800x600x256 and 1024x768x16 from the 80386 protected mode. The code was developed with MicroWay's NDP C-386 compiler, running under Phar Lap's protected mode extensions to MS-DOS, as part of a larger device independent graphics library. The ability to address four gigabytes of linear memory and other advantages of 386 protected mode extensions to DOS are discussed in Ducan (1990).<P>
<h4><FONT COLOR="#000080"><A name="022B_0134">Pixel Addressing<A name="022B_0134"></FONT></h4></P>
Low-level pixel addressing cannot be accomplished with ANSI C constructs alone. At some point, C extensions are necessary to invoke interrupts, address ports, and read or write graphics card registers or memory. These operations may all readily be done in assembly language, but assembly language is very hardware-specific and not portable. The first version of the code presented here was developed using the <I>blk_bm(), blk_mb(), inp(), int386()</I> and <I>outp()</I> extended functions in the <I>libGREX.lib</I> of MicroWay's NDP C-386 compiler. The MicroWay manual states: "These routines allow you to write to I/O ports, access memory directly, and pass control to interrupt service routines. Used improperly, they will almost certainly lead to disaster. Under most circumstances, you should not have to use these functions. When they are used, these routines should be called with extra care." Taking extra care, these are exactly the functions required for pixel-level graphics drivers. After development and testing with these extended functions, critical functions were recoded with the Phar Lap 386 | ASM assembler. Then, the assembler output of the compiler was studied to locate the time-sensitive portions where the C and assembler code could best be merged. The final products were functions coded in NDP C-386 using the inline assembler (a portion of which are presented here).</FONT></FONT></FONT></FONT></FONT></FONT><P>
ATI provides (with the card) a number of assembly language code fragments to assist program development. Developing protected mode code required solving several problems, only one of which is discussed here: addressing the graphics card registers and memory in real mode from protected mode. The code was developed in a mixture of C and inline assembler as a trade-off between the portability of C and the speed of assembler. Inline assembly keeps all the code in one place without separate compile, assemblage, and link steps. This is a significant advantage when supporting more than one graphics card, each with separate assembly-level SVGA driver requirements.<P>
MicroWay suggests addressing real mode memory through the <I>blk_mb()</I> and <I>blk_bm()</I> functions. I wanted more selective control at the byte, word and double word level, so I developed the code to address real mode memory more directly. An example is the <I>poke()</I> function that puts a single byte into real mode memory:</FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>#define   poke(addr,  val) asm("  push  es");\
asm("     mov    ax,  034h");\
asm("     mov    es,  ax");\
ebx  =   addr;  cl =  val;\
asm(ebx,   cl,  "    mov  byte  ptr  es:[ebx],  cl");\
asm("     pop    es")</pre>
implemented as a #<I>define</I> using inline assembler. A commented version appears in <A href="list2.htm">Listing 2</a>.
 <A href="list1.htm">Listing 1</a>
also shows the <I>peek()</I> function.</FONT></FONT></FONT></FONT><P>
<A href="list3.htm">Listing 3</a>
shows how to substitute and poke an 8-bit byte, 16-bit word or 32-bit double word into real memory from protected mode.<P>
The simplest example is illustrated with the 256 color MCGA mode 0x13 320x200 that uses one byte per pixel. To write color (0-255) to pixel (<I>x,y</I>), the code is:</FONT></FONT><P>
<pre>poke(655360 + y*colx + x, color);
/*  colx = 320 pixels across the screen */</pre>
where <I>x</I> and <I>y</I> are pixel screen coordinates; <I>0, 0</I> at upper left.</FONT></FONT></FONT></FONT><P>
Not quite as simple, but given as examples in several texts, the 16-color EGA modes (0x10 640x350, 0x12 640x480 and 0x54 800x600) are addressed through the EGA registers (where <I>colx</I> is 640 or 800) (<A href="list4.htm">Listing 4</a>)
.</FONT></FONT><P>
Still more complicated are the higher color or resolution 640x480x256, 800x600x256, and 1024x768x16 modes. The real mode graphics memory starting at address <I>655360 </I>(<I>0xA000000</I>)<I> </I>only stretches for 64K (65536) bytes in size. Yet these modes require 307,200 (640x480), 480,000 (800x600), or 393,216 (1024x768) bytes (the last is two pixels per byte) to fill a graphics screen. Addressing the graphics memory in the graphics card requires sending the data through the 64K region starting at real memory address <I>655360</I>. Sending through more than 64K requires breaking the data into 64K blocks and paging the graphics card. Going through the same exercise as before, <A href="list5.htm">Listing 5</a>
shows the code to write color (0-255) in 640x480 or 800x600 256-color mode to <I>x,y.</I></FONT></FONT></FONT></FONT></FONT><P>
The variable <I>old_page</I> is used to determine whether the current and previous coordinates are on the same or different memory pages. After the paging code, note the similarity to the 320x200x256 mode. <A href="list6.htm">Listing 6</a>
gives the code to write color (0-15) in 1024x768 mode to <I>x,y.</I></FONT></FONT></FONT><P>
However, in this version the code changes to accommodate two pixels per byte. Since only one pixel is changing, the byte containing both neighboring current pixels must be read in, it must be determined which half of the byte to change, and both (original and changed) pixels must be written back out as one byte.<P>
As shown, these code fragments plot a single pixel at a time. If a group of pixels are to be plotted at once (as a series of points defining a line vector or plane image), the code can be optimized. For example, in raster plotting in the 1024x768 mode, paging is only important when <I>y</I> is changing, not when <I>x</I> is changing. Similarly in 256 color mode, instead of writing one byte at a time, four pixels along the <I>x</I>-axis can be combined into one 32-bit double word that can be moved much faster than four individual bytes. On a 25-MHz 80386 using raster methods on the ATI VGA Wonder, the entire screen can be filled with an image in 0.17 second (320x200x256 MCGA) to 0.83 second (1024x768x16 SVGA) to 4.28 seconds (640x480x16 VGA).<P>
The remainder of <A href="list1.htm">Listing 1</a>
shows how to open graphics modes and generalize a pixel write for any mode (mode independent graphics). The code also shows the differences between setting the color palettes in the various modes. All of the 256-color modes use the <I>vga_palette()</I> function, and the 16-color modes (except 1024x768) use the <I>set_palette()</I> function from the MicroWay <I>libGREX. lib.</I> The 1024x768x16 mode uses the <I>ext_palette()</I> function shown in the listing.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The complete library uses this type of approach to provide device independent graphics for several graphics cards of different manufacturers, with windowing and global user scaling (instead of pixel counting), WYSIWYG CRT vector graphics to HPGL plotters/printers, rotatable and scalable fonts, mixed vector and raster graphics, and more. Only four library functions (the vector pixel driver, the raster image driver, the graphics mode function, and the window clear function) need modification to add capabilities of new graphics cards. Most graphics cards will obey the EGA 16-color register modes, with allowances made for the differing mode numbers (for example, the 800x600x16 mode on the ATI is <I>0x63,</I> but the Orchid is <I>0x30</I> and Paradise is <I>0x58)</I>. Most graphics cards set the video mode much like the standard IBM modes (using BIOS interrupt <I>10h</I> and function <I>00h</I>) as shown in the listing, but some (for example, Everex and Video 7) set the video mode differently. The 1024x768x16 modes may or may not be paged. The 256-color modes use different memory paging boundaries and addresses, requiring separate treatments for each card beyond the IBM standard MCGA 320x200x256 (for example, ATI uses 64K pages but Paradise uses 4K pages). The Video Electronics Standards Association (VESA) is attempting to standardize these super VGA graphics modes, and VESA compatible cards are now available. The IBM 8514/A and Texas Instruments 340x0 TIGA graphics interfaces are different due to the on board graphics co-processor. However, the same types of problems addressed in these examples will also guide the solution to driving those graphics boards (although some, such as the Truevision ATVista 34010 board, may be addressed directly from protected mode). </FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022B_0135">Suggested reading:<A name="022B_0135"></FONT></h4></P>
Duncan, Ray, ed., 1990, <I>Extending DOS,</I> Reading, MA, Addison-Wesley, 432p.<P>
Ericson, Bo, 1990, "VESA VGA BIOS Extensions," <I>Dr. Dobb</I>'<I>s Journal,</I> v.14, n.4, p.65-70.<P>
Kliewer, Bradley D., 1988, <I>EGA/VGA A</I> <I>Programmer's Reference Guide</I>, NY, McGraw-Hill, 269p.<P>
Richter, Jake and Smith, Bud, 1990, <I>Graphics Programming For The</I> <I>8514/A</I>, Redwood City, CA, M&amp;T Books, 366p.<P>
Stevens, Roger T., 1988, <I>Graphics Programming In C</I>, Redwood City, CA, M&amp;T Publishing Inc., 639p.<P>

<h4><a href="../../../source/1990/oct90/olhoeft.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
