


<HTML>
<HEAD>

<TITLE>October 1990/Standard C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Standard C<A name="022F_0137"><A name="022F_0137"></font></h2><P>
<h3 align="center"><A name="022F_0000"><A name="022F_0000">Character Classification Functions</h3><P>
<h3 align="center"><font color="#800000">P.J Plauger</font></h3><hr><blockquote><P>
<P><i><A name="022F_0000"><A name="022F_0000">P.J. Plaunger has been a prolific programmer, textbook author, and software enterprenuer. He is secretary of the ANSI C standards committee, X3J11, and convenor of the ISO standards committee, WG14. His latest book is Standard C which he co-authored with Jim Brodie.</i></P><P>
Last month, I began the long trek through the Standard C library. I discussed the header &lt;<I>assert.h</I>&gt;, how to use it and how it can be implemented. The next stop on the journey, in alphabetical order at least, is the header &lt;<I>ctype.h</I>&gt;.</FONT></FONT></FONT><P>
Here is what the C standard has to say about this header:<P>
<h4><FONT COLOR="#000080"><A name="022F_0138">4.3 Character Handling <B><I>&lt;ctype. h&gt;</I><A name="022F_0138"></B></FONT></h4></P>
The header &lt;<I>ctype.h</I>&gt; declares several functions useful for testing and mapping characters. [<B>Footnote:</B> See "future library directions" (§4.13.2).] In all cases the argument is an <I>int</I>, the value of which shall be representable as an <I>unsigned char</I> or shall equal the value of the macro <I>EOF</I>. If the argument has any other value, the behavior is undefined.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The behavior of these functions is affected by the current locale. Those functions that have implementation-defined aspects only when not in the "<I>C</I>" locale are noted below.</FONT></FONT><P>
The term <I>printing character</I> refers to a member of an implementation-defined set of characters, each of which occupies one printing position on a display device; the term <I>control character</I> refers to a member of an implementation-defined set of characters that are not printing characters. [<B>Footnote:</B> In an implementation that uses the seven-bit ASCII character set, the printing characters are those whose values lie from <I>0x20</I> (space) through <I>0x7E</I> (tilde); the control characters are those whose values lie from <I>0</I> (<I>NUL</I>) through <I>0x1F</I> (<I>US</I>), and the character <I>0x7F</I> (<I>DEL</I>).]</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0139">Forward References: EOF (4.9.1), localization (4.4).<A name="022F_0139"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_013A">4.3.1 Character Testing Functions<A name="022F_013A"></FONT></h4></P>
The functions in this section return nonzero (true) if and only if the value of the argument <I>c</I> conforms to that in the description of the function.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_013B">4.3.1.1 The <B><I>isalnum</I></B> Function<A name="022F_013B"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_013C">Synopsis<A name="022F_013C"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int isalnum(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_013D">Description<A name="022F_013D"></FONT></h4></P>
The <I>isalnum</I> function tests for any character for which <I>isalpha</I> or <I>isdigit </I>is true.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_013E">4.3.1.2 The <B><I>isalpha</I></B> Function<A name="022F_013E"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_013F">Synopsis<A name="022F_013F"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int isalpha(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_0140">Description<A name="022F_0140"></FONT></h4></P>
The <I>isalpha</I> function tests for any character for which <I>isupper</I> or <I>islower</I> is true, or any character that is one of an implementation-defined set of characters for which none of <I>iscntrl, isdigit,</I> <I>ispunct</I>, or <I>isspace</I> is true. In the "<I>C</I>" locale, <I>isalpha</I> returns true only for the characters for which <I>isupper</I> or <I>islower</I> is true.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0141">4.3.1.3 The <B><I>iscntrl</I></B> Function<A name="022F_0141"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_0142">Synopsis<A name="022F_0142"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int iscntrl(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_0143">Description<A name="022F_0143"></FONT></h4></P>
The <I>iscntrl</I> function tests for any control character.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0144">4.3.1.4 The <B><I>isdigit</I></B> function<A name="022F_0144"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_0145">Synopsis<A name="022F_0145"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int isdigit(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_0146">Description<A name="022F_0146"></FONT></h4></P>
The <I>isdigit</I> function tests for any decimal-digit character (as defined in §2.2.1).</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0147">4.3.1.5 The <B><I>isgraph</I></B> Function<A name="022F_0147"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_0148">Synopsis<A name="022F_0148"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int isgraph(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_0149">Description<A name="022F_0149"></FONT></h4></P>
The <I>isgraph</I> function tests for any printing character except space (' ').</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_014A">4.3.1.6 The <B><I>islower</I></B> Function<A name="022F_014A"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_014B">Synopsis<A name="022F_014B"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int islower(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_014C">Description<A name="022F_014C"></FONT></h4></P>
The <I>islower</I> function tests for any character that is a lower-case letter or is one of an implementation-defined set of characters for which none of <I>iscntrl, isdigit, ispunct,</I> or <I>isspace</I> is true. In the "<I>C</I>" locale, <I>islower</I> returns true only for the characters defined as lower-case letters (as defined in §2.2.1).</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_014D">4.3.1.7 The <B><I>isprint</I></B> Function<A name="022F_014D"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_014E">Synopsis<A name="022F_014E"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int isprint(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_014F">Description<A name="022F_014F"></FONT></h4></P>
The <I>isprint</I> function tests for any printing character including space (' ').</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0150">4.3.1.8 The <B><I>ispunct</I></B> Function<A name="022F_0150"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_0151">Synopsis<A name="022F_0151"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int ispunct(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_0152">Description<A name="022F_0152"></FONT></h4></P>
The <I>ispunct</I> function tests for any printing character that is neither space (' ') nor a character for which <I>isalnum</I> is true.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0153">4.3.1.9 The <B><I>isspace</I></B> Function<A name="022F_0153"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_0154">Synopsis<A name="022F_0154"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int isspace(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_0155">Description<A name="022F_0155"></FONT></h4></P>
The <I>isspace</I> function tests for any character that is a standard white-space character or is one of an implementation defined set of characters for which <I>isalnum</I> is false. The standard white-space characters are the following: space (' '), form feed ('\<I>f '</I>), new-line ('\<I>n '</I>), carriage return ('\<I>r '</I>), horizontal tab ('\<I>t '</I>), and vertical tab ('\<I>v '</I>). In the "<I>C</I>" locale, <I>isspace </I>returns true only for the standard white-space characters.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0156">4.3.1.10 The <B><I>isupper</I></B> Function<A name="022F_0156"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_0157">Synopsis<A name="022F_0157"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int isupper(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_0158">Description<A name="022F_0158"></FONT></h4></P>
The <I>isupper</I> function tests for any character that is an upper-case letter or is one of an implementation-defined set of characters for which none of <I>iscntrl, isdigit, ispunct,</I> or <I>isspace</I> is true. In the "<I>C</I>" locale, <I>isupper</I> returns true only for the characters defined as upper-case letters (as defined in §2.2.1).</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0159">4.3.1.11 The <B><I>isxdigit</I></B> Function<A name="022F_0159"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_015A">Synopsis<A name="022F_015A"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int isxdigit(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_015B">Description<A name="022F_015B"></FONT></h4></P>
The <I>isxdigit</I> function tests for any hexadecimal-digit character (as defined in §3.1.3.2).</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_015C">4.3.2 Character Case Mapping Functions<A name="022F_015C"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_015D">4.3.2.1 The <B><I>tolower</I></B> Function<A name="022F_015D"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_015E">Synopsis<A name="022F_015E"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int tolower(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_015F">Description<A name="022F_015F"></FONT></h4></P>
The <I>tolower</I> function converts an upper-case letter to the corresponding lower-case letter.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0160">Returns<A name="022F_0160"></FONT></h4></P>
If the argument is a character for which <I>isupper</I> is true and there is a corresponding character for which <I>islower</I> is true, the <I>tolower</I> function returns the corresponding character; otherwise the argument is returned unchanged.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0161">4.3.2.2 The <B><I>toupper</I></B> Function<A name="022F_0161"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="022F_0162">Synopsis<A name="022F_0162"></FONT></h4></P>
<pre>#include &lt;ctype.h&gt;
int toupper(int c);</pre>
<h4><FONT COLOR="#000080"><A name="022F_0163">Description<A name="022F_0163"></FONT></h4></P>
The <I>toupper</I> function converts a lower-case letter to the corresponding upper-case letter.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0164">Returns<A name="022F_0164"></FONT></h4></P>
If the argument is a character for which <I>islower</I> is true and there is a corresponding character for which <I>isupper </I>is true, the <I>toupper</I> function returns the corresponding character; otherwise the argument is returned unchanged.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="022F_0165">History<A name="022F_0165"></FONT></h4></P>
Character handling has been important since the earliest days of C. Many of us were attracted to the DEC PDP-11 because of its rich set of character manipulation instructions. When Ken Thompson moved UNIX to the PDP-11/20, he gave us a great vehicle for manipulating streams of characters in a uniform style. When C came along, it was only natural that we should use it to write programs preoccupied with walloping characters.<P>
This was truly a new style of programming. C programs tended to be small and devoted to a single function. The tradition until then was to write huge monoliths that offered a spectrum of services. C programs read and wrote streams of human-readable characters. The tradition until then was to have programs communicate with each other via highly structured binary files. They spoke to people by producing paginated reports with embedded carriage controls.<P>
Those of us who wrote character manipulation programs before C wrote mostly in assembly language. A few of us more daring souls used FORTRAN as well. That took dedication, however. FORTRAN had few facilities, and fewer standards, for trafficking in characters.<P>
So the early toolsmiths writing in C under UNIX began developing idioms at a rapid rate. We often found ourselves sorting characters into different classes. To identify a letter, we wrote<P>
<pre>if ('A' &lt;= c &amp;&amp; c &lt;= 'Z'
    || 'a' &lt;= c &amp;&amp; c &lt;= 'z')
   .....</pre>
To identify a digit, we wrote<P>
<pre>if ('0' &lt;= c &amp;&amp; c &lt;= '9')
   ..... </pre>
And to identify white space, we wrote<P>
<pre>if (c == ' ' || c == '\t' || c
== '\n')
   .....</pre>
Pretty soon, our programs became thick with tests like this. Worse, some became thick with tests <I>almost</I> like this. Opinions differed on the best way to write a range test. Only a few diehards avoided the operators &gt; and &gt;= as religiously as I still do. You can contrive to write the same idiom a number of different ways. That slows comprehension and increases the chance for errors.</FONT></FONT><P>
Opinions also differed on the makeup of certain character classes. White space has always suffered notorious variability. Should you lump vertical tabs in with horizontal tabs and spaces? If you include new lines (which are actually ASCII line feeds), should you also include carriage returns (which UNIX reserves for writing overstruck lines)? The easier it is to get tools to work together, the more you want them to agree on conventions.<P>
The natural response was to introduce functions in place of these tests. That made them at once more readable and more uniform. The idioms for letter, digit and white space became<P>
<pre>if (isalpha(c))
   .....</pre>
and<P>
<pre>if (isdigit(c))
   .....</pre>
and<P>
<pre>if (isspace(c))
   .....</pre>
It wasn't long before a dozen-odd functions like these came into being. They soon found their way into the growing library of C support functions. More and more programs began to use them instead of reinventing their own idioms. The character classification functions were so useful, they seemed almost too good to be true.<P>
They were. A typical text processing program might average three calls on these functions for <I>every</I> character from the input stream. The overhead of calling so many functions often dominated the execution time of the programs. That led some programmers to back off from using the standard functions that had evolved. It led others to develop a set of macros to take their place.<P>
C programmers tend to like macros. They let you write code that is as readable as calling functions but is much more efficient. You just have to be ready for a few surprises:<P>
<UL><li>The macro may expand into much more code than a function call, even if it executes faster than the function call. If your program expands the macro in many places, it can grow surprisingly larger.</li>
<li>The macro may expand to a subexpression that doesn't bind as tight as a function call. This is an unacceptable surprise and always has been. A liberal use of parentheses in the macro definition can eliminate such nonsense.</li>
<li>The macro may expand one of its arguments to code that is executed more than once or not at all. A macro argument with side effects will cause surprises. While some C programmers consider such surprises acceptable, modern practice avoids them. Only two Standard C library functions, <I>getc</I> and <I>putc</I>, permit such <I>unsafe</I> behavior.</FONT></FONT></FONT></FONT></li></UL>
So the challenge in those early days was to produce a set of macros to replace the character classification functions. Because they were used a lot, they had to expand to compact code. They also had to be reasonably safe to use. What evolved was a set of macros that used one or more <I>translation tables</I>. Each macro took the form:<P>
<pre>#define isxxx(c) (ctyptab[c] &amp; XXXMASK)</pre>
The character <I>c</I> indexes into the translation table <I>ctyptab</I>. Different bits in each table entry characterize the index character. If any of the bits corresponding to the mask <I>XXXMASK</I> are set, the character is in the tested class. The macro expands to a compact expression that is nonzero for all the right arguments.</FONT></FONT></FONT></FONT></FONT></FONT><P>
One drawback to this approach is that the macro generates bad code for all the wrong arguments. Expand it with an argument not in the expected range and it accesses storage outside the translation table. Depending on the implementation, the error can go undetected or it can terminate execution with a cryptic message.<P>
On a machine that represents type <I>char</I> the same as <I>signed char</I>, this is a common error. The function call <I>isprint</I>(<I>c</I>) looks safe enough. But say <I>c</I> has type <I>char</I> and holds a value with the sign bit set. The argument will be a negative value almost cetainly out of range for the function. Few programmers know to write the safer from <I>isspace</I>((<I>unsigned char</I>)<I>c</I>).</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Nevertheless, translation tables remain the basis for many modern implementations of the character classification functions. They help the implementor provide efficient macros, even in the presence of multiple locales. And these functions remain important to the modern C programmer. You should use them wherever possible to sort characters into classes. They greatly increase your chances of having code that is both efficient and correct across varied character sets.<P>
<h4><FONT COLOR="#000080"><A name="022F_0166">Character Classifications<A name="022F_0166"></FONT></h4></P>
Classifying characters is not as easy as it appears. First you have to understand the classes. Then you have to understand where all the common characters live within the class system. Then you have to decide where to tuck the less than common characters. Then you need some understanding of how everything changes when you move to an implementation with a different character set. Finally, you need to be aware of  how the classes can change when the program switches out of the <I>"C"</I> locale.</FONT></FONT><P>
Let's start at the beginning. The classes defined by the character classification functions are:<P>
<I>digit</I> &#151; one of the ten decimal digits <I>'0'</I> through <I>'9'</I></FONT></FONT></FONT><P>
<I>hexadecimal digit</I> &#151; a digit or one of  the first six letters of the alphabet in either case, <I>'a</I>' through '<I>f</I>' and '<I>A</I>' through <I>'F'</I></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>lower case letter</I> &#151; one of the letters '<I>a</I>' through '<I>z</I>', plus possibly others outside the "<I>C</I>" locale</FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>upper case letter </I>&#151; one of the letters '<I>A</I>' through '<I>Z</I>',<I> </I> plus possibly others outside the "<I>C</I>" locale</FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>letter</I> &#151; one of the lower case or upper case letters, plus possibly others outside the "<I>C</I>" locale</FONT></FONT><P>
<I>alphanumeric </I>&#151; one of the letters or digits<P>
<I>graphic </I>&#151; a character that occupies one print position and is visible when written to a display device<P>
<I>punctuation</I> &#151; a graphic character that is not an alphanumeric, including at least the 29 such characters used to represent C source text<P>
<I>printable</I> &#151; a graphic character or the space character ' '<P>
<I>space </I>&#151; the space character ' ', one of the five standard motion control characters (form feed, newline, carriage return, horizontal tab, or vertical tab), plus possibly others outside the "<I>C</I>" locale</FONT></FONT><P>
<I>control</I> &#151; one of the five standard motion control characters, backspace, alert (or bell), plus possibly others.<P>
Note that two of these classes are open-ended even in the "<I>C</I>" locale. An implementation can define any number of additional punctuation or control characters. In ASCII, for example, punctuation also includes characters such as <I>@</I> and <I>$</I>. Control characters include all the codes between decimal 1 and 31, plus the delete character, whose code is 127.</FONT></FONT><P>
If you find all these classes confusing, take heart. So do I. I need a diagram to sort them all out. Figure 1 (taken from P.J. Plauger and Jim Brodie, <I>Standard C</I>, Microsoft Press, 1989) shows how the character classification functions relate to each other. <P>
The characters in the rounded rectangles are all the members of the basic C character set. These are the characters you use to represent an arbitrary C source file. The C standard requires that every target character set contain all of these characters. Every target character set must also contain the null character, whose code is zero.<P>
I have added single and double plus signs under some of the function names. A single plus sign indicates that the function can represent additional characters outside the "C" locale. A double plus sign indicates that the function can represent additional characters even in the "C" locale. </FONT></FONT></FONT></FONT><P>
A target character set can contain members that fall in none of these classes. The null character is best left out of all classes, for example. The same character must not, however, be added at more than one place in the diagram. If it is a lower case letter, it is of course also in several other classes by inheritance. But a character must not be considered both punctuation and control, for example.<P>
As you can see from the diagram, nearly all the functions can change behavior in a program that alters its locale. Only <I>isdigit</I> and <I>isxdigit</I> remain unchanged. If your code intends to process the local language, this is good news. The locale will alter <I>islower</I>, for example, to detect any additional lower case letter. </FONT></FONT></FONT></FONT></FONT></FONT><P>
If your code endeavors to be locale independent, however, you must program more carefully. Supplement any tests you make with the character classification functions to weed out any extra characters that sneak in. Or get all your locale independent testing out of the way before your program changes out of the "<I>C</I>" locale.</FONT></FONT><P>
If neither of these options is viable, you may have to revert part or all of the locale for a region of code. Begin the region with<P>
<pre>#include &lt;locale.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
   .....
   char *ls = setlocale(LC_TYPE, "C");
   if (ls)
      {
      char *ss = malloc(strlen(ls) + 1);
      ls = strcpy(ss, ls);
      }</pre>
And end the region with<P>
<pre>   if (ls)
      {
      setlocale(LC_CTYPE, ls);
      free(ls);
      }</pre>
If the region contains no calls to <I>setlocale</I>, you can eliminate the code that allocates, copies and frees the locale string. If the region is large, however, or if the code will be maintained by others in the future, play it safe. You are better off making the code robust than saving a few microseconds.</FONT></FONT><P>
The important message is that Standard C introduces a new era. You can now write code more easily for cultures around the world, which is good. But you must now write code with more forethought. If it can end up in an international application, it may someday process characters undreamed of by early C programmers. Trust the character classification functions to contain the problem, to help you with it, and to delineate what can change.<P>
<h4><FONT COLOR="#000080"><A name="022F_0167">Summary<A name="022F_0167"></FONT></h4></P>
I've reviewed the evolution of the character classification functions in the Standard C library. I've shown you how they relate to each other. And I've indicated how the functions can change between implementations and between locales.<P>
Next month, I will discuss implementation issues for the functions and macros defined in &lt;<I>ctype.h</I>&gt;. I will also present code for the header and the functions. None of it is complex, but keeping it portable and adaptable to changing locales is a delicate matter. Stay tuned. </FONT></FONT><P>
</BLOCKQUOTE>
</BODY>
</HTML>
