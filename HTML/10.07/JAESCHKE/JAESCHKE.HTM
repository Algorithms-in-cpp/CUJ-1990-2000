


<HTML>
<HEAD>

<TITLE>July 1992/Doctor C's Pointers</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjul.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Doctor C's Pointers&reg;<A name="014D_00AF"><A name="014D_00AF"></font></h2><P>
<h3 align="center"><A name="014D_0000"><A name="014D_0000">Data Structures, Part 14: Trees</h3><P>
<h3 align="center"><font color="#800000">Rex Jaeschke</font></h3><hr><blockquote><P>
<P><i><A name="014D_0000"><A name="014D_0000">Rex Jaeschke is an independent computer consultant, seminar leader, and author of several books, including The Dictionary of Standard C (Professional Press, Horsham, PA). Readers are encouraged to submit column topics and suggestions to Rex at 2051 Swans Neck Way, Reston, VA, 22091 or via UUCP at rex@aussie.com.</i></P><P>
In previous installments, this column has looked at arrays, linked lists, stacks, and queues. All of these data structures are linear. This month I begin a tour of a non-linear structure, the <I>tree</I>. The concept of a tree, with its root, branches, and leaves (or terminal nodes), is common in representing data organized as a hierarchy. By convention, however, you tend to view the tree as being inverted: the root is located at the top and the branches spread out in a downward direction. The whole set of nodes and branches below a given left or right child branch is known as a <I>subtree</I>.<P>
While a tree can have many branches and each branch can, itself, have many other branches, I will initially concentrate on a special kind of tree, the binary tree. A (non-empty) binary tree consists of a root node. This node may have zero, one, or two branches. A node is often referred to as a parent. As such, the two branches from a node lead to that node's left and right child nodes. Since each node may have up to two children and each child is a node, a binary tree can be arbitrarily deep.<P>
<h4><FONT COLOR="#000080"><A name="014D_00B0">Representing Algebraic Expressions<A name="014D_00B0"></FONT></h4></P>
One of the most common instances of trees in computing is algebraic expressions. (Refer to installment #9 in the February 1992, issue for an introduction to this subject.) Consider the expression<P>
<pre>((A + B) * (C - (D / E)))</pre>
Since every operator is binary (that is, it takes two operands), you can easily represent this expression as a binary tree, as in <A href="fig1.htm">Figure 1</a>.
<P>
This particular tree is reasonably well balanced. That is, the depth of each branch (as indicated by (1), (2), etc.) from the root is about the same. For the most part it is useful to keep tree depths shallow and the tree balanced.<P>
Throughout this series I have shown that data structures can be represented in memory either as elements in an array or in some form of dynamically allocated list. Trees are no exception. <A href="list1.htm">Listing 1</a>
implements the tree in <A href="fig1.htm">Figure 1</a>
as a statically allocated array of structures.<P>
In this simple tree, each node stores only one character of data, though it could easily store more within the structure, or else contain pointers to larger data structures. What the nodes contain is of no consequence here.<P>
The left and right child pointers are actually indices into the array that lead to the corresponding child, if any. If no child is present, the node's <I>left_child</I> and <I>right_child</I> contain the value <I>zero</I>. Because of this tactic, this scheme cannot use element zero of the array. I could have used some other sentinel value, like <I>-1</I>, but I would have been forced to use a signed rather than unsigned index variable, thereby losing half the possible range of index values.<P>
From a C programmer's point of view, it is more natural to write the left and right child branches as pointers. A <I>NULL</I> can then indicate "no child" and avoid wasting element zero of the array. In fact, using pointers completely frees you from using an array. The program in <A href="list2.htm">Listing 2</a>,
 which uses pointers, statically creates and initializes the tree, and proceeds to traverse it in three possible ways: <I>prefix, infix</I>, and <I>postfix</I> orders. Depending on the data you are using the tree to represent, you may wish to maintain the nodes in one of these three orders.<P>
Note that the codes uses a stack as well as a tree. The stack is a useful tool in traversing trees.<P>

<h4><a href="../../../source/1992/jul92/jaeschke.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
