


<HTML>
<HEAD>

<TITLE>July 1992/Extending C with Stored SQL Procedures</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjul.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Extensions</FONT></H2>

<hr><h2 align="center"><font color="#800000">Extending C with Stored SQL Procedures<A name="013D_00A3"><A name="013D_00A3"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="013D_0000"><A name="013D_0000">William Smith</font></h3><hr><blockquote><P>
<P><i><A name="013D_0000"><A name="013D_0000">William Smith is the engineering manager at Montana Software, a software development company specializing in custom applications for MS-DOS and Windows. You may contact him by mail at P.O. Box 663, Bozeman, MT 59771-0663.</i></P><P>
Extending C by embedding it with Structured Query Language (SQL) code takes advantage of both languages. For report generation and database querying, SQL works better than C. On the other hand, C works better than SQL for developing the overall application and user interface.<P>
To avoid complicating maintenance, debugging and portability when embedding SQL, you should isolate the SQL code from the C code. You can accomplish this with an extension interface technique called <I>stored procedures</I>, which stores the SQL statements for a given task in a database record. Storing procedures in a database record gives the user the ability to extend the application by creating new custom procedures and saving them for future use, without changing or recompiling the C code. Storing procedures in a database keeps them all located and organized in one place for fast retrieval.<P>
I will use examples from a project I completed for a customer to illustrate the technique of storing procedures in a database. The customer used Raima Data Manager in applications. While some DBMS applications support stored procedures, others, such as Data Manager, do not. So one of the first things I did was to add support for stored procedures.<P>
Raima Data Manager is a relational and network model DBMS. Data Manager (formerly <I>db_Vista</I>) is the C API and <I>db_Query</I> is the SQL API. Although Raima corporation sells Data Manager by itself without <I>db_Query</I>, to support SQL you must purchase the entire package including <I>db_Query</I>. Since the concept of SQL and stored procedures requires both Data Manager and <I>db_Query</I>, any reference I make to Data Manager is a reference to both Data Manager and <I>db_Query</I>.<P>
The version of SQL supported by Data Manager is a subset of standard SQL. It is only suitable for report generation. It does not support making modifications to the database. Even so, using SQL as the means to query the database and generate reports is much more efficient than using the C function interface.<P>
The code presented here is a library of functions for providing stored SQL procedure support to Data Manager. The code will work with either the MS-DOS or MS-Windows versions of the Data Manager and <I>db_Query</I> libraries. There are some subtle differences between these two versions. A small amount of conditionally compiled code (based on the whether or not the constant <I>_WINDOWS</I> is defined) accounts for these differences. The code works with v3.1/3.2 of Data Manager and v2.1/2.2 of <I>db_Query</I>.<P>
<h4><FONT COLOR="#000080"><A name="013D_00A4">Extension Interface Functionality<A name="013D_00A4"></FONT></h4></P>
Extending another language with stored procedures requires support of certain core functionality. In addition to the normal activities of storing, retrieving, modifying, and deleting data records in the database, the database functions must include the ability to execute the stored procedure. The DBMS API usually contains a function supporting the ability to parse and execute an SQL statement. In the case of Data Manager, these functions are <I>d_query</I>, <I>q_sqlinit</I>, and <I>q_nextval</I>.<P>
<h4><FONT COLOR="#000080"><A name="013D_00A5">Sample Code<A name="013D_00A5"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>,
 <I>SQL_PROC.C</I>, contains the functions required to support SQL stored procedures with Data Manager.<P>
Besides the basic functions for store, retrieve, modify, delete, and execute there are three other functions in <A href="list1.htm">Listing 1</a>.
 <I>sql_fetch_str</I> and <I>sql_fetch_dev</I> retrieve data after executing a SQL command. These two functions take a fairly simple approach and concatenate the column data for each row. Columns are comma and tab delimited. If you want to load individual columns into different entries in a 2-D list box in Windows, for instance, you will have to use the <I>db_Query</I> function <I>q_nextval</I> directly. You use <I>sqlproc_fetch_str</I> to fetch the results of query row by row. <I>sqlproc_fetch_str</I> returns the text for the row as a pointer to a dynamically allocated string. You must call <I>sqlproc_fetch_str</I> for each row. It will return NULL when there is no more data to fetch. <I>sqlproc_fetch_dev</I> will fetch rows to a device or file. You pass a pointer to the device (type FILE) as a parameter. A single call to <I>sqlproc_fetch_dev</I> will fetch all the rows to the device.<P>
The third additional function in <A href="list1.htm">Listing 1</a>
is <I>sqlproc_find</I>. You use this function to set the current record to the one specified by the procedure name (unique key). This function is a helper function for most of the other functions in <A href="list1.htm">Listing 1</a>.
<P>
Before you can call any of the functions in <A href="list1.htm">Listing 1</a>,
 you must have already opened the database that contains the <I>sql_proc</I> record and <I>sql_name</I> key field. Your program code will have to handle opening and closing the Data Manager database.<P>
<A href="list2.htm">Listing 2</a>,
 <I>SQLPPROC.H</I>, is one of the associated include files for <A href="list1.htm">Listing 1</a>,
 <I>SQL_PROC.C</I>. This include file contains prototypes for the functions in <A href="list1.htm">Listing 1</a>.
 It also contains some necessary manifest constants.<P>
<A href="list3.htm">Listing 3</a>,
 <I>SQL_PROC.DDL</I>, is the Data Definition Language (DDL) file that contains the definition of the <I>sql_proc</I> record and all its fields. It is set up to store the SQL procedures in their own database. If you choose, you can incorporate the <I>sql_proc</I> record into your own DDL file and database. To do this, just modify your database scheme to provide for a stored procedure record.<P>
The <I>sql_proc</I> record contains three fields. They are <I>sql_name</I>,<I> sql_description</I> and <I>sql_command</I>. <I>SQL_PROC.DLL</I> specifies <I>sql_name</I> as a unique key. The code in <A href="list1.htm">Listing 1</a>
uses this field as an access mechanism for each stored procedure. The field, <I>sql_description</I>, provides for an optional description of the procedure. The field, <I>sql_command</I>, is the actual SQL command string. All three fields are strings. The maximum lengths are set at 16, 64, and 424 characters (including zero terminator) respectfully. Feel free to change the length of these fields or even to add fields as required by your specific application. The sizes as they stand now, fit very efficiently into the Data Manager block file format. Changing the sizes will undoubtably lead to some wasted space.<P>
<A href="list4.htm">Listing 4</a>,
 <I>SQL_PROC.H</I>, is the Data Manager generated include file for <I>SQL_PROC.DDL.SQL_PROC.H</I> contains the structure definition for the <I>SQL_PROC</I> record and some manifest constants used to identify this record and its fields. The Data Manager utility <I>DDLP.EXE</I> creates this include file when processing the DDL file. <A href="list4.htm">Listing 4</a>
is the other associated include file for <A href="list1.htm">Listing 1</a>.
<P>
SQL commands can range from simple and short to very complex. The length limit on the field that holds the SQL command is arbitrarily set at 424 characters. Under Data Manager, creating a virtual table to view data with the <I>create</I> <I>view</I> command and then selecting data with the <I>select</I> command is a common scenario. SQL commands used to format the output data and to make mathematical calculations on the output data can get complicated. Generally the SQL statements I use with Data Manager fit within the 424 character field size. You may find that this is not an appropriate size for your situation. If you need a larger field, I recommend breaking the SQL command into separate lines and storing each in its own record. This is much more space efficient under a fixed field and record size DBMS such as Data Manager.<P>
<h4><FONT COLOR="#000080"><A name="013D_00A6">Sample Implementation<A name="013D_00A6"></FONT></h4></P>
The code<P>
<pre>sqlproc_store( "ListField",
   "Generate a list of "
   "all the stored "
   "procedures",
   "select %s;" );</pre>
stores a new procedure in the database under the name <I>ListField</I>. Since the name of the procedure field, <I>sql_name</I>, is a unique key, Data Manager will only create a new record if there is not an existing procedure with the name <I>ListField</I>. Typically the text for the name, the description, and the command will be input by the user through a data entry screen or editor.<P>
The following command will execute this procedure.<P>
<pre>sqlproc_exec( "ListField", "sql_name" );</pre>
Again, you should supply the stored procedure and field name as variables in the code, not as constants.<P>
Once you have executed a stored procedure and produced output associated with this procedure, you can fetch the output with either <I>sqlproc_fetch_str</I> or <I>sqlproc_fetch_dev</I>. <I>sqlproc_fetch_str</I> dynamically allocates strings row by row. You must call <I>sqlproc_fetch_str</I> once for each row until <I>sqlproc_fetch_str</I> returns NULL. You can also fetch all the rows to a device (file) with a single call to the function <I>sqlproc_fetch_dev</I>. If you need to fetch into a Windows list box or some other particular user-interface object, you will most probably have to write your own fetch function.<P>
<h4><FONT COLOR="#000080"><A name="013D_00A7">Argument Passing<A name="013D_00A7"></FONT></h4></P>
Notice, that <I>sqlproc_exec</I> supports a variable argument list. You need this to support passing arguments to the stored procedure. If you need a stored procedure with arguments, the command string for the SQL statements will have to contain markers to where the arguments go. I use the C syntax for <I>printf</I>. In effect, the SQL command string that is stored in the database is a format string. You build the actual SQL command with the requested arguments with the function <I>vsprintf</I>. You must make sure you match the number and type of arguments with a specific stored procedure. The simple example above passes a single string argument to the stored procedure <I>ListField</I>. The stored procedure expects the name of a field in the database. Passing arguments are important from the standpoint of code reusability. In this case you are reusing the stored-procedure code. If you want to query the database for fields that match a certain value, it is natural to have that value be set with an argument.<P>
<h4><FONT COLOR="#000080"><A name="013D_00A8">Hints<A name="013D_00A8"></FONT></h4></P>
Providing a list of all the stored procedures for a user to choose from is one of the first user-interface features you will want to add to your program. Loading all the procedure names into a list box is a handy way to accomplish this under Windows. The user can then select a procedure by name to either execute, edit (modify), delete, or view. Having a second list box that contains the descriptions for the procedures or even static text that you update with the description of current highlighted procedure will help make the interface easier to use.<P>
<h4><FONT COLOR="#000080"><A name="013D_00A9">Debugging<A name="013D_00A9"></FONT></h4></P>
Before you save a stored procedure to the database, it is a good idea to make sure that it parses and executes correctly. To help in this regard, the code displays the error message, if any, resulting from parsing the SQL statement. You can turn this feature on or off when compiling <A href="list1.htm">Listing 1</a>.
 If you define <I>_DEBUG</I> when you compile <A href="list1.htm">Listing 1</a>,
 this feature will be supported. The message is sent to <I>stderr</I> under MS-DOS and displayed in a Message Box under MS-Windows.<P>
A DBMS that supports stored procedures directly usually stores the procedures in a pre-parsed or compiled format. This eliminates the need to parse the SQL command before execution. The speed advantages are obvious. The implementation presented here for Data Manager is unable to do this.<P>
<h4><FONT COLOR="#000080"><A name="013D_00AA">Conclusions<A name="013D_00AA"></FONT></h4></P>
Extending C by embedding SQL can have great benefits when working with a DBMS that has both a C and SQL API. Using stored procedures for embedding SQL keeps the SQL statements out of the C code and stores them in your database. By storing the SQL statements in the database, you can modify the SQL statements and maintain them independently of the C code. This provides a means to have user-defined and maintainable procedures. The maintenance of the SQL statements can proceed without modifying the C code and recompiling. Likewise, you can modify and recompile C code without change to the database.<P>
The concept of stored procedures as an extension interface is not limited to SQL and C. You can treat any language you are embedding in another in a similar fashion. Keystroke macros and specific text-processing extensions to C come to mind. If you can store the embedded language or language extensions outside the Standard C code, do it. The advantages are many. When maintenance and modification time comes, you will be glad you did.<P>

<h4><a href="../../../source/1992/jul92/smith.zip">Get Article Source Code</a></h4>

</BODY>
</HTML>
