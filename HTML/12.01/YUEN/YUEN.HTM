

<HTML>
<HEAD>

<TITLE>January 1994/Handling Time-Consuming Windows Tasks</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Handling Time-Consuming Windows Tasks<A name="0024_0009"><A name="0024_0009"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0024_0000"><A name="0024_0000">Andy Yuen</font></h3><hr><blockquote><P>
<P><i><A name="0024_0000"><A name="0024_0000">Andy Yuen has a Master and a Bachelor degree in Electrical Engineering from Carleton University in Ottawa, Canada. He has been working in the software industry for over 14 years. He is currently a senior software engineer with a company in Sydney, Australia, which specializes in automation and network management. Andy can be reached by e-mail at auawyl@grieg.sdi.oz.au.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0024_000A">Introduction<A name="0024_000A"></FONT></h4></P>
Microsoft Windows 3.X and OS/2 Presentation Manager (PM) programmers are probably all aware of the "1/10 second rule" &#151; an application should take no longer than 1/10 of a second to process a message. Any task which takes longer can be considered a "big job." And a big job degrades the system response. Sometimes, it even brings the system to a standstill while it is running. This happens because there is only one input message queue for all Windows or PM applications. Once you hold up this queue, other applications cannot run. OS/2, to some extent, is less affected by a big job than Windows due to its true multitasking capability; other non-PM tasks can still run. Also, OS/2 has a lot more built-in facilities to combat this problem. (For example, see the <a href="sidebar2.htm">sidebar</a> on OS/2's object windows.)<P>
The usual work-around under Windows is to have <I>PeekMessage</I> loops scattered all through a program. This article proposes an alternate solution. It describes the small C++ class <I>Cschlr</I> which provides the functions of a simple scheduler. It manages thread creation, deletion, and synchronization by using counting semaphores and timed functions. A Windows program can create one or more threads to handle time-consuming tasks and then pass control back to Windows quickly via the message loop. Thread interactions can be synchronized by using counting semaphores and timed functions. Although this C++ class has been designed from the ground up for Windows, it can actually be used unmodified for OS/2. I also discuss a number of the design/implementation issues, and illustrate its use with a complete example.<P>
<h4><FONT COLOR="#000080"><A name="0024_000B">Design<A name="0024_000B"></FONT></h4></P>
The design criteria of <I>Cschlr</I> are based on the KISS (Keep-It-Simple-Stupid) principle. Consequently, <I>Cschlr</I> must be simple, small, and portable. It is intended to work in the following fashion:<P>
1.     Threads can be created before entering the main <I>PeekMessage</I> loop or can be created anywhere in an application.<P>
2.     Threads can terminate themselves anywhere within an application.<P>
3.     Parameters can be passed to threads during thread creation.<P>
4<I>.     PeekMessage</I> needs only be used once in <I>WinMain</I>.<P>
5.     Counting semaphores and timed functions provide synchronization among threads.<P>
The interface to the <I>Cschlr</I> class (C++ header file) can be found in <A href="list1.htm">Listing 1</a>.
 Member functions can be found in <A href="list2.htm">Listing 2</a>.
 The constructor and destructor are self-explanatory. I give below a brief description of the rest of the methods:<P>
<pre>int CreateThread(THDFN func, int stacksize, void *param);</pre>
Used to create a thread, where <I>func</I> is the thread procedure, <I>stacksize</I> is the size of the stack for the thread and <I>param</I> is a pointer to user parameters to be passed to the thread. This method is modelled after the <I>BeginThread</I> function provided by C compilers for OS/2. The returned integer is the thread number.<P>
<pre>void Suicide();</pre>
The counterpart of <I>CreateThread</I>. A thread can kill itself by either calling <I>Suicide</I> explicitly or by letting itself to fall through the end of the thread function.<P>
<pre>Csemq* CreateSem(long lValue);</pre>
Used to create a counting semaphore and to initialise its value to <I>lValue.</I> It returns the semaphore object on success or a null pointer on failure.<P>
<pre>void Signal(Csemq *sem, long lMaxCount = 256);</pre>
Used to signal a semaphore. <I>Sem</I> is a semaphore object created by <I>CreateSem. lMaxCount</I> is the maximum semaphore count allowed. If the current semaphore count is greater than or equal to <I>lMaxCount,</I> its count will not be increased any further. The calling thread always gets back control after calling <I>Signa1</I>. (Refer to the <a href="sidebar1.htm">sidebar</a> for a description of the operation of counting semaphores)<P>
<pre>void Wait(Csemq *sem);</pre>
Used to wait on a semaphore. If the semaphore count is smaller than 1, the calling thread will be blocked until signalled by another thread.<P>
<pre>void Preempt();</pre>
Used by the calling thread to give up the CPU voluntarily.<P>
<pre>void Sleep(long 1Seconds);</pre>
Used by the calling thread to go to sleep for <I>lSeconds</I>. Another ready-to-run thread will be despatched.<P>
<pre>void GetSemStates(Csemq *sem, long &amp;lCount, int &amp;fWait);</pre>
Used to retrieve the current states of the semaphore object <I>sem</I>. On return, <I>lCount</I> contains the semaphore count and <I>fWait</I> is set to TRUE if there is at least one thread waiting on the semaphore and FALSE otherwise.<P>
<pre>void Run();</pre>
Used to dispatch threads and to give them a slice of the CPU. This method is normally only invoked in the main <I>PeekMessage</I> loop.<P>
<h4><FONT COLOR="#000080"><A name="0024_000C">Implementation<A name="0024_000C"></FONT></h4></P>
<I>Cschlr</I> implements the high-level thread and semaphore management services and provides the interface to the user. It maintains a ready-to-run queue for threads and keeps tracks of the identity of the running thread. The state transition diagram of <I>Cschlr</I> is shown in <A href="fig1.htm">Figure 1</a>.
 <I>Preempt</I> handles the task switch. It moves the running thread to the ready-to-run queue and schedules another thread from the ready-to-run queue for execution. <I>Wait</I> allows the running thread to wait in a semaphore queue while another ready-to-run thread is dispatched. <I>Signal</I> moves a thread waiting in a semaphore queue back to the ready-to-run queue. And <I>Sleep and Wakeup</I> provide time-delay services to all threads. Please note that <I>Wakeup</I> is used only internally by <I>Cschlr</I>.<P>
In order to implement the above, <I>Cschlr</I> calls on the services of two private classes: <I>Csemq</I> (see <A href="list3.htm">Listing 3</a>
and <A href="list4.htm">Listing 4</a>)
 and <I>Cthread</I> (<A href="list5.htm">Listing 5</a>
and <A href="list6.htm">Listing 6</a>)
. Consequently, it is easy to understand how <I>Cschlr</I> works once one knows the internals of <I>Csemq</I> and <I>Cthread</I>. Hence, I'll start with these and come back to <I>Cschlr</I> later.<P>
<I>Csemq </I>is a private class of <I>Cschlr.</I> This means that all of its methods and data are private to the containing class. Only <I>Cschlr</I> can access them, besides <I>Csemq</I> itself, because <I>Cschlr</I> has been declared as a friend of <I>Csemq</I>.<P>
<I>Csemq</I> provides semaphore services to <I>Cschlr</I>. There is a counter and a queue associated with each counting semaphore. Most C++ compilers come with class libraries which provide common objects like lists, stacks, queues, etc. However, if I had used any one of these class libraries, the code would no longer be portable among different compilers. Also, in examining the requirements, and sticking to the small-is-beautiful design philosophy, I decided to implement my own queue management routines because I don't need the full functions of these class libraries anyway.<P>
I use a long integer to represent both a queue and a counter. If the MSB (Most Significant Bit) is a 0, the long integer is a counter, which means that the counter is at most 31 bits long. When the MSB is 1, the long integer is a queue. Each set bit (non-zero bit) in the long integer represents a thread. For example, a value of <I>0x8003</I> contains two threads: bit 0 is thread #0, and bit 1 is thread #1. This implies that there are at most 31 threads possible. This should be more than enough for our purpose.<P>
If multiple threads are waiting on a semaphore, which thread should we resume when a signal has been received? I decided that a somewhat round-robin algorithm should be implemented. I said "somewhat" because it is not possible to implement a truly round-robin algorithm using the queue implementation described above &#151; such a queue does not keep the order in which threads are queued. (Someone might point out that this is a contradiction in terms, and that it is not really a queue if it does not maintain the order. Maybe I should have called it an unordered list. Anyway, I'll refer to it as a queue throughout this article.)<P>
In order to simulate a round-robin effect, each <I>Csemq</I> object has a private variable priority associated with it. Priority is set to <I>CSC_NO_THREAD</I> (whose value is 31) when a <I>Csemq</I> object is created. Method <I>Dequeue</I> returns a thread number for <I>Cschlr</I> to schedule its execution. It starts scanning the semaphore queue one bit to the left of the bit position recorded in priority. Since priority is set to 31, it starts scanning from bit 0 (wraparound) moving to bit 1, bit 2, etc.<P>
When a thread is found, its position is saved in priority. For example, if thread 4 (bit 4) is the first thread found waiting on the semaphore, <I>Dequeue</I> starts scanning from bit 5 the next time it is invoked. The reason that I go to such trouble to implement this scheduling algorithm is to prevent a thread from monopolizing the CPU. Take for example the following case: thread 0 and thread 1 are waiting on the same semaphore. Assume that thread 0 starts execution and later waits on the same semaphore. If I start scanning always from bit 0, thread 0 will always get awakened when the semaphore gets signalled. Thread 1 will never get a chance to run. By implementing the aforementioned "somewhat" round-robin scheduling algorithm, this situation could be avoided.<P>
Semaphore operations such as <I>Signal</I> and <I>Wait</I> should be atomic or indivisible. They cannot be interrupted in the middle of an operation. If the operation is not atomic, one might get into the situation where two threads try to perform an operation on the same semaphore concurrently. It may happen that while one operation is half-way through the operation, the operating system switches to another thread which then updates the semaphore count or queue, rendering the semaphore structure inconsistent. Under Windows, this would never happen because of the cooperative multitasking model used: a Windows procedure only gives up the CPU voluntarily. There is no chance of having two truly concurrent threads of execution under Windows. The <I>PeekMessage</I> loop is the mechanism to multiplex the CPU among a number of pseudo-concurrent threads in an application which uses <I>Cschlr</I>.<P>
<h4><FONT COLOR="#000080"><A name="0024_000D">Class <B><I>Cthread</I><A name="0024_000D"></B></FONT></h4></P>
<I>Cthread</I> is also a private class of <I>Cschlr</I>. It provides thread objects to <I>Cschlr</I>. In order to keep this class implementation portable, I avoided the use of inline assembly since the syntax is different among compilers. The most portable way to implement this is to use the Standard C library's <I>setjmp</I> and <I>longjmp</I> functions. These were originally designed for error recovery purposes and people are starting to question their usefulness under C++, which has exception handling. However, these two funcitons prove to be invaluable in implementing the <I>Cthread</I> class.<P>
Unfortunately, the use of <I>setjmp</I> and <I>longjmp</I> do not make <I>Cthread</I> 100 per cent portable, due to the layout of the <I>jmp_buf</I> structure. <I>jmp_buf</I> is used to save the context of execution when <I>setjmp</I> is called. The execution context consists of various CPU registers. The only time that I need to know which registers go where is during the creation of a thread. One needs to set the CS:IP (Code Segment:Instruction Pointer) and the SS:SP (Stack Segment:Stack Pointer) to simulate a <I>setjmp</I> during thread creation.<P>
<I>Cthread</I> maps the <I>jmp_buf</I> to a data structure defined within <I>CTHREAD. CPP</I>. The <I>typedef</I> statement:<P>
<pre>typedef struct {
    long ip; //CS:IP
    short filler; //don't care
    long sp; //SS:SP
} *mapptr;</pre>
defines a pointer type for this purpose. It works for the Zortech C++ Version 3 compilers for Windows and OS/2, which I am using for the development of <I>Cschlr.</I> If you are using a different compiler, you need to change this type definition to reflect the difference in implementation of these functions.<P>
There are two ways to find out the structure of your compiler's <I>jmp_buf</I>. The first is to examine the sources for the C library if they are available. The second method, and probably the easier of the two, is to write a very simple C program which calls <I>setjmp</I>. Compile and link it with debugging information. Then use the source-code debugger to compare the register and <I>jmp_buf</I> values before and after executing <I>setjmp</I> to find out where the CS:IP and SS:SP registers get saved.<P>
The other thing to remember is that <I>Cthread</I> is intended to be compiled using the large memory model. The magic number <I>WORDSTOREMOVE</I> is defined as 3. Different values are needed for different memory models. The magic number is 3 because the C library function <I>setjmp</I> has the form:<P>
<pre>int setjmp(jmp_buf env);</pre>
A thread pushes <I>env</I> onto the stack, and then calls s<I>etjmp</I>, thus saving the 32-bit return address on the stack. <I>setjmp</I> then saves the BP (Base Pointer) register on the stack (the standard C function prologue). When <I>longjmp</I> is called to restore the stack environment, it discards the saved BP and return address on the stack. For the <I>large</I> memory model, the return address occupies four bytes while BP occupies two bytes, for a total of three 16-bit words. Since this function relies on the standard C prologue to work properly, the compiler must be instructed to generate the standard C function prologue instead of the one for Windows. Consequently, you will notice that there are two different compile option macros defined in the Makefile (<A href="list8.htm">Listing 8</a>)
 for the example program: one for compiling <I>Cschlr, Csemq</I>, and <I>Cthread</I>, the other for compiling the Windows main program.<P>
<I>Cthread</I> saves the context of a thread in the data structure <I>THD</I>. The member <I>Context</I> is the <I>jmp_buf</I>. <I>TotalLen</I> is the total length of the <I>THD</I> structure in bytes. This value is needed for the destructor of a thread object, which frees the allocated storage for the stack. <I>OverFlowed</I> is a flag set to zero to guard against stack overflow. <I>Stack</I> is the stack for the thread. Since the stack grows downward in a X86 processor, if overflow occurs <I>Overflowed</I> will hopefully be overwritten with a nonzero value. <I>Cthread</I> refuses to switch to a thread with a nonzero <I>OverFlowed</I> flag when the <I>Transfer</I> method is invoked.<P>
The implementation of <I>Cschlr</I> is quite straightforward except for <I>CreateThread</I>, which passes a user parameter to the thread, and the implicit termination of a thread by falling through the thread function. Again, <I>Cschlr</I> is designed for the <I>large</I> memory model. <I>CreateThread</I> creates a new thread by:<P>
<pre>task[i] = new Cthread(func, stacksize, (int *) &amp;retaddr, 4);</pre>
The argument value 4 specifies the number of 16-bit words to copy to the new thread's stack. In order to force a thread to kill itself when falling through the thread function body, a return address is copied to the stack, together with the user parameter to be passed to the thread. This return address points to <I>Kill</I>, a static function within <I>CTHREAD.CPP</I>. See <A href="fig2.htm">Figure 2</a>
for the stack layout during thread creation. When the thread exits the thread function, it returns to <I>Kill</I>, which calls <I>Suicide</I> to terminate itself. The address of <I>Kill</I> and the user parameter pointer take up four words when the large memory model is used.<P>
Note also that there are 33 slots reserved:<P>
<pre>Cthread *task[CSC_NO_THREAD + 3];</pre>
in the <I>Cschlr</I> object although there can only be 31 threads. One extra slot is used for the Windows main program while the other is for termination of threads. When <I>Run,</I> the method that multiplexes the CPU among various threads, is called within the <I>PeekMessage</I> loop, its context gets saved in the slot <I>task[MAIN]</I>. When a thread gives up the CPU voluntarily, control is passed back to <I>MAIN</I> so that it can continue with the <I>PeekMessage</I> loop. Consequently, a <I>Wait</I> or a <I>Sleep</I> must not be called within the <I>PeekMessage</I> loop. Otherwise it will bring back the big-job problem that we meant to avoid.<P>
When <I>Sleep</I> is called, the thread is put to sleep in the dummy semaphore queue <I>WaitQ</I>. All sleeping threads are maintained in chronological order in the form of a linked list. During each task switch, the table is scanned and the threads that have reached the end of their sleep are moved to the ready-to-run queue <I>ReadyQ</I>. If there is no ready-to-run thread in <I>ReadyQ</I>, control is returned to <I>MAIN</I> immediately.<P>
The slot <I>task[DUMMY]</I> is used for thread termination. It is required because a <I>Cthread</I> object always saves the context of the running thread during a task switch. <I>task[DUMMY]</I> is used for saving the context of the terminating thread temporarily. The context saved in it never needs to be restored because that thread no longer exists after committing suicide.<P>
<h4><FONT COLOR="#000080"><A name="0024_000E">An Example<A name="0024_000E"></FONT></h4></P>
The best way to understand <I>Cschlr</I> is by example. Charles Petzold describes the Salvage benchmark as an example of a "big job" <a href="#2">[2]</a>. I'll use the same example to contrast the <I>Cschlr</I> solution to the big job to the solutions described in his article. Instead of starting from scratch, I'll use Gpf Systems Inc.'s OS/2-based Gpf code generator. My version of Gpf is Version 1.3, which runs on OS/2 V1.3. It is a tool very similar to Microsoft's Visual C++. However, it generates Windows, OS/2 16-bit, and 32-bit C code.<P>
It was ahead of its time when I first got it in early 1992. I believe the latest version is Gpf 2.0. Instead of going into details as to how it works, let me just say that it generates the framework for a Windows applications and creates the necessary resources. I am just using it as an event dispatcher, which means that whenever an event occurs &#151; the user clicks on a menu item, for example &#151; Gpf will call my function for handling that event.<P>
The example program is called <I>BIGJOB.CPP.</I> [Note: <I>BIGJOB.CCP</I> is not listed here because of its size. It will be on the monthly code disk. See <I>BIGJOB.H</I>, <A href="list7.htm">Listing 7</a>,
 which implements the main logic of the example. &#151; mb] <I>BIGJOB</I> has only two menu items: Repetition and Action. Repetition allows a user to select the number of iterations to run the Salvage benchmark and Action allows a user to either Start or Abort its execution. Running it for 10,000 iterations may take quite a while depending on the speed of your system. <I>BIGJOB</I> displays a progress report every five seconds and shows the total time taken for running the benchmark to completion. While the benchmark is running, a user can switch to any Windows application at will without appreciable delay. An application which is not designed to execute a big job will lock up the computer for the duration of the benchmark. This example clearly demonstrates the power of <I>Cschlr</I>.<P>
As I have said before, I am using Gpf as an event dispatcher. Whenever an event occurs, one of my functions gets called. The only thing I need to change in the Gpf generated source code is to replace the generated main message loop with my <I>PeekMessage</I> loop. In order to expedite the development, the body of my event handling functions (the file <I>BIGJOB.H</I>) is included in <I>BIGJOB.CCP</I> by an <I>#include</I> directive. People may frown at this method, but it is actually suggested in the Gpf manual <a href="#4">[4]</a>.<P>
Another thing that needs to be done is to rename the generated file <I>BIGJOB.C</I> to <I>BIGJOB.CPP</I> in order to use C++ classes. Some may find Gpf's generated comments to be excessive. Other may find that, for such a small application, the generated code is more complex than necessary and many functions are included although they never get used. This is no longer true if you use Gpf to develop a large application. After all, there is always a price to pay for the convenience one gets by using Gpf.<P>
The events that I hook into include:<P>
<h4><FONT COLOR="#000080"><A name="0024_000F"><I>WM_CREATE<A name="0024_000F"></I></FONT></h4></P>
Gpf calls <I>CreateThread(VOID)</I> to create two threads: <I>Timer</I> and <I>Big. Timer</I> is responsible for the periodic progress report when the benchmark is running. It invalidates the main window to force <I>PaintWindow(pGpfParms)</I> to repaint the screen. Note that Gpf usually passes a pointer of type <I>PGPFPARMS,</I> which contains all windows-related parameters like handles, messages, etc. to a user-supplied function for event handling.<P>
<I>Big</I> is the thread that actually carries out the benchmark. Notice that <I>Big</I> gives up the CPU voluntarily after each invocation of <I>Salvage</I> by calling <I>mtask.Preempt()</I>. This allows the main <I>PeekMessage</I> loop to regain control so that other Windows applications may run. It also examines <I>fContinue</I> to see whether it should abort the benchmark and enable the <I>Start</I> item in the application menu.<P>
<h4><FONT COLOR="#000080"><A name="0024_0010"><I>WM_PAINT<A name="0024_0010"></I></FONT></h4></P>
Gpf calls <I>PaintWindows(pGpfParms)</I> which displays the appropriate message on the screen.<P>
<h4><FONT COLOR="#000080"><A name="0024_0011"><I>WM_COMMAND<A name="0024_0011"></I></FONT></h4></P>
Gpf calls <I>SelectRep(pGpfParms)</I> which sets the number of repetitions and puts a check mark in the selected item by calling the Gpf function <I>GpfMenuTick.</I><P>
Gpf calls <I>StartSalvage(pGpfParms)</I> to disable the item <I>Start</I> to avoid further selection. The function then enables the Abort item, sets the boolean variable <I>fContinue</I> to TRUE, and signals the <I>Big</I> thread to carry out the benchmark.<P>
<I>AbortSalvage(pGpfParms)</I> sets <I>fContinue</I> to FALSE, disables the Abort item, and enables the Start item by calling the Gpf function <I>GpfMenuGray.</I><P>
Semaphores <I>semtimer</I> and <I>semjob</I> are used to synchronize the actions among the Window procedure and the threads <I>Timer</I> and <I>Big.</I><P>
<I>PeekMessageLoop</I> is the function that replaces the normal <I>GetMessage</I> loop in WinMain.<P>
<h4><FONT COLOR="#000080"><A name="0024_0012">Cross-platform Development<A name="0024_0012"></FONT></h4></P>
<I>Cschlr</I> works under both Windows and 16-bit OS/2 PM. Since I am using compilers from the same vendor, I don't even have to make any change to the <I>mapptr</I> type definition in <I>Cthread</I> because the <I>jmp_buf</I> structure remains unchanged for both Windows and OS/2 compilers. <I>Cschlr</I> works under OS/2 because OS/2's PM also has the same architecture as Windows: it uses a single message queue for all PM applications.<P>
<I>Cschlr</I> does not take advantage of the true multi-tasking (multi-threading) capabilities of OS/2. It dispatches threads by multiplexing the CPU with <I>Run()</I> in the main <I>PeekMessage</I> loop in Windows and the <I>WinPeekMsg</I> loop in OS/2. But it has one advantage that true OS/2 multi-tasking does not have. OS/2 threads cannot directly force an event to occur by calling APIs like <I>WinInvalidateRect</I> if the calling thread is not the message thread (the thread where the message queue is created). <I>Cschlr</I> allows you to do that because all threads it creates are actually part of the message thread.<P>
Although one can use Gpf to define the screen layout and use the same Gpf file to generate both Windows and OS/2 C source codes, the user-supplied event handling functions still need to be changed if they use GUI-specific calls, due to the differences between Windows and PM APIs. This brings one to ask the question: is there a tool which allows you to develop an application once and port it to other platforms without any source changes? The answer is both yes and no. Yes, there are some tools in the market which claim to do that. No, they may not do what you intend them to do.<P>
Most of these tools take the common denominator approach, which limits you to use only a small subset of features available from a particular GUI. Although they usually provide ways for you to handle GUI-specific features, once you've done that, the application is no longer portable. Some class libraries attempt to encapsulate GUIs in C++ and force you to learn a totally new set of functions and programming model to gain portability. Some of them have over 150 classes with thousands of methods. The learning curve is steep even if they can do what they claim to do.<P>
My friends and I did some extensive research on cross-platform tools sometime ago. The verdict: package the non-GUI-related functions in the most portable way possible and use the best tool you can find to generate the particular GUI that you are interested in. If the non-GUI part &#151; the heart of your application &#151; is well packaged, it should be possible to interface the two components together. Of course, it is easier said than done. The best way to do this varies depending on the application. Since <I>Cschlr</I> works unmodified under both Windows and OS/2, I think it should qualify as a cross-platform tool.<P>
<h4><FONT COLOR="#000080"><A name="0024_0013">Conclusions<A name="0024_0013"></FONT></h4></P>
I have presented a simple C++ class, <I>Cschlr</I>, to handle time-consuming tasks under Windows, and demonstrated its use by a complete example. It should be evident from the example that <I>Cschlr</I> helps in limiting the proliferation of <I>PeekMessage</I> loops that are quite commonplace in applications that are CPU bound. It reduces the total number of <I>PeekMessage</I> loops to exactly one and provides counting semaphores and timed functions for synchronisation.<P>
All these functions are provided without increasing the memory usage significantly, due to the small size of <I>Cschlr.</I> The use of <I>Cschlr</I> also improves the readability of source code by reducing the proliferation of <I>PeekMessage</I> loops and by providing a facility for the user to organize a Windows application by breaking it up into smaller and more manageable pieces in the form of threads. And a Windows application written using threads should make porting to OS/2 less painful.<P>
<h4>References</FONT></h4></P>
<a name="1">1.</a>     Dror, A., Lafore, R. <I>0S/2 Presentation Manager Programming Primer</I>. McGraw-Hill 1990.<P>
<a name="2">2.</a>     Petzold, C. <I>Utilizing OS/2 Multithread Techniques in Presentation Manager Applications.</I> Microsoft Journal, March 1988.<P>
<a name="3">3.</a>     Comer, D., Fossum, T. V. <I>Operating System Design Vol. 1. The Xinu Approach.</I> Prentice-Hall 1988.<P>
<a name="4">4.</a>     Gpf Systems, Inc. <I>Gpf.</I> Gpf Systems Inc. 1992.<P>

<h4><a href="../../../source/1994/jan94/yuen.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
