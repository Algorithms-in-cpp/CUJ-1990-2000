

<HTML>
<HEAD>

<TITLE>January 1994/CUG New Releases</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">CUG New Releases<A name="003D_0015"><A name="003D_0015"></font></h2><P>
<h3 align="center"><A name="003D_0000"><A name="003D_0000">C Exploration Tools, GNU Indent, and Miscellaneous Goodies</h3><P>
<h3 align="center"><font color="#800000">Victor R. Volkman</font></h3><hr><blockquote><P>
<P><i><A name="003D_0000"><A name="003D_0000">Victor R. Volkman received a BS in Computer Science from Michigan Technological University, He has been a frequent contributor to The C Users Journal since 1987. He is currently employed as Senior Analyst at H.C.I.A. of Ann Arbor, Michigan. He can be reached by dial- in at the HAL 9000 BBS (313) 663- 4173 or by Usenet mail to sysop@hal9k.com.</i></P><P>
<h4><FONT COLOR="#000080"><A name="003D_0016">Introduction<A name="003D_0016"></FONT></h4></P>
This month's new offerings actually spreads five new releases across three CUG volumes. Generally, a single CUG volume covers one specific library or programming tool. A CUG volume typically consists of from one to ten individual diskettes. However, there are some releases for which an entire diskette provides way too much space. These releases often have titles like "Miscellany #x," reflecting the eclectic nature of the submissions. For small releases, the CUG Library will cluster several of them on the same diskette (and hence the same volume). This practice both conserves resources and provides more value to the end users of the CUG Library.<P>
<h4><FONT COLOR="#000080"><A name="003D_0017">New Library Acquisitions<A name="003D_0017"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="003D_0018">C/C++ Exploration Tools v2.12: CUG #391<A name="003D_0018"></FONT></h4></P>
C/C++ Exploration Tools, by Juergen Mueller (Kornwestheim, Germany), includes both his C Function Tree Generator (CFT) and the C Structure Tree Generator (CST). CFT and CST analyze the C/C++ source code of applications of any size, over multiple files. CFT and CST are useful for exploring new, unknown software and for supporting re- use, maintenance and re- engineering of software. By preprocessing, scanning, and analyzing the program source code, these programs generate the function call hierarchy (CFT) and the data structure/class (CST) relations. While both programs can handle C and C++ code, CFT can also analyze assembly language code.<P>
An important feature of this product is its database generation, which allows you to recall code information without reprocessing the source. You can read this database again from CFT and CST to produce different outputs or to add new files to the database. The database format is dBASE compatible. Special recall programs called CFTN and CSTN perform fast searching for items in the database. These programs can be used within any environment, for example, from within editors like BRIEF, QEDIT, or MicroEMACS (DOS and Windows version), to provide a full software project management system with access to all functions and data types with just a keystroke. This feature makes a comfortable "hypertext source code browser and locator" system out of the editor.<P>
The documentation is supplied in ASCII and includes 63 pages of reference material. The manual is written in plain English and should be accessible to even novice C programmers even though the manual discusses advanced techniques.<P>
The C Exploration Tools v2.12 released 07/03/93) are immediately available as MS- DOS executables on CUG volume #391. The C Exploration Tools are shareware and require registration with the author if you decide to use them beyond the 30- day evaluation period. The registration price is $46 U.S. or 60 DM for a single copy. Generous site license discounts with prices as low as $15 are appropriate for corporate use or educational institutions. Registered users automatically receive Protected Mode versions of the tools optimized for the 80386 and the latest versions of everything. Source code for the C Exploration Tools is not available.<P>
<h4><FONT COLOR="#000080"><A name="003D_0019">GNU Indent v1.8: CUG #392<A name="003D_0019"></FONT></h4></P>
GNU Indent, from Joseph Arceneaux (San Francisco, CA), becomes the newest installment of high quality tools from the GNU project. The Indent program changes the appearance of a C program by inserting or deleting whitespace. The Indent program can make code easier to read. It can also convert C code from one writing style to another. Indent understands a substantial amount about the syntax of C, but it also attempts to cope with incomplete and misformed syntax. Indent can replace the original source .C file and retain a backup copy or else write its output to a new .C file.<P>
There are several common styles of C code, including the GNU style, the Kernighan &amp; Ritchie style, and the original Berkeley style. You may select a style with a single "background" option, which specifies a set of values for all other options. However, explicitly specified options always override options implied by a background option. Thus, you can create hybrid styles or a new coding style uniquely your own by combining the many option settings.<P>
Option settings cover many things that programmers regularly spar about, such as:<P>
<UL><li>Placement of blank lines, braces, and comments</li>
<li>Special handling for braces around <I>if/then/else </I>constructs</li>
<li>Spacing around casts and <I>sizeof</I></li>
<li>Overall number of spaces per indentation level</li>
<li>Alignment of parentheses on continuation lines</li>
<li>All aspects of function declaration layout</li></UL>
Each option can be specified in short form or long form. For example, the short form option "- ncdb" can be entered as "&#151;no-comment-delimiters-on-blank-lines."<P>
GNU Indent supports MS- DOS, OS/2, VAX VMS, and most versions of UNIX. For UNIX versions, Indent includes the popular GNU auto- configuration utility which customizes the Makefile to meet the needs of your system. The CUG Library distribution includes source code only. GNU Indent v1.8 (released 06/16/93) is immediately available as CUG volume #392.<P>
<h4><FONT COLOR="#000080"><A name="003D_001A">LL, GIFSave, and Cordic++: CUG #393<A name="003D_001A"></FONT></h4></P>
As you might have guessed from the introduction, this volume is something of a C potpourri. George Matas (University of Surrey, U.K.) presents his LL for a generic double- linked list library with examples. Sverre H. Huseby (Oslo, Norway) contributes GIFSave to save bitmaps in this popular image file format. Last, Cordic++ by Timothy M. Farnum (Rochester, NY) builds on Michael Bertrand's C implementation of fast trigonometric functions. Altogether, these are three very useful and specialized tools for common C problems. The entire set fits on just one diskette. This diskette is immediately available as CUG volume #393.<P>
<h4><FONT COLOR="#000080"><A name="003D_001B">LL: CUG#393A<A name="003D_001B"></FONT></h4></P>
LL is a double- linked list handler library with more than four dozen operator functions. Variables of any type can be stored in an LL list. Individual elements of a list may be of different types. With LL, you can create any depth of lists of lists. You create an instance of a list using either <I>ConsLL, ConsCopyLL</I>, or <I>ConsPtrLL</I> functions. It's best to call one of these functions at the point of a list variable's declaration. You must assign the result of one of the constructor functions to a given list instance before passing it to any other function in the LL library.<P>
<I>ConsLL</I> creates an empty list. <I>ConsCopyLL(src)</I> creates a new copy of an existing list. <I>ConsPtrLL(src)</I> creates a list of pointers to elements stored in list <I>src</I>. <I>DestLL(list)</I> destroys a list; i.e. it deletes all elements and frees all memory allocated for <I>list</I>. <I>DestLL</I> should be called at the point where <I>list</I> goes out of scope.<P>
LL has been tested only on SUN Sparcstations and DEC Ultrix machines. In these environments, LL works with both the native "cc" compiler as well as GNU C ("gcc"). The CUG Library distribution includes source only.<P>
<h4><FONT COLOR="#000080"><A name="003D_001C">GIFSave: CUG#393B<A name="003D_001C"></FONT></h4></P>
The GIFSAVE library enables you to save GIF- images from your own graphics- producing C programs. GIFSAVE creates simple GIF files following the GIF87a standard. You can't create GIF files from interlaced images, and you should store only one image per file.<P>
GIFSAVE consists of four functions, all declared in GIFSAVE.H:<P>
<UL><li><I>GIF_Create</I> creates new GIF files. <I>GIF_Create</I> takes parameters specifying the filename, screen size, number of colors, and color resolution.</li>
<li><I>GIF_SetColor</I> sets up the red, green, and blue color components. It should be called once for each possible color.</li>
<li><I>GIF_CompressImage</I> compresses an image. <I>GIF_CompressImage </I>accepts parameters describing the position and size of the image on screen, and a user- defined callback function that is supposed to fetch the pixel values.</li>
<li><I>GIF_Close</I> terminates and closes a GIF file.</li></UL>
You should call these functions in the listed order for each GIF file. You must close one file before you creates a new one. To use these functions, you must create a callback function that will retrieve the pixel values for each point in the image.<P>
GIFSAVE includes a makefile for use with Borland C/C++. Huseby claims he has taken care to insure that all byte- order sensitive operations are handled in a platform- independent method. Therefore, the source code should work without modification on non- MS- DOS platforms.<P>
The Graphics Interchange Format(C) is the Copyright property of CompuServe Incorporated. GIF is a Service Mark property of CompuServe Incorporated. Huseby has released GIFSAVE as Public Domain source code with no restrictions on its use.<P>
<h4><FONT COLOR="#000080"><A name="003D_001D">CORDIC++: CUG#393C<A name="003D_001D"></FONT></h4></P>
The Coordinate Rotational Digital Computer (CORDIC) was an early device implementing fast integer sine and cosine calculations. By favoring integer operations over floating point, CORDIC demonstrated a classic computing tradeoff of speed vs. precision. Although the CORDIC algorithm was first documented by Jack E. Volder in 1959, most <I>CUJ</I> readers may remember Michael Bertrand's C implementation (see "The CORDIC Method for Faster <I>sin</I> and <I>cos</I> Calculations," <I>CUJ</I>, November 1992). Farnum presents his own reimplementation of Bertrand's code &#151; this time as a full C++ class.<P>
According to Farnum, the most notable change in his C++ version is his encapsulation of variables which were global in the C version. As static member variables of a <I>CORDIC</I> class these encapsulated variables become protected from accidental modification by routines unaware of them. Moving these variables inside a class structure makes it necessary to develop interface routines. Farnum decided to predefine one member of the <I>CORDIC</I> class, <I>cord</I>, to access the member functions which compute the integer sine and cosine. You could create other instances of class <I>cordic</I> that would work as well as the predefined instance, but there is little advantage to this in the current implementation.<P>
Ambitious readers could build upon this implementation by providing the ability to instantiate the <I>CORDIC</I> class with different levels of accuracy. For example, a programmer could provide different levels of accuracy by using different bases for the CORDIC algorithm. Farnum decided against this approach because the complexity of such an implementation seemed to go against the straightforwardness which is the main advantage of the CORDIC algorithm.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
