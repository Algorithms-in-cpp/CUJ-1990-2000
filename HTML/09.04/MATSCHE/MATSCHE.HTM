


<HTML>
<HEAD>

<TITLE>April 1991/Point-And-Shoot Menus</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocapr.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   User Interfaces</FONT></H2>

<hr><h2 align="center"><font color="#800000">Point-And-Shoot Menus<A name="00AA_0068"><A name="00AA_0068"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="00AA_0000"><A name="00AA_0000">John Matsche</font></h3><hr><blockquote><P>
<P><i><A name="00AA_0000"><A name="00AA_0000">John J. Matsche has a B.S and an M.B.A. from the University of Central Florida. His experience includes ten years of systems analysis on various platforms. His language experience includes C++, Pascual, Assembler, Algol, Cobol, and Basic. You can contact John at 4662 Millhaven Rd., Martinez, GA 30907.</i></P><P>
In the beginning, programming a menu screen was easy. You presented a list of program options to the user. The user would select an option by entering the corresponding number and pressing the enter key. It was a simple programming task, usually requiring nothing more than a looping series of write statements followed by a read, then some sort of a branching statement.<P>
When I bought my first copy of Lotus 1-2-3, I realized the inadequacies of this algorithm. The point-and-shoot menus that run along the top of my spreadsheet do more than provide a raw list of program options. These menus also describe each option. Once selected, it is easy to maneuver down the hierarchy, and even easier to back out. In short, the point-and-shoot menu system is more intuitive. More important, at that stage in my career, the point and shoot system looked more polished and professional.<P>
The Lotus menu system has many variations. Basically, it consists of a list of words or short narrative that describes an option. The selected option, is highlighted in some fashion, usually by display in reverse video. When the user presses the right arrow key, the next option becomes the selected option. The left arrow key selects the previous option. The user points to an option by pressing the arrow keys, then invokes the option by pressing the enter key &#151; hence the name "point and shoot." If the user presses the escape key, the menu backs out. No option is selected and control returns to some previous state.<P>
I set out to develop an algorithm that would implement point-and-shoot menus as efficiently as possible. At the same time, I wanted it to be generic enough to work with any application program. C is an ideal programming language for this type of project. It is low-level enough to provide the speed necessary for quick screen displays. It is compact enough to have negligible impact on an application programs's size. For this project, I used Borland's Turbo C++ compiler running on an IBM-compatible 386 using MS-DOS v4.01.<P>
<h4><FONT COLOR="#000080"><A name="00AA_0069">Implementation<A name="00AA_0069"></FONT></h4></P>
I make use of three video modes that I call normal, reverse, and highlight. These terms are left over from the days of monochrome displays, but are also applicable to color systems. Simply choose your own favorite color scheme for each mode. In this implementation, reverse video implies that both background and foreground colors are reversed from normal. Highlight video uses the intense foreground color of the normal video mode.<P>
The program shown in <A href="list1.htm">Listing 1</a>
contains the complete implementation. I added a <I>main</I> function to demonstrate the execution of the menu system. By removing <I>main</I>, you make the program a compilable module that can easily be linked into any application program. To complete the conversion from program to module, you should create a separate header file containing a prototype of the <I>menu</I> function. The remaining functions should stay relatively hidden from the application.<P>
The <I>#defines</I> at the top of the listing provide logical names for the various keys that <I>menu</I> recognizes. Some of the keys can be read directly by the <I>getch</I> function. For example, the enter key will always generate an ASCII 13 (hex 0x0d). Other keys, such as the function keys and the arrows, do not generate a single character code when pressed. To recognize these keys, you must look at something called a <I>scan code</I>.<P>
From a software point of view, think of a scan code as an extended return value for special keys. Whenever a special key such as a function or arrow key is pressed, <I>getch</I> returns an ASCII NUL (hex 0x00). The next call to <I>getch</I> returns the scan code for the pressed key. Note that this does not mean you must press the special key twice. It simply means that whenever you press a special key two characters are loaded into the keyboard buffer instead of just one. In fact, if you were to use <I>getch</I> as a pause mechanism, and you didn't test for scan codes, you might inadvertently pick up the scan code later on in another <I>getch </I>call.<P>
As previously mentioned<I>, main</I> is a demonstration function that is not a part of the <I>menu</I> logic. It illustrates how easy the menu is to call. By looking at <I>main</I>, you see that <I>menu</I> requires only two parameters. The first points to the first element of an array of pointers to the menu items to be displayed. Note that in this implementation, each menu item begins with a different letter. This restriction allows you to select a menu item by pressing this letter on the keyboard. The array is terminated with a null pointer. You don't need to tell <I>menu</I> how many items are being passed to it. The second parameter to <I>menu</I> is a Boolean value (1 means true, 0 means false) that specifies whether or not a horizontal format is to be used.<P>
The rest of the setup sets the desired colors and formats the screen. The primary loop in <I>main</I> displays which item the user chose and positions the cursor for the next menu display. The loop terminates when the user presses <I>Q</I> for quit.<P>
Five functions carry out the menu's actual implementation: <I>show, findletter, init, keypress</I>, and <I>menu</I>. <I>show</I> displays one menu item on the screen. <I>findletter</I> searches the list of items for the letter pressed by the user. <I>init</I> sets up screen locations for displaying items, <I>keypress</I> handles all keyboard input, and <I>menu</I> controls the show.<P>
<I>menu</I> initializes screen colors and locations, displays all of the items, gets user input, and loops until the user wants to exit. To initialize screen locations, call the function <I>init</I>. The <I>gettextinfo</I> function, included with Turbo C++, is called to provide <I>menu</I> with screen information as stored in the <I>text_info</I> type structure called <I>info</I>. This structure allows you to derive the current colors and cursor position for reference. Next, <I>menu</I> turns off the cursor to present a cleaner looking menu and calls <I>show</I> repeatedly to display each menu item.<P>
The main loop of <I>menu</I> displays the currently selected menu item in reverse video, then waits for the user to press a key. Once a key is pressed, the function tests for a scan code. <I>menu</I> then displays the current item in normal video, effectively de-selecting it from the user's point of view. Finally, the function calls <I>keypress</I> to act on the selected key. The value returned by <I>keypress</I> determines whether or not the loop is repeated.<P>
The last task <I>menu</I> must complete before exiting is to turn the cursor back on and return the user's selection to the calling function.<P>
Screen locations, as stated earlier, are set up by <I>init</I> and used by <I>show</I>. Setting up the locations depends on which format, vertical or horizontal, is specified. For vertical formats, screen location is simply based on the starting row plus the current index. For horizontal formats, the position is calculated from the starting column location plus the length of the previous menu items. Because the horizontal format involves more calculation, it is only done once in <I>init</I>, then it is stored in an array.<P>
<I>show</I> adds the starting row and column information, contained in the <I>x</I> and <I>y</I> variables, to an offset based on the chosen format (horizontal or vertical). It sets the video mode to highlight by setting the high bit of the foreground color attribute. It then displays the first character, returns video mode to normal, and displays the rest of the menu item.<P>
<I>keypress</I> has been set up separately to isolate the logic necessary to handle the user's input, so you can easily add new key handling ability to the function's repertoire. <I>keypress</I> is responsible for calculating which menu item will be made current based on which key the user pressed. It does this using an index value (variable <I>i</I>) that can vary from zero to the maximum number of items less one. The function returns --1 as an index value when the user has pressed the enter key. <I>menu</I> then knows to quit and return whichever option was previously current to the calling function. Note that <I>keypress</I> returns an index value instead of the menu item letter. <I>keypress</I> was implemented to return an index value so <I>show</I> will easily know where to display the next menu item.<P>
The last function to discuss is <I>findletter</I>. It is called from <I>keypress</I> whenever the user presses a key that is not specifically handled. <I>findletter</I> loops through the menu items looking for a match between the key pressed and the first character of the menu item. If found, it changes the current menu item index and passes it to the caller as a return value.<P>
Collectively, these functions provide a simple and clean looking point-and-shoot menu system that is flexible enough to handle most applications' needs. At the same time, it is simple enough not to bog down the programmer in detail. There are, obviously, many enhancements that can be made to this system.<P>
<h4><FONT COLOR="#000080"><A name="00AA_006A">Enhancements<A name="00AA_006A"></FONT></h4></P>
The basic point-and-shoot menu theme has many variations. For example, you can display a more descriptive explanation of each menu item on a separate line when it is selected. To do this you might want to pass to <I>menu </I>another array of pointers (call this the description array) which correspond on a one-for-one basis to the original array (list of menu items). If the first menu item is "Load," then the first element of the description array might be "Load a file from disk." <I>show</I> would display this description on some predesignated line. Many applications reserve the bottom line of the screen display for this purpose.<P>
You could enhance this implementation by creating a more sophisticated approach to color selection. Even though the menu example described in this article is a stand-alone module, it would normally be incorporated as part of an overall module to handle screen formatting. Several other utility functions for windowing and formatting would be included that also require a way to specify color selection. One popular way to designate color selection is to define a color palette, implemented as an array of allowable color combinations for foreground and background. You might select normal, highlight, and reverse colors with a call like <I>color(3,2,5)</I> in which each parameter represents a specific index within the color palette.<P>
This particular implementation of point-and-shoot menus relies on the user to provide a Quit option as one of the menu items. Many applications recognize the escape key as the key to press to back out of a menu without selecting anything. To add this capability to the example, modify <I>keypress</I> to return a special value for escape to <I>menu</I>. A value of --2 should be used since --1 designates the enter key. (Remember that <I>keypress</I> returns an index value, not a character.) In turn, <I>menu</I> returns some prearranged value such as ASCII 27, so the calling application can recognize a back-out request and act accordingly.<P>
Many applications these days are demanding mouse support. The actual implementation would depend on the mouse support library that you use. A detailed discussion of mouse support is beyond the scope of this article, but its impact on the menu system is easy to describe.<P>
Adding mouse support would involve replacing the <I>getch</I> logic used for detecting characters and scan codes with a separate function. This function would return the same character value or scan code based on the user's selection. The function would probably detect what the user selected using some sort of loop that continuously tests the keyboard and mouse devices for input. You need modify no other function.<P>
This example of point-and-shoot menus was implemented in ANSI C to enhance its portability. Note that it's not strictly ANSI. For example, <I>gettextinfo</I> is available only for IBM-compatible systems. However, other systems do have other functions for performing similar tasks.<P>
Implementing a point-and-shoot menu system with the object-oriented flavor of Turbo C++ has many advantages also. One of the greatest advantages is the ability of a function to inherit behavior. For example, if you want to enhance the behavior of function <I>keypress</I> (called <I>method keypress</I> in OOP) to recognize the escape key, you create a new function (method) that contains only the escape key handling logic. Everything else is already provided.<P>
<h4><FONT COLOR="#000080"><A name="00AA_006B">Summary<A name="00AA_006B"></FONT></h4></P>
You can approach programming problems or ideas in a variety of ways. I've attempted to describe one generalized approach and several possible enhancements that I've had great success with in my own application programs.<P>
The overall design goal of this menu system is to isolate into separate functions, as much as possible, discreet parts of the process such as keyboard handling, location calculations, and screen displays. This modular approach facilitates making future enhancements without completely rewriting the process every time.<P>

<h4><a href="../../../source/1991/apr91/matsche.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
