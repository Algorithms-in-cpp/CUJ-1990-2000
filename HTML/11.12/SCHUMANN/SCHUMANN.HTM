

<HTML>
<HEAD>

<TITLE>December 1993/Using C/C++ with Clipper</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Advanced Development Strategies</FONT></H2>

<hr><h2 align="center"><font color="#800000">Using C/C++ with Clipper<A name="0335_0122"><A name="0335_0122"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0335_0000"><A name="0335_0000">Mark W. Schumann</font></h3><hr><blockquote><P>
<P><i><A name="0335_0000"><A name="0335_0000">Mark W. Schumann lives in Cleveland's trendy Brooklyn Centre neighborhood and works for STR, Inc., of Brecksville, Ohio, to help develop the In$torePlus and In$toreLink retail software lines. He's been programming in C and Clipper long enough to appreciate both. You can reach Mark on the Internet at mark@whizbang.wariat.org or by voice at 216-546-9510 x220.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0335_0123">Introduction<A name="0335_0123"></FONT></h4></P>
Clipper is a high-level applications programming language for MS-DOS. Originally a pure dBASE compiler, Clipper has since gained lexically scoped variables, multi-dimensional arrays, replaceable database drivers, and predefined object classes, to become a general application development tool. Importantly for C programmers, Clipper has a well-documented interface for C/C++ and assembly-language subroutines. <P>
This article shows how to build C and C++ routines that provide new capabilities or greater performance to Clipper applications using the documented Extend System interface. This article also gives examples and a walkthrough, and finally, explains how to use third-party C libraries which have not been designed for Clipper programs.<P>
<h4><FONT COLOR="#000080"><A name="0335_0124">Why Clipper and C/C++?<A name="0335_0124"></FONT></h4></P>
Clipper's high-level features can accelerate DOS-based applications development. Clipper includes a DOS character-mode user interface, as well as a database interface with drop-in replaceable database drivers. The core language feature set includes built-in string and date types, and a run-time expression evaluator. Clipper also includes a preprocessor that is more complex and useful than C's.<P>
On the other hand, it's hard to beat well-written and optimized C or C++ code on a PC. C and C++ deliver excellent run-time speed, small code size, and direct access when needed to devices, interrupts, and memory.<P>
By combining Clipper and C/C++, you can design and implement a high-level application quickly, without giving up the power and efficiency of C/C++ when you need it.<P>
<h4><FONT COLOR="#000080"><A name="0335_0125">Compilation<A name="0335_0125"></FONT></h4></P>
Clipper normally calls C functions through its Extend API, which provides mechanisms for passing function arguments and return values. Since all Clipper releases in widespread use were developed with Microsoft C version 5.1, other compilers may present compatibility problems. If you own later versions of MSC, use the/Gh compiler switch to invoke alternate floating-point libraries. If you own a Borland compiler, you must avoid floating-point declarations and operations in your C code, since they invoke run-time library functions that are incompatible with Microsoft's. When acquiring third-party C or C++ libraries to use with Clipper, you should always request compatibility with Microsoft C 5.1, again because Clipper was also developed with MSC5.1.<P>
Most important, compile in the <I>large</I> model, since Clipper deals only with far code pointers and far data pointers. If you include any inline assembly code, be sure to save and restore registers BP, SP, SI, DI, and DS.<P>
<h4><FONT COLOR="#000080"><A name="0335_0126">Declaring C Functions for Clipper<A name="0335_0126"></FONT></h4></P>
Clipper variables are not typed, and sometimes not even scoped, at compile-time, so the run-time engine (really a p-code interpreter) must maintain a symbol table and pseudo-stack for evaluations. Clipper's lack of compile-time typing prevents you from passing arguments to a C function directly, since C compilers for the PC must have argument type information to set up the machine stack and don't recognize run-time type information. Likewise, Clipper does not use standard C methods to return function values.<P>
Therefore, you should declare any C function to be linked with Clipper as <I>void</I>, and you should declare it with <I>void</I> arguments, as in the following:<P>
<pre>void far foo (void);</pre>
To access function arguments and to create return values, use the Extend API functions described later in this article. The macros in <I>CLIPDEFS.H</I> let you conveniently use <I>CLIPPER foo (void)</I> which preprocesses into the same.<P>
<h4><FONT COLOR="#000080"><A name="0335_0127">Passing Parameter to C functions<A name="0335_0127"></FONT></h4></P>
You can transfer parameters and other information from the Clipper stack into C variables with a series of functions whose names begin with <I>_par</I>.<P>
<I>_parinfo (0)</I> returns the number of arguments passed by Clipper; <I>_parinfo (x)</I> returns an <I>int</I> indicating the data type of the <I>x</I>th argument in the list; you can bitwise-OR its return value with macros such as <I>CHARACTER</I> and <I>NUMERIC</I> (in <I>EXTEND.API</I>) to extract type information. For the most bulletproof code, you should check an argument's data type with <I>_parinfo</I> before attempting to retrieve its value.<P>
The other <I>_par</I> functions, shown in <A href="tab1.htm">Table 1</a>,
 return data values. Each <I>_par</I> function takes an argument indicating the position in the call's argument list. When passing an array, an optional second argument indicates which specific array element is required. Be careful: elements of a Clipper array do not have to be the same type.<P>
<h4><FONT COLOR="#000080"><A name="0335_0128">Returning Values from C Functions<A name="0335_0128"></FONT></h4></P>
A set of functions whose names begin with <I>_ret</I> parallel the <I>_par</I> functions but return values to the Clipper application. These are shown in <A href="tab2.htm">Table 2</a>.
<P>
To return a string, you would normally use <I>_retclen</I> because Clipper strings normally are not null-terminated and therefore could contain nulls.<P>
<h4><FONT COLOR="#000080"><A name="0335_0129">Returning Values in Reference Parameters<A name="0335_0129"></FONT></h4></P>
Similarly, you can call Extend API to store values in reference parameters. In Clipper, these are arguments that are passed to a function with an @ (at-sign) prefix or with the obsolete <I>DO</I> &lt;<I>func</I>&gt; <I>WITH</I> &lt;<I>args</I>&gt; syntax.<P>
The <I>_stor</I> functions (<A href="tab3.htm">Table 3</a>)
 work exactly like their corresponding <I>_ret</I> cousins but take an additional first argument indicating the position in the Clipper function's argument list to be affected. Note that a <I>_stor</I> function call has no effect if it targets a Clipper parameter that was passed by value.<P>
<h4><FONT COLOR="#000080"><A name="0335_012A">Calling "Unmangled" C++ Functions<A name="0335_012A"></FONT></h4></P>
So far I have described how to write vanilla C code to interface with Clipper's Extend API. What to do if you want to link in C++ code? The answer is familiar to anyone who has written C-to-C++ interfaces before: prepend the <I>extern</I> declaration modifier to all C++ function declarations to be called directly by C or Clipper code, and prepend <I>extern "C"</I> on the Extend API declarations if they are called from C++.<P>
Prepending <I>extern "C"</I> is the standard way to make all C++ compilers turn off "name mangling," the feature which allows function name overloading. Of course, the cost of this approach is that you can't overload function names (or class members) in code that touches C or Clipper code. In practice, this inability to overload is not much of a loss because C and Clipper don't directly support overloading, and in any case, your C++ functions probably will not be elaborate enough to need a complicated interface.<P>
<h4><FONT COLOR="#000080"><A name="0335_012B">An Example<A name="0335_012B"></FONT></h4></P>
<I>CLIP.C</I> (<A href="list1.htm">Listing 1</a>)
 contains a set of useful low-level functions not already found in the Clipper run-time library.<P>
<I>sum</I> takes any number of numeric arguments &#151; even zero &#151; and returns their sum as integers. In line 43 I put the number of Clipper function arguments into <I>pcount</I>. Lines 47 through 49 step through the list of arguments, retrieving each argument with <I>_parni</I>, and accumulating their values in <I>sum</I>. Line 52 calls <I>_retni</I> to hand the result as a Clipper numeric value to the caller.<P>
Note that the results of this function are undefined if the passed parameters are not actually numeric. For example, if the Clipper programmer tries to execute <I>SUM ("ABC", "DEF")</I> the results are guaranteed to be meaningless (although in my testing a zero was returned consistently). Also note that Clipper provides no compile-time or link-time type checking, so a call such as this one could go unnoticed until it returned bogus results to the running program.<P>
The correct way to implement this function, and in fact all the functions in <A href="list1.htm">Listing 1</a>,
 is to call the <I>_parinfo</I> function to determine each argument's Clipper type before evaluating it. This type checking is especially important for production-quality code to be used by others. I left out such type checking to avoid obscuring the main logic of these functions.<P>
<I>reverse</I> simply reverses a character string. This exercise is not as trivial as it sounds, since Clipper strings, even those of a single byte, are always dynamically allocated; string arithmetic is therefore relatively expensive. If your Clipper application calls for intensive string manipulation you might want to use C functions like <I>reverse</I> to take the load off of Clipper's memory management subsystem.<P>
<I>reverse</I> first stores the length of the string in <I>len;</I> you can't use C's <I>strlen</I> because you cannot assume that Clipper strings are null-terminated. The functions <I>_xgrab</I> and <I>_xfree</I> from the Fixed Memory (<I>FM.API</I>) work like the Standard C library's <I>malloc</I> and <I>free</I>, to allocate and discard a buffer pointed to by <I>newstring</I>. Next, a straightforward loop copies bytes from the old string to the new. I don't have to append a null terminator since the <I>_retclen</I> call on line 82 takes an explicit length argument.<P>
<I>peek</I> and <I>poke</I>, like the BASIC commands of the same name, enable the Clipper programmer to read and write bytes at specific memory locations. <I>peek</I> simply obtains two integer numeric arguments as a segment and offset, coerces them into a <I>far</I> pointer to an <I>unsigned char</I>, then returns the dereferenced value as a Clipper numeric. <I>poke</I> takes a third numeric argument, which is the value to be stored in the given segment/offset address.<P>
<I>lrc</I> is a very fast routine to calculate a simple checksum on a Clipper character variable. <I>lrc</I> is useful for communications or data compression applications that require parity checks. Like <I>reverse</I>, <I>lrc</I> takes a Clipper string argument and stores both its location and its length with <I>parc</I> and <I>parclen</I>. A <I>while</I> loop XORs each byte in the string into the variable. Both <I>*s</I> and <I>sum</I> are declared as <I>unsigned char</I> to prevent any complications resulting from the presence of a sign bit.<P>
Note that <I>lrc</I> returns the checksum value with <I>_retni</I>. Since Clipper does not have an explicit "unsigned" data type, I count on the fact that the range of values an <I>int</I> can represent exceeds the range of an <I>unsigned char</I>. I assume that the code will never be run on a platform for which <I>sizeof (int) == sizeof (unsigned char)</I>. This is a safe bet since Clipper applications only run in an Intel 80x86 environment. However, the cast can conceivably produce portability problems in extreme cases.<P>
<h4><FONT COLOR="#000080"><A name="0335_012C">Using Third-party C/C++ Libraries<A name="0335_012C"></FONT></h4></P>
In some cases you may want to link C++ class libraries into a Clipper application. Since Clipper can't call mangled functions by name, you must prevent mangling by making all direct calls through wrapper functions with the <I>extern "C"</I> declaration modifier. If you have the library's source code, of course, you may be able to edit a class header to achieve the same result.<P>
You should call only small utility functions from libraries which were developed specifically for C applications. Anything that attempts direct screen writes, standard console I/O, database manipulation, or memory management is likely to conflict with Clipper's standard library code. This limitation is not as severe as it seems. Third party developers have already written an enormous array of utility and special-purpose libraries specifically for Clipper programmers. These utilities and libraries generally use the Extend interface for maximum compatibility with future Clipper releases.<P>
<h4><FONT COLOR="#000080"><A name="0335_012D">Summary<A name="0335_012D"></FONT></h4></P>
By combining C and C++ with Clipper, you can design and implement a high-level application quickly and still have low-level control when you need it. I've shown how to call C code from Clipper using well-documented interfaces, and how to adapt existing libraries.<P>
I have provided just an overview of what you can do by combining the power and efficiency of C/C++ with a high-level applications development language.<P>
<h4><a href="list2.htm">Listing 2: Test Program for CLIP.C</a></h4>
<h4><a href="list3.htm">Listing 3: MAKEFILE for CLIP.C and test program</a></h4>
<h4>Sidebar: <a href="sidebar1.htm">"The Current State of Clipper"</a></h4>

<h4><a href="../../../source/1993/dec93/schumann.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
