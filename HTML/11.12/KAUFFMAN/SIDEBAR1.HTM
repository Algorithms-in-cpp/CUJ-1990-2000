<HTML><HEAD><TITLE>December 1993/A Windows Debugging Stream/Sidebar</TITLE></HEAD><BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">iostreams</FONT></h3><hr>
<BLOCKQUOTE>
The iostreams classes introduce the notion of a stream, a mechanism for sending (or getting) C++ variables to (or from) files. The iostream classes also support string I/O, and enable developers to easily add support for user-defined data types, as well as user-defined streams. Given the following data:<P>
<pre>int i = 17;
float f = 3.14159;
char buf[100];
strcpy( buf, "This is a C string" );</pre>
The following code performs stream outputs:<P>
<pre>cout &lt;&lt; "i = " &lt;&lt; i;
cout &lt;&lt; "f = " &lt;&lt; f;
cout &lt;&lt; "buf = " &lt;&lt; buf;</pre>
and the following code performs input:<P>
<pre>cin &gt;&gt; i &gt;&gt; f &gt;&gt; buf;</pre>
Note that this mechanism does not require programmers to supply data type information in the I/O statements, and the syntax for all data types is consistent. Compare the preceding statement to their C equivalents:<P>
<pre>printf( "i = %d", i );             /* output */
printf( "f = %f", f );
printf( "p = %s", p );

scanf( "%d, %f, %s", &amp;i, &amp;f, p );  /* input */</pre>
The <I>printf</I> and <I>scanf</I> data-type specifiers (<I>%d, %f, %s</I>) must match the parameters (<I>i, f, p</I>) both by order and by type (<I>%d</I> for <I>int, %f</I> for <I>float</I>, etc.). Also, in these C I/O statements, programmers must treat pointer and non-pointer variables differently, at least in the <I>scanf</I> (and other input) statements. The C program must pass the <I>address</I> of non-pointer variables (as in <I>&amp;i</I> or <I>&amp;f</I>) to <I>scanf</I>, but it must pass a variable like <I>p</I> directly by name, since it is already an address. This inconsistency leads to various sorts of problems. For example, when a type or positional mismatch exists between type specifiers and data values, the programmers can spend time looking for an error that doesn't even exist!<P>
The (possibly) mysterious variables <I>cout</I> and <I>cin</I> in the preceding C++ example are C++ pre-defined variables corresponding to the pre-opened C files <I>stdout</I> and <I>stdin</I>. Both the C++ variables and their corresponding C streams refer to the redirectable I/O streams provided by DOS, UNIX, etc. The C <I>printf</I> and <I>scanf</I> functions are convenient equivalents for:<P>
<pre>fprintf( stdout, ...</pre>
and<P>
<pre>fscanf( stdin, ...</pre>
The iostreams classes also support I/O to explicitly named files, as in:<P>
<pre>fstream of( "file.dat", ios::in );

of &lt;&lt; "i, f, p = " &lt;&lt; i &lt;&lt; f &lt;&lt; p;</pre>
as well as string I/O corresponding to <I>sprintf</I> and <I>scanf</I>:<P>
<pre>char buf[200];
ostrstream os( buf, sizeof( buf ) );

os &lt;&lt; "i, f, p = "&lt;&lt; i &lt;&lt; f &lt;&lt; p;</pre>
I/O manipulators, another important aspect of streams, allow programs to control streams in specialized ways, such as:<P>
<pre>cout &lt;&lt; "this is 75 in hex: " &lt;&lt; hex &lt;&lt; 75 &lt;&lt; endl;</pre>
Using I/O manipulators, programmers can specify type-specific attributes, such as hex notation for a following value, or insert control characters like endl (for end of line) in a portable and mnemonic way.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
