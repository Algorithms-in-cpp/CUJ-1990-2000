

<HTML>
<HEAD>

<TITLE>December 1993/Bitmap Image Transformations</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Bitmap Image Transformations<A name="033D_0128"><A name="033D_0128"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="033D_0000"><A name="033D_0000">Christopher Dean</font></h3><hr><blockquote><P>
<P><i><A name="033D_0000"><A name="033D_0000">Christopher Dean has been a computer programmer for Teacher Support Software for 6 years and has almost completed his Bachelor of Science in Computer Engineering from the University of Florida. He is interested in computer graphics, object-oriented programming, and artificial intelligence. He may be reached via e-mail at cjd@reef.cis.uf].edu or via phone (904) 332-8655.</i></P><P>
<h4><FONT COLOR="#000080"><A name="033D_0129">Introduction<A name="033D_0129"></FONT></h4></P>
Manipulation of bitmap images is important when performing tasks such as computer art and animation. Many paint programs allow images to be scaled, sheared, and rotated. When I wanted to mimic the actual turning of book pages to increase the realism of a reading program, I ran into problems because the user could alter the contents of the page. Standard animation techniques would not work because the animation would have to vary for every page and the content of each page was not known ahead of time. As a result I decided to simulate the page turning by successive shears and reductions of the page. <A href="fig1.htm">Figure 1</a>
shows how this appears on the screen. The only problem was that I could not find any algorithms to perform these transformations, so I decided to write my own.<P>
Image processing normally requires some sort of filtering and convolutions to accurately transform images. Unfortunately, for most practical uses this is too time consuming and in some cases very complex. The algorithms developed here are relatively quick and simple considering the task involved. The one drawback is that the transformations cause some aliasing, caused by the fixed resolution of the image. As a result, some lines and curves appear jagged. This is the case with shearing. In the case of scaling some lines may disappear and others may be duplicated too many times (edges, for example). For most animation purposes this is of no consequence. In any case, the effect can be reduced by using higher resolution graphics modes, digitizing images (which tend to blur the edges), or incorporating antialiasing techniques (see modifications).<P>
<h4><FONT COLOR="#000080"><A name="033D_012A">Scaling Images<A name="033D_012A"></FONT></h4></P>
Expansion of images in integral multiples is fairly standard &#151; just duplicate every pixel column or row <I>N</I> times. Shrinking of an image by a factor of 1<I>/N</I> is achieved by removing every Nth column or row. However, when you want to scale an image by a non-?? scalar, the procedure becomes more complex. You have to d?? cate or remove pixel rows or columns according to some spe?? pattern.<P>
The basis for determining this pattern is the Rothstein code, binary sequence representing a line with slope <I>p/q</I>. In the case o?? expanding an image horizontally, it tells you how to distribute <I>q</I> columns of the source image among <I>p</I> columns of the target, duplicating each appropriate column to fill in the gaps. For example, if you are expanding an image with <I>q</I> columns to a width of <I>p</I> columns, the Rothstein code will be a set of <I>p</I> bits with <I>q</I> of them set, each set bit evenly distributed among the <I>p</I> bits. Each set bit indicates that this column is to be copied, and each unset bit indicates that the column is to be a duplicate of the copied columns.<P>
In the case of shearing, each set bit in the Rothstein code tells you which columns to move up. For shrinking an image, you use the inverse of the expansion slope, the factor <I>q/p</I>. The Rothstein code then tells you which columns to remove. Again each column with a set bit in the Rothstein code is copied and each column with an unset bit is removed. For scaling and shearing in other directions you use the code in the same way just for the rows instead of the columns.<P>
The generation of the Rothstein code can be described graphically. First, plot a line with the desired slope on a grid. Every column in which the line crosses a horizontal grid line receives a one, all others a zero. If the slope of the line is greater than 45 degrees some adjustments must be made as described later. <A href="list2.htm">Listing 2</a>
shows the routine to calculate the Rothstein code. At every column you increment <I>psum</I> by <I>p</I>. When <I>psum</I> overtakes <I>qsum</I> the line crosses a horizontal grid mark &#151; the Rothstein code for the current column is set to one and <I>qsum</I> is incremented by <I>q</I>. This process continues until the number of columns has been reached.<P>
For an expansion of 9/5 horizontally (<A href="fig2.htm">Figure 2</a>)
 we traverse the image column by column copying every column with a one in the Rothstein code and duplicating the previous column if the code has a zero (which itself may be a duplicate). For reduction of an image, every column whose Rothstein code is a zero is removed. Scaling vertically requires calculating the Rothstein code based upon the height instead of the width. This time the image is traversed row by row, removing every row with a code of zero for reduction, or duplicating the previous row if the code has a zero for enlargement.<P>
<h4><FONT COLOR="#000080"><A name="033D_012B">Shearing images<A name="033D_012B"></FONT></h4></P>
Shearing vertically is similar to horizontal scaling in that the Rothstein code is computed using the width of the image. A one in the Rothstein code means the corresponding column and all columns following it are raised up one from the height of the previous column. The image can be traversed left to right or right to left to shear in different directions. Shearing horizontally is the same except the height is used for the Rothstein code and the image is traversed row by row. <A href="fig2.htm">Figure 2</a>
shows the Rothstein code for a vertical right shear of 5/9.<P>
The routines for the scaling horizontally and shearing vertically are presented in <A href="list2.htm">Listing 2</a>.
 They work with any noncompressed image whether it be text or graphics and are fast and simple enough for use in animation applications. The transformations can be done on compressed images but only as they are decompressed. PCX images, for example, can be transformed as each pixel line is decompressed.<P>
Rotations can be performed using vertical and horizontal shears by the same amount. To rotate clockwise you shear the image horizontally right and then vertically left by the same amount. Rotation in the counter-clockwise direction is just the opposite; you shear horizontally left and then vertically right by the same amount. The demo code in <A href="list1.htm">Listing 1</a>
does just this in increments of five pixels. This illustrates some of the interesting transformations you can achieve by shearing a previously sheared image in a different direction and by altering the image dimensions between successive shears.<P>
<h4><FONT COLOR="#000080"><A name="033D_012C">VGA-256 routines<A name="033D_012C"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
and <A href="list2.htm">Listing 2</a>
are the code for a demo in the VGA-256 mode (320 x 200 256 colors) written using Borland C and the Borland Graphic Interface (BGI). I chose this mode initially because it has one pixel per byte addressing, which makes transformations on individual columns easier than other modes. The demo presents a 3-D line drawing of a house that you can manipulate. You can only do one type of transformation at a time: scaling, right vertical shearing, left vertical shearing, right horizontal shearing, left horizontal shearing, or rotations. These transformations can be combined in any way necessary for your purposes (remembering that scaling an already scaled image increases aliasing) as in the turning of a page in a book.<P>
After selecting your transform choice you may use the arrow keys (up, down, left, and right for scaling; up and down for vertical shearing; left and right for horizontal shearing and rotations) to manipulate the image. The current width and height of the image are displayed at the bottom of the screen. The routines will not let the image become larger than the screen. When you are finished with your selected transformation press the END key.<P>
<A href="list2.htm">Listing 2</a>
contains the transform code for the VGA-256 mode. The first function calculates the Rothstein code based upon the fraction <I>p/q</I> (<I>p</I> = new dimension, <I>q</I> = old dimension). The <I>max</I> parameter may be one of four values depending on the transform desired, the bitmap's width, new width, height, or new height. <I>TransXY</I> combines scaling in both the horizontal and vertical directions for efficiency. It takes as arguments the source image, its dimensions, and its new dimensions.<P>
First, the function determines if it is expanding or shrinking in either direction, allocates the memory needed to hold the new bitmap and computes the Rothstein codes for both directions. Next, it loops through the rows of the image, manipulating each based upon the Rothstein code for that row. If the Rothstein code for the current row is a one then the routine copies this row. If the Rothstein code is a zero then the routine does one of two things: it copies the previous row if the image is being expanded (horizontally) or it skips the row if the image is being reduced. When the row is copied, it must be traversed one column at a time. Each pixel in each column of the current row will be manipulated based upon the Rothstein code for that column. The pixel is copied if the Rothstein code for the column is a one. If the Rothstein code is a zero and the image is to be expanded (vertically) then the previous pixel is duplicated. Otherwise, the pixel is skipped. Thus, through two nested traversal loops, one for the row and one for the column, the image can be simultaneously scaled in both the <I>x</I> and <I>y</I> directions.<P>
The shear routines are broken up into two functions, one for horizontal shearing and one for vertical. The vertical shear routine uses the difference between the new height and the original height as <I>p</I> and the width as <I>q</I> to calculate the Rothstein code for the shear. To perform what I call a right shift the routine starts at the left side of the image shearing the columns up so that the right side is the apex of the shear. The left shear is just the opposite, starting at the right side and moving toward the left shifting up. (The routine could also start at the same side only shifting down instead of up.)<P>
To perform the shearing the routine traverses each column of the image, moving the column up one row for each one in the Rothstein code. The shifting is cumulative so that the next column is moved up as much as the previous column and moved up one more if the code is a one. If the shear is greater than 45 degrees the routine shifts each column up one for each multiple the new height is of the width. This is a quick and simple way to make this adjustment but not as precise as some other methods. Unless you require the shear to be exact, this is not a problem. The horizontal shear function works in the same manner as the vertical except the routine traverses the rows instead of the columns and shifts the rows horizontally.<P>
<A href="fig3.htm">Figure 3</a>
shows a house in the VGA-256 mode. <A href="fig4.htm">Figure 4</a>, <A href="fig5.htm">Figure 5</a>, <A href="fig6.htm">Figure 6</a>, <A href="fig7.htm">Figure 7</a>, <A href="fig8.htm">Figure 8</a>, <A href="fig9.htm">Figure 9</a>, <A href="fig10.htm">Figure 10</a>, 
and <A href="fig11.htm">Figure 11</a>
show this house after being transformed through each of the transformations in the demo.<P>
<h4><FONT COLOR="#000080"><A name="033D_012D">The Problem with Shearing<A name="033D_012D"></FONT></h4></P>
The biggest problem with shearing an image is that you no longer have a rectangular bitmap; you have empty areas at the corners. If you want to preserve the background underneath the sheared image there are two alternatives: using a mask or a special method for putting the sheared image to the screen. <A href="list1.htm">Listing 1</a>
uses a modified version of Borland's <I>putimage</I> function. Because there are 256 colors to work with and only one pixel per byte in this mode, you can fill the destination buffer with a color that is not being used in the background. Thus, when you shear the image, the empty areas have this special color. When you put the image onto the screen you check for this color when copying the image. If the current pixel is this color then you don't copy it, thus the background is preserved.<P>
The <I>xputimage</I> function in <A href="list1.htm">Listing 1</a>
accomplishes this. In other graphics modes this cannot be done because there are either not enough colors or there are multiple pixels per byte in more than one bit plane (usually) which complicates the writing of each byte to the screen. More than one pixel per byte causes each pixel to be more difficult to isolate and move. A mask can be used that is sheared along with the original image and ORed to the screen with the sheared image being ANDed on top.<P>
<h4><FONT COLOR="#000080"><A name="033D_012E">Enhancements and Modifications<A name="033D_012E"></FONT></h4></P>
The VGA-256 routines can be modified for other graphics modes. The routines must handle multiple bit planes and multiple pixels per byte. Offsets within the source and destination bytes for each pixel must be maintained since they will become out of sync. As you duplicate or remove columns and rows, the source and destination pixel offsets within their respective bytes move apart from each other. The bit(s) that make up each pixel column must be shifted into the appropriate destination bit position before copying. To copy the bit(s), a mask is used so only the corresponding bit(s) are changed in the destination byte. If your application only requires vertical scaling then the bit shifting is unnecessary. For shearing, however, it is still needed.<P>
The shear routines must also be modified to shear a mask that is the same size as the image. A modified <I>putimage</I> routine is also necessary to use this mask. As mentioned previously, this mask is ORed to the screen and the image is ANDed on top of the mask, preserving the background. Unfortunately, these modifications will slow the transformations drastically. For example, routines for the sixteen-color VGA modes must read and write each byte of an image eight times more than VGA-256, not to mention traversing all four bit planes.<P>
Some speed enhancements can be implemented especially if you know ahead of time the exact transforms that will be performed. Each transform routine allocates a new buffer for the transformed image. If you know the size of the biggest resulting image you will need then you can allocate this buffer ahead of time and pass it to the transformation routines so the time acquiring and freeing memory will be removed. Also, if you do write routines for other graphics modes you can make your images start and change width on byte boundaries. Then the excess code necessary to manage the trailing and preceding pixel columns not starting on byte boundaries can be removed. The <I>putimage</I> routine then becomes almost as simple as that of VGA-256. Other speed enhancements include using inline assembly where necessary to speed up reading and writing the image.<P>
To increase the quality of the images after transformation, some antialiasing techniques can be used. However, these will slow down the transformations considerably so only use them if necessary. For my animation purposes the quality was not an issue. A typical antialiasing procedure is to make every pixel the average color (RGB values) of its neighbors. This will blur the edges so they appear smoother. This will only work satisfactorily when you have many colors to choose from. Many other techniques for edge detection and smoothing can be found in image processing books.<P>
<h4><FONT COLOR="#000080"><A name="033D_012F">Conclusion<A name="033D_012F"></FONT></h4></P>
Whether it be for painting, animation, font manipulation, or even text manipulation, the algorithms presented above can help. They offer easy methods for scaling, shearing, and rotating bitmaps in your own programs much like those used in commercial paint programs and some graphics packages.<P>
<h4>References</FONT></h4></P>
Foley, James D.; van Dam, Andries; Feiner, Steven K.; Hughes, John F. <I>Computer Graphics Principles and Practice</I>. Addison-Wesley Publishing Company, 1990.<P>
Wilton, Richard. <I>Programmer's Guide to PC &amp; PS/2 Video Systems</I>. Microsoft Press, 1987.<P>

<h4><a href="../../../source/1993/dec93/dean.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
