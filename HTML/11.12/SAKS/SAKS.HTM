

<HTML>
<HEAD>

<TITLE>December 1993/Stepping Up To C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Stepping Up To C++<A name="0358_0132"><A name="0358_0132"></font></h2><P>
<h3 align="center"><A name="0358_0000"><A name="0358_0000">Virtual Functions</h3><P>
<h3 align="center"><font color="#800000">Dan Saks</font></h3><hr><blockquote><P>
<P><i><A name="0358_0000"><A name="0358_0000">Dan Saks is the founder and principal of Saks &amp; Associates, which offers consulting and training in C++ and C. He is secretary of the ANSI and ISO C++ committees. Dan is coauthor of C++ Programming Guidelines, and codeveloper of the Plum Hall Validation Suite for C++ (both with Thomas Plum). You can reach him at 393 Leander Dr., Springfield OH, 45504-4906, by phone at (513)324-3601, or electronically at dsaks@wittenberg.edu.</i></P><P>
Object-oriented programming is a collection of programming techniques:<P>
<UL><li>data abstraction</li>
<li>inheritance</li>
<li>polymorphism</li></UL>
C++ is an object-oriented language in the sense that it provides specific language features that support each of these techniques. (However, it's not a pure object-oriented language in that it doesn't insist that you use any of these techniques.)<P>
C++ supports data abstraction (also called encapsulation) by providing classes with public and private access specifiers. I first introduced classes and access specifiers way back in "Writing Your First Class," <I>CUJ</I>, March, 1991, and I've been using them ever since. C++ supports inheritance through class derivation, which I introduced in my column starting with "Inheritance, Part 1," <I>CUJ</I>, March, 1993. C++ supports polymorphism by providing virtual functions, which is my topic for this month.<P>
Just as you can't use inheritance unless you're already using classes, you can't use polymorphism unless you already understand inheritance. Thus I'll start with a brief review of inheritance and type hierarchies before introducing new terminology.<P>
<h4><FONT COLOR="#000080"><A name="0358_0133">Type Hierarchies<A name="0358_0133"></FONT></h4></P>
Data abstraction is a technique for grouping into a single program unit all the data that represents a single variable of an abstract type along with all the functions that can operate on that data. In C++, that unit is called a class. The data and functions declared inside the class are called its members.<P>
A class controls access to its members by using access specifiers (the keywords <I>public</I> and <I>private</I>). The public members in a class define the class interface, that is, the set of outward functional characteristics that the class provides to the rest of the program. The private members specify implementation details that the class chooses to hide from the rest of the program.<P>
Inheritance creates a new class (the derived class) from some existing class (the base class). The derived class inherits all the members (both data and functions) of the base class. The derived class may add more members, but it cannot take any away. However, a derived class can <I>override</I> the definition of an inherited member function with a new definition.<P>
Inheritance can also be public or private; public is the more useful form. Public inheritance defines an Is-A relationship between a derived class and its base class. That is, an object of a (publicly) derived class is an object of its base class (and probably more). A function that expects an object (or a pointer or reference to an object) of some base class <I>B</I> will readily accept an object (or a pointer or reference to an object) of any class publicly derived from <I>B</I>.<P>
You can use inheritance to define hierachies of related classes. That is, you can derive several classes from a single base class, and then derive additional classes from each of those derived classes. Class hierarchies let you propogate a host of common attributes from a base class to many derived classes, and provide a range of behaviorial variations with a minimum of effort.<P>
For example, you can design a class hierarchy to implement a device-independent file system, such as the ones in Unix or MS-DOS. In these systems, each device type &#151; disk, tape, serial port, parallel port &#151; usually has a distinct low-level I/O protocol for sending (flushing) data to the device, receiving (filling) data from the device, or signalling I/0 status. But the file system provides a common set of high-level operations, like <I>read</I> and <I>write</I>, so that all these different device types look essentially alike to application programmers.<P>
At some low level, programs reading from or writing to a device must behave differently according to the true device type. But most of the high-level algorithms and data structures, such as those for buffering and unbuffering data, are the same for all devices. Furthermore, random-access devices like disks and tapes share some characteristics with each other, while sequential devices like ports share a slightly different set of common characteristics.<P>
You can model a device-independent file system with a multi-level class hierarchy as outlined in <A href="list1.htm">Listing 1</a>
and graphically represented in <A href="fig1.htm">Figure 1</a>.
 The root of the hierarchy is the base class, <I>file</I>, which declares functions, like <I>read, write</I> and (test for) <I>eof</I>, that are common to all files. <I>file</I> also defines the data structures for buffering that every derived class needs.<P>
Class <I>random_file</I> derives from <I>file</I> and overrides the inherited functions with revised definitions that work properly for random access. In many cases, an overriding function will be very simple because it can call the function it overrides to do most of the work, as in<P>
<pre>int random_file::read(char *buf, size_t len)
   {
   // do something specific for random access
   // call file::read(buf, len)
   // do something else specific for random access
   }</pre>
Class <I>random_file</I> defines additional members unique to random access devices. In particular, it provides additional operations like <I>seek</I> and <I>tell</I>, along with a nested type <I>pos_t</I> for representing a file position indicator. Classes <I>disk_file</I> and <I>tape_file</I> derive from <I>random_file</I>, overriding and augmenting inherited characteristics to match the needs of each device exactly.<P>
On the other side of the hierarchy, class <I>sequential_file</I> derives from <I>file,</I> overriding inherited functions as needed and defining additional members to support sequential devices. Classes <I>parallel_port</I> and <I>serial_port</I> derive from <I>sequential_file</I>, and in turn, add the appropriate embellishments.<P>
Type hierarchies like these arise in many other libraries and applications. Of particular interest these days are user interface libraries containing all sorts of graphical objects that share common properties. For example, an interface library might support different kinds of menus: drop-down menus, pop-up menus, and menu bars. All of these different menu types can be classes derived from a single menu base class.<P>
<h4><FONT COLOR="#000080"><A name="0358_0134">Polymorphism<A name="0358_0134"></FONT></h4></P>
Inheritance simplifies the task of implementing families of related class types. But by itself, inheritance doesn't necessarily make life any easier for users of these types.<P>
Consider the file system hierarchy. As a user, I want to be able to write a function that operates on a file and to pass it an object of any <I>file</I> type. That is, I want to be able to pass a <I>disk_file</I>, a <I>tape_file</I>, or any other kind of <I>file</I> to the function and have it work correctly in all cases. Furthermore, I don't want to add code to my function to ask the file "What are you, really?" before it reads or writes. The function should simply apply <I>read</I> or <I>write</I> to its <I>file</I> parameter, with the expectation that the call will do the right thing for whatever type of <I>file</I> that parameter is.<P>
That's what I want. But that's not quite what I get.<P>
Using the file hierarchy from <A href="list1.htm">Listing 1</a>,
 I can indeed create a <I>disk_file</I> object and pass it to a function that expects a <I>file</I> (or a <I>file &amp; or file *</I>). I can pass a <I>disk_file</I> object as a <I>file</I> object because a <I>disk_file</I> Is-A <I>file</I>. Unfortunately, when the <I>disk_file</I> object arrives in the function, the function only knows it has base class <I>file</I> object. It can't tell what kind of file it really has.<P>
Consider the example outlined in <A href="list2.htm">Listing 2</a>.
 The filter function accepts two parameters, <I>fin</I> and <I>fout</I>, that are both of type <I>file &amp;. main</I> calls <I>filter,</I> passing <I>disk_files din</I> and <I>dout</I> as the actual arguments. I would like the call <I>fin.read(buf, BUFSIZ)</I> inside <I>filter</I> to invoke the appropriate function for reading a <I>disk_file</I>, namely <I>disk_file::read</I>. Unfortunately, as the hierarchy is currently written, <I>fin.read</I> always calls <I>file::read</I> regardless of the file's type. The same problem occurs with the calls to <I>fin.eof</I> and <I>fout. write</I>.<P>
What we have here is a failure to communicate. Communication breaks down because C++ uses <I>static binding</I> by default. That is, when translating a call like <I>r.f</I>, where <I>r</I> is a reference, C++ normally selects the member function based on the static type of <I>r</I>. If <I>r</I> is declared in the current scope with type <I>B &amp;</I>, then the call <I>r.f</I> invokes <I>B::f</I>. Even if <I>r</I> is actually bound to a <I>D</I> object, where <I>D</I> is derived from <I>B</I> and overrides <I>B::f</I>, calling <I>r.f</I> still calls <I>B::f</I>, applying it to the object referenced by <I>r</I>. Similarly, when translating a call like <I>p-&gt;f</I> where <I>p</I> is a pointer, C++ selects the member function based on the static type of <I>*p</I>.<P>
With static binding, if you want an object to exhibit the derived class's behavior, you have to refer to the object with an object expression of the derived type. (The object expression is the expression in a member function call that appears to the left of the dot or arrow.) So, to work properly, the filter function in <A href="list2.htm">Listing 2</a>
must somehow determine that <I>fin</I> refers to a <I>disk_file,</I> and then cast <I>fin</I> to a <I>disk_file &amp;</I> before calling <I>read</I>, as in<P>
<pre>n = ((disk_file &amp;)fin).read(buf, BUFSIZ);</pre>
Such conversions are inconvenient and generally unsafe.<P>
I won't get the kind of behavior I want unless the file system hierarchy uses <I>dynamic binding.</I> That is, each <I>file</I> object should remember what type it really is (its <I>dynamic type)</I> so that member function calls applied to that object invoke the overriding functions for the object's true type. For example, with dynamic binding, the call to <I>fin.read</I> in the filter function of <A href="list2.htm">Listing 2</a>
would call <I>disk_file::read</I> whenever <I>fin</I> is actually bound to a diskfile. It would call <I>tape_file::read</I> whenever <I>fin</I> really refers to a <I>tape_file</I> object. And so on.<P>
This combination of inheritance and dynamic binding is called polymorphism (from the Greek for "manyformism"). Polymorphism is a programming technique which lets you pass an object of a derived class type (the dynamic type) to functions that know the object only by its base class type (the static type). Yet, the object retains its dynamic type so that member function calls applied to that object invoke the derived class behavior. With polymorphism, the calling function need not ask for the object's dynamic type. In effect, the the caller just says "Whatever you are, do this operation in whatever way is right for you."<P>
Calls to dynamically-bound functions are typically a little slower than calls to statically-bound functions. Since C++ tries to avoid making you pay for a feature unless you use it, you can't get dynamic binding unless you ask for it. You ask for dynamic binding one function at a time, by adding the keyword <I>virtual</I> to the beginning of the function declaration. Only member functions can be virtual. A class with at least one virtual function is called a polymorphic class.<P>
<h4><FONT COLOR="#000080"><A name="0358_0135">A Hierarchy of Shapes<A name="0358_0135"></FONT></h4></P>
I prefer to demonstrate virtual functions with a complete working example. Unfortunately, a file system hierarchy is a bit too large to present in its entirety. So I'll use a simpler example involving a collection of shapes, like circles, rectangles and triangles, all derived from a common base class.<P>
A graphical application might employ a basic set of shapes for composing complex diagrams. For example, CASE (computer-aided software engineering) tools use different shapes to represent classes, objects, and processes. A drafting tool might use shapes as the basic building blocks for representing complex 3-D entities.<P>
Of course, my shapes are much simpler. <A href="list3.htm">Listing 3</a>
shows the class definition for the base class <I>shape.</I> The public member functions define the basic operations common to all shapes. The class provides a constructor, <I>shape(palette)</I> that creates a shape with a given color, along with the following member functions:<P>
<I>color</I> &#151; return the color of a shape<P>
<I>name</I> &#151; return the name of a shape<P>
<I>area</I> &#151; return the area of a shape<P>
<I>put(ostream &amp;)</I> &#151; display a shape on a stream<P>
All of the member functions except the constructor are virtual. The compiler will use dynamic binding when calling any of these virtual functions.<P>
Constructors cannot be virtual. Virtual functions make an object act according to the type it was given when it was created. In a sense, the constructor "gives" an object its type. You can't ask an object to construct itself in a way appropriate to its type because, prior to the constructor call, the object doesn't even exist. The constructor for a polymorphic object (of a class with at least one virtual function) puts something in the object to describe its dynamic type. Subsequent virtual function calls applied to that object use that something to route the calls to the right place.<P>
Destructors can be virtual. Each object in the hierarchy may have different resource requirements, and thus different procedures for discarding those resources. Using virtual destructors, you can delete an object via a base class pointer and rest easy that the appropriate destructor will be called.<P>
Shapes come in a variety of decorator colors. The nested type <I>palette</I> defines the available colors. By nesting the type inside the class, the names of the type and the enumeration constants are all in the scope of the class, and not global. This eliminates the possibility of global name conflicts that might occur if another library defines a different color scheme but uses the same names.<P>
You specify a shape's color as an argument to the shape constructor. The constructor stores that color into the data member <I>_color,</I> as shown in <A href="list4.htm">Listing 4</a>.
 The notation <I>: _color(c)</I> is a member initializer that initializes member <I>_color</I> with value <I>c.</I> The data member <I>_color</I> is private; non-members can inspect its value by calling the public member function <I>color.</I><P>
The area member function returns the area of a shape. Derived classes like <I>circle</I> have some dimension, like radius. But the base class <I>shape</I> has no dimension, so its area is just zero. The <I>name</I> member function returns a null-terminated string representing a shape's name. A shape with zero area has the name <I>"point."</I><P>
<I>shape::put(ostream &amp;os)</I> writes a shape's attributes to <I>ostream os</I> in text form. The static member <I>color_image</I> is an array of strings that are printable spellings for the colors. <I>color_image</I> contains one string for each selection from palette. For example, <I>color_image[GREEN]</I> selects the string "<I>green</I>." (The declaration for <I>color_image</I> appears in the class definition in <A href="list3.htm">Listing 3</a>.
 The definition for <I>color_image</I> appears in <A href="list4.htm">Listing 4</a>.
) Thus, <I>shape::put</I> displays a shape's color and its name.<P>
So much for the base class. <A href="list5.htm">Listing 5</a>
shows the class definition for <I>circle,</I> derived from <I>shape. circle</I> redeclares the functions <I>area, name,</I> and <I>put,</I> each with the same signature and return type that it has in the base class. Thus, these functions override the inherited definitions.<P>
Even though the keyword <I>virtual</I> does not appear in <I>circle's</I> declarations for <I>area, name,</I> and <I>put,</I> these functions are virtual nonetheless. A function in a derived class that overrides a virtual function in a base class is itself a virtual function. Adding virtual to the overriding function's declaration in the derived class doesn't hurt, but isn't necessary.<P>
<A href="list5.htm">Listing 5</a>
also contains <I>circle's</I> member function definitions. The constructor creates a circle with a specified color and radius. The constructor initializer list<P>
<pre>: shape(c), radius(r)</pre>
passes <I>c</I> to thenstructor when it initializes the base class part of a circle, and then initializes the radius with <I>r.</I><P>
<I>circle::area</I> computes a circle's area using the familiar pr2 formula. <I>circle::name</I> simply returns the string <I>"circle."</I><P>
<I>circle::put</I> does something very interesting. It calls the <I>put</I> function from the base class using the explicitly-qualified name <I>shape::put.</I> Even though <I>shape::put</I> is virtual, this call with explicit qualifier turns off the dynamic binding. A call to <I>shape::put</I> puts the color and name of the shape, and returns to <I>circle::put,</I> which displays the radius as well. The output looks something like:<P>
<pre>blue circle with radius 3</pre>
<h4><FONT COLOR="#000080"><A name="0358_0136">Dynamic Binding in Action<A name="0358_0136"></FONT></h4></P>
Consider the consequences if the <I>circle::put</I> called <I>shape::put(os)</I> using dynamic binding. Remember, inside <I>circle::put,</I> the compiler translates the call <I>shape::put(os)</I> into <I>this-&gt;shape::put(os).</I> That is, the call applies <I>shape::put</I> to the object addressed by <I>this.</I> If the call binds dynamically, then it calls the <I>put</I> function for the dynamic type of <I>this,</I> which in this case is <I>circle.</I> Thus, if this call were dynamically bound, it would call itself recursively until the call stack overflowed.<P>
Notice that <I>circle</I> does not override the inherited <I>color</I> function. The color of a <I>circle</I> is the value stored in its inherited <I>_color</I> data member. The rule for inspecting <I>_color</I> is the same for all shapes, so derived classes need not override it. But if derived classes never have a reason to override the color function, then it need not be virtual. Just because some functions in a base class are virtual doesn't mean all of them must be.<P>
For good measure, <A href="list6.htm">Listing 6</a>
shows a <I>rectangle</I> class derived from the <I>shape</I> class. Each <I>rectangle</I> stores its height and width (along with its inherited color). The overriding member functions fall in line accordingly.<P>
<A href="list7.htm">Listing 7</a>
illustrates the real power of dynamic binding using virtual functions. The function <I>largest</I> selects the shape with the largest area from a collection of shapes. In this example, the collection is simply an array, <I>sa,</I> of pointers to (constant) <I>shapes.</I> Thus, <I>sa[i]</I> is the <I>i</I>th shape in the collection, and <I>sa[i]-&gt;area</I> returns the area of the <I>i</I>th shape. Since <I>area</I> is a virtual function, <I>largest</I> never needs to know the dynamic type of a shape. Dynamic binding automatically selects the appropriate <I>area</I> function for each shape.<P>
Even better, <I>largest</I> works not only for collections of <I>circles</I> and <I>rectangles,</I> but for collections of any shapes derived from the base class <I>shape.</I> If you derive <I>triangle</I> from <I>shape,</I> and add a <I>triangle</I> to the collection, <I>largest</I> can handle it. If you put <I>largest</I> in a separate source file, you don't even have to recompile <I>largest</I> each time you add a new shape to the hierarchy. <I>largest</I> only depends on the definition for the base class, which doesn't change. So the derived classes for <I>circle, rectangle, triangle,</I> and so on, need not be in scope when compiling <I>largest.</I><P>
Collections of polymorphic objects are a staple in object-oriented applications. For example, in a windowing environment, the desktop can simply be a collection of window objects ("views"). These objects might be message boxes, dialog boxes, or edit windows. Closing a message box might simply erase the box, while closing an edit window might close a file before erasing the box. But an operation like <I>close_all</I> (clear the desktop) need not concern itself with these subtleties. It simply visits each desktop object and invokes its virtual <I>close</I> function.<P>
<I>main</I> in <A href="list7.htm">Listing 7</a>
writes shapes to <I>cout</I> using the <I>&lt;&lt;</I> operator. For example, the statement<P>
<pre>cout &lt;&lt; *ls &lt;&lt; ".\n";</pre>
puts the shape addressed by <I>ls</I> to <I>cout.</I> The definition for the overloaded <I>operator&lt;&lt;</I> appears in <A href="list8.htm">Listing 8</a>.
 It's trivial, but dynamic binding makes it quite powerful.<P>
The call <I>s.put(os)</I> in <A href="list8.htm">Listing 8</a>
uses dynamic binding. That is, calling <I>os &lt;&lt; s</I> to write shape <I>s</I> to <I>ostream os</I> simply calls the <I>put</I> function defined in the class of the dynamic type of <I>s.</I> As with <I>largest, operator&lt;&lt;</I> never asks what that dynamic type is. It justs makes the call, and the virtual call mechanism does the rest. Thus, you don't need to define <I>operator&lt;&lt;</I> for <I>circle, rectangle,</I> or any other derived type. This one operator works with any type derived from <I>shape.</I><P>
<h4><FONT COLOR="#000080"><A name="0358_0137">The File Hierarchy, Again<A name="0358_0137"></FONT></h4></P>
Adding the right virtual functions to the base class <I>file</I> should give my <I>File</I> objects the behavior I want. As with the <I>shape</I> hierarchy, not all the base class functions need to be virtual &#151; only the ones that I override in derived classes.<P>
There are more refinements I can make to these hierarchies that require additional languages features. Stay tuned.<P>

<h4><a href="../../../source/1993/dec93/saks.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
