

<HTML>
<HEAD>

<TITLE>December 1993/Writing Solid Code</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Book Reviews</FONT></H2>

<hr><h2 align="center"><font color="#800000">Writing Solid Code<A name="0360_0138"><A name="0360_0138"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0360_0000"><A name="0360_0000">Reviewed by A. Donnie Hale, Jr.</font></h3><hr><blockquote><P>
<P><i><A name="0360_0000"><A name="0360_0000">Mr. Hale is a senior software engineer at IMAGE Engineering, a developer of document-imaging tools and systems. He has been developing graphical, client-server applications in C for 5 years. He can be reached at IMAGE Engineering (614) 899-7226, his voice mail (614) 898-2675, or on CompuServe at 74260,1022.</i></P><P>
Microsoft is one of the most prominent developers of software in the world today; and despite some false starts and initial version problems, its software is, for the most part, sound and robust. What enables Microsoft to develop best-selling software, product-after-product, release-after-release?<P>
Microsoft Press's recently released book, <I>Writing Solid Code</I>, by Steve Maguire, partly answers this question, by offering frequent interesting insights into the successes and failures of software development at Microsoft. <I>Writing Solid Code,</I> subtitled <I>Microsoft's Techniques for Developing Bug-Free C Programs,</I> is just that: a summary of C software development practices at Microsoft. The book targets project leaders and developers of large-scale software products, and assumes that its readers are intimately familiar with the software development process. The book does not address commonly-preached C techniques; instead, the author tries "to focus on the little-known, or rarely published, techniques for writing bug-free code."<P>
The foreword by Dave Moore, Director of Development at Microsoft, recounts Microsoft's internal growth as a software company. The author also details his experience at Microsoft, including his departure from the Macintosh Excel group to another, newer group, which did not always acquire the company's existing knowledge. This preface, along with the foreword, provide an excellent background to the usefulness, importance, and practicality of the material in <I>Writing Solid Code</I>.<P>
<h4><FONT COLOR="#000080"><A name="0360_0139">Learn by Example<A name="0360_0139"></FONT></h4></P>
Chapter 1 introduces a hypothetical and probably ideal compiler that not only flags syntax errors but warns about any potential obscurities in a developer's code. The rest of that chapter and the subsequent seven chapters detail real methods and tools that, in combination, approach the capabilities of such a compiler.<P>
Among other topics, the book covers the proper use of assertions (not necessarily the standard C <I>assert</I> function) and debug-only redundancy systems which use backup algorithms; subsystem integrity checking; tracing through all lines of code with a debugger (the author states, "I don't know many programmers who consistently write bug-free code, but the few I do know habitually step through all of their code."); proper function development; minimizing risky algorithms and language constructs in favor of safer, proven alternatives; practices to avoid altogether; and the mindset of a good programmer. The book also includes checklists for design, implementation, adding debug support, testing, and debugging.<P>
To illustrate his points, the author develops a memory-management subsystem. The system reflects all of the techniques recommended by the author that can be adequately described in book form. The author includes source for the subsystem in an appendix. In addition, he provides hundreds of examples of good and bad source code.<P>
I am disappointed by one aspect of the book, though my disappointment may only reflect personal bias. The introduction begins by quoting the preface of Donald Knuth's <I>TEX: The Program:</I> "I believe that the final bug in TEX was discovered and removed on November 27, 1985." The author's inclusion of this quote seems to imply that he believes it really is possible to write bug-free code; the remainder of the book also seemed to be based on this assumption. I also subscribe to this belief, though it seems few hold it these days. In the epilogue, though, the author says, "you're probably wondering if I really believe it's possible to write bug-free programs. The answer is no, I don't, not absolutely. But I do believe you can come very close to writing bug-free programs, much closer than the current norm; you just have to decide to do it."<P>
<h4><FONT COLOR="#000080"><A name="0360_013A">Conclusion<A name="0360_013A"></FONT></h4></P>
Overall, <I>Writing Solid Code</I> is an excellent book. The book is very readable (though you must read each chapter in sequence). I found the Microsoft anecdotes and development case histories to be the most interesting parts of the book. The book shows Microsoft as a development shop which has gone through the same challenges as all development shops, albeit at an accelerated rate. C developers of all varieties will find the information and techniques in <I>Writing Solid Code</I> useful in their pursuit of bug-free software.<P>
<B>Title:</B> <I>Writing Solid Code</I><br>
<B>Author:</B> Steve Maguire<br>
<B>Publisher:</B> Microsoft Press, 1-800-MSPRESS,<br>
<B>Price:</B> $24.95<br>
<B>ISBN:</B> 1-55615-551-4<br>
<B>Pages:</B> 228<P>
</BLOCKQUOTE>
</BODY>
</HTML>
