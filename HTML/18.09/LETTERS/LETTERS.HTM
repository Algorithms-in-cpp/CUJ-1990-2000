<HTML>   
     <HEAD>
<TITLE>September 2000/We Have Mail</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">We Have Mail</FONT></H2>

<HR>
<BLOCKQUOTE>
<p><I>Letters to the editor may be sent via email to </I>cujed@cmp.com<I>, or via the postal service to Letters to the Editor, </I>C/C++ Users Journal<I>, 1601 W. 23rd St., Ste 200, Lawrence, KS 66046-2700.</I></p>

<hr><I><p>David Berry, author of the article, "Combining Boyer-Moore String Search with Regular Expressions" (CUJ, June 2000), has responded to several bug reports from readers. He has contributed an updated source listing, which we have uploaded to our ftp site and website (See </I><B>ftp://ftp.cuj.com/pub/2000/cujjun2000.zip</B><I> or </I><B>www.cuj.com/code/updates.hmtl</B><I>). Dave writes:</I></p>
<p>All,</p>
<p>Thank you for your contributions to the <B>CRegEx</B> class. I have been told that you can't prove that an algorithm works, only that it doesn't work. Well, each one of you have found something that did not work. As you all know, the algorithm works by breaking the regular expression into sub-expressions, then matching the individual sub-expressions. The problem with the original implementation was that I was looking for the sub-expressions in the wrong place. I needed to be looking for the sub-expressions within the Boyer-Moore loop rather than outside it.</p>
<p><a href="list1.htm">Listing 1</a> shows the modified Boyer-Moore loop that correctly handles the matching of sub-expressions. I have also included the latest code for the algorithm. The code also includes a test program that can be used to regression test the algorithm.</p>
<p>Once again, thanks for all the help.</p>
<p>Dave Berry</p>

<hr><p>Dear <I>CUJ,</I></p>
<p>Just a note from a reader to say that I fully agree with the spirit of your editorial in July's <I>CUJ.</I></p>
<p>And while I'm at it I'll also mention that I'm pleased with the <I>CUJ</I>'s general content these days, speaking as someone who's been a subscriber on and off for the last nine years (The "off" years were prompted by the observation that I wasn't reading it, not by any active dissatisfaction with it.) Among other things I'm pleased to see that you've decided to have a regular column on Java. I think increasing numbers of C++ programmers including myself need to know Java, while remaining mostly C++ programmers, and Java is part of the C family.</p>
<p>Sean Furlong</p>
<p><I>Thanks for the compliments, Sean. It's also good to hear from someone who isn't violently allergic to Java. (In case anyone was wondering, though, we have no plans to add a C# column.) &#151; mb</I></p>

<hr><p>Marc,</p>
<p>I thoroughly enjoyed your Editor's Forum in the July <I>CUJ,</I> along with your neat "Simple Unit Tests in C++" template. Let me share my personal experience of when the light came on regarding pointers.</p>
<p>My introduction to pointers was in college. We learned and primarily used Pascal. It is a great language for learning, and pretty good for doing real work. Anyway, in all of the text books, pointers were always shown as little boxes with arrows coming out of them. Also, pointers were supported <I>only</I> when used with dynamic memory allocation, another abstract concept. Pointers themselves were "abstract." They were little boxes. They contained arrows. They could point to something, or nothing (called <B>NIL</B>). But you sometimes had to delete them, and sometimes re-assign them, and you had to be very carful on how and when you created/used/deleted them.</p>
<p>I also had taken assembly language my junior year. I understood what an address was. I understood what it meant to dereference an address in an operation.</p>
<p>Then, at my first job, we used C, not Pascal. I learned how to take the address of something and store it in a pointer. No dynamic memory. No little boxes with arrows in them. <I>Ding,</I> the light bulb came on! Pointers were addresses! Dynamic memory allocation requires the use of pointers, but not vice versa!</p>
<p>After just a few days, I could write C statements out the wazoo to reference some variable 14 levels deep of nesting, knowing when to use <B>.</B> (dot) <B>*</B> (dereference) <B>-&gt;</B> or <B>[index]</B>. Statements like:</p>

<pre>
char c = **ppChar;
</pre>

<p>did not faze me. I know some C programmers who say, "I can't get this to compile, I keep adding *s in the front, but that doesn't seem to help." A little scary, huh?</p>
<p>Yes today, when I draw trees and linked lists, I use arrows. I don't write addresses down &#151; I understand the abstraction of pointers. But, the light did not come on until 3+ years after I was introduced to the concept of pointers and someone showed me how they are implemented at the processor level!</p>
<p>Luckily, when I was first introduced to references in C++, I was told they are basically pointers without the pointer syntax. So I understood references pretty quickly.</p>
<p>Regarding your testing template, I hope I get to try it out soon. We're about to start a rather large project dealing with some embedded programming. I'd like to test some of my routines utilizing the <B>BaseTestxx</B> templates. Our professional discipline needs more ideas like this to promote developer testing. Even though testing is usually very specific to the problem at hand, your <B>BaseTestxx</B> templates can be applied across many, many routines.</p>
<p>Regards,</p>
<p>Mark Franjione<br>
Sr. Software Engineer<br>
Host Engineering, Inc.</p>

<p><I>In my electrical engineering days we used to have an inside joke about how to handle a circuit that was too noisy. We would say, "put a capacitor on it." It was sort of the electronic equivalent of your scary C programmers adding asterisks to declarations. Amazingly, adding a capacitor sometimes worked, but when we did that we sure weren't doing engineering. There's no substitute for knowing how something really works. &#151; mb</I></p>

<p>Marc,</p>
<p>I enjoyed your article on unit testing in the July 2000 issue of <I>CUJ.</I> I've been wrestling with a variety of implementations of such a framework and haven't come up with one quite so elegant.</p>
<p>I write software used to design highway bridge structures. As such, I use a lot of floating-point numbers and my unit tests must compare these numbers. Using <B>operator==</B> usually isn't a good idea because of small round-off errors (1.00000001 is equal to 1.0 for my purposes but <B>==</B> evaluates to <B>false</B>).</p>
<p>A nice refinement to your test framework would be the use of a predicate object to determine equivalence. Much the way the STL uses predicate objects.</p>
<p>Richard Brice, PE<br>
Software Applications Engineer<br>
Washington State Department of Transportation,<br>
Bridge and Structures Office</p>

<p><I>Yes, I also soon discovered that my framework wasn't so hot for testing routines that produced floating-point outputs, for the very reason you cite. There is a workaround, but with too many workarounds such a tool becomes more trouble than it's worth. I should also point out that if you supply non-primitive types as template parameters, you'll probably have to supply overloaded versions of </I><B>operator&lt;&lt;</B><I> to print out their values.</I></p>
<p><I>I like your idea of using STL-style predicate objects, but have not had time to try it out. I imagine there are several ways the framework could be improved. In fact, not long after the article was published, a reader sent in an idea that seemed simpler in most respects; we may end up publishing it as an article in a future issue. Also, if you haven't already done so, check out Chuck Allison's article, "The Simplest Automated Unit Test Framework That Could Possibly Work," elsewhere in this issue. He takes a somewhat different approach. (He also wins this month's award for "The Longest Article Title That Could Possibly Get Past an Editor.") Thanks for writing. &#151; mb</I></p>

<hr><p>Dear <I>CUJ,</I></p>
<p>Michael Bramley presents a useful algorithm for "Data-Based Axis Determination" (<I>CUJ</I>, July 2000, p. 20). But it could be improved.</p>
<p>The algorithm should be scale-invariant, in the sense that multiplying the inputs by any power of 10 should multiply the outputs by the same power of 10. For example, (1,10) as inputs gives (1,10,1) as outputs, so any input of the form (10n, 10(n+1)) should give (10n, 10(n+1), 10n). Table 1 in the article includes several examples in this pattern:</p>

<pre>
Data   Data   Scale  Scale  Scale
min    max    min    max    inc
---------------------------------
 0.01    0.1   0.01    0.1   0.01
 1      10     1      10     1
10     100    10     100    10
</pre>

<p>But that invariance is broken by the fixed value 1e-10 (I'm assuming the test on <B>fabs(Test_min)</B> is activated.) Suppose you're measuring a fast reaction in picoseconds, and you want values from 1e-12 to 10e-12. The scale minimum gets reset from 1e-12 to zero. A simple fix is to multiply the tiny cutoff value by the range so it scales with the data.</p>
<p>Another problem is that the roundoff can cause an additional decrement loop, resulting in a smaller minimum than necessary. For example, for data from 10 to 11, the calculated scale minimum is 9.9 instead of 10. That can be fixed by moving the test inside the loop and comparing against <B>Min</B> rather than zero:</p>

<pre>
do {
   ++i ;
   Test_min -= Test_inc ;
   if( fabs(Test_min - *Min)
          &lt; 1E-10 * Range )
      Test_min = *Min ;
   }
while( Test_min &gt; *Min ) ;
</pre>

<p>A sampling of problem cases appears in <a href="fig1.htm">Figure 1</a>.</p>
<p>Incidentally, the algorithm does not guarantee "at least six major tick marks." For example, data from 0 to 11 gets only four ticks:</p>

<pre>
Data  Data  Scale  Scale  Scale
min   max   min    max    inc
-------------------------------
 0    11     0     15      5
</pre>

<p>This could be fixed by looping on the <B>( i &lt; 6 )</B> fixup.</p>
<p>Finally, <B>pow10(x)</B> is not a standard function; it could be <B>pow(10.0, x)</B>.</p>
<p>Peter Hollinger<br>
<B>peterh@intex.com</B></p>

<hr><p>Dear <I>CUJ,</I></p>
<p>Thanks for Micheal Bramley's interesting and insightful article "Data-Based Axis Determination" (<I>CUJ,</I> July 2000). It was especially interesting to me, since I had come up with almost the exact same algorithm while creating a ruler control for a windowing package for my employer. Given the number of pixels available between the whole units and the minimum space between tick marks, the number of tick marks between whole units can be calculated thus:</p>

<pre>
// Minimum pixels allowed between
// tick marks
int minPixPerTick = 10

// 2.0 for inches, 10.0 for cm &amp; mm
int baseMode = 10.0

// Use resolution and zoom
// to determine
int pixelsPerUnit = 100;

int ticksPerUnit =
   pow(baseMode,
      floor(log(pixelsPerUnit/
         minPixPerTick)/
            log(baseMode)));
</pre>

<p>Regards,</p>
<p>Scott Miller<br>
Lectra Systems, Inc.<br>
<B>s.miller@lectra.com</B></p>

<p><I>Michael Bramley replies:</I></p>
<p><I>Scott:</I></p>
<p><I>Thank you for your kind and generous comments regarding my article! In hindsight, I am not surprised that you too had discovered this elegant, yet simple, little algorithm to make dealing with graphics easier. However, I now wonder how many other programmers are out there that read my article and looked at their code, thinking, "Gee, I've done this..."</I></p>
<p><I>It's interesting to note that this concept does generalize nicely to other "graphics," such as rulers. This only goes to demonstrate that it is one of those algorithms with many uses &#151; all we have to do is find the problem it solves!</I></p>
<p><I>Sincerely,</I></p>
<p><I>Michael Bramley</I></p>
<p><I>Cha Geil!</I></p>

</blockquote></body></html>
