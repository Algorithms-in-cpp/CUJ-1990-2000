<HTML>   
     <HEAD>
<TITLE>September 1999/STL-Style Iterators for MFC</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Algorithms</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">STL-Style Iterators for MFC</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Kevin Kostrzewa</FONT></H3>

<BLOCKQUOTE>
<p>STL prides itself on being extensible. You can even extend it to subsume MFC with all its varied containers.</p>
</BLOCKQUOTE>
<hr>
<BLOCKQUOTE>

<h4><FONT COLOR="#000080">Introduction</FONT></H4>

<p>The MFC (Microsoft Foundation Classes) library is the most commonly used C++ application framework and class library for writing Windows GUI programs. This library contains both an object-oriented hierarchy of windowing elements and a number of helper classes. A part of these helper classes consists of a set of type-safe (template-based) and type-unsafe (class-based) collection classes. These collection classes fit the requirements and behavior of growable arrays, associative arrays, and linked lists, otherwise known as arrays, maps, and lists.</p>
<p>The Standard C++ library, by adopting Alexander Stepenov and Meng Lee's STL (Standard Template Library), offers its own set of collection classes <a href="#1">[1]</a>. These collection classes support a concept called iteration, which enables the collections to be used with a rich set of already written and tested freestanding library functions.</p>
<p>Unfortunately, MFC does not support the STL concept of iteration. In this article, I describe the use and implementation of a component I've created that fills in this gap by allowing MFC collection classes to be iterated. Providing iterators to MFC offers three advantages. First, code written with the MFC iterators walks through contained elements in a standard manner. Second, using iterators with MFC serves as an introduction to the powerful STL portion of the Standard C++ library. Finally, and perhaps most importantly, the rich set of STL algorithms can be seamlessly incorporated into code based on MFC collections.</p>
<p>All of the code for this article was compiled and tested using version 6.0 of Microsoft's Visual C++. Due to the complexities of supporting templates in a C++ compiler, I highly doubt that any of this code is executable on versions of Visual C++ prior to v6.0.</p>

<h4><FONT COLOR="#000080">About Iterators</FONT></H4>

<p>Iterators are objects that "provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation" <a href="#2">[2]</a>. According to the iterator concept, when you use an iterator (any iterator, not just ones provided in STL), you are blissfully unaware of how the data is internally stored by the aggregate object. All you need to know is which iterator operations allow you to move from element to element, and which iterator operations allow you to access a particular element.</p>
<p>In STL, iteration is viewed as a service provided by a separate member type that a collection doles out when asked. That iterator type can be manipulated without knowing the kind of collection being iterated. The iterator can be as simple as a pointer or as complex as a C++ class, as long as it follows some predefined rules of behavior. This behavior varies according to the classification of iterator. For example, an iterator can be classified as <I>forward,</I> meaning that it can move only one element at a time forward through a sequence. Another iterator could be classified as <I>random access,</I> meaning that it can move many elements at a time forward or backward through a sequence. For a full description of the classes of iterators and their required behavior, please see <a href="#1">[1]</a>.</p>
<p>To obtain an iterator to an STL collection, you call a member function on the collection. The STL collections provide a set of member functions that return iterators. These member functions share common names from one collection to the next (see <a href="fig1.htm">Figure 1</a>). In MFC, on the other hand, the names of the member functions to iterate the collection change with the collection type (see <a href="fig2.htm">Figure 2</a>). One of the advantages of STL over MFC is that it has iterators that share a common interface and are defined separately from the collection classes over which they operate. You can take advantage of STL's common naming convention and behavior by writing template functions that accept iterators to the beginning and end of a sequence. If the functions are written in such a way as to not care about what collection is being iterated, they will automatically work for all existing STL collections, as well as any future collections that support STL iterators. This is how the algorithms section of STL is implemented. STL implements a set of common algorithms (searching, sorting, etc.) once in terms of STL iterators over a sequence. Any new collection written to support STL iterators automatically acquires this rich set of algorithms as supported functionality.</p>

<h4><FONT COLOR="#000080">Goals for the MFC Iterators</FONT></H4>

<p>Other than the obvious goal of making this component work, I want usage of the MFC iterators to mimic the usage of the STL iterators as much as possible. The other common goals (such as good performance) follow naturally, since the iterators can be implemented inline with very little code. In fact, a cursory analysis shows that about 10% of the code does the "real" work of iteration, and 90% of the code is dedicated to making the component look and feel more like STL.</p>
<p>An STL iterator is typically a nested type within a template class. An example of an iterator typename is:</p>

<pre>
std::list&lt;T&gt;::iterator  
</pre>

<p>Here, the <B>iterator</B> type is a nested type of the template class <B>list&lt;T&gt;</B>. The left-hand side of the iterator's typename is the name of the collection class template (<B>std::list</B> in this example &#151; <B>std</B> is the name of the namespace in which <B>list</B> is defined), followed by a template parameter enclosed in angle brackets (<B>&lt;T&gt;</B>). The right-hand side of the declaration is either <B>iterator</B>, <B>const_iterator</B>, <B>reverse_iterator</B>, or <B>const_reverse_iterator</B>. In between the left-hand side and the right-hand side of the typename is the scope resolution operator (<B>::</B>). Thus, <B>std::list&lt;int&gt;::reverse_iterator</B> is the typename of an STL iterator defined to operate over a <B>list</B> of <B>int</B>s.</p>
<p>The nested type <B>iterator</B> is used when an increment operation (any variant of <B>operator++</B>) implies forward movement through the sequence. Also, <B>iterator</B> provides access to elements of the sequence via non-const reference, which means that any element accessed via the iterator can be modified. The <B>const_iterator</B> member type works just like <B>iterator</B>, except that it provides access via a const reference. You can't modify an element directly through the use of a <B>const_iterator</B>.</p>
<p>To fulfill the goal of usability similar to the STL, I have to support all these types of iterators on the appropriate collections. If you want to have a <B>CArray</B> and be able to protect it from modification, I have to support <B>const_iterator</B> and <B>const_reverse_iterator</B>. If you also want to have a modifiable <B>CList</B>, I have to support <B>iterator</B>, <B>const_iterator</B>, <B>reverse_iterator</B>, and <B>const_reverse_iterator</B>. Complicating matters, MFC has 23 versions of their template and non-template collections, compared to three in STL. Complicating matters even further, I can't add any new member functions to the existing MFC collections. I discuss how I deal with these problems in the Implementation section of this article.</p>

<h4><FONT COLOR="#000080">Usage</FONT></H4>

<p>All the MFC iterator template classes and supporting freestanding functions are hidden within the namespace <B>mfciter</B> to avoid global namespace pollution. Every time you call an MFC iterator function or instantiate an MFC iterator class, you must either use the <B>mfciter::</B> prefix or add a using directive to your code. For the majority of collections, access to the beginning of the collection is obtained via a call to the freestanding <B>mfciter::begin</B> function, with the collection object passed as the lone parameter. In corresponding fashion you can get an iterator to the end of a collection via a call to <B>mfciter::end</B> (also passing the collection as a parameter). This interface enables access to the beginning and end of a sequence in the style of STL.</p>
<p>The iterator type returned is a member typedef of a struct (possibly a template struct, depending on the collection). The name of the struct identifies what kind of collection is being iterated. It also serves as a way to simulate the iterator declaration style of STL without adding member types to the MFC collections classes (more on this in the Implementation section). The typedef member of the struct that is returned is either <B>iterator</B> or <B>const_iterator</B>, whichever is more appropriate (according to the desired const-ness of the collection object).</p>
<p>There are some simple rules for figuring out the name of the struct to use for the collection being iterated. For example, if you're iterating a <B>CStringList</B>, the struct returned is of type <B>mfciter::slst</B> (<B>slst="String LiST"</B>). If you're iterating a <B>CArray&lt;int, int&gt;</B>, the struct returned is of type <B>mfciter::carr&lt;int&gt;</B> (<B>carr="CARRay"</B>). If you're iterating a <B>CTypedPtrMap&lt;CMapPtrToPtr&gt;, void *, foo *&gt;</B>, the struct returned is of type <B>mfciter::tppmap&lt;void *, foo *&gt;</B> (<B>tppmap="Typed Ptr to Ptr MAP"</B>). The full declarations of the above examples are shown in <a href="fig3.htm">Figure 3</a>. A table of the various collections and the structs that they use are shown in <a href="tab1.htm">Table 1</a>.</p>
<p>For reasons specified in the Implementation section, the templates <B>CTypedPtrArray</B>, <B>CTypedPtrList</B>, and <B>CTypedPtrMap</B> require a different freestanding accessor function call. It can't be just <B>begin</B> or <B>end</B>. The accessor function for a given <B>CTypedPtrX</B> instance requires a prefix, which is formed by the first few letters of the name of the returned struct container. For example, for a <B>CTypedPtrList&lt;CPtrList, int *&gt;</B> the returned struct container would be (from <a href="tab1.htm">Table 1</a>) a <B>tplst&lt;int *&gt;</B>. Therefore, the accessor function would be <B>mfciter::tp_begin</B>. <a href="tab2.htm">Table 2</a> shows the accessor functions for the various <B>CTypedPtrX</B> template collections.</p>
<p>After you have obtained the appropriate iterator type, you can manipulate it using some very familiar operators. Iterators are a generalization of pointers, so you can use the same operations on them that you would use on a pointer, with restrictions depending upon the iterator's classification. The map iterators are classified as forward iterators, which means that you can advance through their sequence using the <B>++</B> operator, copy their value (but not the element they point to) using copy construction or the <B>=</B> operator, compare them (but not the elements they point to) using <B>==</B> or <B>!=</B>, and access the value that they represent using <B>*</B> (the indirection operator, not the multiplication operator) or <B>-&gt;</B>. When accessing the element represented by a map iterator, you must specify whether you want the key field or the value field of the element. The key field is accessed by specifying the <B>first</B> field of the element accessed via the iterator <B>*</B> or <B>-&gt;</B> operator. The value field is accessed by specifying the <B>second</B> field of the element. Note also that although the map iterator provides non-const access to the map's data, you can modify only the value field (<B>second</B>) of any element, not the key field. For examples of valid operations using the map forward iterator, see <a href="fig4.htm">Figure 4</a>.</p>
<p>The list iterators are classified as bidirectional iterators, which means that in addition to the previously mentioned forward iterator operations, you can use some new operators to move backwards as well. You can move backwards only one position at a time with a bidirectional iterator, using the <B>--</B> operator. Since a list element has no key-value fields, you can access an element simply through either the <B>*</B> or <B>-&gt;</B> operator, just as you would with a pointer. For examples of valid operations using the list bidirectional iterator, see <a href="fig5.htm">Figure 5</a>.</p>
<p>The array iterator is the most powerful of the three iterators. It is classified as a random-access iterator, which means that it acts just like a memory pointer. With a random access iterator, you can jump through an array as many positions at a time as you wish, using <B>operator+</B>, <B>operator-</B>, <B>operator+=</B>, <B>operator-=</B>, <B>operator--</B>, or <B>operator++</B>. In addition to this greater freedom of movement, more functions are available for comparing positions of iterators. Iterators can be compared by their relative position on a sequence using <B>operator&lt;</B>, <B>operator&gt;</B>, <B>operator&lt;=</B>, and <B>operator&gt;=</B>, as well as the basic <B>==</B> and <B>!=</B> operators. You can even calculate the integer distance between two random-access iterators by subtracting them. For an example of operations using the array random-access iterator, see <a href="fig6.htm">Figure 6</a>.</p>
<p>In addition to the forward and bidirectional iterators, there are iterators that explicitly support reverse iteration through a sequence. These are named either <B>reverse_iterator</B> or <B>const_reverse_iterator</B>, and are accessed by calling the freestanding functions <B>mfciter::rbegin</B> and <B>mfciter::rend</B> in the same manner as <B>mfciter::begin</B> and <B>mfciter::end</B> are called to obtain forward iterators. There are no reverse iterators defined for a map, but there are for arrays and lists. The reverse iterators fit the same classification scheme as the regular iterators through a sequence, so a list's reverse iterator is bidirectional, and an array's reverse iterator is random access.</p>
<p>Once you are familiar with declaring your own iterators for walking through a sequence, the true power of the component is available to you. The algorithms section of STL, as part of the Standard C++ library, is now applicable to any MFC collection. Sorting, searching, and copying elements is as simple as calling a freestanding function from the STL <B>&lt;algorithm&gt;</B> header file. Before, if you wanted to sort an MFC array, even a simple array of atomic elements, you'd have to use a sorting function that supported hand-coded callback functions to pluck out individual elements from a sequence and compare them. Now, all that is necessary is to ensure that <B>operator&lt;</B> is a callable operator on the contained elements, and then call <B>std::sort</B>, passing the beginning and end of the sequence to be sorted. <a href="fig7.htm">Figure 7</a> shows a comparison of sorting methods on an MFC array of unsigned integers, using the old method and the new iterator-based method.</p>
<p>Another advantage of using iterators when calling these algorithms is the ability to perform the algorithm on a subsequence. Suppose you want to use the function <B>std::find</B> to find a match to an element in your container, but you want to consider just the first five elements. Instead of passing <B>mfciter::begin()</B> and <B>mfciter::end()</B> to <B>std::find</B>, which you would do to search the entire sequence, you pass <B>mfciter::begin()</B> and <B>mfciter::begin()+5</B>.</p>
<p>I try to prevent invalid operations on iterators by making those operations result in either compile-time errors or run-time errors. I'd rather generate a compile-time error than a run-time error, but that is not always possible. Some invalid usages will result in assertion failures inside the template code. The compile-time errors that result from invalid operations may produce some very long and cryptic error messages, which can be troublesome if you are not used to using template classes. My only advice for dealing with iterator compilation errors is to read through the entire text of the error message and try to block out unnecessarily long template type names. I've tried to add enough comments around assertion failures to make the cause of the error easy to find and fix.</p>

<h4><FONT COLOR="#000080">Implementation</FONT></H4>
<p>There are two major forces to contend with in implementing the MFC collection iterators. First, as I mentioned in the Goals section, I want the declarations of these iterators to mimic the declaration style of the STL iterators as much as possible. Second, each iterator needs to know the collection class it is operating on and the value type that the collection class contains. An STL iterator knows the collection class it operates on because it is a member type of that class. It knows the value type because it can "see" the class's template parameters.</p>
<p>Communicating the type of the MFC collection class to the iterator proved to be the biggest hurdle. Following are a few approaches I rejected:</p>

<UL><LI>Make the iterator class a member of the MFC collection class, in the manner of STL. I rejected this because it would have meant modifying the MFC code.</LI>
<LI>Derive new classes from the MFC collection classes and add iterator members to the derived classes. This would have meant using inheritance to model a questionable "Is-A" relationship between the derived and base classes.</LI>
<LI>Create three iterator templates, one for arrays, one for lists, one for maps, parameterized only by MFC collection type. Unfortunately, the iterator would have no way to infer the value type.</LI>
<LI>Create an iterator template that takes both the MFC collection class and value type as template parameters. This might have worked, but would have required an excessive amount of typing to declare some kinds of iterators (e.g., for a <B>CTypedPtrMap</B> of <B>CString</B> objects to <B>CWindow</B> pointers).</LI></UL>

<p>The approach I settled on is to create three template structs, one for each of the MFC collection class types. These template structs are not designed to be instantiated. Rather, they serve as a sort of a parameterized namespace that defines all of the generic iterators used for MFC arrays (<B>struct base_array</B>), lists (<B>struct base_list</B>) and maps (<B>struct base_map</B>). This approach takes advantage of the common member function names found in MFC collection types. The template parameters passed to these structs are both the collection type and the value type, fulfilling one of my initial requirements. As I said, these template structs are not designed to be instantiated. What's more, their design assumes they will never be named in user code.</p>
<p>To declare an iterator, users do not name the base template struct directly as the left-hand side of the scope resolution operator. Instead, new non-instantiatable structs are derived from the base template struct for the 23 implementations of the MFC collection classes. The name of each of the derived structs is the mnemonic created from the collection class found in <a href="tab1.htm">Table 1</a>. Each derivation specializes the template parameters passed to the base template struct. If a derivation represents a non-template collection class (like <B>CStringList</B>), the derivation is a non-template struct. Otherwise, the derivation must be a template struct, to allow the user to plug in the proper type parameters. Along with the derivation of the new structs, the pairs of freestanding <B>begin/end</B> functions (and <B>rbegin/rend</B>, where applicable) are defined. I feel this is the best way of balancing the forces mentioned at the beginning of this section. I fulfill the requirement of passing down collection type and value type while producing a terse iterator declaration style like that of STL. (Collection type is implied based on the mnemonic name of struct used, and value type is either implied or a template parameter.)</p>
<p>The helper templates <B>CTypedPtrArray</B>, <B>CTypedPtrList</B>, and <B>CTypedPtrMap</B> present a special problem. Each template class accepts a single base collection class from a finite set of classes as a template parameter. So, if you have a <B>CTypedPtrArray</B> of <B>int *</B>, you would declare an instance of that class as:</p>

<pre>
CTypedPtrArray&lt;CPtrArray, int*&gt;
</pre>

<p>If I create a single template struct derived from <B>base_array</B> that contains iterators on all <B>CTypedPtrArray</B> objects, I will need to pass template parameters that specify the base collection class type as well as the element type, kind of like this:</p>

<pre>
mfciter::tpp&lt;CPtrArray, int*&gt;::
    iterator
</pre>

<p>Because up to now I've been able to exclude the collection class in the template parameters of the iterator declaration, this style of declaration is ugly and unacceptable.</p>
<p>To get around this problem, I provide n versions of the template struct for each <B>CTypedPtrX</B> template, where n is the number of acceptable base collection classes that can be the first template parameter of the <B>CTypedPtr</B>. The name of each of the n versions of the struct starts with the letter <B>t</B>, serving as the reminder that it is a typed pointer. For example, if you have a <B>CTypedPtrArray</B> on a <B>CObArray</B> that contains <B>CView</B> pointers, the name of the struct is <B>toarr&lt;CView*&gt;</B>. For a complete listing of all structs for <B>CTypedPtrX</B>, see <a href="tab1.htm">Table 1</a>.</p>
<p>Complicating matters further, my scheme of overloading the freestanding accessor functions <B>mfciter::begin</B>, <B>mfciter::end</B>, <B>mfciter::rbegin</B>, and <B>mfciter::rend</B> for <B>CTypedPtrX</B> templates causes internal compiler errors whenever those functions are called. I believe it should be possible to create overloaded versions of those functions in C++, but that's not a valid argument when you've got a compiler crashing on you. My solution is to create special versions of the freestanding accessor functions that have unique names (which can be seen in <a href="tab2.htm">Table 2</a>). Avoiding multiple function overloads with partial template arguments seems to make the compiler happy. I still feel that this represents a bug in Microsoft's compiler, and will explore using common accessor function names when future compilier versions are released.</p>
<p>I've tried to keep the implementations between the three styles of iterators as common as possible, which does lead to some implementation concessions. For example, Visual C++ 6.0 does not yet support static const typed member constants. Member constants must be simulated with enumerations. I would like to use a special enumeration value to represent "end of iteration" with all of the iterators (called <B>end_of_sequence</B>). The obvious choice for array (-1) works fine as an enumeration value, but the obvious choice for lists and maps (<B>NULL</B>) will not work without typecasting, because enumeration values are represented as numeric, not pointer, constants. Eventually, when Visual C++ supports static const member constants, I'll be able to make "end_of_sequence" be a const member of the appropriate type and avoid all this typecasting.</p>
<p>By definition, the <B>iterator</B> and <B>reverse_iterator</B> member types provide non-const access to a sequence. They must allow modification of the values in the sequence that they represent. With the array iterators, implementing this is trivial because MFC arrays return members by reference. Lists and maps pose a bit more of a problem because they require separate functions to be called to access members vs. modify members. To allow modification, I've created a helper template for both lists and maps called <B>_modifiable_value</B>. The <B>_modifiable_value</B> template looks like a value unless you try to assign to it. It forwards that assignment down to the appropriate assignment function of the associated collection class.</p>
<p>Other than these workarounds, the code for these classes is very straightforward. Map iterators go forward through their maps using the member function <B>GetNextAssoc</B>. List iterators move through their list using the member functions <B>GetNext</B> and <B>GetPrev</B>. As I said before, about 10% of this code actually works on getting iteration done. That 10% is not very complex, especially if you are even slightly familiar with MFC collection classes.</p>

<h4><FONT COLOR="#000080">Conclusion</FONT></H4>

<p>This set of iterators on MFC collection classes should provide both a rich set of new functionality to MFC collections and a good bridge to the advanced collection concepts of STL. Many common operations that were difficult to implement directly on MFC collections, such as sorting, should now have trivial implementations and be much less error prone.</p>

<h4><FONT COLOR="#000080">Acknowledgements</FONT></H4>

<p>Thanks to John Harding and Tonya Kostrzewa for their assistance and suggestions.</p>

<h4><FONT COLOR="#000080">References</FONT></H4>

<p><a name="1"></a>[1]  Alexander Stepanov, et al. The Standard Template Library. Made available by Hewlett Packard. <B>http://www.hpl.hp.com/techreports/95/HPL-95-11.html</B></p>
<p><a name="2"></a>[2]  Erich Gamma, et al. <I>Design Patterns</I> (Addison-Wesley, 1995).</p>

<p><i><B>Kevin Kostrzewa</B> works as a computer programmer in Ann Arbor, Michigan. He has a Bachelor's degree in Computer Science from Michigan State University. His programming interests include design patterns and application frameworks written in C++. He can be reached at <B>tkkost@newsguy.com</B>.</i></p>

<h4><a href="../../../source/1999/sep99/kostrzew.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY>
</HTML>
