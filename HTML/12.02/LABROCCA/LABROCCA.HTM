

<HTML>
<HEAD>

<TITLE>February 1994/A Self-Extracting Archive for MS-DOS</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">A Self-Extracting Archive for MS-DOS<A name="005F_0022"><A name="005F_0022"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="005F_0000"><A name="005F_0000">P.J. LaBrocca</font></h3><hr><blockquote><P>
<P><i><A name="005F_0000"><A name="005F_0000">Pat LaBrocca is the author of ReCalc(TM), a set of rational expression calculators that never give answers (well, almost never), and run identically on PCs, Macintoshes and Apples. He has a BS and MA in Chemistry and teaches computer science at Peter Rouget Middle School 88 in Brooklyn, NY. You can contact him at plabrocc@nycenet.edu.</i></P><P>
<h4><FONT COLOR="#000080"><A name="005F_0023">Introduction<A name="005F_0023"></FONT></h4></P>
An archive is a file that contains several other files. A self-extracting archive (SEA) is a file that doesn't need the original archiving software to release its contents. In this article I present pair of utilities for creating SEAs under MS-DOS. The utilities provide a somewhat barebones implementation in that they don't provide features common to other archives, such as compression, or preservation of subdirectories. Once you understand how these utilities work, you may want to extend them. I provide some references at the end of this article for those wishing to extend the utilities.<P>
<h4><FONT COLOR="#000080"><A name="005F_0024">The SEA Structure<A name="005F_0024"></FONT></h4></P>
My self extracting archive consists of three parts. The first part is the set of files that have been archived, which I refer to as the component files. The second part, the extraction module, is the code embedded in the archive that reads the component files from the archive and writes them to new output files. Finally, a system of headers embedded in the archive tell the extraction module the lengths and names of the component files. The extraction module uses the information in the prefix headers to recreate the files. To avoid confusing C's <I>include</I> header files and MS-DOS's program file headers, I refer to my headers as prefix headers, since they prefix each component file. Also, when I refer to the "archiver" I am speaking of the utility that <I>builds</I> the archive. When I refer to the "SEA" I am speaking of the archive itself.<P>
The disk layout of a SEA containing <I>n</I> component files is shown in <A href="fig1.htm">Figure 1</a>.
<P>
A terminating suffix header follows the last component file. The suffix header indicates to the extraction module that there are no more component files.<P>
<h4><FONT COLOR="#000080"><A name="005F_0025">Overview of SEA Process<A name="005F_0025"></FONT></h4></P>
The archiver starts by copying the extraction module to the archive. Then for each component file, the archiver constructs a prefix header and writes the header and the associated file to the archive. When the archiver runs out of files to archive, it writes the suffix header.<P>
The SEA appears to MS-DOS as an .EXE file and executes like any other .EXE file. The SEA is actually an .EXE file with extra information appended to the end. The appended information does not interfere with the SEA's execution. (See the sidebar, <a href="sidebar2.htm">"Piggybacking an .EXE File."</a>)<P>
When you run the SEA, the extraction module reads the prefix headers and recreates each of the files in turn. This process continues until the SEA reads the suffix header, at which time the extraction is complete.<P>
<h4><FONT COLOR="#000080"><A name="005F_0026">The Archiver &#151; Detailed Operation<A name="005F_0026"></FONT></h4></P>
The source code for the archiver is in <I>arch.c</I> (<A href="list2.htm">Listing 2</a>)
. The extraction module and the archiver expect the same prefix headers, so I put the prefix header structure in a separate include file (see <A href="list1.htm">Listing 1</a>)
. After verifying that the user has provided a list of files to archive, the archiver begins opening files. First, <I>arch.exe</I> tries to open the extraction module, <I>extr.exe</I>, to prepare to copy it to the archive. If <I>arch.exe</I> can't find the extraction module, <I>arch.exe</I> displays an error message and halts. The default name for the SEA to be created is <I>out.exe. arch.exe</I> tries to open the output file with this name, this time for writing, and issues a message if the open fails. <I>Arch.exe</I> opens <I>out.exe</I> as a binary file to ensure that other functions will not perform unwanted conversions on the file. For example, when <I>fopen</I> opens a file in text mode, subsequent reads strip out extra carriage returns. Since archive files need to contain any kind of file, <I>fopen</I> must treat all files as binary files, thus guaranteeing the integrity of each byte in the file.<P>
If all goes well, <I>arch.exe</I> copies the extraction module to <I>out.exe</I>, and then closes it.<P>
Next, <I>arch.exe</I> attempts to open a file from the command line list. If <I>arch.exe</I> can't open the file, it displays a message indicating the name of the file, increments <I>count</I>, and forces a jump to the top of the loop. (In this case, the failure of a file to open may not indicate a problem. Wild-card expansion in the command line sometimes generates the name of a subdirectory, which, of course, can't be opened.)<P>
Next, <I>arch.exe</I> calls <I>fseek</I> and <I>ftell </I>to determine the size of the opened file. The call<P>
<pre>fseek( input, 0, SEEK_END );</pre>
moves the file position indicator (an index into the file maintained by the <I>FILE</I> type) to one byte after the last byte in the file. A call to <I>ftell</I> returns the current file position. The combination<P>
<pre>fseek( input, 0, SEEK_END );
header.filesize = ftell( input );</pre>
stores the file's size, in bytes, in <I>header.filesize</I>. Another call to fseek, this time with argument <I>SEEK_SET</I>,<P>
<pre>fseek( input, 0, SEEK_SET );</pre>
repositions <I>input</I>''s file position indicator to the beginning of the file.<P>
Depending on how it is built, <I>arch.exe</I> may provide wildcard expansion of command line arguments. Most compilers provide an object module which can be linked into the program to provide this feature (see the sidebar <a href="sidebar1.htm">"Wildcard Expansion"</a>). Therefore, after <I>arch.exe</I> reads the command line, the command-line arguments may be in the form of file names with or without extensions, with partial paths or full paths. The prefix header structure expects at most a file name plus extension. <I>arch.exe</I> has to process the command line arguments into that form. Some C compilers provide a function that does just that job. Unfortunately, it's not a standard function. For example, Microsoft C provides <I>_splitpath</I>, which breaks a path into its component parts and stores them in strings. Zortech C++ 3.0 supplies the function <I>filespecname</I>, which returns a pointer to a string containing the file name plus extension. Instead of using a compiler-specific function, I created the function <I>filename</I> in <A href="list2.htm">Listing 2</a>.
 <I>filename</I> is a stripped down version of <I>_splitpath</I> that extracts the file name plus extension from a path. <I>Arch.exe</I> passes <I>filename</I> the path and a character buffer. <I>filename</I> scans the path in reverse order, by decrementing a pointer, and stops when it has a full file name. The call to <I>filename</I> completes the prefix header data structure.<P>
<I>Arch.axe</I> calls <I>fwrite</I> to write the prefix header to <I>out.exe</I>. After writing, <I>fwrite</I> leaves the file position indicator just beyond the prefix header. After copying the current file to <I>out.exe</I>, <I>Arch.exe</I> then closes <I>input</I> in preparation for the next file and increments <I>count</I>.<P>
When there are no more files to be archived, <I>arch.exe</I> writes one final header, with header.filesize set to -1L, to the output file. This suffix header serves as the end-of-archive mark for the extraction module and completes the SEA.<P>
<h4><FONT COLOR="#000080"><A name="005F_0027">Extraction Module &#151; Detailed Operation<A name="005F_0027"></FONT></h4></P>
<A href="list3.htm">Listing 3</a>
contains the source code for the extraction module, <I>extr.exe. extr.exe</I> reads in prefix headers, and uses the information thus gleaned to recreate files.<P>
<h4><FONT COLOR="#000080"><A name="005F_0028">The Magic Number<A name="005F_0028"></FONT></h4></P>
The extractor must know where the first prefix header starts, which means the extractor must know its own length. To get the size information into the extraction module, I needed to know the size of <I>extr.exe</I> before I compiled it. So I declared a <I>long int, MagicNumber</I>, and initialized it with a dummy value. Then I compiled and linked <I>extr.c the</I> usual way. I ran MS-DOS's DIR command to obtain <I>extr.exe</I>'s file size and used this value to initialize <I>MagicNumber</I>. I had to recompile, of course, since I had edited the source code, but the size of <I>extr.exe</I> doesn't change. Now <I>MagicNumber</I> tells the extraction module how big it is. (I use a batch file to automate keeping the value of <I>MagicNumber</I> synchronized with the size of <I>extr.exe.</I> See "Miscellaneous Implementation Notes" for some details.)<P>
<h4><FONT COLOR="#000080"><A name="005F_0029">Command Line Processing<A name="005F_0029"></FONT></h4></P>
When the extraction module begins execution just inside functin <I>main</I>) it first checks for arguments on the command line. If the user types in an unknown option at the command line, the SEA displays a usage message and exits. When <I>argc</I> equals <I>1</I> the default action, extraction, is performed. The only option <I>extr.exe</I> recognizes is <I>-l(ist)</I>, which causes a list of archived files and their sizes to be sent to the standard output.<P>
<I>argv[0] </I>contains the string used to invoke the extraction program, so the function call <I>fopen(argv[0]</I>, <I>"rb"</I>) opens the file that is currently executing. The program can open its own .EXE file from disk because the executing image is just a copy of the disk file. Using this technique to open the SEA allows you to rename <I>out.exe</I> to whatever you want.<P>
<h4><FONT COLOR="#000080"><A name="005F_002A">Navigating the File<A name="005F_002A"></FONT></h4></P>
The program calls<I> fseek</I> with arguments <I>SEEK_SET</I> and <I>MagicNumber</I> to move the file position indicator just past the extraction module, to the beginning of the first prefix header. (Remember to adjust <I>MagicNumber</I> if you edit <I>extr.c</I>!)<P>
In the while loop, <I>fread</I> reads in a prefix header. If it's the suffix header, there are no more files to extract, so the program exits the loop and closes <I>input</I>. Otherwise, the program attempts to create a file in the current directory using the string from the prefix header, <I>header.filename</I>. If a file with the same name already exists, the program overwrites it. The messages displayed along the way indicate progress. When the program has copied <I>header.filesize</I> bytes to the new file, it closes the new file, increments <I>count</I>, and starts the next iteration.<P>
The procedure for listing the component files is the same, except instead of copying a file, the program skips the file by calling<P>
<pre>fseek( input, header.filesize, SEEK_CUR );</pre>
which moves the file position indicator <I>header.filesize</I> bytes forward from its current position, to the beginning of the next prefix header.<P>
<h4><FONT COLOR="#000080"><A name="005F_002B">Miscellaneous Implementation Notes<A name="005F_002B"></FONT></h4></P>
The prefix header is a structure declared in <A href="list1.htm">Listing 1</a>,
 <I>sea.h.</I> The first member, <I>filename</I>, holds the file's name in an array of characters, as a C-style string. The array only needs to be thirteen bytes long in this implementation. If you decide to store more than a base name, a dot, and an extension, you adjust the array's size accordingly. A <I>long int, filesize</I>, contains the file's length.<P>
If you change the size of <I>extr.exe</I> you must recompile the extraction module. I run a little batch file, <I>REMAKE.BAT</I> (<A href="list5.htm">Listing 5</a>)
, from the makefile each time <I>extr.exe</I> gets rebuilt, which prints a message to the screen indicating if <I>MagicNumber</I> equals the size of <I>extr.exe</I>. The batch file creates a temporary file composed of <I>extr.c</I> and a one-line directory listing. An awk program (<A href="list6.htm">Listing 6</a>)
, called from the batch file, digs out the file size from the directory line and the value used to intialize <I>MagicNumber</I>, compares them, and prints a one line report to the screen. (To keep the awk program simple, I put a space between <I>MagicNumber's</I> initializer and the semicolon.) I use MKS Awk, but other versions should work, too.<P>
To use the archiver, copy <I>arch.exe</I> and <I>extr.exe</I> to a separate subdirectory on your system. <I>arch.exe</I> expects to find <I>extr.exe</I> in the same subdirectory. The files to be archived can exist in any subdirectory and on other drives. However, the SEA as currently implemented does not store subdirectory or drive information. Therefore, when you run the SEA, it will extract all files to the same subdirectory. This can be a problem if the archive contains duplicate file names from different subdirectories. The extractor will overwrite files with duplicate names. If you compiled with Microsoft C and linked with <I>setargv.obj as</I> described in the sidebar <a href="sidebar1.htm">"Wildcard Expansion,"</a> you can use the usual MS-DOS wildcards, ? and *. Other compilers may or may not offer wildcard expansion as an option. The archiver produces a SEA named <I>out.exe</I> in the current directory. You can rename it to anything you want.<P>
To add compression to the archiver see "A Simple Data-Compression Technique" by Ed Ross in the October 1992 issue of <I>The C Users Journal.</I> He describes a method of run length encoding. The source code is available on the <I>CUJ</I> code disk, or you can download it from one of the online sources listed at the end of the table of contents.<P>
For an extensive introduction to methods of data compression in C, see <I>The Data Compression Book</I> by Mark Nelson, from M &amp; T Books. Nelson presents explanations and detailed working versions of popular varieties of data compression. The final chapter contains a complete compression/archiving package, CARMAN.<P>
<h4><FONT COLOR="#000080"><A name="005F_002C">Conclusion<A name="005F_002C"></FONT></h4></P>
The SEA and archiver I have described are very simple, but useful. Because of the SEA's simplicity, programmers should find it easy to modify for their own use. The SEA's straightforward structure also makes it useful as a learning tool.<P>

<h4><a href="../../../source/1994/feb94/labrocca.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
