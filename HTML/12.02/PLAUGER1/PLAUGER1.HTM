

<HTML>
<HEAD>

<TITLE>February 1994/C++ Memory Management</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">C++ Memory Management<A name="0063_0024"><A name="0063_0024"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0063_0000"><A name="0063_0000">reviewed by P.J. Plauger</font></h3><hr><blockquote><P>
<P><i><A name="0063_0000"><A name="0063_0000">P.J. Plauger is senior editor of The C Users Journal. He is convenor of the ISO C standards committee, WG14, and active on the C++ committee, WG21. His latest books are The Standard C Library, and Programming on Purpose (three volumes), all published by Prentice-Hall. You can reach him at pjp@plauger.com.</i></P><P>
The authors begin by admitting that memory management on the 80X86 family of microprocessors is byzantine. I'd call that an understatement. I once estimated that hundreds of programmer years were expended simply because someone at IBM decided in the early 1960s that System 360 could do quite nicely with 12-bit displacements in essentially all of its machine instructions. At the time, I never thought that a future decision would ever be as costly. IBM, Intel, and others (acting separately and in concert) have proved me wrong with the IBM PC memory layout and access machinery.<P>
I won't bore you with a recitation of all those definitions. You know: conventional memory, upper memory, high memory, expanded memory, extended memory, and so forth. Chances are you care intimately about this stuff and know far more than I. Or you neither know nor care how all that PC software manages to find enough storage to get the job done. But there is also a real chance that you fall somewhere in the middle &#151; you'd love to write large programs that run under MS-DOS, but blanch at the thought of mastering all that memory-management nonsense.<P>
If you fall in that third category, or even the first, then this is a book you should take a serious look at. It is written in the tradition of the best articles in <I>The C Users Journal</I>. You will find oodles of code that does all the various bits of magic needed to do battle with EMS, XMS, and even swapping memory to disk. The presentation starts with the (reasonably) simple and progresses in stages to a comprehensive solution that hides most of the uglies behind a clean interface. Along the way, the writing is generally clear and to the point.<P>
You might even buy the book just for the code disk in the back. The authors assert that it works with both Borland C++ v3.1 and Microsoft C++ v7.0. I didn't try it out, mostly because I cling desperately to my ignorance of PC memory management. But I have to say that the code listings and the presentation certainly <I>look</I> credible. After reading thousands of manuscripts, I like to think that I've developed an eye for this sort of thing.<P>
Dorfman and Neuberger give you working C++ code to interface to EMS and XMS. That's laudable in its own right. But it also amounts to rather thin icing over a lumpy underlying cake. Most important, they end with a virtual memory manager (VMM) that manages whatever kind of memory it can get its hands on. And that can include what they call "fast" memory &#151; the conventional or upper memory that reads and writes as fast as the rest of the stuff in your program. Their VMM interface is simpler than any of its building blocks. Moreover, the underlying implementation is willing to adapt over a broad range of possibilities.<P>
I can only carp about a couple of small items, after a fairly cursory review of this book. One is that the authors tend to be a bit cute in their writing. They should think twice about quoting words and phrases. Almost every use should be replaced by a font shift, a less clichd phrase, or straight text spoken without seeming apology. But that is a minor blemish on otherwise clear writting.<P>
The other carp is the choice of C++ as a presentation language. I found very few places where they arguably took advantage of the greater power of C++ over C. They might have a more usable product written in C. On the other hand, they could have made better use of the information hiding made possible by C++. But that too is a minor issue, given the near universal packaging of C and C++ compilers these days, particularly under MS-DOS.<P>
In summary, this book looks to be a valuable asset if you want to learn more about the various ways to stretch memory under MS-DOS. It is equally useful is you <I>don't</I> want to know any more than absolutely necessary, but still need to get the job done. That makes it a double winner, in my book.<P>
<B>Title:</B> <I>C++ Memory Management</I><br>
<B>Author:</B> Len Dorfman and Marc J. Neuberger<br>
<B>Publisher:</B> Windcrest/McGraw-Hill, New York, 1993<br>
<B>Price:</B> $32.95<br>
<B>ISBN:</B> 0-8306-4288-9<br>
<B>Pages:</B> 293<P>
</BLOCKQUOTE>
</BODY>
</HTML>
