

<HTML>
<HEAD>

<TITLE>February 1994/Standard C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Standard C<A name="0065_0026"><A name="0065_0026"></font></h2><P>
<h3 align="center"><A name="0065_0000"><A name="0065_0000">The Header &lt;exception&gt;</h3><P>
<h3 align="center"><font color="#800000">P. J. Plauger</font></h3><hr><blockquote><P>
<P><i><A name="0065_0000"><A name="0065_0000">P.J. Plauger is senior editor of The C Users Journal. He is convenor of the ISO C standards committee, WG14, and active on the C++ committee, WG21. His latest books are The Standard C Library, and Programming on Purpose (three volumes), all published by Prentice-Hall. You can reach him at pjp@plauger.com.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0065_0027">Introduction<A name="0065_0027"></FONT></h4></P>
This is the fourth installment in a series on the draft standard being developed for the C++ library. (See "Standard C: Developing the Standard C++ Library," <I>CUJ</I>, October 1993, "Standard C: C++ Library Ground Rules," <I>CUJ,</I> November 1993, and "Standard C: The C Library in C++," <I>CUJ</I>, December 1993.) I am slowly working my way through the entire library, much as I did with the Standard C library in years past. The major difference is that this journey travels far more uncharted territory. So I endeavor to provide consistent landmarks along the way. For example, here, once again, is the overall structure of the draft C++ library standard:<P>
(0)     introduction, the ground rules for implementing and using the Standard C++ library<P>
(1)     the Standard C library, as amended to meet the special requirements of a C++ environment<P>
(2)     language support, those functions called implicitly by expressions or statements you write in a C++ program<P>
(3)     iostreams, the extensive collection of classes and functions that provide strongly typed I/O<P>
(4)     support classes, classes like <I>string </I>and <I>complex</I> that pop up in some form in every library shipped with a C++ compiler<P>
Thus far I have described (0) introduction and (1) the Standard C library. I have to confess, however, that I'm aiming at a moving target. Both those items have changed in an important regard, thanks to the introduction of namespaces into C++. Namespaces went into the language at the March 1993 meeting in Munich. The library adopted a style for using namespaces at the July 1993 meeting in San Jose. But I won't confuse you by rehashing those topics just to make them current. That would be an endless battle, these days. You can expect changes in C++ every four months for the next year or two. We can only hope that the changes will grow ever smaller as the draft C++ standard converges to final form.<P>
More important, namespaces are so new that no commercial compiler I know of supports them yet. Nor are many likely to do so in the near future. And even when they're more widely available, you can bet that backward compatibility will remain an issue. I expect that namespaces will remain under the hood for some time to come. In the medium to long term, they are most likely to be of interest only to the more sophisticated C++ programmers.<P>
So I will begin, as I intended, with a new topic this month, (2) language support. It contains no small amount of news in the area of exceptions, which <I>have</I> been implemented by several C++ compilers. And it deals with issues of much wider interest, such as the global <I>operator new</I> and <I>operator delete</I>, plus a few newer odds and ends. For this installment, I focus only on the library support for exception handling.<P>
This section of the draft C++ library standard is called language support because it, more than any other part of the C++ library, is on rather intimate terms with the language proper. A compiler will generate code that uses the classes declared in this section, or that implicitly calls functions defined here. In the case of exception classes, you will also find quite a few fellow travelers, not directly connected to language support. But the tie is there, nevertheless.<P>
<h4><FONT COLOR="#000080"><A name="0065_0028">Exceptions<A name="0065_0028"></FONT></h4></P>
Exceptions represent a significant departure in C++ from past programming practice in C. Much of what you write in C++ translates one for one to very similar C code. The rest may get longer winded, and a bit harder to read, but it's still conventional C. Exception handling, however, changes the underlying model of how functions get called, automatic storage gets allocated and freed, and control gets passed back to the calling functions.<P>
A compiler <I>can</I> generate reasonably portable C code to handle exceptions, but that code can have serious performance problems &#151; even for programs that don't use exceptions. The very <I>possibility</I> that an exception can occur in a called function changes how you generate code for the caller. Alternatively, a compiler can generate code directly that can't quite be expressed in C &#151; and face a different set of problems. It may be hard to mix such C++ code with that generated from C or another programming language. Perhaps you can see now why C++ vendors have generally been slow to add this important new feature to the language.<P>
What makes exception handling important is that it stylizes a common operation expressible in C only in a rather dirty fashion. You can think of exception handling, in fact, as a disciplined use of the notorious functions <I>setjmp</I> and <I>longjmp</I>, declared in <I>&lt;setjmp.h&gt;.</I> (Strictly speaking, <I>setjmp</I> is a macro, but let's not pursue that distraction for now.)<P>
In a C program, you call <I>setjmp</I> at a point to which you expect to "roll back." The function memorizes enough context to later reestablish the roll-back point, then returns the value zero. A later call to <I>longjmp</I> can occur anywhere within the same function or a function called from that function, however deep in the call stack. By unspecified magic, the call stack gets rolled back and control returns once again from <I>setjmp</I>. The only difference is, this time you can tell from the nonzero return value that a <I>longjmp</I> call initiated the return.<P>
That all adds up to a clever bit of machinery, used to pull off all sorts of error recovery logic over the past couple of decades. The only trouble is, it's too clever by half. Many implementations have trouble determining how to roll back all the automatic storage properly. The C Standard is obligingly vague on the subject, making life easier on the implementors at the expense of being harder on those wishing to write portable and robust code. Nobody pretends that <I>&lt;setjmp.h&gt;</I> is an elegant piece of design.<P>
In C++, matters are much worse. That language prides itself on cradle-to-grave control of objects, particularly nontrivial ones. You are assured that every object gets constructed exactly once, before anybody can peek at its stored values. And you are promised with equal fervor that every object gets destroyed exactly once. Thus, you can allocate and free auxiliary storage for an object with a discipline that ensures no files are left open, or no memory gets lost, in the hurly burly of execution.<P>
<I>longjmp</I> sabotages the best efforts of C++ compilers to maintain this discipline. In rolling back the call stack, the older C function cheerfully bypasses all those implicit calls to destructors strewn about by the C++ compiler. Promises get broken, files remain open, storage on the heap gets lost. The draft C++ standard leaves <I>&lt;setjmp.h&gt;</I> in the library for upward compatibility. But it discourages the use of these heavy handed functions in the neighborhood of "real" C++ code with nontrivial destructors.<P>
Enter exceptions. In modern C++, you don't report a nasty error by calling <I>longjmp</I> to roll back to a point established by <I>setjmp</I>. Instead, you evaluate a <I>throw</I> expression to roll back to a <I>catch</I> clause. The <I>throw</I> expression names an object whose type matches that expected by the <I>catch</I> clause. You can even examine the object to get a hint about what caused the exception. It's kind of like calling a function with a single argument, only you're not always sure where the function actually resides. And the function is further <I>up</I> the call stack instead of one level further down.<P>
Most important of all, none of those destructors get skipped in the process of rolling back the call stack. If that sounds like a nightmare in bookkeeping to you, you're absolutely right. Somehow, the executing code must at all times have a clear notion of what destructors are pending before control can pass out of a given block or a given function. It must also deal with exceptions thrown in constructors and destructors, and exceptions thrown while processing earlier exceptions. Kids, don't try this at home.<P>
<h4><FONT COLOR="#000080"><A name="0065_0029">The header &lt;<B><I>exception</I></B>&gt;<A name="0065_0029"></FONT></h4></P>
So this fancier machinery is now in the draft C++ standard. All that remains is to decide what to do with it. You can get a few hints from other programming languages. Ada, to name just one, has had exceptions for over a decade. Their very presence changes how you design certain interfaces and how you structure programs that must respond to nasty errors. The one thing we know for sure is that you must develop a <I>style</I> for using exceptions that fits the language as a whole, then use it consistently.<P>
That has serious implications for the Standard C++ library. Traditionally, of course, the library has thrown or caught no exceptions. (There weren't any such critters to throw!) But it's a poor advertisement for this new feature if the library itself makes no use of exceptions. Put more strongly, the Standard C++ library has a moral obligation to set a good example. Many programmers will use only the exceptions defined in the library. Others will model their own on what they see used by the library. Thus, the library is duty bound to set a good example for the children.<P>
Most decisions about the Standard C++ library are made within the Library Working Group (or LWG) of X3J16/WG21, the joint ANSI/ISO committee developing the draft C++ standard. Early on, the LWG committed to using exceptions as part of the error reporting machinery of the library. Not everyone is happy with this decision. Some people object to this decision because they don't want to incur the inevitable overheads of exception handling in every program that touches the library &#151; and that's essentially every program you write in C++. Others object because of the putative difficulties of validating a program that throws exceptions. Some projects require that the software vendors assert that exceptions can never be thrown. So the decision to use exceptions in the library was not lightly made.<P>
Only recently has the LWG agreed on an overall structure. What I present here was approved by the joint committee as recently as November 1993. But aside from a few name changes and other small tweaks, it is likely to survive reasonably unchanged.<P>
All the relevant declarations and class definitions for exception handling can be had by including the header <I>&lt;exception&gt;</I>. (Note the absence of a trailing <I>.h</I>, the hallmark of new C++ headers.) Within this header you can find the definition for class <I>xmsg</I>, the mother of all exceptions thrown by the library. (Yes, the name is horrid &#151; it's very likely to be changed to <I>exception</I> in the near future.) <A href="list1.htm">Listing 1</a>
shows at least one way that this class can be spelled out.<P>
The basic idea is that each exception has three null-terminated message strings associated with it:<P>
<I>what</I> &#151; telling <I>what</I> caused the exception<P>
<I>where</I> &#151; telling <I>where</I> it occurred<P>
<I>why</I> &#151; telling <I>why</I> it occurred<P>
Some exceptions may use only the first one or two messages, leaving the later pointers null.<P>
The next important notion is that an exception should have private copies (on the heap, presumably) of all these message strings. A typical exception constructor allocates storage on the heap, copies the strings, and sets the flag <I>alloced</I>. That way, the destructor knows to free the storage once the exception has been processed.<P>
But then why the flag if this is the preferred mode of operation? Well, one important exception derived from this base class is <I>xalloc</I>. It is thrown by <I>operator new</I> when it fails to allocate storage. (More on this in a later installment.) The last thing you want to do is try to copy strings onto the heap when you have to report that there's no more room on the heap! Thus, the special protected constructor that lets you specify no copying of strings. Of course, anyone using this constructor had better provide strings with a sufficiently long lifetime, or trouble ensues. That's why this form is discouraged, except where absolutely necessary.<P>
<h4><FONT COLOR="#000080"><A name="0065_002A">Throwing an Exception<A name="0065_002A"></FONT></h4></P>
You'd think then that all you have to do to throw an exception is write something like:<P>
<pre>   throw xmsg("bad input record");</pre>
You can certainly do so, but that is not the preferred method. Instead, for any exception object <I>ex</I>, you're encouraged to call <I>ex.raise()</I>. That function does three things:<P>
<UL><li>First it calls <I>(*ex.handler)(*this)</I> to call the <I>raise handler</I>. The default behavior is to do nothing, but you can hijack any thrown exception by providing your own handler with a call to <I>xmsg::set_raise_handler</I>.</li>
<li>Then it calls the virtual member function <I>do_raise</I>. That permits you to hijack thrown exceptions only for some class derived from <I>xmsg</I>.</li>
<li>Finally it evaluates the expression <I>throw *this</I>.</li></UL>
The first escape hatch is for embedded systems and those projects I indicated above that abhor all exceptions. You can reboot, or <I>longjmp</I> to some recovery point (and to beck with the skipped destructors).<P>
The second is best illustrated by the derived class <I>reraise,</I> shown in <A href="list2.htm">Listing 2</a>.
 It overrides the definition of <I>do_raise</I> in a special way. The override evaluates the expression <I>throw</I>, which "rethrows" an exception currently being processed. It turns out that iostreams has an occasional need to pass an exception up the line to another handler. I invented <I>reraise</I> as a way to do this, but it looks to be generally useful.<P>
The third thing is to do what exception classes were invented to do in the first place. By having <I>all</I> library exceptions be thrown through this machinery, however, the class meets the needs of several constituencies.<P>
<h4><FONT COLOR="#000080"><A name="0065_002B">Exception Hierarchy<A name="0065_002B"></FONT></h4></P>
There's still more to library exceptions. <A href="fig1.htm">Figure 1</a>
shows a whole hierarchy of classes derived from <I>xmsg</I>. Some are defined in other headers, but most are to be found in <I>&lt;exception&gt;</I>. The basic partitioning is into two groups:<P>
<UL><li><I>logic errors</I>, derived from class <I>xlogic</I>, which report errors that you can, in principle, detect and avoid when writing the program</li>
<li><I>runtime errors</I>, derived from class <I>xruntime</I>, which report errors that you detect only when you run the program</li></UL>
The former category is for those "can't happen" events that are often too hard to really prevent, at least until after some thorough debugging. The latter is for surprises that happen during program execution, such as running out of heap or encountering bad input from a file.<P>
<A href="list3.htm">Listing 3</a>
shows the class <I>xlogic</I> and <A href="list4.htm">Listing 4</a>
shows the class <I>xruntime</I>. Note the slight asymmetry. The latter class has an extra low-level constructor, as I described earlier, which is supposed to be used only by <I>xalloc.</I> Two more classes are derived from these to report mathematical errors. <A href="list5.htm">Listing 5</a>
shows the class <I>xdomain</I> and <A href="list6.htm">Listing 6</a>
shows the class <I>xrange</I>. A <I>domain error</I> occurs when you call a mathematical function with arguments for which its behavior is not defined (such as taking the real square root of -5). A <I>range error</I> occurs when the result of a mathematical function is defined in principle but not representable in practice (such as raising e to the 10,000 power).<P>
Finally, <A href="list7.htm">Listing 7</a>
shows the class <I>bad-cast</I>. It is the one exception thrown implicitly by statements generated by the compiler. C++ now includes <I>dynamic casts</I> which, in certain contexts, yield a null pointer if the cast is not permissible at runtime. If the context also requires that a reference be initialized, the executable code throws a <I>badcast</I> exception instead. (A reference can never be to a nonexistant object.)<P>
<h4><FONT COLOR="#000080"><A name="0065_002C">Terminate and Unexpected Handlers<A name="0065_002C"></FONT></h4></P>
Exception processing code can also call two additional functions:<P>
<UL><li><I>terminate</I>, when exception handling must be abandoned for any of several reasons</li>
<li><I>unexpected</I>, when a function throws an exception that is not listed in its (optional) exception specification.</li></UL>
A terminate condition occurs:<P>
<UL><li>when the exception handling mechanism cannot find a handler for a thrown exception</li>
<li>when the exception handling mechanism finds the execution stack corrupted</li>
<li>when a destructor called during execution stack unwinding caused by an exception tries to transfer control to a calling function by throwing an exception</li></UL>
The default behavior of <I>terminate</I> is to call <I>abort</I>, while the default behavior of <I>unexpected</I> is to call <I>terminated.</I> As usual in C++, however, you can provide your own flavors of these functions. A call to <I>set_terminate</I> lets you specify a pointer to a new function that must still somehow terminate the program. A call to <I>set_unexpected</I> lets you specify a pointer to a new function that can itself throw (or rethrow) an exception or terminate program execution.<P>
<h4><FONT COLOR="#000080"><A name="0065_002D">Conclusion<A name="0065_002D"></FONT></h4></P>
As you can see, the facilities provided by <I>&lt;exception&gt;</I> give you considerable latitude in reporting and handling exceptions. The C++ library uses this machinery exclusively, so you can control what the library does with exceptions. You can even prevent the library from actually evaluating any <I>throw</I> expressions.<P>
Given our limited experience to date with using expressions in C++, I'm fairly confident that this is mostly a good design. Time, of course, will tell us better how well we've done.<P>

<h4><a href="../../../source/1994/feb94/plauger.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
