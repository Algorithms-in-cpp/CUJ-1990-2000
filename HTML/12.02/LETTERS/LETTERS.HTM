

<HTML>
<HEAD>

<TITLE>February 1994/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="0082_0033"><A name="0082_0033"></font></h2><hr>
<BLOCKQUOTE>
<A name="0082_0000"><A name="0082_0000">Dear Dr. Plauger:<P>
I am writing in response to P.J. LaBrocca's recent article "Dynamic Two-Dimensional Arrays" (November 1993 issue of <I>The C Users Journal</I>)<I>.</I> On page 77 of that article, LaBrocca mentions that his <I>dyn2darray</I> routine suffers from limited portability because of memory-alignment problems. I have found a method of implementing LaBrocca's two-dimensional array allocation without his memory-alignment problem. The method I describe below maintains a crucial advantage of <I>dyn2darray</I>, it still requires only one call to <I>calloc</I>. The key idea is to determine which memory addresses are suitably aligned for storing the objects. The allocated memory is used to store three different data types: pointers to void, unsigned integers, and objects of unknown type. This might necessitate leaving gaps between objects of different types to achieve proper memory alignment.<P>
I start with the following question: How do we know at which addresses we can safely store the objects of the 2-D array?<P>
Let obj_size = sizeof(object type).<P>
Let <I>p</I> be a character pointer to dynamically allocated storage.<P>
C allows us to store a one-dimensional "array" of these objects starting at address <I>p</I>. From this it follows that the addresses<P>
<pre>p + k * obj_size (k = 0,1,2,...)</pre>
are properly aligned for storing these objects (as long as we don't go beyond the allocated region of memory). For example, if the object has type <I>double, sizeof (double) = 8.</I> (Suppose this to be the case on some machine.) Then<P>
<pre>p, p+8, p+16, p+24, ...</pre>
are valid addresses at which to store a <I>double</I>.<P>
This example shows how to allocate a 2-D array of doubles so that the pointers and the objects are stored in the same allocated memory region while preserving proper memory-alignment. For the moment I will not worry about the added complication of storing the number of rows and columns. Suppose that we want to allocate a 2-D array of doubles given the following conditions:<P>
<pre>sizeof (double *) = 2, rows = 3,
columns = 4, sizeof (double) = 8</pre>
Storage for the pointers uses up 14 characters of memory. The first available spot after the pointers at which we can store the doubles is at <I>p+16.</I> This means that a gap of two characters must be left between the pointers and the doubles to ensure proper alignment of the doubles. In general, we would store the objects at the address<P>
<pre>p + DynRndUp(SpaceForPointers, obj_size)</pre>
where<P>
<pre>SpaceForPtrs = rows * sizeof (void *)</pre>
and<P>
<pre>Dyn2dRndUp(i,j)</pre>
is a macro that rounds <I>i</I> up to the nearest multiple of<I> j. </I>(i.e., <I>Dyn2RndUp(14, 8) = 16)</I>.<P>
Of course, we still have to consider how to store the number of rows and columns between the pointers and objects. The first address at which we could store these values is given by:<P>
<pre>p + SpaceBeforeRowsAndCols</pre>
where<P>
<pre>SpaceBeforeRowsAndCols = Dyn2dRndUp(SpaceForPtrs, sizeof (unsigned))</pre>
The amount of space used by the pointers and the two unsigned values (number of rows and number of columns) is:<P>
<pre>SpaceForPtrsRowsAndCols = SpaceBeforeRowsAndCols + 2 * sizeof(unsigned)</pre>
Finally we can begin storing the objects at the address<P>
<pre>p + SpaceBeforeObjects</pre>
where<P>
<pre>SpaceBeforeObjects = Dyn2dRndUp(SpaceForPtrsRowsAndCols, obj_size)</pre>
If there is a substantial gap between the end of the pointers and the beginning of the objects there may be several locations at which we could store these two unsigned values. To make sure that we can recover these two values (given only the 2-D array) we <I>must</I> store them as close to the objects as possible. An example will clarify the matter. Suppose:<P>
<pre>rows = 3, cols = 2,
sizeof (void *) = 2,
sizeof (unsigned) = 4,
obj_size = 22</pre>
These sizes were chosen to illustrate the most general case. The pointers use up the first six characters of memory. The first address available to store the number of rows would be <I>p+8</I>. The objects can be stored starting at <I>p+22.</I> The first two columns in Figure 1 show that we have two choices as to where to store the number of rows and columns.<P>
In this example, <I>SpaceBeforeObjects = ((char **) p)[0] - p</I> is 22. If you redo this example setting <I>rows = 5</I> you will also get 22 (see third column in the diagram above). Therefore, storing the number of rows and columns as close to the pointers as possible makes it impossible to recover them later. The first and third columns in the diagram above makes it is clear that the location of these two values cannot be determined by the amount of space before the objects.<P>
Storing these two values as close to the objects as possible solves this problem. We simply round down the space before the objects to the nearest multiple of <I>sizeof (unsigned</I>). In the example above (columns 2 and 3) the space before the objects (22) is rounded down to the nearest multiple of <I>sizeof (unsigned)</I> (4) to get 20. The values for the number of rows and columns are to be stored immediately before this offset (<I>p+20</I>).<P>
In general, the expression<P>
<pre>p + Dyn2dRndDown(SpaceBeforeObjects, sizeof (unsigned)) - 2 * sizeof (unsigned)</pre>
where <I>Dyn2dRndDown(i,j)</I> is a macro which rounds <I>i</I> down to the nearest multiple of <I>j</I>, gives us a pointer to the beginning of the row and column data. In the above example we would get<P>
<pre>p + Dyn2dRndDown(22,4) - 2 * 4 = p + 12</pre>
I provide new versions of dyn2darr.c and dyn2darr.h [available on the monthly code disk &#151; pjp].<P>
Finally, I should mention that one small portability problem still remains. Both my version of the code and LaBrocca's make the assumption that all pointers have the same size and representation. My understanding is that this is much less of a portability issue than is the memory-alignment problem. (I have seen several C books write "portable" code which makes this assumption).<P>
P.S. I hope this proves useful to your readers. I do not have my own email address but I can be reached at the address shown below, or at jessica @ engin.umich.edu.<P>
Steve Coffman<br>
C-TAD Systems, Inc.<br>
Boardwalk Office Center<br>
3025 Boardwalk Drive<br>
Ann Arbor, Michigan 48108<br>
(313)-665-3287<P>
<I>Whew! I think you illustrate neatly why LaBrocca saw fit to sidestep the storage alignment issue. You can also sidestep the problem of different sizes of data pointers by storing only pointers to void. Still, beyond a certain point, the investment in potential portability starts getting hard to justify. &#151; pjp</I><P>
Hi Bill,<P>
I've just finished reading the November CUJ &#151; very entertaining as always &#151; and I couldn't help notice the inside back page ad:<P>
Sequiter Software Inc. says, "As with C, ANSI C++ is an international standard across all hardware platforms. This means you can port CodeBase++ applications between DOS, Windows, NT, OS/2, Unix, and Macintosh &#151; today."<P>
Sigh! The BSI jumped up and down on a few advertisers over stuff like this in the days before validated C compilers were available. Perhaps someone should have a word with the folks at Sequiter?<P>
See you in San Jose?<P>
Regards,<P>
Sean Corfield<br>
Development Group Manager<br>
Programming Research, England<br>
<I>Sean.Corfield@prl0.co.uk</I> (44) 372-462130<P>
<I>Yeah. People aren't supposed to claim conformance to a standard until it's approved. In the case of C++, it's particularly daring to refer to a putative "international standard." </I>&#151;<I> pjp</I><P>
Greetings,<P>
Enough of the language standards and extensions stuff already. Compare and contrast:<P>
Applications: Sequiter Software's CodeBase 5.0 vs Kedwell's DataBoss<P>
Libaries: Greenleaf's SoftC Database Lib vs Software Science's Topaz<P>
GO BROWNS!<P>
Sincerely,<P>
Noah Hester<br>
<I>nbh@cis.csuohio.edu</I><P>
<I>Your wishes are noted, except for the part about the Browns. </I>&#151;<I> pjp</I><P>
Dear PJP:<P>
In a letter published in the November 93 <I>CUJ</I>, you mention the problem of using <I>sizeof</I> in preprocessor statements, something most ANSI compilers don't allow. Mr. Plauger offered a solution:<P>
<pre>static char junk[sizeof(structname) !=132 ? 0 : 1];</pre>
but also offered the caveat that it wastes a byte of storage. I've been using a similar solution for several years that doesn't waste any storage:<P>
<pre>typedef struct {
    // ensure sizeof(structname)
    char x[sizeof(structname) == 132];
// is exactly 132 bytes.
} _size_check_structname_;</pre>
Because the statement is a typedof, no storage is allocated. The == operator is guaranteed to generate a 0 or 1 result (on an ANSI compiler). Even on a few compilers I've encountered which have an extension which allows a zero-sized array to appear as the last element in a structure, an error message is generated because the size of the structure overall cannot be zero. The error message you get from this construct varies between compilers, but it rarely indicates what the <I>real</I> problem is, so comments in the code are essential. (The fact that the typedef name is <I>_size_check_something_</I> helps. Using a similar standard naming convention throughout a project is probably a very good idea.)<P>
Other checks are possible using this method. For example, in a project once I had special 16-byte-at-a-time block zero and block move routines for performance. To safely use them on structures, I included the check:<P>
<pre>typedef struct {
    // ensure sizeof(memnode)
    char x[(sizeof(memnode) &amp; 0x0F) == 0];
// is a multiple of 16 bytes.
} _size_check_memnode_;</pre>
I've encountered several C programmers who hated such compile-time assertions in source (or header) files; perhaps they never make mistakes, or they enjoy long debugging sessions. While it is rare to make a mistake which causes one of these assertions to fail, the hours saved when it happens are worth the minutes it takes to code them.<P>
Ian Lepore<br>
Moderator, BIX c.language conference<br>
<I>ianl@bix.com</I><P>
<I>I like your solution better than mine. Thanks for telling us about it. </I>&#151;<I> pjp</I><P>
Dear Sir<P>
Since a long time ago, I'm an avid reader of the articles that you write in <I>Dr. Dobbs, C Users Journal</I>, etc. I enjoy every piece, especially with your style of writing.<P>
I just want to say thanks for your <I>great </I>writing, and for being such a great <I>researcher </I>in the computer area (and the like).<P>
Your Friend,<P>
Leo Medellin<br>
<pre>                          0
                        _.&gt;/)
leo.medellin@asb.com * (_) \(_)....
leo.medellin%bbs@quake.sylmar.ca.us
ak467@FreeNet.HSC.Colorado.EDU</pre>
<I>Thanks. And I like your bicyclist. </I>&#151;<I> pjp</I><P>
Mr. Plauger<P>
Thanks for continuing to produce an interesting magazine. I have been a subscriber for about 5 years. Some points/comments:<P>
1.     Articles such as "Code Capsules" by Chuck Allison are useful &#151; we must all remember that new, young C programmers join the ranks and have missed all the useful information contained in the early issues of the <I>Journal</I>.<P>
2.     Linux &#151; a Unix System V clone which runs on a PC, costs virtually nothing and includes Emacs, Latex, and X together with the GNU C and C++ compilers &#151; is becoming very popular. Is there any possibility of some coverage for Linux in your magazine?<P>
3.     <I>Dr Dobb' s Journal</I> have produced a CD-ROM containing all articles from January 1988 to June 1993 together with text search facilities. Is there any chance that such a product will be produced by R&amp;D as I feel that many subscribers would find this of interest.<P>
Yours sincerely,<P>
David Richards<br>
184 Turf Pit Lane<br>
Moorside<br>
Oldham<br>
OL4 2ND<br>
ENGLAND<P>
<I>(1) I like Chuck's writing too. Glad you appreciate the function it serves in this magazine. (2) I'll happily entertain proposals for articles in Linux. (3) We've been exploring numerous ways to make the material from CUJ more available to our readers, but I don't have an answer for you yet on this topic. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
I really enjoy reading <I>The C Users Journal</I>. There is one glaring omission in the C++ I/O streams library: a reset manipulator to set the stream back to default mode. Any function (except for <I>main</I>) has no knowledge of what flags, fill character, and precision are set for any streams it receives from the caller. To make sure there are no surprises, it has to explicitely set all the flags, the fill character and the precision to the values it needs. Having a reinit manipulator would make this much easier. Now let's take it one step further: what happens when the function returns control back to the caller. The mode of the stream may have changed, and the caller has to re-set everything. What a mess! Of course the called procedure should undo any changes it has made, so it has to save the mode on entry and restore it on exit, adding a couple of lines to every function. It seems obvious that we need save and restore manipulators to do the job. Of course you can implement the reinit, save, and restore manipulators, but this is such a universal need that I don't understand why they're not part of the standard library. Right now everyone who uses I/O manipulators has to reinvent the wheel on their own. Incidentally, C Standard I/O has a clear advantage here because it's modeless.<P>
Sincerely,<P>
Hans Salvisberg<br>
Salvisberg Software &amp; Consulting<br>
Bellevuestr. 18<br>
CH-3095 Berne<br>
SWITZERLAND<P>
<I>The nearest thing to what you want in the current C++ library draft is</I><I> </I>ios::copyfmt<I>, which lets you copy just the formating information between one </I>ios<I> object and another. </I>&#151;<I> pjp</I><P>
Dear PJP:<P>
I wish to comment on the article "A Revision Control System for MS-DOS", published in the July 1993 issue of <I>The C Users Journal</I>. There are two errors that will cause people a lot of grief. The function <I>print_warning</I> listed on page 48 declares the variable <I>string</I> as a character pointer, but doesn't assign it a value. It is then used in a call to <I>fgets</I> as the buffer location. This will lead to the data <I>fgets</I> reads being written to who knows where, and may cause serious problems. It caused my system to re-boot. The same type of error exists in the function <I>rev_number,</I> listed on page 50.<P>
Another concern I have about the code presented in the article is the lack of checks for unexpected end-of-file conditions. The first thing I put under RCS control, after fixing the above mentioned fault, was the RCS source code. I believe I then used checkout to get a copy of a file, and my system hung. The reason the system hung was that the editor I used to create the source files did not require that the file end with a newline character, so the RCS file did not end with a line containing the delimiter, but with a line containing the <I>}</I> character followed by the delimiter. Since there were no checks for EOF on the input file, the system kept calling <I>fgets</I> to get the next line, and the check for the delimiter always failed.<P>
I also worry about the lack of checks for write failures. It appears that there could be serious problems of writes are attempted and the disk is already full, though I must admit, I have not seen this problem.<P>
J.P. Schoonover<br>
(708) 979-7907<P>
<I>It is always interesting to see what you have to do to code prepared for presentation when you start using it seriously. Or code tested on one system when you move it to another. </I>&#151;<I> pjp</I><P>
Dear PJP:<P>
Over the years I've gotten much useful code and advice from <I>CUJ</I>. However, lately the quality of the published code has decreased significantly.<P>
As an example, consider the last two articles on exceptions <I>CUJ</I> has published. While I do not wish to single out these authors, neither of these packages compiled without significant modification on any popular workstation or PC operating system, nor worked as advertised once compiled. In addition, neither package (on the code disk or as available from the Internet) included any installation instructions. It seems obvious the articles were accepted on the basis of perceived interest and not the portability or functionality of either package.<P>
I think all but the most basic of packages offered should include installation instructions and dependencies. Both exception packages have substantial requirements for non-standard development packages (such as a specific version of gmake). Perhaps a "tools and rules" sidebar containing instructions for building and using the code would solve this problem.<P>
A more significant problem is the poor performance and portability of the code. While I would not expect production or GNU quality code from <I>CUJ</I>, the functionality advertised should be present and hopefully relatively bug free. I was especially disappointed with the most recent package because of the attractiveness of an exception mechanism portable between C and C++. After much work by myself and the author I was able to compile this package but then discovered substantial run-time problems. Test cases were not present and the samples provided with the package would not even compile &#151; due to undefined symbols rather than any obscure portability issue. I commend the author for all the help he gave me but why did <I>CUJ</I> publish a package seemingly without looking at the source or attempting to build it? Good examples of previous high quality <I>CUJ</I> articles include the socket library and generic object packages. Both were simple enough to compile on any operating system offering TCP/IP services or a C++ compiler and are robust enough to have become a standard part of my programming toolbox. Both of the articles I've singled out offered functionality of great usefullness but neither delivered on their promises nor did the articles contribute substantially to the understanding you could gain from a quick reading of any number of C++ or EIFFEL books.<P>
If <I>CUJ</I> is to be a pragmatic magazine for professional programmers and not a fluff publication or academic journal a la <I>Communications</I>, its offerings should set the standard for well-executed, portable code. Professionals as well as beginners could benefit from the example such a publication would set.<P>
C. Justin Seiferth<br>
Phillips Laboratory<br>
(505) 846-0561 (V)<br>
(505) 846-0473 (F)<br>
<I>seiferth@lyra.plk.af.mil</I><P>
<I>We do indeed make some effort to pick articles that have code which is both useful and reasonably correct. Sadly, we (I) don't always guess right. And we lack the resources to compile and test all the submitted code, or even verify that they are easy to install and run cursory examples. I wish it were not so.</I><P>
<I>On the other hand, your experience with one particular author is not unique. Often, our readers tell us that authors make extraordinary efforts to assist potential users of their code. I am pleased that our contributors are so willing to follow through on their submissions.</I><P>
<I>Both this and the preceding letter underscore the essential problem of using other people's code. There is a tremendous variation in robustness, portability, and ease of use. I'm not casting aspersions on the talents of our contributors when I say this </I>&#151;<I> what is a good design decision for one person may be an incredibly poor decision for someone else. We can only hope that most of the articles we run are useful to many of our readers much of the time. We'll keep trying. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
In the August 1993 <I>C Users Journal</I> article "Automated Unit Testing," Mr. Meadows lists several guidelines he recommends. The first is "Include all test code inside a main program, that is, inside a <I>#ifdef TESTMAIN</I> block."<P>
Well, that approach just does not work that well. Having developed and maintained several large products over a number of years, I have found it better to have truly independent test stubs. Aside from not having lint complain about multiple mains, having one test program that exercises all the functions in a library is much more useful and compact. In addition, golden output of each test function is easier to manage if it is maintained in files along with the library.<P>
A library (or application) code area is then composed of Source Code, Make files, a regression test script, and golden unit test case input and output files. This is all maintained in the RCS pool along with the source. Although we find it easier to keep the unit tests with the source code, if disk space is a problem they can be maintained separately.<P>
This does violate another guideline of Mr. Meadows. "Do not make the test program dependent on external files." Well, sorry. But any sufficiently large system will have some external files. Libraries will rely on other libraries. And applications will have large external data files. Having some simpler versions of the data files for unit tests is not a bad tradeoff.<P>
We find, as a general rule of thumb, that our library unit test cases are at least as large as the code itself. When one adds in the test stubs, and golden output files, it does build up quickly. Some Application Unit Tests can grow even larger, say 2-5x.<P>
However, the payback is when <I>any</I> developer can go into a library or application, run <I>make test</I>, and in a few minutes see if their changes have affected any previous results. Given that 20% of a 150,000 line software product may be changed during a given release, this pays off very quickly in not introducing unwanted bugs. The costs of this approach are disk space, and the displine to maintain the tests as part of the source and development process.<P>
On a final note, one of our newer tools has been the Purify software from Pure Research. Even in evaluation, the product was able to find several memory leaks and other problems which had gone undiscovered for years. I personally recommend this group of products for any serious software team.<P>
Sincerely,<P>
Richard Vireday<br>
Sr. Software Engineer, Intel<br>
<I>rvireday@pldote.intel.com</I><br>
(916)351-6105<P>
<I>I've found the approach described by Meadows very useful for smaller projects, and the approach you describe better for larger ones, for the reasons you describe. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
While I can't claim your longevity in data processing, I have been in the industry since 1976. As you have pointed out, there's little in the world of data processing that hasn't been seen before. In particular, there have always been people who believe it is possible to constsruct a perpetual motion machine for software support. Once you prime the pump with an initial license fee, the machine keeps producing answers, bug fixes, and enhancements with no further input. This belief is reinforced by the examples of Word Perfect Corporation and Microsoft, who seem to keep providing support just because they think it's the right thing to do.<P>
Free support is really a variation on the infamous Ponzi scheme; you give me $1,000 and I will pay you $250 interest every month forever. Or, to rephrase, you buy my $125 competitive software upgrade, and I will pay the distributor his cut and provide you with $45 per hour support forever. It's become the case for PC software, including the development tools advertised throughout your magazine, that selling computer software in an extended market requires the vendor to either lie or become a software missionary.<P>
This leaves potential customers only two ethical and legal purchase alternatives: only buy products from vendors who charge enough to cover support, or accept spotty support provided for free. Anyone who steals software should never become a parent, or should have a high tolerance for hypocrisy when their child is found cheating or shoplifting.<P>
Sincerely,<P>
James P. Hoffman<br>
416 West Kerr St.<br>
Salisbury, NC 28144<P>
<I>While I wouldn't use your emotion-charged phraseology, I agree with much of what you say. I ran a software company for a decade and found myself entertaining a different scheme for pricing code and maintenance almost every year. Charge too much and your competitors steal the market. Charge too little and you go broke getting rich. I'm glad I don't run a software company today. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger:<P>
I want to express my thanks for the three part series <I>CUJ</I> ran on pointers by Chuck Allison. These are the kind of articles that are so helpful to me. Incidentally, they exemplify what is missing from most books on C that Mr. Musielski complained about in his letter in the October issue. But to Chuck Allison's articles: I was raised on the assembly language programming and did nothing else for the first ten years of my programming experience. Consequently, I was well aware of the advantages of indirect addressing, but it has been amazing to me how little this benefited me understanding C's pointer syntax.<P>
I have a library of 38 books on C. Yet it is so often when I run into a problem that I must wade through more than half of them before I discover the key. It is a constant annoyance that most books on C never proceed beyond the simplest example. I will give you a trivial example: look at most books aimed at beginners in C. How many show that curly brackets are necessary with if, for, do, while when more than one statement follows? Trivial, maybe, but not to a beginner. How many warn that <I>scanf</I> is worthless for dealing with user responses that don't meet the programmed format requirements? How many show useful alternatives for interactive user responses?<P>
My first exposure to higher-level language was BASIC. I have exactly three books explaining the language and never needed more. Mike Musielski has a valid grievance and it is just a little unsettling to me that I have had to collect so many books on C despite my admiration for C and appreciation of its features and power.<P>
On the subject of Numerical Extensions to C, about which you wrote in the September issue: My interest in C mainly centers on electronic engineering programming and I watch with great interest the deliberations of the NCEG group. One feature which I have seen no information is whether they are looking at non-integer exponentiation. BASIC allows statements such as 2^1.6 which save a lot of bother working with logarithms. The only text I have found dealing with engineering programming is <I>Numerical Recipes in C</I>. Unfortunately, the authors worked assiduously at a FORTRAN translation and mostly ignored the powerful features of C because no counterpart existed in FORTRAN. The result is that oft-times the sources are not easy to read. I often fall victim to their "unit" approach to arrays where they simulate FORTRAN's elimination of the zero element of an array.<P>
Sincerely,<P>
Forrest Gehrke<br>
75 Crestview Rd.<br>
Mountain Lakes, NJ 07046<P>
<I>There are so many books on C simply because there is a huge market. Everybody wants to write the next Kernighan &amp; Ritchie (still the best selling technical book ever), and nobody wants to leave an entire market to some other potential K&amp;R.</I><P>
<I>As for your question about exponentiation, it seems to me that the current </I>pow<I> function does what you want. </I>&#151;<I> pjp</I><P>
Mr. Plauger,<P>
With much amusement, I read your article "An Embedded C++ Library" in the October 1993 issue of <I>Embedded Systems Programming</I>. In the past, standards and embedded systems were always separate subjects. They did not benefit from each other. Now that you are an official EPSILON [Embedded Programming Society, International, and the Loyal Order of Nonentities &#151; pjp] author I am glad to see that you want to become part of the solution rather than part of the problem. By way of your first paragraph in the Embedded Wish List section of your article, I see that you understand that the major problems are non-technical. Welcome and glad to have you on board.<P>
I have some experience trying to get the ANSI C standards committee to provide language support for embedded systems. For the most part, the ANSI C committee was a very homogeneous group of compiler writers whose expertise in embedded systems was unhindered by their ignorance of the subject. I tried to make some of your points at one of their meetings. They literally laughed at me. The chair of the subcommittee addressing these issues openly equated embedded systems with toasters. As a group, they were arrogant, rude, and lacked the experience to understand the technical issues except from the standpoint of compiler design. For the most part, they seemed to prefer it that way.<P>
It reminds me of the story of the salesman and the engineer or safari in Africa. The first morning, the salesman took the engineer lion hunting. Shortly after they left the hut, the salesman and the engineer came running back with a lion snapping at their heels. As they reached the hut the salesman opened the door and stepped aside as the engineer and then the lion ran into the hut. Slamming the door shut the salesman bragged, "I caught him, now you skin him."<P>
Instead of dealing with embedded systems issues, the ANSI C committee slammed the door and was done with the problem. It is the embedded systems programmers who are constantly reminded that they are still living with a lion. I hope the C++ salesman knows more about catching lions.<P>
Years ago, at your request, I sent you copy of my public comments on ANSI C by fax. Let me paraphrase a few key recommendations.<P>
<UL><li>Freestanding libraries must be a superset not a subset of the hosted library requirements because embedded systems requirements are more strict.</li>
<li>Functions that require operating systems support must have a defined interface to the operating system. For example, in the freestanding library, <I>printf</I> should call <I>putc</I>. The library should include <I>printf</I> and the user should write <I>putc</I>. The library should also provide a <I>putc</I> that acts a data sink, in case the user written <I>putc</I> is not available. The standard should document both functions as well as the relationship between them. In some cases, the standard will need to define new freestanding user written functions. For portability all library functions must be present in the freestanding environment without exception.</li>
<li>The standard needs to define which freestanding library functions you may call recursively and which you may not call recursively.</li></UL>
Now we get to deal with the C++ standard. I hope history will not repeat itself. I wish you lots of luck, fortitude and the tenacity to get the job done.<P>
Yes, I know your article appeared in another magazine. The other magazine is deficient. It lacks a Mail column. I suppose it has something to do with committing space to advertisers or readers depending upon where your priorities lie. I like <I>The C Users Journal</I>. It has lots of mail with many differing and even critical viewpoints. Since you write for both magazines and because this is a topic with very significant impact on readers of both magazines, please forgive me the sin of mentioning the name of another publication. This is just my way of trying to get broader support for making a better language.<P>
Sincerely,<P>
Russell Hansberry<br>
171 Whitney Road<br>
Quilcene, WA 98376-9629<br>
Telephone: 206 765-4465<br>
Fax: 206 765-4430<br>
Compuserve ID: 70314,1506<P>
<I>I'm really sorry you left that C Standards meeting feeling the way you did. I can assure you that Jim Brodie as Chair would not tolerate such open expressions of disdain as you perceived. (He is personally incapable of being rude to another person, in my experience.) There was expertise on embedded systems within X3J11 and we had discussed any number of such issues in earlier meetings. My article in DDJ expressed my dismay that we chose to provide so little explicit support for embedded programming in Standard C, but it was not intended as a criticism of the committee's decisions.</I><P>
<I>I agree that the level of standardization you describe would be helpful in many circles. From experience, however, I know how much work it takes to flesh out what you propose. And I know the burden it would impose on most implementors to conform. So I expect that, while some things will be better attended to in the C++ standard for embedded programming, the final result will still fall short of your guidelines. </I>&#151;<I> pjp</I><P>
Dear PJP,<P>
Thanks for the informative article [on what? can someone guess what this refers to and insert its name and publication date? - pjp]. Incidentally, the October issue of <I>Byte</I> carries two excellent articles on similar products, which are more expensive, yet seem to do the same thing: CodeCenter, ObjectCenter, and others (page 28) and the heavily-advertised and consequently high-priced BoundsChecker (page 159). (I suggest, <I>CUJ</I> acquire a copyright and carry those articles in December, for the benefit of all readers.)<P>
Isn't it a shame (for the C language compiler manufacturers) that such products are necessary? I understand that in the early days of C, products like the manifold LINTs were necessary. There was memory either for a compiler or a LINT-type consistency check. But nowadays, our compiler manufacturers go after a fashionable C++ compiler, allowing their C-compiler to gather dust. Can't someone produce a decent C compiler which catches those memory overwrites etc. in a "debug" or "verbose" mode? And then give us decent <I>longs</I> which can be used for business applications also (the "pennies in <I>long doubles</I> problem")? You mentioned in your October editorial that people are demanding a revision of the C standard. You seemed surprised, after having jumped onto the C++ wagon in a hurry. You made me curious. Can you tell us more?<P>
Ref: C++ vs.C<P>
I have learnt that mediocre standards are better than brilliant ideas, which turn the users into guinea-pigs for testing one revision after another. See the PC, which in its days was not the most brilliant, yet... See C nowadays. It is alright for an academician to buy a C++ compiler. But what if you produce a "ton" of software in C++, knowing that you will adapt your code by July 1994, when the new standard arrives hopefully. The guinea-pigs are necessary to fund the development effort, but not everyone can afford... I think the field is maturing. We don't believe anymore that the latest is the best. In a different field, take the software developers (WordPerfect e.g.) who deliberately shun Windows, as their own graphics routines under DOS are superior! (Going by <I>BYTE</I> October 1993.)<P>
Suggestion: Devote a topical issue of <I>CUJ</I> to the C++ vs. C debate, and discuss &#151; for the benefit of your readers &#151; the merits of the one over the other. The basics. Not the style you adopt when you talk to colleagues on the C++ committee. You get my idea. I am particularly interested in the performance payoff for the interpretative elements in C++ ("housekeeping" known from good olde BASIC back in ..., with the deletion of runtime objects). Everyone knows by now that programs consist of data and algorithms. C hinges everything on algorithms, so that data are ubiquitous unless you deliberately implement some "information hiding." C++ sees data only (or mainly) and subordinates algorithms to data. It is the other extreme, certainly more appropriate for big projects, but hardly suitable for the small application and hardly suitable for top-down design. Once you know what you want it is alright to pull the objects together, which you have collected in a bottom-up approach. The shift in paradigm is total...<P>
Organizing code is very much like organizing companies. (I have worked in that field called management consultancy for some 10 years!) In the small company the boss looks after everything. No need for information hiding. Then come the specialized departments. In C++ these are the objects. C++ uses structures to bundle data and algorithms. What if C was (made) a little more aware of subdirectories? (Yes the subdirectories of the operating system.) That is also a way of organizing data. It can be done, even with the current implementations of C, which know about an INCLUDE directory and the source-code directory, at best. The root directory is the boss. It just does a few strategic calls to the subdirectories visible from the root directory (I am talking development time). The visibility of data is restricted to a subdirectory. Between subdirectories there are no side-effects: all data is passed as arguments or returned as return values. I have been organizing my programs like that for some time. With enormous benefits. I plug and play, even without C++ constructors and destructors. The stack is a fabulous automatic constructor/destructor. And there is no need for housekeeping. We are talking about two languages, which unfortunately are "marketed" as successors of each other! What confuses everyone is that in C++ you can program (almost) just as if it were good old C!<P>
You get my message? Give us a decent C, with <I>llongs</I> 64-bits wide (for business applications, accounting, and the like), with decent compilers that can check for memory overwrites in a verbose mode, with some evolution (not revolution) on information hiding, and then move to C++, Smalltalk, when the job is done. We are judging a half-finished product against another half-finished product. That obscures everybody's judgement. And in turbid waters there is good fishing (marketing). Remember: "With our modern marketing techniques we would easily have pushed Beethoven's symphony production into the double-digit bracket".<P>
Sincerely yours,<P>
L. Engbert<br>
Engbert UB<br>
Taunusstrasse 8<br>
61389 Schmitten<br>
Germany<br>
(06084) 2367<br>
FAX +49-6084-2458<P>
<I>As a rip-roaring pragmatist, I applaud that the world has both C and C++ compilers in it. And that more often than not, the two more or less play together. Right now, I view C as the safe and solid bet for delivering serious applications with serious robustness and performance requirements. I view C++ as the cauldron in which ambitious new ideas are being stewed. There's a place in my tool chest for both. That seems to be the case for many of our readers as well. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger:<P>
In reading your July 1993 issue, I noticed a letter to the editor from Kevin Nickerson asking about distribution of the ANSI C (IS0) Standard. While not in machine-readable form, <I>The Annotated ANSI C Standard,</I> recently published by Osborne/McGraw-HiII, contains the ANSI C Standard on left hand pages with annotations by C programming author Herbert Schildt on right hand pages. This book is now available in bookstores or by calling 1-800-227-0900 at a price of $39.95.<P>
We published the book because we felt that there are thousands of people like Mr. Nickerson who would like to have the Standard, but don't have their own copy. As a special offer to your readers, Osborne/McGraw-Hill will give a ten per cent discount off the cover price to those who call our 800 number and say they saw it in <I>The C User's Journal</I>.<P>
Sincerely,<P>
J. M. Pepper<br>
Editor-in-Chief<br>
Osborne/McGraw-Hill<br>
2600 Tenth Street<br>
Berkeley, CA 94710<br>
510-548-2805<br>
FAX 510-54906693<P>
<I>Here's your chance to get a good price on a useful document. </I>&#151;<I> pjp</I><P>
To the Editor:<P>
The code from the October 1993 issue shown in <A href="list1.htm">Listing 1</a>
was compiled with Borland C++ (Chuck Allison's "Code Capsules: Pointers, Part 3"). It <I>does not work</I> with the input<P>
<pre>sortargs *.c</pre>
as alleged, but does sort command line arguments if all are entered at the command line. It does not work with redirection or using <I>more</I>.<P>
Any Comments?<P>
Yours Sincerely,<P>
James R Lane<br>
13 Waratah St.<br>
Walkerville 3959<br>
Victoria<br>
Australia<P>
<I>Chuck Allison is obviously speaking UNIX shell language here, not DOS command lines. The UNIX shell expands wildcards such as *.c and invokes the command with the argument list spelled out completely. DOS passes on the wildcard as a single argument and leaves it to each command to expand the wildcard as it sees fit (if at all). Redirection has no effect on the interpretation of command-line arguments. </I>&#151;<I> pjp</I><P>
Dear P.J. Plauger:<P>
I have a couple of important comments about "Dynamic Two-Dimensional Arrays," by P.J. LaBrocca in the November '93 issue: VERY! USEFUL!<P>
His dynamic 2-D arrays slipped <I>painlessly</I> into an application that desperately needed them. Exactly the kind of information I read your magazine for.<P>
Jeffrey Siegel<br>
Tokyo, Japan<P>
<I>Thanks. Glad we could be of help.</I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
This is a response to the letter from Lawrence H. Hardy in <I>CUJ,</I> December 1993. A readily available source of documentation of the PCX file format is <I>Flights of Fantasy,</I> by Christopher Lampton, Waite Group Press, 1993. This book is both fun and informative. It contains C++ source for a flight simulator. It does a good job of explaining C++ classes, VGA graphics, and animation.<P>
Steve Robison<P>
<I>Thanks. </I>&#151;<I> pjp</I><P>
Gentlemen:<P>
I am writing in response to a couple of letters in the December 1993 issue of <I>The C Users Journal</I> about the Hayes AT Command set. An excellent reference is the <I>Technical Reference for Hayes Modem Users,</I> Hayes Microcomputer Products, 1992. This publication is available free to Hayes modem purchasers when requested within 90 days of purchase of a Hayes modem. Others can purchase this publication from Hayes for $25.00. They accept prepayment by check and will take Visa and MasterCard or they will send C.O.D.<P>
Hayes Microcomputer Products, Inc.<br>
Attention: Customer Service<br>
P.O. Box 105203<br>
Atlanta, GA 30348-9904<br>
(404) 441-1617<P>
Sincerely,<P>
James E. Truesdale<br>
Systems Analyst<br>
jbm electronics<br>
4645 LaGuardia<br>
St. Louis, MO 63134-9906<br>
<I>Thanks. </I>&#151;<I> pjp</I><P>

<h4><a href="../../../source/1994/feb94/letters.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
