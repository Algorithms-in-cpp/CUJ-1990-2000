<HTML><HEAD><TITLE>February 1994/Coding with Printable Characters/Sidebar</TITLE></HEAD><BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">Some Printable Encoding Background</FONT></h3><hr>
<BLOCKQUOTE>
There are several ways to encode binary data into printable form. Some of the first I encountered were programs designed to allow an assembler to run on one type of machine but produce code for another. Since the type of file storage and I/O devices were, in general, unknown, these programs produced the output in records, one per line, containing hexadecimal values for the object data. Usually, there were other characters, such as <I>S</I> for Motorola's format or <I>:</I> for Intel's format, to designate the start of a record, followed by the hexadecimal data, each byte being encoded as two ASCII hexadecimal digits. These formats became popular and are still in use today for cross assemblers and compilers, PROM programmers, emulators, and other tools for cross-platform development.<P>
The efficiency of these formats, using two characters to represent one byte, took a back seat to portability. My first such use of a hexadecimal object format was in punched cards, read by a system which didn't even use ASCII or EBCDIC!<P>
Later, ASCII become popular and utilities such as UUEncode translated six bits of data into a 64-character subset of ASCII. Three eight-bit bytes could be broken into four six-bit values, which became four characters by either adding the value to the starting ASCII code or by indexing into a lookup table. Special character sequences would normally designate the start and end of coding, and other information about the file. The output was normally broken into lines of 80 characters or less for ease of handling.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
