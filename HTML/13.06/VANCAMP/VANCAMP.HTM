

<HTML>
<HEAD>

<TITLE>June 1995/Dynamic Inheritance Using Filter Classes</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Dynamic Inheritance Using Filter Classes<A name="00C5_0076"><A name="00C5_0076"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="00C5_0000"><A name="00C5_0000">Kenneth E. Van Camp</font></h3><hr><blockquote><P>
<P><i><A name="00C5_0000"><A name="00C5_0000">Kenneth Van Camp is a Vice President at Bear Stearns Securities Corporation. He has been programming in C++ for about four years, and in C for about twelve years. His applications experience includes securities, databases, graphics, product planning, contact management, engineering simulations, real-time control, and robotics. He may be reached via e-mail at camp@bear.com.</i></P><P>
<h4><FONT COLOR="#000080"><A name="00C5_0077">Introduction<A name="00C5_0077"></FONT></h4></P>
Of all the techniques offered by object-oriented programming (OOP) languages, inheritance is probably the most powerful. And of all the OOP languages, C++ is generally regarded as the most robust and flexible. Yet despite all its flexibility, C++ still lacks some basic features found in other OOP languages. One of these is dynamic inheritance.<P>
Most C++ programmers are familiar with the technique of multiple inheritance. There are times, however, when the multiple inheritance approach breaks down. A class may need to inherit properties from several different base classes in different combinations, resulting in an unwieldy number of derived classes.<P>
Consider a common business problem, in which a table of data may require several different representations. <A href="tab1.htm">Table 1</a>
shows a typical spreadsheet interface to display a stock market portfolio.<P>
Several other views of this data may be required. For instance, the user may need to see a summary of the portfolio by type (stocks, bonds, futures, etc.). It may be necessary to show data as a percentage of the total, or normalized relative to a baseline data point. The application may need to show aggregates by week, month or year, averages, percentages of the total, or the results of other formulas specific to the data being presented.<P>
All of these represent different views of the same data, and their display can be thought of as a specialization of the basic data display. This is an obvious application of inheritance, but the number of possible combinations is large. The program may need to show monthly aggregates in either standard or normalized form. Type summaries may be required by the percentage of the total. The list goes on and on.<P>
For example, <A href="fig1.htm">Figure 1</a>
shows a multiple-inheritance approach to one of these views using the Booch notation <a href="#1">[1]</a>. The arrows joining the different class "clouds" show the inheritance relationships between them (e.g., <I>TableDataAverage</I> is inherited from the <I>TableData</I> and <I>Average</I> classes).<P>
In this diagram, <I>TableData</I> is the basic class to hold a table of data. By deriving <I>TableDataAverage</I> from both <I>TableData</I> and an <I>Average</I> class, the user of this class could show an average of the table of data. Likewise, by deriving <I>TableDataNormal</I> from both <I>TableData</I> and a <I>Normalize</I> class, a normalized view of the data might be created. And by deriving a class from all three of these base classes, an average of the normalized data (<I>TableDataNormalAvg</I>) could be created.<P>
Now consider what would happen if you added a fourth base class to this hierarchy &#151; say a percentage mode class. Here is a list of all the new classes you would have to define to allow the user to access the possible views:<P>
<pre>   Percent
   TableDataPercent
   TableDataPercentAvg
   TableDataPercentNormal
   TableDataPercentNormalAvg</pre>
In fact, there may be other classes if the attributes are order-dependent. For instance, is the average of the percents the same as the percents of the averages?<P>
By now you have seen the problem. As new attributes are added, the number of classes in the hierarchy grows quickly. In fact, the growth is exponential. The inheritance tree will become a tangled web, and maintenance will be a nightmare.<P>
<h4><FONT COLOR="#000080"><A name="00C5_0078">Dynamic Inheritance<A name="00C5_0078"></FONT></h4></P>
What the program needs is a class whose full inheritance is established at run time. Although C++ does not directly support dynamic inheritance, it can be simulated with a technique known as the envelope-letter idiom. Using this approach, each instance of a class maintains a pointer to another object of the same (or similar) type. In this way, multiple objects can be connected to form a "chain." Each object specializes, or <I>filters</I>, the data it receives from the previous object in the chain. Since links in the chain can be dynamically assigned at run time, and even modified on the fly, the effect is similar to that of dynamic inheritance. (For more details, see the sidebar, <a href="sidebar1.htm">"The Envelope-Letter Class Idiom."</a>)<P>
The approach I have described is analagous to the "filter" concept that was championed by the designers of the UNIX operating system (and later emulated in MS-DOS and others). In UNIX, a user can "pipe" the output of one command to the input of another command. Generic filter commands (like <I>cut</I>,<I> paste</I>,<I> sort</I>, etc.) can be linked up to form complex commands whose inner workings are invisible to the user.<P>
Consider the class hierarchy diagram shown in <A href="fig2.htm">Figure 2</a>.
 I will use this class hierarchy as an example, throughout the rest of the article, to illustrate a useful application of filter classes. The example will allow a table of data values to be displayed in four different display modes: the original data, the average of the original data, the normal of the original data, and the average of the normal of the original data. Adding a new option (percentage mode, for example) would only add one additional class to the hierarchy, yet would create four additional display modes (the same as the original four, but shown in percentage mode).<P>
In <A href="fig2.htm">Figure 2</a>,
 the line circling from <I>TableData</I> back to itself, with a circle on one end and a box on the other, shows that each <I>TableData</I> "uses" another instance of itself. This shows the envelope/letter relationship. It is the link between objects in the chain. The 'A' in the triangle denotes that <I>TableData</I> is an abstract base class.<P>
Notice that all of these filter classes are descended from a common base class, <I>TableData</I>. This is important, because the link that joins objects in the chain is a pointer to an object of the base class type. Polymorphism in C++ will be used to select the proper filtering methods to invoke for each object.<P>
Next consider <A href="fig3.htm">Figure 3</a>,
 which shows one possible way to arrange filters in a chain. This is an object scenario diagram (again using the Booch notation), and shows how the objects may be linked at run time (the "uses" relationship from <A href="fig2.htm">Figure 2</a>)
. In this case an instance of the <I>TableDataMarketBuf</I> class (called <I>aTableDataMarketBuf</I>) holds the original data to be presented. It is used by an instance of the <I>TableDataNormalize</I> class, which in turn is used by an instance of the <I>TableDataAverage</I> class.<P>
The 'F' in the box on <I>aTableDataMarketBuf</I> merely notes that this object is a field in <I>aTableDataNormalize</I>, and the arrow pointing toward this object shows that <I>aTableDataNormalize</I> invokes methods from <I>aTableDataMarketBuf</I>. It does not indicate the direction of data flow. In fact, if anything data tends to flow more heavily in the direction against the arrow. This may be more clear if you think in terms of the pipe analogy made earlier:<P>
<pre>aTableDataMarketBuf
    | aTableDataNormalize
    | aTableDataAverage</pre>
By accessing methods at run time from <I>aTableDataAverage,</I> the user would see the average of all the normalized values. A second view of the data could be gained simply by accessing methods from <I>aTableDataNormalize</I>. The result would be the normalized values without averaging. Yet a third view of the data could be presented by omitting the middle object in the chain (<I>aTableDataNormalize</I>), which would show the average of the original values (unnormalized).<P>
<h4><FONT COLOR="#000080"><A name="00C5_0079">Implementation<A name="00C5_0079"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
shows the base class, <I>TableData</I>, from which all others are derived. Its lone constructor accepts a pointer to the previous <I>TableData</I> object in the chain as its argument. Referring back to <A href="fig3.htm">Figure 3</a>,
 when instantiating a <I>TableDataNormalize</I> object, this pointer would reference the <I>TableDataMarketBuf</I> object. When instantiating <I>TableDataAverage</I>, it would reference the <I>TabledataNormalize</I> object.<P>
The methods in the <I>TableData</I> class are all quite simple. Any requests for information are simply passed up the chain to the previous object. In this sense, <I>TableData</I> is a "do-nothing" filter that never alters any data. Its main purpose is to maintain <I>PrevTD</I>, the pointer to the letter object in the envelope.<P>
Notice that all of <I>TableData</I>'s methods are virtual. This is very important for dynamic inheritance to work. Polymorphic behavior will cause the proper virtual method to be invoked for each object.<P>
In my implementation, <I>TableData</I> is actually a template class. This makes <I>TableData</I> a generic container class that can hold any type of tabular data, but it is not important for the filtering behavior we have been discussing.<P>
To make <I>TableData</I> a useful class, you must add some processing in a derived class. <A href="list2.htm">Listing 2</a>
shows the <I>TableDataNormalize</I> class, which overrides the <I>GetCell</I> and <I>PutCell</I> methods. Instead of merely passing values on from the previous filter in the chain, <I>TableDataNormalize::GetCell</I> performs some calculations to normalize each data value (i.e., divide each cell by the value in the first row).<P>
In order to write <I>TableDataNormalize</I>, it was necessary to make some assumptions about the <I>cellType</I> class that the template is parameterizing. Since the normalizing process requires calculations, the <I>cellType</I> class must contain some type of numeric data. For that reason, <I>TableDataNormalize</I> assumes that the <I>cellType</I> class has <I>GetValue</I> and <I>SetValue</I> methods to operate on its numeric data.<P>
<A href="list3.htm">Listing 3</a>
shows the <I>TableDataAverage</I> class. This filter differs from both the <I>TableData</I> and <I>TableDataNormalize</I> classes in that it also changes the size of the table. For the previous two classes, the <I>GetNumRows</I> method always returned the value of the previous filter. The <I>TableDataAverage</I> class, however, collapses an entire table into a single row. The <I>GetCell</I> method, which is only valid for row zero, returns the average of all cells in the specified column.<P>
<h4><FONT COLOR="#000080"><A name="00C5_007A">Data Buffers<A name="00C5_007A"></FONT></h4></P>
None of the classes presented so far actually contain any data &#151; they merely filter the data from a previous filter in the chain. In order to be useful, however, it is necessary to put some real data in the chain. This is where the <I>TableDataBuffer</I> class comes in (<A href="list4.htm">Listing 4</a>)
. In addition to accepting a pointer to the previous filter in the chain, the constructor accepts a count of the number of rows and columns in the table. Then it allocates a buffer large enough to hold all the cells in the table. The <I>RefCell </I>method and the three validation methods provide a convenient interface to the buffer. The remaining methods are for compatibility with the base class.<P>
In order to load the table with real data, it is necessary to derive an application-specific class from <I>TableDataBuffer.</I> <A href="list5.htm">Listing 5</a>
shows the <I>TableDataMarketBuf</I> class, which is an example of one such class. In a real application, this class would probably contain a reference to a database interface object. For this simple example, however, I have merely inserted some dummy data in the buffer. In addition to containing the main buffer inherited from <I>TableDataBuffer</I>, the <I>TableDataMarketBuf</I> class also contains two arrays to hold the column and row headings.<P>
The second class in <A href="list5.htm">Listing 5</a>,
 <I>ValAttrCell</I>, is an example class to be used as the <I>cellType</I> template parameter in any of the <I>TableData</I> classes. One instance of this class will be created by <I>TableDataBuffer</I> for each cell in the table, so this class should be relatively simple and efficient. Note the <I>GetValue</I> and <I>SetValue</I> methods &#151; as previously noted these are required for compatibility with the <I>TableDataNormalize</I> and <I>TableDataAverage</I> classes.<P>
The <I>ValAttrCell</I> class holds two pieces of data for each cell: a floating-point value and an enumerated attribute that can be used to hold cell-specific display options. It may make sense to add other data to this class, for instance a date field or other fields to hold application-specific data.<P>
Finally, <A href="list6.htm">Listing 6</a>
shows a simple demonstration of the use of these classes. <I>TableDataMarketBuf</I> must be instantiated first. This will be the first object in the chain of filters (which you can tell because its <I>PrevTD</I> pointer is null). It's important for the beginning link in the chain to be a buffer class (i.e., descended from <I>TableDataBuffer</I>). If a non-buffer object started the chain, there would be no data to filter. (This is the reason why many methods in the non-buffer classes contain the assertion <I>PrevTD != 0.</I>)<P>
Next, the <I>TableDataNormalize</I> class is instantiated, with its <I>PrevTD</I> referencing the <I>TableDataMarketBuf</I> object. Simply by instantiating these two classes, we have created two different views of the data. By using methods from the buffer object, we see the original data. By using methods from the normalizing class we see the normalized view.<P>
This example program also demonstrates the <I>TableDataAverage</I> class, by creating two additional objects: one pointing to the original data buffer (the average of the original data) and another pointing to the normalized view (the average of the normalized values). Finally, the example program prints the two sets of data. The original table of data is printed, followed immediately by the average of all the rows. Then the normalized table is printed, followed by its average. The output is shown in <A href="list7.htm">Listing 7</a>.
<P>
<h4><FONT COLOR="#000080"><A name="00C5_007B">Other Applications<A name="00C5_007B"></FONT></h4></P>
The techniques shown in this article are not restricted to displaying tables of data. Any data-centered application that requires multiple views of the data can use this approach. It is particularly useful when an application must show multiple views simultaneously, because a single data buffer can be routed through multiple display filters to present two or more simultaneous views. Even if your application shows only one view at a time, however, the application of filter classes can greatly enhance the flexibility of your programs.<P>
A word processor, for instance, might use the filter approach to separate character data into words, phrases, sentences, pages, paragraphs, or chapters. Such filters might be used for something as complex as a language-recognition engine, or as simple as a continuously updated word count.<P>
In some applications, it may be necessary to extend some of the concepts presented in this article. For instance, there is nothing that says each filter must have a pointer to only a single "previous object" in the chain. A concatenation class might reference multiple objects to join two or more tables together. This could have been used effectively in the example presented, where an average row was displayed after the full table of data.<P>
My simple example makes no allowance for dynamically relinking objects after their instantiation, although this is easily done. The programmer must just make sure that any buffers are refreshed from the underlying filters.<P>
It may also make sense to make more of the objects be buffer-holding objects. The <I>TableDataAverage</I> class, for instance, could be modified to calculate the average when it is first instantiated and hold it in a buffer, instead of always recalculating the average when the value is requested for an individual cell. A tradeoff exists here in terms of space versus time, and the correct mix depends upon the application requirements. Maintaining multiple buffers may also make it more difficult to show multiple views simultaneously, unless a method is implemented to force changes to be refreshed in the different views.<P>
Maintaining multiple buffers in the chain can be especially useful in database applications. The first buffer can represent the original state of the database when the data was loaded and a second buffer can hold user updates. To commit the user's changes to the database, you can write a method to compare the first buffer to the second buffer and only update the values that changed.<P>
Filter classes are not appropriate for all applications, but they are a useful addition to any programmer's repertoire. You might want to think about using them when you design your next program.<P>
<h4>References</FONT></h4></P>
<a name="1"></a>1.     Booch, Grady, <I>Object Oriented Design With Applications</I>, 2nd ed. (Benjamin/Cummings, 1993).<P>
2.     Coplien, James O., <I>Advanced C++ Programming Styles and Idioms</I> (Addison-Wesley, 1992).<P>

<h4><a href="../../../source/1995/jun95/vancamp.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
