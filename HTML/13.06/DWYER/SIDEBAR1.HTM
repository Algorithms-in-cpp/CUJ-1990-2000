<HTML><HEAD>
<TITLE>June 1995/Quick and Portable Random Number Generators/Sidebar</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">Approximate Factoring</FONT></h3><hr>
<BLOCKQUOTE>
Suppose you want to compute <I>(a*x) mod m</I> where <I>a</I> and <I>x</I> are positive and less than the modulus <I>m</I>. If integer overflow is not an issue, you can do this by computing <I>k1 = </I><I>a*x/m</I><I>*m</I> where, <I>a*x/m</I> signifies the largest integer less than or equal to <I>a*x/m,</I> and then computing the result <I>k1*m,</I> called the residue. Suppose, however, that the intermediate value <I>a*x</I> would overflow. The modulus <I>m</I> can always be approximately factored into <I>m = a*q + r</I> with <I>q = </I><I>m/a</I>. Now calculate <I>k=</I><I>ax/aq</I>. Note that <I>k</I> is <I>x/q</I><I>,</I> thereby avoiding this overflow of <I>a*x</I>. Using the fact that <I>m = a*q+r</I>, you can see that the residue is:<P>
<pre>a*x- k1*m</pre>
or<P>
<pre>a*(x - k*q) - k*r + (k-k1)*m</pre>
If <I>a*a</I> is less than <I>m, k-k1</I> is either zero or one, and <I>x</I> is positive and less than <I>m</I>, the following code fragment using signed integers computes the residue correctly without overflow:<P>
<pre>k = x / q;
residue = a* (x - k * q) - k * r;
if (residue &lt; 0)
residue += m;</pre>
The check against only negative values can be used in computing the residue if zero values are impossible, as they are if <I>m</I> is prime.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
