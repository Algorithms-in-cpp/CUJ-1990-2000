

<HTML>
<HEAD>

<TITLE>February 1993/C++ Components and Algorithms</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Book Reviews</FONT></H2>

<hr><h2 align="center"><font color="#800000">C++ Components and Algorithms<A name="00A7_003C"><A name="00A7_003C"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="00A7_0000"><A name="00A7_0000">Reviewed by Steve Halladay</font></h3><hr><blockquote><P>
<P><i><A name="00A7_0000"><A name="00A7_0000">Steve Halladay owns Creative C Corp. in Louisville, CO. He has over 10 years experience developing products like CSIM and Multi-C in C and C++. Steve received his MS in Computer Science in 1982 from Brigham Young University. You can reach Steve at Creative C Corp. (303) 673-6683.</i></P><P>
C++ Components and Algorithms is not just another text on how to use C++. This book focuses on a few useful software components and shows how to implement them in C++. In addition, Scott Ladd provides the kind of insight associated with experienced software developers. Ladd expects the reader to have a working knowledge of C++.<P>
<h4><FONT COLOR="#000080"><A name="00A7_003D">Organization and Contents<A name="00A7_003D"></FONT></h4></P>
<I>C++</I> <I>Components and Algorithms</I> includes C++ source code that shows the implementation of strings, arrays, sorting algorithms, statistical functions, persistent objects, hash tables, binary trees, and B-trees. The 779 pages of the book are divided into four major sections entitled "Groundwork," "Arrays," "Indexing, Hashing and Filing," and "Appendices."<P>
In his first section, entitled "Groundwork", Ladd describes the philosophy that guides the development of the objects he presents. As he points out, it is important to understand the developer's general philosophy to fully understand the software. Ladd briefly describes how object-oriented software differs from traditional software and defines some of its associated terminology. Ladd also takes time to describe some pitfalls associated with "trendy" C++ such as the additional opportunity the language gives you to make mistakes.<P>
In this first section Ladd also introduces some basic types such as booleans, error reporters, random-number generators, and strings. Ladd mentions that the string class he presents in the third chapter is very similar to string classes he has presented in previous books, but notes that he has included the string class in this book for completeness. This is certainly useful for those who do not own his previous books.<P>
The second section of the book, entitled "Arrays," introduces a couple different types of arrays. The inherent implementation of arrays in C and C++ gives programmers enough rope with which to hang themselves. Ladd shows how to build an array class that helps programmers avoid common array pitfalls by supplying enhancements like index bounds checking. The array types he describes include integer and floating-point arrays. Ladd avoids the use of templates for his implementation of arrays because many current compilers have template implementation deficiencies. But since Ladd gives both integer and floating-point examples of arrays, it is easy to see how to create additional types of arrays using his base classes.<P>
In the section on arrays, Ladd also takes advantage of array constructs to discuss some related topics. For example, Ladd presents one chapter on sorting in which he describes the quicksoft algorithm and shows how to implement it in C++. He also has a chapter about statistics in which he discusses some basic statistical concepts like mean, variance, and correlation. Ladd shows how both sorting and statistics relate to his array classes.<P>
The third section of the book, entitled "Indexing, Hashing and Filing," discusses some basic database concepts. Ladd starts the third section by talking about persistent objects. He shows how to store and retrieve objects with files. The third section also discusses hash tables and shows how to use them as an indexing mechanism for a simple database. Ladd ends the third section of the book by discussing tree structures as database indexing mechanisms. In the chapters on tree structures, Ladd shows a binary tree and a B-tree implementation. He also explains the strengths and weaknesses of each structure. Ladd's implementation of the B-tree is thorough enough that he includes code to perform not only key insertion and searching, but also key deletion.<P>
The fourth section of the book is an appendix that includes the complete source code for all the classes presented in the earlier parts of the book. The appendix is 279 pages of listings. The book comes with an accompanying disk that also contains the complete source listings as contained in the appendix.<P>
<h4><FONT COLOR="#000080"><A name="00A7_003E">Commentary<A name="00A7_003E"></FONT></h4></P>
<I>C++ Components and Algorithms</I> is Ladd's third book. His comfortable writing style attests to his experience as a writer. The explanations and examples are clear and concise. Most of the book is written in the first person as though you were looking over his shoulder as he guides you through his code.<P>
This book is not for the passive reader. Ladd includes lots of source code. The average page probably has more lines of source code than accompanying textual explanation. However, the code is commented where necessary and easy to understand. If you like to see examples of good clean code, this book is full of them.<P>
Ladd's source code also is reasonably compiler and system independent. There is nothing more frustrating than getting a book of programming examples only to find that they will not work on your system. The only system specific code handles the different PC compilers' file opening command modes.<P>
You might think that a book with so much source code is bound to have many errors. On the contrary, Ladd seems to have taken meticulous care to make sure his code compiles under at least Borland's and Microsoft's compilers. The very few errors I noticed in the book were not in the source code at all.<P>
The most interesting part of the book to me was Ladd's use of sound development techniques throughout the book. Ladd's class designs are elegant and simple. He avoids the convoluted inheritance hierarchies that are often prevalent in many current C++ programming examples. He also uses a fundamental programming style that avoids the many confusing extensions that C++ offers. But Ladd's avoidance of the exotic features of C++ does not prevent him from showing how to use the major valuable aspects of the language. It was refreshing to see code that did not try to impress you with its extreme use of the language.<P>
<h4><FONT COLOR="#000080"><A name="00A7_003F">Conclusion<A name="00A7_003F"></FONT></h4></P>
<I>C++ Components and Algorithms</I> fills a niche for the intermediate software developer. The book focuses on useful, sound implementations of data structures and algorithms in C++. Ladd's down-to-earth approach and clear explanations make both his descriptions and examples useful to students of C++ and software engineering.<P>
Title: <I>C++ Components and Algorithms</I><br>
Author: Scott Robert Ladd<br>
Publisher: M&amp;T Books, 411 Borel Avenue, San Mateo, CA 94402<br>
Price: $39.95 (disk included)<br>
ISBN: 1-55851-227-6<P>
</BLOCKQUOTE>
</BODY>
</HTML>
