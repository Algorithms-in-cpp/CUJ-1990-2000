

<HTML>
<HEAD>

<TITLE>February 1993/Sorting Networks</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Algorithms</FONT></H2>

<hr><h2 align="center"><font color="#800000">Sorting Networks<A name="0053_0026"><A name="0053_0026"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0053_0000"><A name="0053_0000">Frederick Hegeman</font></h3><hr><blockquote><P>
<P><i><A name="0053_0000"><A name="0053_0000">Frederick Hegeman is an amateur programmer and computer language hobyist. He can be reached at P.O. Box 2368, Rapid City, SD 57709, telephone (605) 343-7014.</i></P><P>
A sorting network sorts <I>n</I> items by performing a predetermined set of comparisons. A software implementation for a sequential computer might take the form<P>
<pre>swap(1,2); swap(4,5); swap(3,5);
swap(3,4); swap(1,4); swap(1,3);
swap(2,5); swap(2,4); swap(2,3);
where swap(a,b) = if(b &lt; a) exchange a and b;</pre>
This is a nine-comparison network for sorting five items. You might try it with pennies, nickels, dimes, quarters, and cheeseburgers. The best-, worst-, and typical-case number of comparisons are the same. Only the number of exchanges varies. Nine comparisons are, in fact, the fewest necessary to sort five items by exchanges when any combination of items is possible. When <I>n</I> is known to be small, these simple predetermined sequences out-perform the best algorithmic sorts.<P>
In theory, the minimum number of comparisons necessary to sort <I>n</I> items is the ceiling of log2(<I>n</I>!). As <I>n</I> grows larger, 1og2(<I>n</I>!) approaches <I>n</I>log2(<I>n</I>). The reason why O(<I>n</I>log2(<I>n</I>)) sorting algorithms, such as Quicksort, are so efficient as <I>n</I> grows larger should be obvious. Sorting networks generated by the Bose-Nelson algorithm (See <A href="list1.htm">Listing 1</a>.
) are O(n<SUP>1.585</SUP>), which diverges from <I>n</I>log2(<I>n</I>) rapidly. However, the Bose-Nelson network for 16 elements is 65 comparisons, which is pretty nearly <I>n</I>log2(<I>n</I>), and sorting 1000 random 16-element arrays using a Quicksort that pivoted on the last element in the array requires 85.43 comparisons on average, which is just over <I>n</I><SUP>1.585</SUP>. This is probably the reverse of what you might have expected. Sorting is so often discussed in terms of increasing <I>n</I> that it is easy to fall into the trap of expecting "efficient" algorithms to behave nicely over the whole range of their inputs. The "gotcha" in Quicksort is the extra comparisons needed to properly partition the array. They are insignificant when sorting a large array but constitute a significant part of the total when the array is small. As <I>n</I> becomes very small, the behavior of sorting networks comes closer to the ideal.<P>
Bose-Nelson generates minimum comparison networks only for <I>n</I> &lt;= 8. However, minimum comparison networks are available for 9 &lt;=<I>n</I>&lt;=16 as well. Those generated by the code in <A href="list2.htm">Listing 2</a>
are based on illustrations in <I>The Art of Computer Programming,</I> Vol. 3 (Knuth 1973). Please note that both listings generate sorts according to element numbers &#151; one greater than the corresponding array index.<P>
Sorting small arrays is a problem all its own, difficult to understand in the usual terms. If you need to sort a small array in a time-critical section of code, you can count on only two things holding true: your algorithmic sort may perform much worse than expected, and no algorithmic sort can match the minimum comparison networks on all combinations of elements. When that code is part of something like an operating system, the networks have at least two other attractive features: many comparisons can be done in parallel, if appropriate; and they are inherently re-entrant, so that sorting may be interleaved with other tasks.<P>
<h4><FONT COLOR="#000080"><A name="0053_0027">Bibliography<A name="0053_0027"></FONT></h4></P>
Knuth, Donald E. 1973. <I>The Art of Computer Programming, </I>Vol. 3. Reading, MA: Addison-Wesley. Pp. 220-229.<P>
Bose, R. C. and Nelson, R. J. 1962. "A Sorting Problem". <I>JACM</I>, Vol. 9. Pp. 282-296.<P>
Davis, Wilbon. September, 1992. "Time Complexity". <I>The C Users Journal</I>, Vol. 10, No. 9. Pp. 29-38.<P>

<h4><a href="../../../source/1993/feb93/hegeman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
