

<HTML>
<HEAD>

<TITLE>July 1993/A Windows and MS-DOS C++ Output Stream for a Secondary Monitor</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjul.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Software Tools</FONT></H2>

<hr><h2 align="center"><font color="#800000">A Windows and MS-DOS C++ Output Stream for a Secondary Monitor<A name="01C0_00A5"><A name="01C0_00A5"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="01C0_0000"><A name="01C0_0000">Kevin Pinkerton</font></h3><hr><blockquote><P>
<P><i><A name="01C0_0000"><A name="01C0_0000">Kevin Pinkerton is a Senior System Programmer for AlliedSignal Technical Services in southern Maryland. He has been programming for sixteen years. Much of that time involved VAX/VMS systems. More recently he has been writing C+ + Windows programs and drivers for specialized data acquisition boards. He can be reached at 301-862-8862.</i></P><P>
How often have you used output statements to try to find that elusive program bug? Carefully placed output statements can help you follow your program's execution flow or watch the state of a variable. If only they didn't tend to clutter up your screen and interfere with the program's user interface. I have developed an output stream compatible with MS-DOS and Windows that will write to  a secondary monitor.<P>
<h4><FONT COLOR="#000080"><A name="01C0_00A6">The <B><I>mstream</I></B> MDA Output Stream<A name="01C0_00A6"></FONT></h4></P>
<I>mstream</I> (<A href="list1.htm">Listing 1</a>
and <A href="list2.htm">Listing 2</a>)
, the output stream class I developed based on the <I>ostream</I> class, inherits all the overloaded insertion operators (&lt;&lt;) from <I>ostream.mstream's</I> class constructor creates an instance of the <I>mstreombuf</I> class and uses it for <I>mstream's</I> buffer. The <I>mstreambuf</I> class is the heart of the MDA output stream. Each character displayed on the MDA monitor uses two bytes of video memory. The low-order byte contains the character and the high order byte contains the display attribute. The video memory is mapped directly to the monitor's display. Each character and display attribute written to video memory is immediately displayed on the MDA monitor.<P>
I also defined a global instance of the <I>mstream</I> class called <I>mout. mstream's</I> header file defines an external reference to <I>mout</I>. You must include the <I>mstream</I> header file in your program and link to the appropriate MS-DOS or Windows link libraries before you can use <I>mout</I> in your program. Once you have linked <I>mstream</I> with your program, you can use <I>mout</I> just as you would use the C++ <I>cout</I> standard output stream. You also can use the standard stream manipulators defined in <I>iomanip.h</I>. Here are some <I>mout</I> usage examples:<P>
<pre>mout &lt;&lt; "XMAX = "&lt;&lt; xmax &lt;&lt;" in module XYZ";
mout &lt;&lt; "bit code =" &lt;&lt; (hex) &lt;&lt; bitcode &lt;&lt; endl;</pre>
An external reference to <I>mout</I> is included in <I>mstream.h</I> so that everyone can use <I>mstream</I> without having to create their own instance of it. The global instance in <I>mstream's</I> source file works well for the MS-DOS and Windows static link libraries. However, defining a global instance in the DLL and trying to get the linker to find it when you link your program won't work. (More on this later.)<P>
<I>mstreambuf</I> uses the <I>screen</I> member to point to the video memory. <I>screen</I> is an unsigned integer array where array position 0 points to row 1, column 1, array position 1 points to row 1, column 2, and so on. <I>mstreambuf</I> uses the <I>row</I> and <I>column</I> class members to form an index into the <I>screen</I> array. The MS-DOS version of <I>mstreambuf</I> creates a far pointer to memory address 0XB000 and assigns it to <I>screen</I>. The Windows version of the <I>mstreambuf</I> assigns <I>_BOOOH</I>, a global selector constant, to <I>screen</I>. The constant_<I>BOOOH</I> is one of several global selector constants that Windows provides for accessing common BIOS memory areas. <I>screen, row,</I> and <I>column</I> are all static class members so only one copy of each of them exists for all instances of the class. This will keep multiple instances of <I>mstream</I> from overwriting each other.<P>
The <I>mstream</I> class constructor sets the stream's unit buffered (<I>unitbuf</I>) format flag. The <I>unitbuf</I> flag causes <I>ostream::osfx</I> to flush the stream after each insertion by calling <I>streambuf::sync</I>. In <I>mstream's</I> case, <I>ostream::osfx</I> will end up calling <I>mstreombuf::sync. mstreambuf::sync</I> takes each character out of the buffer and writes it (along with a display attribute byte) to the MDA video memory. The <I>mstreambuf</I> class also redefines the <I>overflow</I> virtual function. Other stream functions frequently call the <I>overflow</I> function when they sense that the <I>put</I> area is full. <I>overflow</I> flushes the stream and resets the <I>put</I> area pointers.<P>
<h4><FONT COLOR="#000080"><A name="01C0_00A7">The Link Libraries<A name="01C0_00A7"></FONT></h4></P>
I compiled, linked, and tested the source code using Borland C++ v3.1. <A href="list3.htm">Listing 3</a>, <A href="list4.htm">Listing 4</a>, <A href="list5.htm">Listing 5</a>, <A href="list6.htm">Listing 6</a>, and <A href="list7.htm">Listing 7</a>
show sample command procedures to compile and build large memory model versions of the MS-DOS and Windows static link libraries and the Windows dynamic link library (DLL). I prefer to use the DLL library when working with Windows. A single copy of a Windows DLL and all of its static and local variables are used by all the programs that link to it. In <I>mstream's</I> case, this means that multiple programs can send output statements to the MDA monitor at the same time and not overwrite each other.<P>
The linker needs to know where to find the references to the DLL routines that your program uses. The easiest way to do this is to create a special import library version of the DLL. The import library contains all the exported (callable by Windows) functions and class names in the DLL and allows the linker to construct a reference table in the <I>.EXE</I> file. When Windows loads the program, it uses this table to resolve calls to the DLL. Unfortunately, you cannot export any of the DLL's static variables (or in this case, class instances) into an import library. So I created a separate source file (<A href="list8.htm">Listing 8</a>)
 that contained the <I>mstream mout</I> global instance statement. I then compiled it using non-DLL compiler switches and added it to the import library. This portion of the import library will be statically linked to your program. This is not a good practice if you plan on distributing your DLL, but as long as the make or batch file automates the process I feel comfortable with it. A DLL also requires two additional routines: <I>LibMain</I> and <I>WEP</I>. Windows calls <I>LibMain</I> when it loads the DLL into memory and <I>WEP</I> when it unloads it. The version of these routines used by the library are empty shells that do the minimum amount required by Windows.<P>
<B>Important Note:</B> The DLL library is compiled with the DLL version of the C Runtime Library. If you use the DLL library, your program must also use the DLL version of the C runtime library. Otherwise the linker will not be able to resolve your references to <I>mstream</I>.<P>
I find this MDA output stream to be an invaluable tool for debugging programs, especially Window programs. There are several enhancements that would increase its usefulness. One of them would be adding a file stream to <I>mstream</I> that would mirror the MDA output to a permanent log file. Another might be to allow exact row and column positioning similar to the <I>conbuf streambuf</I>.<P>

<h4><a href="../../../source/1993/jul93/pinkerto.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
