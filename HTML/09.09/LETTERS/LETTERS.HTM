


<HTML>
<HEAD>

<TITLE>September 1991/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="0210_010E"><A name="0210_010E"></font></h2><hr>
<BLOCKQUOTE>
<A name="0210_0000"><A name="0210_0000">Dear CUJ,<P>
I am pleased to see more interest in floating-point applications in the letters published in the April issue. I must apologize to Mr. Taylor if I didn't make it clear that I was suggesting the use of <I>double</I> as a 53-bit integer for monetary calculations partly because 32 bits could easily be insufficient, but also because, on modern systems, it allows satisfactory control over rounding of fractional cents. Several people have pointed out the <I>floor(x+</I>. <I>5)</I> solution for rounding, which is satisfactory when you are not concerned about speed or the mis-matched treatment of positive and nagative multiples of 0.5.<P>
Getting on to a more interesting subject, I wish Mr. Rudin well in his publishing endeavor, and I expect he has plenty of valuable material. On the other hand, I find it outrageous to criticize the authors of <I>Numerical Recipes</I> for putting clarity and reliability ahead of efficiency in their published code.<P>
If Mr. Rudin compares the FORTRAN and C editions, he will see that they made a sincere effort to clarify the code in the C edition. I, for one, feel that they made a great stride forward in eliminating programming style which caters to the weaknesses of the systems of a particular era, instead concentrating on the basic requirements of the job. At the time their book came out, I thought it might be a mistake to ignore the fact that most C compilers required local variables to be declared <I>register double</I> for efficiency. Since that time, enough compilers have appeared with excellent register allocation to more than justify this omission.<P>
Mr. Rudin castigates us for writing code which relies on the compiler to perform strength reduction in inner loops. I tried the Listing 3 code on several levels of Sun C, operating system 4.x, both Sun 3 and Sun 4, and found that all of them were able to remove the integer multiply from the inner loop and create their own local pointers. If this were not so, the SPARC architecture, which has no integer multiply, would not be viable as a C platform. The GNU C compiler, version 1.37.1, does not perform strength reduction on these multiplications, but I'm sure that some future version will.<P>
There is no measurable difference between the speed of Listing 3 and Listing 4 under these compilers, at least when the sum is accumulated in a local non-volatile variable. That is not a question of FORTRAN vs. C style; it has always been good style in either language to use local variables when appropriate, both for efficiency and to avoid side effects. With any good optimizing compiler, the programmer is and should be free to write this code in the way which is most legible and secure. Why compromise published code to fit the limitations of current and past systems, when there is ample proof that these limitations can be removed?<P>
Along with Mr. Rudin, I have played with the FFT and quicksort algorithms from <I>Numerical Recipes</I> and found more efficient versions, more so in FORTRAN than in C. The loading of the dice against quicksort was already present in the FORTRAN version, which, however, is considerably better than some versions which I have seen published by eminent authorities.<P>
Never say always. If you are writing code for the 68000 family, a loop control of the form<P>
<pre>short j=n-l;
do{ ... }
while( j-- != 0 )
   /* or while( --j != -1 ) */</pre>
corresponding to the <I>dbra</I> instruction, is faster than Mr. Rudin's form, which is excellent on most processors, but often requires special peephole patterns to eliminate unnecessary sign extensions on 32-bit processors. Making the comparison to zero explicit is preferable, as it results in the same code as the cryptic form.<P>
I seem to recall authors with more experience than I stating that <I>for</I> or <I>while</I> are to be preferred over <I>do</I>{}<I>while</I> when both will do the job. I mention this only to point out again that the lack of a <I>REPEAT..UNTIL</I> in standard FORTRAN (there is a <I>DO...IF() EXIT; ENDDO</I> in FORTRAN 90) is not an issue over which I would discard the best textbook in its category.<P>
Finally, I would like to point out that the marked similarity between the <I>Numerical Recipes</I> codes in the FORTRAN, Pascal, and C has enabled the authors to take advantage of years of practical experience and debugging which are not matched in any comparable collection.<P>
Sincerely yours,<P>
Tim Prince<br>
39 Harbor Hill Rd.<br>
Grosse Pte Farms, MI 48236<P>
Dear Bill,<P>
I am near to completing a product for the C marketplace and hope you can direct me toward a software publisher. As background, I have a Ph.D. in Computing and about 30 years experience in computing. I grew up in Cronulla, about 15 miles down the coast from where you are living. During summer in the 50's, I spent most of my time in the surf.<P>
In 1986-87 I built a trace system for the MIX C compiler down in Dallas, Texas. This trace was written in assembler code for the IBM PC, and relied on information generated by the C compiler. This system has been well received and is still selling well.<P>
Last year I started thinking about building a next step in the visualization techniques I have been developing. Briefly, I think it is valuable to show a programmer as much as possible about the program he is running. A fully instrumented system is another description.<P>
After looking for a C compiler maker who would generate the information that I need, I decided I would be better off to build an interpreter for the C language myself and add all the trace behavior into one system. With control over the entire system, I am also able to include a browser. Overall, the system will be able to tell the user anything he wants to know about the program as static source or a running program.<P>
The bias of such a system is toward giving the user information about his program, rather than toward high speed execution. Since a lack of execution speed can be an embarrassment, I have included a P-code generator so that the first time an expression is seen, it is parsed and a much faster form built. The next time that expression is seen, it can be evaluated much more quickly. Using this technique, I am running at speeds of over 1000 stats/sec on my 386/25Mhz.<P>
This interpreter is itself written in ANSI standard C and implements ANSI standard C. I have about 24,000 lines of C code working and I estimate the final size of the product at about 30,000 lines. Proof-of-concept wise it is more than 80% completed, exhaustive-testing wise it is less than 80% completed. I am building it under DOS 3.3 using MS C 5.1 and writing directly to the screen rather than using any windowing scheme. [This code is well isolated!]<P>
Because it is written in C, my system needs a fast computer and lots of memory space. I feel that problem will become less important with time. Because it is written in C with a view to being as portable as possible, I am hopeful that it will be applicable to a large range of platforms. The basic techniques I am building will be applicable to other languages such as Pascal and Algol. The obvious future target will be C++, but I will be content to handle C for the moment.<P>
One of the new features I am adding is a visualization of the reduction of expressions. The user can see exactly how any expression is broken down, and also the value and type of any operand at any stage in the reduction of the expression. Another is to show the interpretation of macros and defines during the initial scanning of the source code.<P>
I am not intending to compete head to head with C compilers biased towards speed of execution. I feel a product which shows a user full information about his C program fills a need.<P>
I estimate I will have my system completed in about a month. I am looking for a small software publisher who is capable of taking my product, testing it properly and porting it to many forms. Please let me know if you can direct me towards such a publisher. Please feel free to make use of any information in this letter.<P>
(Dr.) Neil Bennett<br>
19916 190th Ave N.E.<br>
Woodinville, WA 98072<P>
<I>You took a major step toward finding a publisher by writing this letter. A significant fraction of the commercial C community watches this space. I have already passed your letter on to one interested party. Good luck.&#151; pjp</I><P>
Dear Editors:<P>
In his letter in the April 1991, issue, Volume 9, Number 4, Morton Rudin made an error in his macro for computing the square of a number. (quoted from Mr. Rudin)<P>
<pre>#define SQR(x) (((z=x)) * (z))</pre>
where z is a "scratch" float variable. Here the extra set of parentheses is to ensure x is put in z first. Parentheses have the highest precedence. It should not be necessary, but one of the things C compilers have been negligent about is following precedence rules. (end of quoted passage)<P>
Mr. Rudin has confused precedence and order of evaluation. Every C compiler I have used has always enforced precedence, but the order of evaluation is entirely up to the compiler, with the exception of certain operations. This renders Mr. Rudin's macro incorrect, as it is entirely possible and permissible to evaluate (z) prior to the evaluation of (z=x), provided that the result is consistent with the mathematical precedence induced by the parentheses. To force the computation of (z=x) to happen first, the macro should be:<P>
<pre>#define SQR(x) (z=(x), z*z)</pre>
since the comma operator does guarantee order of evaluation. Naturally, z must be appropriately defined and in scope whenever SQR() is invoked.<P>
Perhaps you should cover the distinction between precedence and order of evaluation in more depth in one of your columns.<P>
Sincerely yours,<P>
Lew Bloch<br>
P.O. Box 407<br>
Bel Air, MD 21014<P>
<I>I already did. See "Grouping," Standard C, CUJ Sep./Oct. 1988. Thanks for the correction. &#151; pjp</I><P>
Dear C Users Journal,<P>
I am in charge of software development at Cambridge Medical and read your journal eagerly each month. One reason for doing this is to identify possible "software components" and read reviews on them. Following the User Report on the C Communications Toolkit in the April 1991 issue, I felt that a report of our experiences was in order.<P>
I am a software engineer, but as an engineering profession, we are still in the stage of infancy. To refer to the state of a more mature discipline: when my electronic engineering colleagues do a design, it involves a lot of selection of components from lists provided by their manufacturers (with second sources, of course). They do design at a high level of abstraction, and generally have to do detailed (gate-level) design for a small portion of the "glue" logic. This is not true for us. Most of my design is at the lowest levels of abstraction.<P>
Our product is an ECG instrument, 68000 uP programmed in Whitesmiths C. The operating system kernel is CEXEC from JMI Associates. When we wanted to add serial communications to this, being good engineers, we shopped around for a software component which would reduce the development time. From the pages of your magazine, we identified and bought the C communications toolkit version 1.00B. An investigation of the sources suggested that the toolkit was of sufficient quality and modularity to survive the port to a different environment.<P>
A software engineer then proceeded with the port. It took him about three months to get file transfer working to and from a PC. During this time a number of problems were identified. Three general problems (e.g., files left open after transfer) and 12 specific problems were encountered (e.g. Kermit Receive can miss every other byte in some circumstances). Work-arounds or fixes were found for about half of these. We reported these problems to Magna Carta, and received an updated version (v1.01) a little while later. Then, for non-technical reasons, the project was abandoned.<P>
My complaint is that we were originally provided with a package which I would describe as "Not fit for the purpose", a term used in English law &#151; the trades descriptions act. This experience with the C communications toolkit is not unique. I have had similar experiences with packages for: operating system; terminal user I/O management, graphics terminal/printer output, DOS disc structure I/O.<P>
I am generally disappointed by the quality of software components. They generally entail more work to use than originally expected. Following their use, we have occasionally remarked that it would have been quicker to start from scratch and do the whole thing ourselves.<P>
Two pleas. Firstly, can we have more of the "lower level of abstraction" of software packages, i.e., components at the function level. Secondly, the profession has to tackle the quality issues. Is there some independent (or user) metric of quality which could be made available prior to selection of a package?<P>
Finally, this is not intended as a specific criticism of Magna Carta. They did respond promptly and courteously to our observations and sent an updated package (subject to trans-Atlantic postal delays). I have no indication that the current version of the package has not fixed all of the problems reported. The project was cancelled before this could be determined. As a software engineer, I would encourage them to continue providing software components, but to look to the degree of validation testing they do before releasing a product.<P>
Adrian P Stephens, M.A., Ph.D.<br>
Principal Software Engineer<br>
Cambridge Medical Equipments Ltd.<br>
50 Clifton Road<br>
Cambridge CB1 4FJ<br>
UK<P>
<I>I'm glad you didn't get around to your gripe list for the C compiler, since I wrote that one. Generally, I agree with your analogy to circuit design and with your assessment of the current state of the software art. I have two observations, however:</I><P>
<I>Mixing pieces of programs is far more complex than mixing electronic components. A closer analogy is requiring that a chip be composed of RTL, ECL, and CMOS technologies because you licensed masks from three different vendors. The software components business has made enormous strides in the last few years in improving interoperability. But we still have a long way to go.</I><P>
<I>Good software designers now know to design as much as possible with higher-level components such as spreadsheet packages, commercial operating systems, etc., rather than build everything from the ground up. That's where the great strides in productivity, and predictability, are coming in.</I><P>
<I>Even after the revolution, however, I can't see how to assign a simple figure of merit to most software packages. A DBMS is somewhat more complex than a resistor. We can expect to rely on product reviews and user reports for some time to come. &#151; pjp</I><P>
Dear Mr. Plauger,<P>
I am a relative newcomer to the C language despite 20-plus years programming experience. Until 10 years ago, I programmed mainly in the assembler language of whichever machine I was working on at the time. After that it was mainly Pascal.<P>
Pascal had its advantages from a production speed point of view but I always felt I was fighting it to make it do the things I wanted. With C, that is still sometimes the case, but not nearly so much. I like the way pointers are implemented, especially pointers to functions. I also like having void and casting. I don't like the way huge chunks of the library get dragged in for relatively minor function calls, but perhaps that is the implementation.<P>
I wrote a Mandelbrot program in Turbo Pascal v5.5 and later converted it to Turbo C++. The Turbo Pascal version produced an .<I>EXE</I> file that was considerably smaller and, partly because of the way floating point is emulated, faster to run. C has many other advantages, however. I tend to use Turbo Pascal for fun programming and C for the serious stuff.<P>
I've started learning C++, but the next project is urgent (again!) so I won't be using it yet awhile.<P>
Now to get to the point. I love your "Standard C" articles. They give me just the sort of background information I need to understand why C developed the way it did. I've bought your Standard C book, but was a bit disappointed that it didn't contain the same historical stuff. I know it is only supposed to be a Quick Reference, and that is how I use it. I only found out about <I>The C Users Journal</I> recently, and have, of course, become a subscriber. How can I get hold of copies of all your earlier "Standard C" articles without having to buy the last however many years worth of the magazine or getting offprints at $5 a shot?<P>
If you are going to publish the articles in a book, then I will buy it. Otherwise, could you quote me, including airmail to Australia, on copies of all your "Standard C" articles up to and including March 1991? I have received my first subscription copy for April 1991.<P>
My favorite other sections in the three copies of the Journal I've seen so far are "Puzzles" by Rex Jaeschke and "Questions and Answers" by Ken Pugh. Please keep up the good work.<P>
Yours Sincerely,<P>
Len Baker<br>
486 Whitehorse Road<br>
Surrey Hills, Vic. 3127<br>
Australia<P>
<I>You make a wonderful "straight man." I have just finished writing my latest opus. It is called</I> The Standard C Library, <I>and it contains quite a lot of the history you seem to like. Some of the material, in fact, is from past articles I wrote for</I> CUJ. <I>The book also contains a complete implementation of the Standard C library for those who love to study code or tinker with it. I have all my past articles in machine-readable form. Contact me at UNSW in Sydney or local e-mail at </I>pjp@wsa.oz<I> if you want to explore ways to get back copies. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger:<P>
John Forkosh's article ("More Accurate Linear Interpolation," May 1991) is an interesting one. Obviously, he was driven by the need for blinding speed in function evaluation of only low or moderate accuracy. Such a concern is common in scientific computing and in computer graphics.<P>
There are several improvements that can be made in such an algorithm, and there is one concern that needs to be expressed about accuracy. Least-squares curve fitting, as John used, suffers from the difficulty that it is impossible to estimate the error in the approximating function without a massive point-by-point search to compare the approximation with the original function. Numerical analysts prefer to use a Chebyshev or minimax type of approximation because the error bound is known and the error is what is sometimes called "equal ripple," or is as uniformly distributed across the interval of approximation as is possible. More about this later.<P>
One improvemnt in the method is to remove the requirement that the straight line approximation be continuous, i.e., that the straight line segments cross at the xi. Seldom is this more than a cosmetic requirement or one intended in some mysterious way to placate Mother Nature (why not require that the slopes also be continuous at the xi?). If a numerical procedure is sensitive to discontinuities in the function, it is very likely to object to discontinuities in solving a huge set of simultaneous linear equations is also removed. The determination of the constants now becomes a matter of solving a large number (the number of intervals) of 2 x 2 equations which can be "presolved" by formula. An added bonus is that the constraint removal will actually improve the accuracy of the approximation! Each line segment now is optimized over its own interval without being forced to compromise with all of its neighbors.<P>
Another improvement, contingent upon removing the constraint mentioned above, is to replace the least squares fit by a Chebyshev economization or minimax fit. Both of these are standard methods. Chebyshev is slightly less accurate, but is often good enough. A FORTRAN programmer for Chebyshev economization can be found in Carnahan, Luther and Wilkes [1], and a Pascal procedure (Remes algorithm) for producing a minimax fit can be found in Hultquist [2].<P>
Finally, equation "a," as it stands, involves three addition/subtraction operations and three multiplication/division operations. For two multiplications and two additions, one can evaluate a quadratic polynomial<P>
<pre>(a[i]*x + b[i])*x + c[i]</pre>
which will give far more accurate results over the same interval. In fact, it may be that with a quadratic interpolation, one could get the same accuracy over twice as large intervals as one gets with linear interpolation, and have a bonus in the reduction of search time that the interpolator spends in deciding which interval (x[i], x[i+1]) must be used for the argument x.<P>
Yours Sincerely,<P>
Paul F. Hultquist<br>
Professor Emeritus of Electrical<br>
Engineering and Computer Science<br>
University of Colorado at Denver<br>
6803 North 68th Plaza<br>
Omaha, NE 68152<P>
References:<P>
1.     <I>Applied Numerical Methods</I>, B. Carnahan, H. A. Luther, J. O. Wilkes, John Wiley and Sons, Inc., 1969.<P>
2.     <I>Numerical Methods for Engineers and Computer Scientists</I>, P. F. Hultquist, Benjamin/Cummings, 1988.<P>
<I>Numerical analysis seems to be a bottomless pit. Thanks for shining the light a bit deeper. &#151; pip</I><P>
Dear CUJ,<P>
I am a new subsciber of your wonderful magazine and wanted to tell you that I thoroughly enjoy every issue I receive. I am fairly new to programming, a college sophomore CS major, and learn something new and useful in each and every issue. I especially enjoyed the articles by Art Shipman on multiple <I>char</I> array allocation and the string comparison article by Hans Zwakenburg. I just have two comments about the second article. First, I really liked the use of <I>#define DEBUG</I> to run the program as standalone and remove the definition for use as a function. Very creative. Second, this question will seem very novice, but that's what I am, so I will ask it. What is the benefit of using a comparison algorithm like Levenstein's rather than a conversion of the strings to uppercase or lowercase and a <I>strcmp</I> or <I>strncmp</I> call? I'm sure this is very obvious to professional programmers, but I'm lost. Thank you for your wonderful magazine. I dutifully await the next issue.<P>
Sincerely,<P>
Andrew Tucker<br>
Seattle Pacific University<br>
SUB Box 2241<br>
Seattle, WA 98119<P>
<I>Sometimes an exact comparison misses the point. &#151; pjp</I><P>
Dear Editor:<P>
I've been kicking around the MS/DOS environment for several years now, hoping someday to learn enough about C to write a few small applications. The only language experience I have is with dBase, where I'm able to write very tight programs, if not elegant applications.<P>
How does one learn C? Put another way, can I learn C without learning Basic or Pascal? How much do I have to learn about the architecture of the machine &#151; and should I learn about the machine with C, assembler, or a good book on the operating system (DOS)?<P>
I doubt I'll ever have time to take classes, so I'd like to teach myself. C isn't dBase, but then C ain't assembler either. The question is what method is best. I subscribe to <I>CUJ</I> because, like anything else, reading good code is important. Somewhere between learning syntax, data types, etc. and allocating memory in protected mode (which I don't plan to do soon), there's a way to teach C without learning another language (right?!).<P>
I plan to go with Borland, and I bought a few C books by the Waite Group and others. I'd love to get a C code generator like Pro-C, but I'm afraid it might be a waste &#151; and my wife would torch my computer if I did anyway, 800 cruiser on top of the 350 for Borland C++!<P>
Thanks for whatever guidance you may provide.<P>
Sincerely,<P>
Glenn White<br>
4308 28th Place #28<br>
Mt. Rainier, MD 20712<P>
<I>Sounds like you're off to a good start. There are oodles of books that endeavor to teach C at various levels. Find one that you like, then practice, practice, practice. &#151; pjp</I><P>
Dear Mr. Plauger,<P>
I have recently begun reading <I>The C Users Journal</I> and have found it very useful. I have one question, though. Is the code displayed with various articles available from some on-line source for downloading?<P>
It would be nice if this were the case, since many of us would prefer not to type things in from a magazine when trying new algorithms.<P>
Other than this one question I do think <I>CUJ</I> is quite a good publication and intend to continue using it.<P>
Scott Hopson<P>
<I>76207. 674@compuserve. com</I><P>
<I>The source for each issue is available on diskette from R&amp;D Publications. We are still investigating on-line options. Thanks for writing. &#151; rlw</I><P>
Dear Mr. Percy:<P>
I have just read your letter in the May 1991 issue of <I>The C Users Journal</I>. I'm sorry that you feel you were "subjected to" my article on large arrays, and that you questioned renewing your subscription as a result.<P>
I, too, am always reluctant to attribute a problem to a compiler bug, since (like all programmers) I have learned over the years that the great majority of program problems are self-inflicted. Now and then, however, when I cannot find any relevant documentation, and the code's behavior seems to contradict everything I have read, I am forced to consider certain instances of behavior to be bugs.<P>
Even if the "bug" turns out to be a documented feature, however, the user is still forced to deal with it, to get around it in some way. That was what my article was intended to do &#151; to help other users use large arrays without running into the same obstacles that I did. You seem to be a knowledgeable C user, able to avoid certain mistakes without the need for an article such as mine. Your compiler also seems to provide more helpful messages than mine, and perhaps your documentation is also better; I can only report what I know. The responses I've received, however, indicate that there are a few grateful readers out there whose C expertise is (even) less than mine, who found the article useful, and who look forward to seeing other articles in <I>The C Users Journal</I> that they can understand and put to practical use. I learned something from your letter and hope you will consider contributing an article some day.<P>
Incidentally, I use Turbo C regularly and consider it an excellent product &#151; in fact, I used the word "excellent" in the draft I submitted, but it was edited out. However, lately I have compiled problem programs with Power C as well, and have found the second opinion it provides to be very helpful in eliminating bugs which go unreported in Turbo C.<P>
Sincerely,<P>
Stuart T. Baird<br>
927 Parkview Drive F-301<br>
King of Prussia, PA 19406<P>
Dear Dr. Plauger,<P>
I would like to let you know how much I appreciated Greg Chursenoff's article on serial communications in the April 1991 issue. I had been unsuccessfully attempting to write an interrupt routine to handle pulses from an anemometer for an AT-based weather station that I am building. The RI input on the serial port was exactly what I needed.<P>
Regarding the debate over the amount of source code needed for publication, I think that Greg's article is just right. (A succinct but complete program with sensible commenting and a clear description).<P>
Yours Sincerely,<P>
Garry Boyce<br>
116 Sheoak Rd<br>
Crafers<br>
S.A. 5152<br>
Australia<P>
P.S. Hope that you are enjoying your stay in Australia.<P>
<I>Thanks, mate. &#151; pjp</I><P>
Dear Rex,<P>
I am most surprised that P. Lyle Mariam (<I>CUJ</I> letters, April 1991) should have assumed that your puzzles were aimed at beginners. I have been programming for quite a few years, and in C for the last three. I was pleased to be able to answer nearly all the questions correctly, though I certainly had to put my thinking cap on.<P>
Furthermore, I like the way you gave the 'answers.' Most of the problems required informed interpretation of the C Standard, and deserved the detailed explanation they received. I thought the style and content of the answers was just right.<P>
My only complaint about your puzzles is that there aren't any! They had rapidly become my favorite part of the magazine, and I am sadly disappointed by their disappearance. Is there any chance they will return? Preferably as a regular, monthly feature. (Are you listening PJP?)<P>
Ian Cargill<br>
Senior Software Engineer<br>
Wyatts<br>
Surrey, UK<P>
<I>Editors can only edit copy submitted by writers. Are you listening, Rex? &#151; pjp</I><P>
Dear Mr. Ward:<P>
I agree with the points raised by Mr. Brad P. Smith in the letters section of the June 1991 issue of <I>The C Users Journal</I> regarding the use of one of the national networks for the distribution of C source code.<P>
The issue that I would raise is that much care should be given to choosing such a network. CompuServe is expensive and so is BIX last time I checked into it. GENIE seems reasonably priced according to their last price sheet that I received. Delphi is one of the most reasonably priced services and it can be accessed through both Telenet and Tymet.<P>
One of the things that really bugs me about both CompuServe and GENIE is that they insist on charging me a monthly "service fee" whether I use the service in a given month or not.<P>
In view of your world-wide readership, the issue of accessibility to your foreign readers needs to be taken into account. Based on past experience, it is typically much more expensive for foreign users to access a U.S.-based service due to tariffs imposed by their local telephone service provider, but this may have changed somewhat in the past year or so.<P>
I really enjoy <I>The C Users Journal</I> each month, please keep up the good work!<P>
Sincerely,<P>
James E. Truesdale<br>
4645 LaGuardia<br>
St. Louis, MO 63134<P>
<I>Living abroad has shown me any number of barriers to communication with U.S.-based services. I haven't found a good solution yet, either. &#151; pjp</I><P>
Mr. Plauger:<P>
More and more, DOS-based C writers are faced with programming in protected mode using either the Microsoft Windows environment or a DOS extender. When these programs go out into the field however, we discover that systems often are configured for both expanded memory and extended memory. Expanded memory managers that are not in conformance with the VCPI or DPMI standard will usually cause Windows or the extender to crash, sometimes with a relevant error message, sometimes not. If the EMM is in conformance, there is usualy no problem.<P>
An extremely useful C function would be to be able to test for the conformance of an EMM driver to the VCPI standard and then have the program provide a graceful resolution/error message accordingly. With a DOS extender, this could be done in real mode before the program itself actually runs in protected mode and causes a crash. It should be noted that detecting the presence of an EMM driver by the <I>int 67h</I> or <I>int 21h</I> function <I>44h</I> (IOCTL) doesn't cut the mustard.<P>
Sincerely,<P>
Thomas Brown<br>
Aries Systems Inc.<br>
One Dundee Park<br>
Andover, MA 01810<P>
<I>Good idea. Any volunteers? &#151; pjp</I><P>
Dear C Users Journal,<P>
Regarding "Word Counting" by L.J.G. Schumerhorn (<I>CUJ</I>, June 1991), did anyone technically competent preview the manuscript &#151; or were you folks just short on material? That WordPerfect 5.1 yields a higher word count than Schumerhorn's pet routines surprises me to no end.<P>
The notion that "a text cannot contain more words than blanks plus one" is absurd. I ain't sure what's customary in Kansas, but &#151; where I come from &#151; punctuation characters [ASCII 33-47, 58-64, 91-96, and 123-126] often imply word breaks. (Kansas-must-be-much-closer-to-Oz-than-I-ever-suspected!)<P>
Apart from this insufferable waste of white-space, your publication remains worth my time &#151; my renewal check will arrive promptly. And &#151; finally &#151;  please pardon my nastiness, I've had a bad day (a convoluted state machine is misbehaving!). Thank you for your time and trouble.<P>
With my regards,<P>
Dan J. Kolar<br>
4901 West McGuire Road<br>
Lincoln, NE 68524<P>
<I>Yes, you are being a bit touchy in my book as well. As always, I defend the right of our authors to take a simple view of the world at times. That happens to be just what many of our readers need, particularly the ones new to C. I'm glad we score often enough at your level of sophistication as well. The balancing act is never easy .&#151; pjp</I><P>
Dear <I>CUJ</I><I>:</I><P>
Mr. Schermerhorn assumes a word is defined as a set of non-space characters followed by a blank. It ain't necessarily so.<P>
When I worked as a an editor (<I>Isaac Asimov's Science Fiction Magazine</I>) we defined a word as six text characters. We skipped the title page and the header and footer, estimated the number of lines per page and characters (counting spaces and punctuation) per line, divided by six and paid the author on that basis. Since there were usually about 22 lines per double-spaced page and 65 characters per line, this came out to about 240 words per page.<P>
It sounds as if WordPerfect may be doing something similar, although their ratio of bytes to words (4.3) is a bit low for the six characters per word rule we used. It is about right for five characters per word (and not counting control characters or headers or footers. I suggest Mr. Schermerhorn check the WordPerfect documentation.<P>
Sincerely,<P>
John Ashmead<br>
139 Montrose Avenue<br>
Rosemont, PA 19010<P>
<I>The word-counting program that Kernighan and I wrote for </I>Software Tools<I> was as simplistic as Mr. Schermerhorn's. It's amazing how closely various methods agree for a large enough sample, even if they differ in many small details. I barely resist making a snarky remark about what </I>IASFM<I> and other science-fiction mags pay for those words they count. &#151; pjp</I><P>
Dear Mr. Plauger,<P>
I am a recent re-subscriber to <I>CUJ</I>. The tone of the magazine appears to be more academic than when I last subscribed. This is a Good Thing; cranial exercise is very hard to come by in print these days.<P>
If you believe that critical mass is the driving force behind many a good project, please let me add the mass of this letter to the BBS proposals. In <I>CUJ</I> 9.6, Brad P. Smith suggested using one of the established BBSs as a gateway. This makes perfect sense:<P>
1) Putting the library on a BBS eliminates the need to charge for media and mailing, which should make your accounting easier.<P>
2) Easier access allows "browsing." If I have to mail away for code that might be interesting, I probably won't. If I can quickly download it, it is more likely to be looked at and used.<P>
3) The BBS will most probably contain a message forum. This will allow <I>CUJ</I> to get more timely feedback about the magazine and library code problems.<P>
4) Most importantly, the BBS is a natural publicity cow (like a "cash cow"). Every time some unassuming CompuServe member (whoops, my bias is showing!) happens to walk through the service looking for new forums, you get another potential subscriber.<P>
The downside is that management of the forum will be much more difficult than managing the current library, just due to the sheer volume of messages that are more easily generated by BBS than U.S. Mail. However, if your ultimate purpose is to spread enlightenment about the C language, (and to me it looks like that is exactly your manifesto) there shouldn't be a question as to whether or not it should be done.<P>
If you want practical advice on how to set it up, I suggest you talk to the Ziff Davis people (if they don't consider you potential enemies.) They have ZiffNet set up on CompuServe for PC Magazine, PC Computing, PC Weekly and a host of other magazines.<P>
In closing, let me re-emphasize that a BBS for <I>CUJ</I> code would be a most outstanding tool.<P>
Sincerely,<P>
Matthew O. Persico<br>
2846 East 197th St.<br>
Bronx, NY 10461<P>
<I>Noted. &#151; pjp</I><P>
Dear Sir:<P>
In regard to E. J. McConnell's letter in the June 1991, issue on graphics play routines, <I>Bit-Mapped Graphics</I> by Steve Rimmer (Windcrest Books/ McGraw-Hill, Inc., ISBN 0-0306-3558-0) might provide some of the information needed.<P>
The book covers the file formats for MacPaint, GEM/IMG and Ventura Connection, PC Paintbrush PCX, GIF, and TIFF. Encoding and decoding of these formats is covered, plus LZW compression and decompression. Also discussed are high-speed monochrome and color screen drivers, PostScript printers, dithering, and format translation. Most of the code is in C with some in 8086 assembler.<P>
Sincerely,<P>
Susan M. Johnson<br>
1515 Albany Circle<br>
Rock Springs, WY 82901<P>
<I>Thanks. &#151; pjp</I><P>
Dear Editor,<P>
I am a novice C programmer mostly interested in realtime applications. So far I have done almost all my programmming with various PLCs (ladder language) but am slowly turning toward a more flexible programming language.<P>
C seemed to be the hottest, and the most capable language to manipulate bits. So I have chosen C.<P>
I have decided to go slow on this and do some practicing at home before I start to do the first "real work." During practicing I got into a problem which is easily solved, but I believe there must be a more elegant way than I'm able to figure out.<P>
Let's say you have a program with a number of options for the user to select. Depending on the selection, the user shall add new data, edit existing data, sort data, and so on.<P>
My program uses a function I've called <I>get_str</I> which takes a <I>char</I> pointer (<I>str_address</I>) and an <I>int</I> (<I>max_str_length</I>) as arguments. This function stays in a loop until the <I>Enter</I> or <I>Esc</I> key is pressed. (I have seen more or less similar functions printed in your magazine.)<P>
The problem arises when I want to call the <I>get_str</I> function from various places in the program. If I want the function keys to have different meanings depending on the calling function, I could have a number of <I>switch</I> statements to check which key is pressed and who is calling. However, I believe it must be possible to have a routine outside the <I>get_str</I> function that generates an "interrupt" each time a function key is pressed.<P>
This is a principal question: Is it possible to have a routine working in the background that comes into action whenever a certain situation occurs, even when you are in a loop which does not test for this situation?<P>
I hope you can help me out on this and I thank you in advance for any thoughts you might offer. I'm using Turbo C for MS-DOS.<P>
Sincerely,<P>
Per Chr Borgvad<br>
Kontravn 4c<br>
1400 Ski<br>
Norway<P>
<I>You have discovered the need for "interrupt handlers." Check for that phrase in a few books on DOS programming. One of them should explain the mechanics at the level you need. And be careful &#151; interrupts offer numerous  opportunites for subtle programming bugs. &#151; pjp</I><P>
Dear Editor,<P>
This letter answers your request for a source of graphics file format information, re: We Have Mail, <I>CUJ</I>, June 1991. In response to the reader inquiry concerning programming screen capture utilities in C, we submit the following source books:<P>
<I>Visualization Graphics in</I> <I>C</I>, Lee Adams, ISBN 0-8306-7487-X, 1991, hardback.<P>
<I>Bit-Mapped Graphics</I>, Steve Rimmer, ISBN 0-8306-3558-0, 1990, paperback.<P>
Both books are published by Windcrest Books, Blue Ridge Summit, PA 17294-0850, and are probably available through the better libraries.<P>
<I>Visualization Graphics in C</I> is a beginning tutorial for programmers just getting into the field and is loaded with valuable source code, including binary screen capture utilities. The book achieves the stated goal of the author, to provide a learning tool designed to teach graphics programming. We highly recommend this publication to anyone not already well-versed in this area.<P>
<I>Bit-Mapped Graphics</I> is another invaluable source of C routines based on the five most popular image file formats. This book has become our standard reference for specific information on encoding, decoding, and the manipulation of image files. This reference also includes working examples of C source code for use with many popular display adapters and printer.<P>
For Windows applications, most of the information is usable if a resource compiler is available to develop and bind the graphics file to an <I>.EXE</I> or <I>.DLL.</I> While the theory remains valid, considerable effort will be necessary to adapt the example code to the Windows platform. The TSRs and screen capture utilities are not conducive to the Windows program environment and will behave erratically. We have found very little reference information in the area of screen capture utilities for Windows and welcome any forthcoming articles or ideas.<P>
Until Bob Montgomery <I>(VPIC.EXE)</I> decides to publish, perhaps your book reviewers can take a look at both of these excellent sources of information on graphics programming in C with a view towards the fastest growing field in PC business software &#151; graphics!<P>
Sincerely,<P>
Robert T. O'Dell<br>
Chief, Program Development<br>
Phase IV Computer Graphics<br>
12708 North Freeway<br>
Houston, TX 77060<P>
<I>Thanks. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger,<P>
In the June 1991 issue Mr. Todd Weiss corrected some mistakes in Stuart Baird's article "Using Large Arrays in Turbo C." Unfortunately, Mr. Weiss made a couple of mistakes of his own.<P>
The first is one I'm surprised you did not catch &#151; the statements about ANSI conformance. An ANSI-conforming compiler only needs to properly compile ANSI conforming programs. One restriction on conforming programs is that they not exceed any of the translation limits in section 2.2.4.1. One of those limits is that a single data object can be as large as 32,767 bytes. All of Mr. Weiss's arrays violate that limit, and so the compiler is under no obligation to compile them. So Turbo C is in conformance with the standard, at least on this point.<P>
Mr. Weiss's befuddlement over the wraparound problem is due to his second mistake. He presumes that because <I>far</I> pointers are 32-bit quantities they are 32-bit integers &#151; they are not. <I>far</I> pointers are composed of two separate and independent 16-bit unsigned quantities, one for the segment and one for the offset used by the Intel chips. Adding any integer value to a <I>far</I> pointer adds the value only to the offset portion. Since unsigned addition is wraparound, that's what happens with addresses as well. The following code demonstrates the problem rather nicely.<P>
<pre>#include &lt;stdio.h&gt;
int main(void)

{
int far *ptr1, *ptr2;

   ptr2 = ptr1 + 32768;
   if(ptr2 == ptr1)
      puts("Pointers are the same!");
}</pre>
This program will print the statement, since <I>32768 * sizeof(int)</I> is 0 done modulo 65536. This is the reason that <I>far</I> objects are limited to 64K in Turbo C, as well as in Microsoft C.<P>
It is possible to have objects larger than 64K, but only by declaring such objects with the keyword <I>huge</I>. <I>huge</I> pointers are also double 16-bit items just like <I>far</I> pointers. The difference is that the compiler will generate extra code to ensure that the offset portion of the address is less than 16, with any excess divided by 16 and added to the segment portion. Changing the sample program above to use <I>huge</I> pointers instead of <I>far</I> pointers makes the pointers differ. These extra instructions make the resulting code both larger and slower, which is why they are not the default.<P>
Perhaps it is time to persuade someone to write an article about addressing on Intel processors.<P>
Sincerely,<P>
Robert L. Milton<br>
E.R.M.Associates<br>
P.O. Box 1032<br>
Agoura Hills, CA 91301<P>
<I>You're correct about the ANSI limitations on data-object size. Much of the machinery added to C for the 803x86 family is pure extension, however. At issue is reasonable or expected behavior, not what the law requires. Any number of articles have tackled various aspects of this thorny issue. For a broad overview, see my article in the February 1987 issue of</I> Computer Language <I>titled, "Son of PC Meets the C Monster." The title says it. &#151; pjp</I><P>
Dear Mr. Plauger,<P>
I am writing to complain and let other readers know of extra financial considerations for choosing between Microsoft QuickC and Borland Turbo C.<P>
First of all, when you buy QuickC you get two abridged manuals. If you want the complete set of reference manuals you must pay extra. Microsoft thinks on-line reference is sufficient. For some people that may be true.<P>
Then there is the question of the font files. The QuickC manuals (even the extra ones you can buy) don't mention the royalty payments due to Bitstream if you distribute any font files with your program. According to the technician I spoke to at Microsoft, you must sign a contract with Bitstream for a license fee of $500. If you can only budget for a $75 compiler how can you afford $500 to distribute a font file with your program?<P>
I read somewhere that Turbo C's manuals give you permission to distribute the font files with your program royalty-free. I'd like to know if this is true. If so, I will buy Turbo C (or Turbo C++ if it includes fonts). It's less  expensive to buy another compiler that offers free use of fonts than it is to pay a $500 royalty fee!<P>
In the May issue of <I>The C Users Journal</I> a letter from Gerhard Wilhelms mentioned how to get a free font editor from Borland. From what I've discovered so far, buying a font editor is another expense if you want to edit QuickC fonts.<P>
It was Mr. Wilhelm's letter and Mr. Kolias's letter in the December 1991 issue which prompted my inquiries to Microsoft regarding the font files. Although the answer I received about royalties displeased me, I'm glad I avoided a potential lawsuit. My application requires fonts. I was just beginning the distribution phase of my project. Now, due to this technicality regarding royalties, I must go back to the development phase.<P>
I don't know how QuickC and Turbo C compare otherwise (that's the disadvantage of commercial software compared to shareware), but I feel that Microsoft is obligated to its users to warn them of the required royalties somewhere in the license agreement or manuals.<P>
To any Borland executives who might be reading this letter: Are you planning any upgrade offer to dissatisfied QuickC users?<P>
Belinda Aboshanab<br>
446 S. Lima Circle<br>
Aurora, CO 80012<P>
<I>Fonts are yet another piece of intellectual property to add to the muddle over software ownership and royalties. The laborer is worthy of his hire, whether he crafts fonts, functions, or folk tunes. I'll bet there are permissions pitfalls even among shareware programs at this stage of evolution. I welcome any informed commentary on the state of the industry. &#151; pjp</I><P>
Dear Mr. Plauger,<P>
I am writing in response to the letter in the June, 1991 issue of <I>The C Users Journal</I> from E.J. McConnell.<P>
The only book I have found that deals with reading and writing different graphics files is <I>Bit-Mapped Graphics</I> by Steve Rimmer. Published by Windcrest Books in 1990, it covers .<I>MAC, .PCX, .GIF</I>, and .<I>TIFF</I> file formats. The code is written in C with assembly. For me, the use of assembly was a drawback since I'm still teaching myself C. However, the speed of assembly becomes necessary for quickly packing and unpacking graphics files.<P>
The book also deals with graphics output, converting files between the graphics formats, and a lot of other valuable information. I would have liked to see more on graphics output to dotmatrix printers. However, that's probably a book topic in itself. If anyone knows of such a book, I'd like to know about it. To get a copy of the book write to: Windcrest Books, Imprint of TAB Books, Blue Ridge Summit, PA 17294-0850. TAB Books has a book club, and I've seen this book in their ads as one of the choices for the introductory offer. They also have the <I>C Programming Series</I> by Lee Adams which covers the topics of animation, simulation, 3D, CAD, and Paint programming.<P>
Also, at this time I'd like to address the issue of a BBS. Rather than have your own BBS you could make the code listings available on other large BBSs, some belonging to software companies. I've seen other magazines do this, and unlike using CompuServe, as was suggested by Brad Smith, I believe these boards are free. Just to name a few:<P>
Ithaca Street (303) 494-8868 &#151; CO<br>
Pathfinder (408) 246-0164 &#151; CA<br>
Magna Carta (214) 226-8088 &#151; TX<br>
Magma Systems (201) 912-0668 &#151; NJ<br>
C BBS (703) 644-6478 &#151; VA<P>
Sincerely,<P>
Belinda Aboshanab<br>
446 S. Lima Circle<br>
Aurora, CO 80012<P>
<I>Thanks for the info. </I>&#151;<I> pjp</I><P>
Dear Mr. Plauger (via e-mail):<P>
I have been reading your article in <I>The C Users Journal</I> about <I>locale.h</I> with great interest. What really was funny was that just last week our company had a seminar concerning the subject and I was able to act somewhat knowledgable because of what I had read.<P>
When I mentioned that I had read about the stuff in <I>The C Users Journal</I>, I was asked to make a copy of the article and pass it around to our department. Since I notice that the entire magazine is considered copyrighted, I wanted to ask you or the magazine (since you are the editor) for permission to reproduce the series of articles and pass them around to our department.<P>
If there is a problem, can you tell me what to do in order to get copies or permission? I'm sure my company will be happy to do what's necessary.<P>
One more question, since I am writing you. I notice that you have written a book, <I>The Standard C Library</I>. What I'm looking for is a <I>complete book</I> describing the ANSI C standards with, possibly, a chapter or something just going over the differences between Standard C, as described by Ritchie and Kernigan. I'm real concerned (since many of the books came out before ANSI completed their decision on the standard) that the books I have are not complete. Do you have a recommendation for a book that would be complete? If not, do you know how an individual such as myself can get a copy of the actual standard from ANSI?<P>
Thank you very much for your help. Keep up the great work with <I>The C Users Journal</I>. I'm considering submitting some ideas/articles myself soon.<P>
Chris Carlson<br>
<I>carlson@support.newport.sgi.com</I><P>
<I>You have my permission to distribute copies of my article for internal use. I speak as the author, since I own the residual rights in this case. And thanks for asking &#151; not everyone bothers to do so.</I><P>
<I>A complete summary of the C Standard can be found in</I> Standard C, <I>written by Jim Brodie and me and published by Microsoft Press. The summary of changes you're looking for can be found in Tom Plum's</I> Notes on the Draft C Standard, <I>published by Plum Hall, Inc. Both books are available from the C Users Bookstore, which invariably advertizes in</I> The C Users Journal (<I>oddly enough</I>). <I>You can obtain the ANSI C Standard from ANSI in Manhattan. &#151; pjp</I><P>
</BLOCKQUOTE>
</BODY>
</HTML>
