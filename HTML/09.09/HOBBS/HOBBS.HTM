


<HTML>
<HEAD>

<TITLE>September 1991/Computers, Pattern, Chaos And Beauty</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Book Reviews</FONT></H2>

<hr><h2 align="center"><font color="#800000">Computers, Pattern, Chaos And Beauty<A name="0209_010B"><A name="0209_010B"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0209_0000"><A name="0209_0000">Reviewed by Sam Hobbs</font></h3><hr><blockquote><P>
<P><i><A name="0209_0000"><A name="0209_0000">Sam Hobbs is a Senior Project Manager at GDS Associates. He is an avid C programmer and assisted in the development of the PowerPro daily load forecasting and energy resource scheduling package. He currently is on the steering committee for the Atlanta Object Oriented Programmers Group. Readers may contact Sam at GDS Associates, Inc., Suite 720, 1850 Parkway Place, Marietta, GA 30067, (404) 425-8100.</i></P><P>
Clifford Pickover challenges readers to understand through seeing. He states that his book could have been entitled "Adventures in Computing" and frankly describes it as a collage of topics. The book is immensely fun and challenging and is packed with widely ranging topics.<P>
Striking black and white figures appear on nearly every page, and there are eight pages of color plates. In addition to the expected discussions of fractals and chaos, there are fascinating discussions of automatically generating different expressions on cartoon faces, computerized visual enhancement of the Shroud of Turin, simulation of plant growth patterns, DNA analysis, and randomly generating patterns of circles, to name only a few. The diverse topics and figures spur interest in reading even for a few spare minutes at a time. The fact that each chapter and most sections of each chapter are nearly independent makes such an approach a practical strategy.<P>
Every section of the book provides insights into some aspect of visual computing. Perhaps more important is the discussion of how to do it, the encouragement and challenge to try it yourself, and the suggestions for experimenting with the basic ideas laid out in the book. Efforts to try it yourself will be richly rewarded by even further insights as you deal with the mechanics and inevitable difficulties of working from a set of suggestions and sketchy recipes rather than from hard source code.<P>
Most of the figures in the book have a reasonable amount of discussion of how the graphics were generated. A few, however, appear to have been generated with powerful ray-tracing programs which properly take into account light sources in rendering highlights and shadows. The book simply shows those figures and does not discuss the particular techniques used.<P>
Although the book is not formally mathematical, the non-mathematical reader will find many areas intimidating. There are no propositions, proofs, or purely mathematical sections, but understanding all of the material requires knowledge of algebra, trigonometry, calculus, differential equations, complex variables and various special functions and analysis techniques. However, just as the book covers a wide range of topics, material is discussed at widely different levels of mathematical sophistication.<P>
The discussion of cartoon faces, visual enhancement methods, and random generation of circles (to name only a few areas) are accessible by virtually anyone with the computer and software resources to write graphics programs, regardless of their level of mathematical sophistication. The more difficult mathematical material usually has some introductory discussion, but not enough to carry someone without a strong background.<P>
Although there is no working code in the entire book, there are many fragments of pseudocode. One is only four lines, most are 15 to 20 lines plus a few lines of explanation, a few others cover as much as an entire page, and one long fragment covers two and half pages (though it is split into three separate listings). Most of the psuedocode resembles PL/I. All of the fragments are straightforward. The occasional minor inconsistencies are no barrier to understanding.<P>
A C programmer with access to graphics primitives can easily (and quickly) translate the psuedocode to C. Making it into real working code is not always as simple. Some of the pseudocode requires little more than line-by-line translation. Other pieces appear deceptively simple until you try to translate it to real working C.<P>
Complicating issues related to system dependencies involve the direct access and display of large arrays (say 2000 X 2000), dealing with colors or gray scales, and, in a few cases, the need to do millions of floating-point calculations before actually getting the display. Other complicating factors involve the underlying mechanics of a particular program. The pseudocode which appears to be (and usually is) simple is only the first step.<P>
For example, once you have code that will produce some of the fractal displays, visual enhancement of the resulting image is required before the display can be properly viewed. (The enhancements are discussed in the chapter on the Shroud of Turin and are not difficult. There is simply an extra level of complication that is not obvious.) In addition, an iterative function to generate the fractal must be written. Again, this is not difficult (although it may be involved).<P>
In some cases, before you can write the generating function, you must develop a set of functions to do arithmetic with complex numbers. Having access to builtin complex arithmetic (for example, in a C++ class) would be a definite advantage.<P>
If you are reasonably knowledgeable of mathematics and interested in doing the kinds of things described in <I>Computers, Pattern, Chaos and Beauty</I>, none of these complications should discourage you. I developed a sample application following the suggestions in Appendix B for generating random tangent circles (see <A href="list1.htm">Listing 1</a>)
.<P>
As an example of the kind of visual fun you can have following Pickover's advice, I had the first (though not the final) version working in about twenty minutes. During the remainder of that first hour, everyone who got a glance at my computer screen commented in virtually identical words "That's neat. Are you developing a screen saver?"<P>
The main function in <A href="list1.htm">Listing 1</a>
encapsulates most of the system dependencies. I implemented this program using the C-compiler portion of Borland C++ and the Borland Graphics Interface. The only actual drawing function used is circle. The <I>exit_if_kbhit</I> function allows a user to exit by striking a key. This function is needed particularly if you change any of the parameters and end up caught in an endless loop, or if you want to exit before the program is finished. (A typical program running time is from 45 seconds to two minutes on a 20 MHz 386, most of which is taken up by randomly searching for where to place the next circle as more and more of the screen is used up.)<P>
Global variables are used for an array of circles, the index to the current circle, and the maximum allowed radius. Using the global variables provides needed access by several different functions. Functions <I>distance</I> and <I>new_radius</I> calculate the distance from a point to a specific circle and from a point to the nearest circle respectively. A negative distance is an indication that the point lies inside another circle.<P>
The function <I>generate_circles</I> simply draws a random first circle and then randomly and repeatedly searches for a point outside any previously drawn circles and draws a new circle which is tangent to its nearest neighbor. The maximum radius allowed is half of the maximum screen dimension, to prevent one of the first few circles filling virtually the entire screen and causing excessively long running times while the random search (slowly) finds the remaining small area in which to draw the remaining circles. The parameter of 150 for the maximum number of circles works reasonably well and gives pleasing results. You may want to change it.<P>
Pickover suggests many variations on these random tangent circles such as size limitations, different kinds of random placement, and using filled rather than hollow circles. <A href="list2.htm">Listing 2</a>
contains code to fill the circles with random colors. This frequently results in pleasant displays.<P>
I enjoyed <I>Computers, Pattern, Chaos, and Beauty</I> and recommend it highly, but with strong reservations for those people who are not mathematically inclined. If you have any doubts, try to browse through the book before making a purchase and see if the level of mathematics is going to be a problem.<P>
<I>Computers, Pattern, Chaos, and Beauty</I><br>
Clifford A. Pickover<br>
St. Martin's Press, 1990<br>
$29.95, 394 pages<br>
ISBN 0-312-04123-3<P>

<h4><a href="../../../source/1991/sep91/hobbs.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY>
</HTML>
