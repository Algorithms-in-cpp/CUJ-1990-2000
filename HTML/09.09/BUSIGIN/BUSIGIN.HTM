


<HTML>
<HEAD>

<TITLE>September 1991/The QNX Operating System</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   User Reports</FONT></H2>

<hr><h2 align="center"><font color="#800000">The QNX Operating System<A name="0207_0109"><A name="0207_0109"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0207_0000"><A name="0207_0000">Comments by Nick Busigin</font></h3><hr><blockquote><P>
<P><i><A name="0207_0000"><A name="0207_0000">Nick Busigin has a chemical engineering degree from the University of Toronto. He works in the Advanced Engineering Department for Standard Products (Canada) Ltd., currently specializing in control system design and implementation. Nick can be contacted through Compuserve: CIS ID 74075, 1501.</i></P><P>
This article describes the QNX operating system v2.15C which runs on the IBM 80x86 class of computers. It is sold by Quantum Software Systems in Kanata Ontario, Canada. This article will focus on the structure of the QNX operating system and the inter-task communication mechanisms available to the QNX programmer. The bibliography at the end of this article provides sources for additional information.<P>
<h4><FONT COLOR="#000080"><A name="0207_010A">Background Information<A name="0207_010A"></FONT></h4></P>
QNX is a multitasking, multi-user operating system designed with the real-time software developer in mind. It has a message passing, server-oriented architecture that facilitates distributed processing and provides transparent access to all resources across a network. Most of the QNX operating system was written in C.<P>
I am a chemical engineer and have been using QNX for a little over four years. I am most interested in process control. I have used QNX in SCADA (Supervisory Control And Data Acquisition) and networked embedded control applications.<P>
<h4><FONT COLOR="#000080"><A name="0207_010B">Structure Of The QNX Operating System<A name="0207_010B"></FONT></h4></P>
QNX consists of a small kernel and five system tasks that are created when the operating system is booted. The QNX kernel is small &#151; about 10Kb in size. Its primary function is to look after inter-task message passing (hence task synchronization) and clock interrupt handling. The rest of the operating system functions are handled by special administrator tasks.<P>
<h4><FONT COLOR="#000080"><A name="0207_010C">Task Administrator (<B><I>task</I></B>)<A name="0207_010C"></FONT></h4></P>
This operating system task creates and terminates tasks, allocates memory, and registers task names. It runs at priority level 1. (QNX priorities range from 1 to 15, with 1 being the highest and 15 being the lowest.)<P>
<h4><FONT COLOR="#000080"><A name="0207_010D">Device Administrator (<B><I>dev</I></B>)<A name="0207_010D"></FONT></h4></P>
This operating system task runs at priority level 2. It looks after all the character devices attached to the system, such as the printer and serial ports, serial terminals, modems, and full screen windows (virtual terminals). The device administrator looks after setting hardware parameters, such as serial port baud rate, parity, stop bits, etc. It also provides character echoing, line editing, line erase, and line recall features. This task also handles requests to open, read, and write to devices.<P>
<h4><FONT COLOR="#000080"><A name="0207_010E">File System Administrator (<B><I>fsys</I></B>)<A name="0207_010E"></FONT></h4></P>
This task runs at priority level 3. It looks after the QNX file system. This task handles all requests to open, read, and write files.<P>
<h4><FONT COLOR="#000080"><A name="0207_010F">Network Administrator (<B><I>net</I></B>)<A name="0207_010F"></FONT></h4></P>
The net task looks after communication of messages over the QNX (Arcnet) network. The net task runs at priority 3. It is started when the system is booted but will automatically terminate itself if it is running on a system that does not contain a network card.<P>
<h4><FONT COLOR="#000080"><A name="0207_0110">Idle Administrator (<B><I>idle</I></B>)<A name="0207_0110"></FONT></h4></P>
The idle task runs at priority level 15, which is the lowest priority available under QNX. Its main purpose is to use up any CPU time that is not used by other tasks.<P>
There are a number of other administrator tasks that come bundled with QNX. Running these tasks is optional, as the operating system is fully functional without them. They provide additional operating system services if there is a need for them. This "mix and match" approach to configuring your operating system environment comes naturally with a server-based architecture. The optional QNX administrator tasks are described below.<P>
<h4><FONT COLOR="#000080"><A name="0207_0111">Timer Administrator (<B><I>timer</I></B>)<A name="0207_0111"></FONT></h4></P>
This task provides a variety of timing services under QNX. The resolution of the timer service can be set to as small a value as 1 millisecond. The timer administrator provides a mechanism for event timing and wake-up services. These services are useful in writing communication routines and time-critical process control applications.<P>
<h4><FONT COLOR="#000080"><A name="0207_0112">Spooling Device Administrator (<B><I>spooldev</I></B>)<A name="0207_0112"></FONT></h4></P>
This optional administrator task creates a mechanism for creating spooling devices under the QNX operating system. Everyone is familiar with "physical" devices which are associated with the computer's hardware. For example, a serial port is a physical device. A spooling device is a "logical" device that provides a disk buffer between a program and a physical device. When information is written to a spooling device, it is written to a temporary file. This temporary file is processed by a user specified command when the file is closed. The most common use of the <I>spooldev</I> administrator is to implement print spooling devices.<P>
<h4><FONT COLOR="#000080"><A name="0207_0113">Queue Administrator (<B><I>queue</I></B>)<A name="0207_0113"></FONT></h4></P>
The queue administrator task provides a non-blocking queued method of passing messages between tasks. A task can open a named message queue that is local to the machine that it is running on, or it can open a named queue that is available across a whole network. The queue administrator can treat the queued messages as a byte stream or as discrete messages.<P>
<h4><FONT COLOR="#000080"><A name="0207_0114">Locker Administrator (<B><I>locker</I></B>)<A name="0207_0114"></FONT></h4></P>
The locker administrator provides QNX with UNIX System V Interface Definition compatible record locking capabilities. This optional system task also provides file caching options not available with the ANSI style stream I/O functions.<P>
<h4><FONT COLOR="#000080"><A name="0207_0115">Other Administrator Tasks<A name="0207_0115"></FONT></h4></P>
Programmers can write additional administrator tasks to extend the services available under the QNX operating system. Administrator tasks have a special status in the QNX operating system. They are immortal, ie., they cannot be killed by other tasks. The only way that an administrator will die is by committing suicide. An administrator task can (optionally) ask to receive notification of the death of every task in the system. All administrator tasks run in the background, at a priority higher than that of the client tasks that will be sending messages to it. Many applications that run under QNX as administrator tasks in order to provide a secure network wide resource. Examples include data base file servers, interfaces to process control systems, electronic mail systems, communication servers that provide gateways to other networks and equipment, etc.<P>
<h4><FONT COLOR="#000080"><A name="0207_0116">Mountable Drivers And Shared Libraries<A name="0207_0116"></FONT></h4></P>
Device drivers are not part of the operating system. They must be mounted so the particular devices which they manage are available to the operating system. This is typically done in a <I>sys.init</I> shell script file that serves the same purpose as <I>autoexec.bat</I> and <I>config.sys</I> files under DOS. Shared libraries are usually mounted by commands in the <I>sys.init</I> file as well. Quantum provides the source to most of the available drivers (free of charge) on their 24-hour-a-day BBS.<P>
<h4><FONT COLOR="#000080"><A name="0207_0117">Inter-Task Communication<A name="0207_0117"></FONT></h4></P>
If you've only programmed under single tasking operating systems, such as MS-DOS or CP/M, this area may be unfamiliar. When working with a multi-tasking operating system, inter-task communication can become one of the lost important aspects of writing programs. QNX provides a rich variety of methods by which tasks can communicate with each other. These include messages, named queues, ports, exceptions, shared memory, and shared files. Some of these are network wide communication methods while others only provide communication that is local to one machine. We will take a fairly detailed look at each of these methods in the following sections.<P>
<h4><FONT COLOR="#000080"><A name="0207_0118">Messages<A name="0207_0118"></FONT></h4></P>
Message passing is the fundamental communication mechanism of the QNX operating system. It is the method by which both the operating system tasks and the user tasks communicate with each other. A message can be sent from any task to any other task in a local area network. It is this message passing mechanism that allows QNX to distribute processing over a network in a transparent fashion. In fact, the message passing mechanism allows a network of computers to appear as one virtual machine (with multiple processors, disk drives, modems, printers, etc.) to both the programmer and the user.<P>
A message is a sequence of bytes that does not have any particular structure as far as the operating system is concerned. The tasks that send messages to each other must impose whatever structure is required by themselves on their messages. Messages can be 0 to 64Kb in length. When a message is sent by one task and received by another, the message data is copied from the address space of the sending task to the address space of the receiving task. The sending task is suspended (blocked) until it receives a reply (to confirm the receipt of the message) from the task to which it sent the message.<P>
There are three primary functions that deal with messages: <I>send</I><I>, </I><I>receive</I>, and <I>reply</I>. Their descriptions (summarized from the QNX C compiler manual) are shown below.<P>
<pre>int send(tid, msg, reply_msg, msg_size)</pre>
where<P>
<pre>unsigned rid,  /* Task identifier of the task to send to. */
msg_size; /* The number of bytes to send. */
char *msg, /* A pointer to the message to send. */
*reply_msg; /* A pointer to the buffer for the reply to the send. */</pre>
<h4><FONT COLOR="#000080"><A name="0207_0119">Send<A name="0207_0119"></FONT></h4></P>
The message pointed to by <I>msg</I> is sent to the task identified by <I>tid</I>. The sending task will <I>BLOCK</I> (go to sleep and not consume any CPU time) until the receiving task has received the message and sent back a reply. The reply will be placed in the buffer pointed to by <I>reply_buffer</I>.<P>
If the receiving task is <I>RECEIVE-BLOCKED</I> (ie., blocked because it called the <I>receive</I> function when there was no message waiting to be received), the transfer of data into its address space will occur immediately, and the receiver will be unblocked and made ready to run. Otherwise, the sender is placed in a queue (perhaps with other tasks that are <I>SEND-BLOCKED</I> on the receiving task), and the transfer does not occur until the receiving task does a <I>receive</I> that satisfies the send.<P>
Sending to a non-existent task or to one which dies before replying will cause the sending task to unblock and <I>send</I> to return <I>0</I>.<P>
<h4><FONT COLOR="#000080"><A name="0207_011A">Return Value<A name="0207_011A"></FONT></h4></P>
The return value of a successful <I>send</I> is the task id of the task to which you sent the message. A <I>0</I> means the target task did not exist or died before replying. A <I>-</I><I>1</I> indicates a failure due to an exception.<P>
<pre>int receive(tid, msg, msg_size)</pre>
where...<P>
<pre>unsigned tid, /* The task identifier of the task to wait on. */
msg_size; /* The maximum size in bytes of the message to receive. */
char *msg;  /* A pointer to the buffer in which to receive the message. */</pre>
<h4><FONT COLOR="#000080"><A name="0207_011B">Receive<A name="0207_011B"></FONT></h4></P>
The <I>receive()</I> function allows a task to receive a message of a <I>msg_size</I> bytes (or less) from the task identified by <I>tid</I>. The receiving task will <I>RECEIVE</I><I> </I><I>BLOCK</I> if no acceptable message has been sent to it.<P>
If tid is specified as 0, (indicates a non-specific <I>receive</I>) then the first task sending to the receiving task will satisfy the <I>receive</I>.<P>
If a task is <I>SEND-BLOCKED</I> on the receiver and satisfies the <I>tid</I> specified, then the <I>receive</I> will not block and the transfer of data will occur immediately.<P>
The task id of the task that sent the message is returned for later use in a reply. An attempt to receive from a non-existent task or one that dies before sending will cause the receiver to unblock and the receive will return <I>0</I>.<P>
<h4><FONT COLOR="#000080"><A name="0207_011C">Return Value<A name="0207_011C"></FONT></h4></P>
Task identifier of the task being replied to if successful or <I>0</I> if the reply failed. A <I>-1</I> indicates a failure due to an exception.<P>
<pre>int reply(tid, reply_msg, msg_size)
unsigned tid,  /* The task identifier of the task to reply to. */
msg_size;      /* The number of bytes of the reply message. */
char *reply_msg;  /* A pointer to the message to reply with. */</pre>
<h4><FONT COLOR="#000080"><A name="0207_011D">Reply<A name="0207_011D"></FONT></h4></P>
The message pointed to by <I>reply_msg</I> is sent as a reply to a task which has sent a message and is awaiting a reply. The reply must occur after the <I>receive</I>. The data transfer occurs immediately and the replying task does not block.<P>
Replying to a non-existent task or one that is not awaiting a reply is a null operation.<P>
Reply changes the state of the replied-to task from <I>REPLY-BLOCKED</I> to <I>READY</I>. (A sending task is <I>SEND-BLOCKED</I> until its message is received. After the receipt of its message it is considered <I>REPLY-BLOCKED</I> until it receives a reply.)<P>
<h4><FONT COLOR="#000080"><A name="0207_011E">Message Passing And Task Synchronization<A name="0207_011E"></FONT></h4></P>
If many tasks send messages to a receiving task, the sending tasks will block and their messages will be queued up. The receiving task will receive the messages in the time order in which they were sent. This message queuing mechanism provides a controlled sequential access to a resource.<P>
<h4><FONT COLOR="#000080"><A name="0207_011F">Message Passing And Task Location<A name="0207_011F"></FONT></h4></P>
To send a message to a task, you must know the task's id number (<I>tid</I>). QNX provides several methods that allow you to determine the task id. When a task spawns a son task, it is returned the task id of the son as part of the call that created the son task. QNX also allows a task to register a name using the <I>name_attach</I> function call. Other tasks can call the <I>name_locate</I> function which locates a task by its registered name and determines its associated task id. Names can be registered locally, globally, and with a distributed name server called <I>clrhouse</I>. As a result of this flexibility, it is not necessary to know the location of a task that you want to communicate with ahead of time. The task of interest may be on the same node or on a remote node somewhere else on the network. This allows for transparent access to all resources across a network and facilitates distributed processing.<P>
<h4><FONT COLOR="#000080"><A name="0207_0120">Message Passing Speed<A name="0207_0120"></FONT></h4></P>
The speed of message passing under QNX is impressive: on a 20MHz AST Premium 386C it takes approximately 140 microseconds to pass a 1-byte message and receive a 1-byte reply between two tasks on the same machine, and about a millisecond to do the same between tasks running on different nodes on a QNX network. Larger messages don't take much longer. For a 100-byte message and a 100-byte reply the corresponding times were approximately 150 microseconds and 1.8 milliseconds.<P>
<h4><FONT COLOR="#000080"><A name="0207_0121">An Example<A name="0207_0121"></FONT></h4></P>
The following example illustrates the degree of network transparency that is provided by the message passing mechanism to both the programmer and the user.<P>
The program <I>holder.c</I> (<A href="list2.htm">Listing 2</a>)
 provides a simple service: it either stores a character string sent to it or replies with a previously stored string. A complementary program <I>sender.c</I> (<A href="list3.htm">Listing 3</a>)
 either sends a string to <I>holder.c</I> for storage or retrieves a previously stored string. These trivial programs illustrate how simple it is to write code that will work whether the programs are run on a single machine or whether they are run on different nodes of a network. The functions <I>name_attach</I> and <I>name_locate</I>, coupled with the network distributed name server (<I>clrhouse</I>) establish a connection between tasks no matter where they are located. Once this connection is established, the operating system takes care of routing the messages. Refer to sidebar entitled <A href="sidebar3.htm">"At The Shell Prompt"</A> on page 116 for additional information on how easy it is to run these programs anywhere on the QNX network.<P>
<h4><FONT COLOR="#000080"><A name="0207_0122">Named Queues<A name="0207_0122"></FONT></h4></P>
It is not always convenient (or necessary) to have a task block and wait for a reply to a message that it has sent. Quantum provides an administrator task (<I>queue</I>) that allows you to create elastic message buffers between tasks. The number of message queues that can be opened are limited only by available memory. The amount of data that a given message queue can buffer is limited to about 50Kb, which is plenty for most applications. When a task opens a queue it gives the queue a name. Other tasks locate a queue by this name to write messages to it. The queue administrator looks after storing the messages and replies immediately to the task that wrote a message in order that it does not block. You can limit the number of messages that a queue will buffer. If this limit is exceeded, the task writing to the queue will block on a queue write until a message is removed from the queue. As mentioned previously, a queue can be looked at as containing discrete messages or it can be treated as a byte stream. Queues are a resource that are available either locally or across the entire network.<P>
<h4><FONT COLOR="#000080"><A name="0207_0123">Ports And Signals<A name="0207_0123"></FONT></h4></P>
In the QNX operating system, there are hardware I/O ports and software ports. Hardware I/O ports refer to device registers and are referenced by hardware I/O addresses. Software ports are unique to QNX. In the rest of this section the term 'port' will always refer to a software port.<P>
Ports can be viewed as software devices that are visible to all tasks on a given node. They are not visible across the network. Functions involving port usage provide the following services:<P>
<UL><li>non-blocking communication</li>
<li>interrupt handling communication</li>
<li>task identification</li>
<li>non-blocking semaphores</li></UL>
Tasks can claim a port by attaching to it and release a port by detaching from it. Only one task can own a port at any given time. If a task tries to attach to or detach from a port that is already owned by another task, it is informed of the task id of the task that currently owns the port.<P>
Ports may be used for simple non-blocking inter-task communication. If a task is attached to a port, another task (perhaps an interrupt handler) may send a signal (<I>not</I> the same as a signal under UNIX) to that port. This causes the port to send a special message to the task that is attached to that port. The message sent to a task by a port as a result of a signal is special for the following reasons:<P>
<UL><li>Messages sent by ports have a higher priority than regular messages. They are placed at the front of a message queue, bypassing the normal time ordering of messages sent by the send function.</li>
<li>Messages sent by ports are zero bytes in length and are distinguishable from regular messages.</li></UL>
This is ideal for interrupt handling. In the QNX world, interrupt handling is done by interrupt administrator tasks. Interrupt administrators consist of two parts. One part is a short assembly language routine that the interrupt is vectored to. The other portion of the interrupt handler is usually written in C, and it provides the interface with the rest of the tasks running on the system (usually via message passing). The assembly language portion of the interrupt handler communicates with the C portion by signaling its software port. The assembly language portion of the interrupt handler can be as simple as a routine that informs the interrupt administrator task that an interrupt has ocurred and no more, or it can do some processing itself: such as buffering message packets and CRC or BCC error checking. It's up to the programmer. The operating system administrator tasks themselves, rely on signals from ports to let them know when a serial line is ready to accept data or when a disk operation has been completed.<P>
A signal to a port under QNX is not the same as a signal under UNIX. A signal to a port under the QNX operating system results when a task calls the QNX signal function. The task which is signaled must call the <I>receive</I> or <I>await</I> (on a port) function to be notified of the signal. Therefore, it can be considered synchronous with respect to the receiving task. A signal under the UNIX operating system is entirely asynchronous and is another name for an interrupt. Exceptions (discussed in the next section) under QNX are analogous to UNIX signals. There is no analog in UNIX for a QNX signal. Unfortunately, Quantum decided to use the names <I>signal</I> and <I>port</I> for the above functions instead of choosing new names. This is being rectified in the upcoming POSIX version of QNX.<P>
Ports are a limited resource. There are 28 ports per computer available under the real mode version of QNX and 40 ports per computer under the protected mode version. Of these, the first 16 are reserved by the operating system. Interrupt handlers have the special ability to signal multiple ports with only one signal system call. Regular tasks can only signal one port per system call.<P>
<h4><FONT COLOR="#000080"><A name="0207_0124">Exceptions<A name="0207_0124"></FONT></h4></P>
Exceptions provide a means of interrupting a task no matter what it is doing and what state it is in (similar to signals under UNIX). They are usually generated as a result of some unusual or abnormal event. For example, typing <I>^C</I> will generate a keyboard break exception on a task. Other examples of events that will generate an exception on a task are floating point errors, divide by zero errors and a modem hangup. In all, QNX allows 32 possible exceptions that may be set on a task. Of these 32 exceptions, the first 16 are reserved for use by the operating system.<P>
QNX provides considerable flexibility with regard to generating and handling exceptions. Normally, the operating system terminates a task that has an exception set on it. A programmer may, however, allow a task to handle exceptions with a programmer-defined function. You can also defer exception processing to a more convenient time. Multiple exceptions may be set on a task by another task. Because exceptions are indicated by setting the bits of two 16-bit integers (one word for operating system exceptions and one for programmer defined exceptions), this opens up another means of inter-task communications. Exceptions may be set on tasks that are on another node of a QNX network as well as on local tasks.<P>
<h4><FONT COLOR="#000080"><A name="0207_0125">Shared Memory<A name="0207_0125"></FONT></h4></P>
This method of inter-task communication refers to a situation in which two or more tasks have access to the same locations in memory. To achieve this under QNX, one task must allocate a segment of memory and then pass the segment address or selector (when in protected mode) to whatever tasks it wants to share this memory with. Once that is done, multiple tasks can access this memory via pointers and communicate without the overhead of message passing. No problem, right? Not really. This scheme of inter-task communication raises the possibility of lost or corrupted data due to the possiblity of more than one task trying to write to the same area of memory at the same time. Another potential problem with this approach is one task reading a section of shared memory while another task is modifying it. These problems can be overcome, but the mechanism by which this is achieved is up to the programmer. A possible solution is to appoint one task as a memory manager that would control access to the shared memory.<P>
Note that shared memory for inter-task communication is local to a node as it doesn't make sense to pass pointers across a network.<P>
<h4><FONT COLOR="#000080"><A name="0207_0126">Shared Files<A name="0207_0126"></FONT></h4></P>
This is the slowest form of inter-task communication because it involves disk file accesses, which are several orders of magnitude slower than memory accesses. The same problems that were mentioned under the shared memory section apply here as well. One possible solution for the problems associated with the contention for records in a file would be to use the UNIX SVID style record locking facilities provided by the locker administrator task. Another approach would be to use a custom data base server task such as the one used with FairCom's c-tree ISAM package. A RAM disk could speed things up considerably but limits the size of the files. This type of inter-task communication is most appropriate for data base type of transactions. It is available across a network since the QNX file system is a network wide resource.<P>
<h4><FONT COLOR="#000080"><A name="0207_0127">Conclusion<A name="0207_0127"></FONT></h4></P>
QNX's unique server-based, message passing architecture provides a rich array of inter-task communication facilities. The beauty of many of them is that they are available across the network in a transparent fashion. These features, coupled with the small size and speed of the QNX operating system, make it ideal for networked embedded control applications. The richness of the QNX operating system utilities and the growing pool of software (both commercial and public domain) make it an attractive choice for general computing as well.<P>
<h4>Additional QNX Information and References</FONT></h4></P>
     "Message-Passing Operating Systems," Dan Hildebrand, <I>Dr. Dobbs Journal of Software Tools,</I> June 1988.<P>
Dan Hildebrand is a programmer at Quantum. This article provides an overview of the QNX operating system.<P>
     "Spreading Out &#151; Distributed Applications on a LAN Are No Longer a Pipedream," Dan Hildebrand, <I>LAN Magazine</I>, October 1988.<P>
In this article, Dan demonstrates how easy it is to develop distributed parallel processing applications under QNX. A fractal generating program that distributes the processing of screen slices over a network is used as an example.<P>
     "QNX &#151; A Real-Time Multi-Everything OS That Runs on LANs," David W. White, <I>LAN Magazine</I>, January 1989.<P>
A description of David White's "test drive" of the QNX operating system.<P>
     "Inter-task Messaging under QNX," William Boyle, <I>The C Users Journal</I>, November 1988.<P>
W. Boyle is a software engineer at FASTech Integration, Inc. and is involved in systems integration for the industrial automation market. His article describes the implementation of a utility (source code provided) which allows viewing a remote node's display console.<P>
     "Real-Time Messaging: A Quantum Approach to Scheduling," <I>Embedded Systems Programming</I>, May 1989.<P>
I haven't read this one, so I can't comment on it.<P>
     "The QNX Operating System: A Multi-tasking, Networking Alternative To UNIX," Marta Greenberg, <I>MIPS</I>, January 1990.<P>
Marta Greenberg is a vice president of Software Innovations Inc., a UNIX consulting firm. She has written a short review of QNX, which highlights its design and compares it to UNIX using a number of benchmark programs. The article is targeted at programmers familiar with UNIX.<P>
     "Off The Shelf: QNX &#151; A UNIX-like Lan Environment," Jon Johnston, <I>UNIX Review</I>.<P>
Jon Johnston is an independent consultant based in the Twin Cities of Minnesota. He specializes in microcomputer LANs. This article provides a brief overview of the QNX operating system.<P>
     "The QNX Operating System &#151; Programming with Messages in a Distributed Environment," Frank Kolnick, <I>Basis Computer Systems Inc.</I>, 1989.<P>
This is an excellent book for C programmers who want to take advantage of the unique strengths of the QNX operating system. I wish I had this book when I first started programming in the QNX environment.<P>
     "A Technical Overview of the QNX Operating System"<P>
     "QNX Reference Guide Version 2.1," Quantum Software Systems Ltd., 1988.<P>
     "QNX C-Compiler And Assembler Manuals," Quantum Software Systems Ltd.<P>
     QUICS, Quantum's Update and Interactive Conferencing System<P>
This is an on-line update and conferencing system similar to BIX that operates 24 hours per day. You can download the latest version of the software which you have purchased from QNX for free. This service also provides a large treasure trove of public domain software and source code to many of the QNX drivers, utilities and C library functions. It allows you to send electronic mail to Quantum staff. A variety of topics are discussed in the forums. Questions are typically answered within one day and very likely by the author of the software package you need help with.<P>
Quantum Software Systems, Ltd.<br>
175 Terrence Matthews Crescent<br>
Kanata K2M 1W8 Ontario<br>
Canada<br>
(613) 591-0931<P>

<h4><a href="list1.htm">Listing 1</a></h4>
<h4>Sidebar: <a href="sidebar1.htm">Operating Systems</a></h4>
<h4>Sidebar: <a href="sidebar2.htm">Real Mode vs. Protected Mode Operation</a></h4>
<h4>Sidebar: <a href="sidebar4.htm">Update: Quantum Releases A Posix Compliant Verion of QNX</a></h4>

<h4><a href="../../../source/1991/sep91/busigin.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
