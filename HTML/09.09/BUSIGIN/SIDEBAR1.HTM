<HTML><HEAD>
<TITLE>September 1991/The QNX Operating System/Sidebar</TITLE></HEAD><BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">Operating Systems</FONT></h3>
<HR>
<BLOCKQUOTE>
<h4>Operating System Architecture</FONT></h4></P>
Operating system architectures of interest in the microcomputer area can be divided into three general classes: monolithic, layered and server based. This section will briefly describe each of these. If additional information regarding operating system architectures interests you, then I highly recommend you read Andrew S. Tanenbaum's book called "Operating Systems, Design and Implementation."<P>
<h4>Monolithic Systems</FONT></h4></P>
The monolithic system derives its name from the fact that the operating system is a one large collection of procedures. To construct the executable code of this type of operating system, one compiles all the separate files containing the procedures that comprise the operating system, and then binds them all together into one monolithic program using a linker.<P>
The system calls provided by such an operating system are requested by putting parameters in registers and then executing a kernel (system) call via an interrupt. This interrupt transfers control of the computer to the operating system. The operating system then examines which system call is to be carried out by examining the parameters passed to it. The appropriate service procedure is called and control of the machine is returned to the user program upon completion of the service procedure.<P>
The simplest organization of a monolithic operating system is one "blob" of code that carries out all the operating system functions and has no real structure. An improvement over this is a monolithic operating system which is structured logically into layers.<P>
<h4>Layered Systems</FONT></h4></P>
The layered operating system model is typically depicted by a figure that looks like a laminated block or a series of concentric rings. The different rings and layers represent a well defined hierarchy of functions that the different layers of the operating system provide. The lower layers (or inner rings) usually concern themselves with task scheduling, memory allocation, I/O management, etc. The outer layers are where the user programs run. If the hardware permits, the lowest layers (or inner rings) run in a more privileged mode than the higher layers (or outer rings). The sidebar entitled "Real Mode vs. Protected Mode Operation" describes real mode and protected mode operation.<P>
MS-DOS and PC-DOS fall in a category somewhere between the monolithic and layered operating system types.<P>
UNIX and OS/2 fall into the layered category.<P>
<h4>Server-Based Systems</FONT></h4></P>
The server based operating system is a radical departure from the monolithic and layered type of designs. Where the monolithic and layered types of designs have a large kernel that looks after all the housekeeping of memory management, task scheduling, file I/O, timer services and inter-task communication, the server based model has a minimal kernel and leaves the provision of the previously mentioned services to discrete "server" tasks which run in the "user" space of the machine as opposed to the operating system space. All the kernel does in the server based operating system, is handle the message based communication between client tasks (which request services) and the server tasks (which process the requests).<P>
This modular architecture has a number of advantages: Since each server task only handles one aspect of the total operating system services, each server is small and manageable. It becomes possible to reconfigure or extend the operating system more easily. If one of the servers crashes, this will not bring down the whole machine. Another, and perhaps the most significant advantage of this architecture, is that it is a perfect architecture for implementing distributed systems. After all, when a client task communicates with a server task by sending messages, the client task does not need to know where the server task is. The server task could be on the same (local) machine, or it could be on a remote machine with the two of them connected via a network. All the client task is concerned with is that it sent a message to a server task requesting a service and that it received a reply. Similarly, a server task does not need to know where a client task is. The operating system looks after the routing of the messages between the two.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
