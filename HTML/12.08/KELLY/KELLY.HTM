

<HTML>
<HEAD>

<TITLE>August 1994/Multithreading with OS/2 and Borland C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Multithreading with OS/2 and Borland C++<A name="015D_00B4"><A name="015D_00B4"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="015D_0000"><A name="015D_0000">Michael Kelly</font></h3><hr><blockquote><P>
<P><i><A name="015D_0000"><A name="015D_0000">Michael Kelly is a member of the staff of Computer Task Group. His current assignment is at IBM in Boca Raton Florida, where he deals with OS/2<I>-</I>related issues.</i></P><P>
MS<I>-</I>DOS programmers who experiment with multithreading usually develop a keen desire for reentrant libraries in short order. I have used third<I>-</I>party C++ classes and C libraries to write multithreading programs in MS<I>-</I>DOS. The classes and/or libraries usually worked well, but I could not call the C standard library I/O functions (e.g. <I>printf</I>) from multiple threads, because my compiler provided only non<I>-</I>reentrant versions of these functions. Moving from MS<I>-</I>DOS to OS/2 solves two problems at once with respect to multithreading. Not only does OS/2 support multiple threads (elimating the need for third<I>-</I>party libraries) but compilers for OS/2 are more likely to provide reentrant I/O libraries. For instance, the Borland C++ compiler for OS/2 2.x comes with reentrant libraries. Having reentrant libraries available speeds development enormously since you don't have to write your own assembly language functions to do I/O.<P>
This article shows an example of a multithreading utility using Borland's reentrant library functions, and OS/2 System API calls. The utility is a file filter that can filter multiple files simultaneously. It uses C++ classes to provide a convenient interface to the threads that do the actual file I/O and filtering.<P>
Each filter class consists of a producer thread and a consumer thread linked together using an OS/2 System Queue and OS/2 System Semaphores. The OS/2 System Queue allows the producer thread to add filtered blocks of data to the end of the queue while the consumer thread de<I>-</I>queues the data and writes it to the output file. The filter class uses the OS/2 System Semaphores to signal when the filtering is complete.<P>
<h4><FONT COLOR="#000080"><A name="015D_00B5">Multithreading Design Issues<A name="015D_00B5"></FONT></h4></P>
A person writing multithreaded programs must solve several problems not encountered in simple, single<I>-</I>threaded programs. One of these problems is controlling access to shared data. Since a thread is a "light<I>-</I>weight process" it may share variables with other threads in the same program. The program must ensure that only one thread has access to shared data during a particular time interval. (That is, the program must <I>serialize</I> access to data.) My <I>FileFilter </I>class must manage shared data in two places.<P>
The first place is in access to file data. In this program a producer thread reads a block of data from an input file, filters it, and passes it along to the consumer thread, which writes the filtered data to the output file. I use an OS/2 System Queue between the producer thread and the consumer thread to ensure that the data is handled cleanly. (The System Queue uses its own semaphore to control access to its data.) To serialize file data access, my <I>FileFilter </I>class dynamically allocates and frees each block of file data as it is used. All this dynamic allocation may seem to require a lot of overhead, but it is negligible compared to the disk I/O involved. Dynamic allocation helps prevent simultaneous access to data, which may occur if static data buffers are used.<P>
The second place requiring serialization is in a class variable named <I>blocks2write. </I>This variable is initialized by the <I>FileFilter </I>constructor; after that the only thing that touches the variable is a consumer thread,which decrements it on each write until it reaches 0. The variable is protected and, since the class is written with this restriction in mind, it is not associated with a semaphore.<P>
Another problem encountered in multithreaded programming is that of adequately coordinating execution between threads. This coordination is required because of multithreading's non<I>-</I>sequential nature. For example, I may create a <I>FileFilter </I>instance to filter a large file, then create another instance to filter a small file. The second instance will usually complete before the first. The main part of the program that launched the threads must not be allowed to drop through to the end of the program while the operations are incomplete. The OS/2 System provides an <I>Event </I>Semaphore for this purpose. To use this semaphore, I have provided a class member function, <I>wait4completion.</I> This function takes a single parameter of type <I>ULONG </I>named <I>max_wait.</I> The function passes this value to the OS/2 API <I>DosWaitEventSem. DosWaitEventSem</I> interprets two values of <I>max_wait</I> as "magic cookies." A value of 0 means to poll the semaphore once to see if it has completed and return. A value equivalent to <I>-1L (0xffffffff)</I> means to wait forever. <I>DosWaitEventSem</I> interprets any other values as an <I>unsigned long </I>designating the number of milliseconds to wait on the semaphore. If only two or three instances of the <I>FileFiIter</I> class are running concurrently, a program could include a simple conditional statement to wait for them all to complete and handle the return codes. A more robust design would probably incorporate the waiting and error checking in a function with time<I>-</I>out values for each instance to avoid hanging the application.<P>
A problem related to multithreading is obtaining optimum performance from the particular platform in use while preserving as much portability as possible. In this example, I wanted to use dynamic memory allocation, and also take advantage of OS/2 2.x's demand paging plus the hardware support available in 386 and higher CPUs. Therefore, I've made the producer thread use a default block size of 4,096 to match 4KB pages issued by the system when an allocation of 4KB or smaller is requested. The consumer thread frees memory blocks after it has dequeued and processed them to the output file. (One hazard of the 4KB page memory allocation is that programs written for 286 protected modes, such as found in OS/2 1.x, sometimes neglect to free allocated memory after usage, especially if the memory blocks are very small. These programs can run out of virtual memory quickly when run on an OS/2 2.x platform.) Freeing dynamic RAM as soon as practicable increases efficiency since the memory will be available for reallocation instead of paging to the system swap file, <I>swapper.dat.</I><P>
To facilitate error checking, I have provided the <I>valid</I> member function. <I>valid</I> returns a nonzero integer value if the constructor completed successfully. If <I>valid</I> should return zero, the culprit is probably the call to <I>fopen.</I> The companion member function <I>error_code</I> returns a <I>ULONG</I> with the error code last stored in the <I>filter_error</I> member variable. Building on this structure you can bullet<I>-</I>proof your enhanced implementation of the <I>FileFilter</I>.<P>
<h4><FONT COLOR="#000080"><A name="015D_00B6">Advantages of Using Multiple Threads<A name="015D_00B6"></FONT></h4></P>
In the previous section I've discussed some of the difficulties of using multiple threads; it's time I pointed out some of the positive aspects. I take advantage of several of these in the file filtering utility. One advantage is that applying multithreading to the producer/consumer paradigm helps the application do productive work when it would otherwise be kept waiting. You can demonstrate this with the file filter utility by reading from a fixed disk and writing to a floppy drive. In a purely sequential implementation the producer thread would be waiting for the consumer thread, which is tied to the slow floppy drive. By contrast, the multithreaded implementatation queues up the producer's filtered data in virtual memory while waiting to write blocks to the floppy drive.<P>
Another advantage of multithreading &#151; even over multi<I>-</I>processing &#151; is that it simplifies the creation of parallel processes. Creating another instance of <I>FileFilter</I> is faster and puts less of a load on system resources than creating another full<I>-</I>fledged process, such as you might do with a call to <I>fork</I> or <I>spawn</I>.<P>
Though not an advantage of multithreading per se, a feature that makes it more practical is the synchronization provided by OS/2. The OS/2 System Queue and System Semaphore APIs enable you to keep the code clean and concise. Indeed one of the problems I encountered when designing my file filter utility is that I kept trying to complicate things unnecessarily. In my first attempts to come up with a working design, I was confusing the issue by trying to use indexes into multiple buffers and other similar techniques. I realized that the best design for my purpose was much easier to implement than that, once I determined to keep the algorithm simple. That is when I decided to allocate blocks of memory as required and keep the data management simple. Once I stripped away the non<I>-</I>essential I discovered that using the OS/2 APIs made the rest of the implementation an enjoyable exercise, and resulted in a clean design.<P>
<h4><FONT COLOR="#000080"><A name="015D_00B7">Running the Application<A name="015D_00B7"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
shows the <I>FileFilter</I> class definition; <A href="list2.htm">Listing 2</a>
shows its implementation. I've written the filter function itself in assembly language (<A href="list3.htm">Listing 3</a>)
. <A href="list4.htm">Listing 4</a>
is a header file for the filter function, while <A href="list5.htm">Listing 5</a>
provides a dummy C++ wrapper to "name<I>-</I>mangle" the function name. You need Borland C++ v.1.0 or higher for OS/2 2.x to assemble, compile, and link the sample application. <A href="list6.htm">Listing 6</a>
shows the test stub (gofilter) for the <I>FileFilter</I> class; A <I>.prj</I> file required by the Borland IDE is included on this month's code disk. If you don't wish to prepare UNIX<I>-</I>style ASCII files to use with gofilter, you may use ordinary IBM PC text files. If you look at the output files with a binary editor you will see that each line will have an extra carriage<I>-</I>return inserted directly before the line<I>-</I>feeds for each line. I used this UNIX<I>-</I>to<I>-</I>PC filter for the test program because it was easy to implement in assembly language and I wished to try out the 32<I>-</I>bit TASM that comes with Borland C++ for OS/2. The secondary motivation was that I have a CD with UNIX source code that I wanted to filter while transferring it from the CD to my hard drive.<P>
As written, you can use the <I>FileFilter </I>class for any filtering job that can operate on blocks of data. If you need to do the filtering line<I>-</I>by<I>-</I>line, then it should be easy to make slight modifications to the code so that the file is read a line at a time and each line fed to the filter as a block of data. Of course additional error checking would be desirable if these classes were to be used in a commercial application.<P>
<h4><FONT COLOR="#000080"><A name="015D_00B8">Conclusions<A name="015D_00B8"></FONT></h4></P>
Encapsulating threads in a C++ class provides a clean interface for the application programmer. As the listings show, creating multiple instances of filter classes to run simultaneously is straightforward. I give the <I>FileFilter </I>class's constructor only three parameters: the source file name, destination file name, and a pointer to the function used to filter the data.<P>
Wrestling with this design has confirmed for me the value of the classic algorithms. When I realized that the class I was trying to construct matched the pattern of the producer/consumer algorithm, I saw the way to a clean concise design. C++ classes provide a framework that requires more time devoted to class design, but rewards this effort with a clean implementation. Last but not least, writing OS/2 2.x multithreaded programs is fun!<P>
<P>

<h4><a href="../../../source/1994/aug94/kelly.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
