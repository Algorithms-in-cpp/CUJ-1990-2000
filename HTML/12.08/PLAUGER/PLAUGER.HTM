

<HTML>
<HEAD>

<TITLE>August 1994/Standard C/C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Standard C/C++<A name="015F_00B6"><A name="015F_00B6"></font></h2><P>
<h3 align="center"><A name="015F_0000"><A name="015F_0000">Extractors</h3><P>
<h3 align="center"><font color="#800000">P.J. Plauger</font></h3><hr><blockquote><P>
<P><i><A name="015F_0000"><A name="015F_0000">P.J. Plauger is senior editor of C/C++ Users Journal. He is convenor of the ISO C standards committee, WG14, and active on the C++ committee, WG21, His latest books are The Standard C Library, and Programming on Purpose (three volumes), all published by Prentice-Hall. You can reach him at pjp@plauger.com.</i></P><P>
This is the second of two installments on the class <I>istream</I>, defined in the header &lt;<I>istream</I>&gt; (See <I>Standard C: The Header</I><I> &lt;istream&gt;, </I><I>CUJ</I><I>,</I> July 1994.) Last month, I showed the definition of the class and described the member functions that perform unformatted input. I conclude this month, as promised, with a description of the member functions that perform formatted input. These functions are commonly known as <I>extractors.</I><P>
Extractors overload <I>operator&gt;&gt;</I>, as in:<P>
<pre>float fl;
cin &gt;&gt; fl;</pre>
This expression extracts characters from the stream controlled by <I>cin</I> (the standard input stream). Extraction continues so long as characters continue to match the text pattern acceptable to the Standard C library function <I>strtod</I>. The entire sequence extracted by this rule must then be successfully converted, as if by calling <I>strtod,</I> and the resulting value must be representable as type <I>float.</I><P>
If all those conditions obtain, the extractor stores the converted value in <I>fl</I> and succeeds. Otherwise, the function reports failure, typically by setting <I>ios::failbit</I> in <I>cin</I>. In any event, all the characters extracted to make up the valid text field (or valid prefix for such a field) are irretrievably consumed.<P>
If all that machinery sounds rather like <I>fscanf,</I> it should. Extractors serve the same function for the Standard C++ library that the <I>fscanf</I> family serves for the Standard C library. You can, in fact, implement extractors by calls to <I>fscanf.</I> That turns out to be not always convenient, however:<P>
<UL><li>The source of input for a stream controlled by an <I>istream </I>object is controlled in turn by a <I>streambuf</I> object. (See last month's installment.) You can't always relate that source directly to the sources accessible by <I>fscanf</I> or <I>sscanf</I>.</li>
<li>You can extract characters and store them in a buffer for processing by <I>sscanf</I>. But doing so requires a buffer that is arbitrarily large. Or you end up doing so much preprocessing of the text that you duplicate much of the work done by <I>sscanf</I>.</li></UL>
For these reasons, I present here a different implementation of the <I>istream</I> extractors. It sits reasonably well atop the Standard C library, but it makes no use of <I>fscanf</I> or its brethren. To provide an overview, <A href="list1.htm">Listing 1</a>
is a repeat from last month. It shows one way to implement the header <I>&lt;istream&gt;,</I> which consists almost entirely of the definition of the class <I>istream.</I> My focus this month is all those overloads of <I>operator&gt;&gt;,</I> plus one or two "secret" member functions that work with them.<P>
<h4><FONT COLOR="#000080"><A name="015F_00B7">Character Extractors<A name="015F_00B7"></FONT></h4></P>
Let's begin with the extractors that perform a minimum of interpretation. These extract one or more characters from the input stream and deliver them either to memory or to an output stream. The simplest of all is <I>operator&gt;&gt;(char&amp;), </I>which extracts a single character, as shown in <A href="list2.htm">Listing 2</a>.
 As usual, class <I>istream</I> also has <I>unsigned char</I> and <I>signed char </I>versions of the same extractor, which call on the plain <I>char</I> version to do the actual work.<P>
Last month, I showed some very similar member functions. <I>get(char&amp;) </I>has much the same external interface, but it is <I>get()</I> that has much the same internal structure as this particular extractor. Both depend on the pair of member functions <I>ipfx(int)</I> and <I>isfx()</I> to enforce various stream disciplines. And both depend on the macros <I>_TRY_IO_BEGIN</I> and <I>_CATCH_IO_END</I> to enforce the required discipline of exception handling.<P>
The only difference is the argument to <I>ipfx</I>. The extractor uses the default zero value for the flag argument. That encourages <I>ipfx </I>to skip leading white space before extracting the actual data to be delivered, assuming the flag <I>ios::skipws</I> is set within the <I>istream </I>flag word. (It is set by default when the object is constructed.)<P>
If you want to skip white space before invoking an extractor, regardless of the setting of <I>ios::skipws,</I> you can always use the <I>manipulator</I><I> ws.</I> You will find it declared near the bottom of the header <I>&lt;istream&gt;,</I> in <A href="list1.htm">Listing 1</a>.
 <A href="list3.htm">Listing 3</a>
shows one way to write this function. If you write:<P>
<pre>cin &gt;&gt; ws &gt;&gt; fl;</pre>
then white space is always skipped before <I>fl</I> is extracted. (These two listings have all the clues you need to figure out how <I>ws </I>works, if you like arcane C++ puzzles.)<P>
<A href="list4.htm">Listing 4</a>
shows the member function <I>operator&gt;&gt;(char *).</I> It extracts a sequence of characters from the input stream and stores it as a null-terminated string in the character array designated by the pointer argument. (Yes, there are three flavors, once again.)<P>
This is one of the few extractors that uses the width value stored in the <I>istream</I> object. (If <I>width()</I> is zero, the width is taken as <I>INT_MAX</I>, as defined in <I>&lt;limits.h&gt;</I>.) Input stops with the first white-space character extracted (which is pushed back), or when the specified number of characters are stored in the array, counting the terminating null. Note that the width field is set to zero by this extractor, as is customary for functions that make use of the field.<P>
Finally, <A href="list5.htm">Listing 5</a>
shows the member function <I>operator&gt;&gt; (streambuf&amp;)</I>. It too strongly resembles one of the unformatted input functions I showed last month. You use it to copy the remainder of the input stream to the output stream controlled by the <I>streambuf</I> operand. The extractor version should be substantially faster because it doesn't have to check for delimiters. Thus, it can move whole blocks of characters at a time.<P>
<h4><FONT COLOR="#000080"><A name="015F_00B8">Integer Extractors<A name="015F_00B8"></FONT></h4></P>
Converting text fields to internal integer forms is rather more complicated. You certainly want existing library functions, such as <I>strtol</I> or <I>strtoul</I>, to do the hard work. But just setting up for one of these functions takes a bit of effort in its own right. Remember, nothing prevents a perverse user from generating an input stream with 5,000 leading zeros, followed by a perfectly reasonable integer. You don't want to blindly gather characters into a buffer as part of the extraction process.<P>
<A href="list6.htm">Listing 6</a>
shows the member function <I>operator&gt;&gt; (long&amp;), </I>which extracts a <I>long</I> integer. It does indeed gather characters into a buffer, but not blindly. And the buffer has a bounded length, in this case the value of the macro <I>_MAX_INT_DIG.</I> For a typical machine with 32-bit <I>long</I>s, a value of 16 is plenty big enough to deal with a sign, prefix, and enough significant digits to ensure overflow if the value is indeed too large.<P>
The work of gathering an integer field is carried out by the private member function <I>_Getifld(char *)</I>, shown in <A href="list7.htm">Listing 7</a>.
 It largely replicates the logic of <I>fscanf</I>, or even <I>strtol</I>, with an important difference or two. It compresses all leading zeros to a single digit. And it truncates a very big number at a value large enough to ensure overflow, as I indicated above. It then counts on <I>strtol</I> (or <I>strtoul</I> for the <I>unsigned long</I> extractor) to do the rest of the conversion.<P>
All the other integer extractors make use of either the <I>long</I> or the <I>unsigned long</I> extractor. By way of example, <A href="list8.htm">Listing 8</a>
shows the <I>int</I> extractor, <I>operator&gt;&gt;(int&amp;)</I>. Once it extracts a <I>long</I>, all it has to do is make a tighter range check before storing the converted value.<P>
Extracting a pointer to <I>void</I> is a slightly different matter. It must, of course, work in concert with its corresponding inserter for pointer to <I>void</I>. Both should also convert an arbitrary representation for pointers, even if it is bigger than the largest integer. You can, and probably should, tailor pointer conversions for each implementation. What I show here is one way to write a pointer extractor that is both portable and robust (even if it doesn't always choose the most appropriate text representation for pointers.)<P>
<A href="list9.htm">Listing 9</a>
shows the pointer to <I>void</I> extractor. The trick it uses is to store the pointer in a union, so that it overlaps an array of <I>unsigned long</I>. The extractor then extracts a series of integers separated by colons and stores them in the union as integers. The resultant pointer value is accessed from the union in the end. So long as the corresponding inserter does the reverse process, you can be sure that a pointer value you extract matches the earlier one you inserted.<P>
<h4><FONT COLOR="#000080"><A name="015F_00B9">Floating-Point Extractors<A name="015F_00B9"></FONT></h4></P>
Converting text fields to internal floating-point forms is even more complicated. You <I>really</I> want existing library functions, such as <I>strtod</I>, to do the hard work. Sadly, the C Standard does not require a <I>strtold</I>, to convert the extra precision and range of a <I>long double</I>. Nor does it require a <I>strtof</I>, to perform the tighter range checking of a <I>float</I>. If you want to write the Standard C++ library in terms of the Standard C library, you're somewhat at a loss in this area.<P>
I have provided both of these functions, with secret names, in my implementation of the Standard C library. I suspect that the next revision of the C Standard will make them mandatory. Meanwhile, you can cop out by using <I>strtod</I> to perform in place of these missing functions. It is deficient in several ways, but it meets many needs.<P>
Setting up for one of these floating-point conversion functions takes even more effort than for integer conversions. Our hypothetical perverse user now has several places to pad a numeric field with gratuitous zeros that don't alter the represented value.<P>
Here is the easiest example of floating-point extractors. <A href="list10.htm">Listing 10</a>
shows the member function <I>operator</I>&gt;&gt;(<I>double&amp;</I>), which extracts a <I>double</I>. It also gathers characters into a buffer with a bounded length, in this case determined by the values of the macros _<I>MAX_SIG_DIG</I> (maximum significant digits) and _<I>MAX_SIG_DIG </I>(maximum exponent digits). For a typical machine with 80-bit <I>long double</I>s, you're looking at 20 or so fraction digits and four exponent digits, plus the usual assortment of signs, decimal point, and exponent character. The buffer still need not be all that large.<P>
The work of gathering a floating-point field is carried out by the private member function _<I>Getffld(char *)</I>, shown in <A href="list11.htm">Listing 11</a>.
 It plays many of the same tricks as its cousin,_<I>Getffld(char *)</I>, to keep the buffer length small and bounded. It then counts on a function much like <I>strtod</I> to do the rest of the conversion. But _<I>Stod </I>takes an additional argument computed by _<I>Getffld</I> &#151; a power-of-ten correction factor. The final converted value is what <I>strtod</I> produces from the compressed text field times ten raised to the correction factor.<P>
With a bit of messy logic, you can fold this factor into the text string you construct to feed to <I>strtod</I>. I chose instead to write a proper version of_<I>Stod</I> (and _<I>Stof </I>and _<I>Stold</I>), because my library calls these functions from <I>fscanf</I> as well. <A href="list12.htm">Listing 12</a>
shows a cheap approximation to_<I>Stod</I>, to show you how it works. A proper version would do better error checking, work faster, preserve precision more carefully, and not cause any floating-point overflows or underflows. But all that machinery is too much to show here.<P>
<h4><FONT COLOR="#000080"><A name="015F_00BA">Conclusion<A name="015F_00BA"></FONT></h4></P>
You can, of course, also write your own extractors. It is commonplace, when designing a new class, to provide a tailored inserter at the very least. If reading values of the class makes sense, then it is good manners to provide an extractor as well. You might even want to write an extractor or two that are not associated with a specific class.<P>
The best style for writing new extractors is to do so in terms of the member functions of class <I>istream</I>. If you must drop below this level and access the associated <I>streambuf</I> object directly, then by all means match the discipline followed in the extractors presented here. If you don't, then it's only a matter of time before you or one of your colleagues gets burned. Such is the blessing, and the curse, of reusable software.<P>

<h4><a href="../../../source/1994/aug94/plauger.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
