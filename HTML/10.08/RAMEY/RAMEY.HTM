


<HTML>
<HEAD>

<TITLE>August 1992/The Postman's Sort</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">The Postman's Sort<A name="018A_00C0"><A name="018A_00C0"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="018A_0000"><A name="018A_0000">Robert Ramey</font></h3><hr><blockquote><P>
<P><i><A name="018A_0000"><A name="018A_0000">Robert Ramey is a computer systems developer based in Santa Barbara, CA. He can be reached at 3949 1/2 Foothill Rd., Santa Barbara, CA 93110, (805) 569-3793.</i></P><P>
<h4><FONT COLOR="#000080"><A name="018A_00C1">Introduction<A name="018A_00C1"></FONT></h4></P>
This article describes a program that sorts an arbitrarily large number of records in less time than algorithms based on comparison sorting can. For many commonly encountered files, the time required will be strictly proportional to the number of records. This is not a toy program; it can sort on an arbitrary group of fields with arbitrary collating sequence on each field faster than any other program available.<P>
Most computer professionals "know" that the time required to sort a file of N records must increase disproportionately to the number of records in the file. In fact, most will cite Donald E. Knuth's book <I>The Art of Computer Programming: Searching and Sorting</I>. Knuth's chapter on minimum comparison sorting shows that a sorting method which compares records can do no less than <I>N</I>log<SUB>2</SUB>(<I>N</I>) comparisons. However, this analysis specifically excludes methods that do not use key comparison. In fact, other sections of the book allude to methods for which time is proportional to the number of records sorted.<P>
Why, then, does it seem that every sort utility uses <I>quicksort</I>? Practical sort utilities have to be fast and have to be able to handle a wide variety of keys and key types. The methods described in Knuth's book that do not use comparison depend on the use of fixed-length keys. Also, although they might be faster for a sufficiently large number of records, they are slow for the numbers of records usually encountered. For example, to sort a group of records on a Social Security number using radix list sort would require 30 passes through the file!<P>
There is a way to overcome these deficiencies. In fact, the post office uses it every day. While researching this article (after writing the program), I found that Knuth alluded to it and left it as an exercise for the reader.<P>
<h4><FONT COLOR="#000080"><A name="018A_00C2">A Generalized Distribution Sorting Algorithm<A name="018A_00C2"></FONT></h4></P>
Upon receiving a huge bag of letters, a postal clerk distributes the letters into other bags by state. The bags are sent to the respective states, where another clerk distributes the letters into bags by city. The process continues until the bags are the size one person can carry and deliver. This is the basis for my sorting method, which I call the Postman's SortTM.<P>
Suppose you are given a large file or list of records to be ordered alphabetically on a particular field. Make one pass through the file, adding the record read to one of 26 sublists according to the first letter in the field. The first sublist contains all the records with fields starting with the letter <I>A</I>, while the last contains all the records with fields starting with the letter <I>Z</I>. Now you have divided the problem down to 26 smaller subproblems. The next step is to sort all the records in the <I>A</I> sublist. If there are no records in the <I>A</I> sublist you can proceed to the <I>B</I> sublist. If the <I>A</I> sublist contains only one record, the record can be written to output. If the <I>A</I> sublist contains more that one record, the list must be sorted, then output. Only after the <I>A</I> list has been disposed of can you move on to each of the other sublists in sequence.<P>
The records in each sublist will be written to the output in alphabetical order. What sorting algorithm should be used? Just like a real postman, use the Postman's Sort, applying the method to the second letter of the field. Continue the process to greater and greater depths until all the words starting with <I>A</I> have been written to the output. You can then proceed to deal with sublists <I>B</I> through <I>Z</I> in the same manner.<P>
The above algorithm is implemented in the accompanying program (<A href="list1.htm">Listing 1</a>, 
<A href="list2.htm">Listing 2</a>, <A href="list3.htm">Listing 3</a>, <A href="list4.htm">Listing 4</a>, <A href="list5.htm">Listing 5</a>, <A href="list6.htm">Listing 6</a>, and <A href="list7.htm">Listing 7</a>
do not contain the entire program, but only an interesting portion. The complete program is available on the code disk.). The function <I>psort</I> is passed a sublist. First, it determines how many records the sublist has. If there is only one, the record is written and the function returns. If the sublist is empty, it just returns. Otherwise it advances the pointer into the sort key and continues. <I>plan</I> and <I>allocate</I> reserve memory on the stack of sublist pointers. <I>dist</I> distributes the input sublist among the newly-created sublists. <I>dsort</I> calls <I>sort</I> for each of the newly-created sublists.<P>
<h4><FONT COLOR="#000080"><A name="018A_00C3">Reality Check<A name="018A_00C3"></FONT></h4></P>
A practical sort utility must be able to sort on any fields in any sequence with any collating sequence. The command-line syntax permits specification of delimited fields, start-of-key within each field, and specification of collating sequences for each field. (See the <a href="sidebar1.htm">sidebar</a>.) Sorting proceeds according to each key field. The first character within a field which corresponds to a zero-collating sequence terminates the field. The rest of the field is not considered in the sort. Sorting continues on remaining key fields. This means that <I>A&lt;0&gt;C</I> might be written to output before <I>A&lt;0&gt;B</I> in the final output. To prevent this, make sure that every character that could appear within a field is assigned a non-zero collating sequence value.<P>
To be really useful the program must take into account that records can have varying numbers of fields, fields can have varying numbers of characters, and that the command line may specify fields and/or key characters that a particular record does not contain. In general, keys corresponding to nonexistent fields are distributed with a collating sequence of zero. This turns out to be the most natural, convenient, and flexible of the possibilities considered, but it introduces some complications which require refinements of the algorithm.<P>
After distribution is completed by <I>dist</I>, the newly-created sublists are processed by <I>dsort</I>. Sublists corresponding to a zero-collating value are handled first. For these sublists, <I>dsort</I> advances key pointers to the next key field before continuing. The remaining sublists are handled as previously described.<P>
<h4><FONT COLOR="#000080"><A name="018A_00C4">Speeding Things Up<A name="018A_00C4"></FONT></h4></P>
Is this the best we can do? Suppose we wanted to sort 100 decks of shuffled playing cards by value and suit. We could first distribute by suit and then distribute each pile by value. But we probably wouldn't. What we would probably do is to arrange four rows and 13 columns. Each card would be dealt to the pile corresponding to its suit and value. All the cards could be sorted in one pass.<P>
When sorting on the basis of a key field, one way to speed things up would be to distribute among a larger number of sublists, so that the sort could be accomplished in one pass. The sublists would include &lt;0&gt;, <I>A, AA, AB...AZ, B, BA</I>, and so forth. In this case information on <I>1</I> + <I>26(1</I> + <I>26) = 703</I> sublists must be maintained in memory, but the effect is to reduce by half the number of times the key has to be addressed. The basic principle is to sort on the basis of as many bytes at a time as possible. To include all eight-bit bytes in the collating sequence you will need 64KB sublists to sort on two bytes at a time. This is not very practical (at least on Intel-type processors where the maximum-size data segment is 64KB). Fortunately, in the real world you usually know something about the fields you want to sort on. For example, a telephone directory would sort on names, last name first, and, since these fields contain only alphabetic characters, it's possible to take two bytes at a time. Similarly, since Social Security numbers contain only decimal digits, you can take three or four at a time before things get out of hand.<P>
The function <I>plan</I>, called from <I>sort</I>, determines the best number of bytes to take given the collating sequences defined for the key fields. It also sets up pointers to find the key fields. The program is designed to take bytes from more than one field on one pass. This should ensure that the maximum number of bytes possible has been used to distribute the record each time it is addressed. To sort a file of records on a Social Security number in the third field in format 999-99-9999, you could use the command line<P>
<pre>psort -k '0'-'9' -f 2 -c 0 -c 4 -c 7</pre>
The default setup for <I>asort</I> will allocate sublist space to handle three-decimal digits. The first time a record is addressed, it will be distributed on the first three digits. The second time, a hyphen (-) will be encountered at the next key position, so that all records with the same first three digits will be added to sublist 0. The third time, distribution will be on the middle two digits. Enough space will be allocated to distribute on three digits, but only a small portion will be used as each field will be terminated by the hyphen. The fourth distribution will be on the next three digits, and the fifth will be on the last digit and field terminator. To sort a file of records based on Social Security number in the third field in format 999-99-9999, the best command line would be<P>
<pre>psort -k '0'-'9' -f 2 -c 0-2 -c 4-5 -c 7-10</pre>
In this case <I>sort</I> would pass through the records only three times. In general, the more information supplied in the command line, the faster the sort is likely to be executed.<P>
<h4><FONT COLOR="#000080"><A name="018A_00C5">Storage Management<A name="018A_00C5"></FONT></h4></P>
Sublists are implemented as linked lists of records, so that moving records around is fast and simple. As records are read from the standard input, they are processed by the first distribution pass. If all the records don't fit in memory, a temporary disk file containing the sublists is created. Compiling with the Microsoft C v5.21 compact memory model (that's small code/large data), it turns out that, for an average file of less than 280 MB with random alphabetic keys, a given record will be written to and read from the temporary file at most once. If the system is MS-DOS, other problems arise first.<P>
As usual, a disproportionate part of the program is taken up with issues of memory management. I won't address that subject here, as it is peripheral to the content of the article.<P>
<h4><FONT COLOR="#000080"><A name="018A_00C6">Comparing Apples and Oranges<A name="018A_00C6"></FONT></h4></P>
Below I offer an informal analysis of the speed of the Postman's Sort for some different types of files. Comparative analysis of comparison sorting and the Postman's Sort is somewhat difficult since the methods are so different. As a basis for comparison, I use primitive operations, with each time instance of a record's being addressed and/or manipulated in some way counting as one operation. If the primitive operation has some sort of inner loop, as a string comparison does, each cycle of the inner loop counts as a primitive operation.<P>
For comparison sorts, this will be comparing two bytes and perhaps moving records. For the postman's sort, this will be manipulation of a byte from the key field. This is a rough approximation but one that I think is worthwhile.<P>
First, consider the case where a relatively short fixed-length key is used for the sort (e.g., a sort of accounting transactions by date in format <I>mmdd</I>). The number of days in a month or year is small enough that the job should be completed in one pass through the file, distributing records among 2x10x4x10 = 800 sublists. This is determined by using a key-of command line of<P>
<pre>-k '0'-'1' -c 0 -k '0'-'9' -c 1
-k '0'-'3' -c 3 -k '0' -'9'</pre>
In this case the number of primitive operations required by the postman's sort will be equal to the number of records to be sorted times four operations per record (since there are four bytes in the record). Note that this is an example of a sorting method which requires time proportional to the number of records in the file. And it's not just a toy problem.<P>
Using any comparison sorting method the number of comparisons will be at least <I>N</I>log<SUB>2</SUB>(<I>N</I>). Since the number of records far exceeds the number of keys, the number of primitive operations per comparison will be close to four. Using three as an estimate, the total number of primitive operations will be about 3<I>N</I>log<SUB>2</SUB>(<I>N</I>). The Postman's Sort will be faster than the fastest comparison sort by the following factor:<P>
<IMG SRC="equat1.gif"><P>
For 100,000 records the fastest comparison sort will require 12 times more primitive operations than the Postman's Sort.<P>
Next, consider the case of a relatively long variable-length key, as, for example, keys made of random alphabetic characters. Using the Postman's Sort and taking two characters at a time, the first pass through the file will generate 703 sublists. Each sublist will, in turn, be distributed among 703 sublists, etc., until each sublist has only one record. Hence each record will be addressed approximately log<SUB>703</SUB>(<I>N</I>) times where <I>N</I> is the number of records in the file. The total number of primitive operations will be 2<I>N</I>log<SUB>703</SUB>(<I>N</I>).<P>
Using a comparison sort, most of the comparisons are between keys that are close together. If there are fewer than 26 records in the file most comparisons would be expected to terminate on the first byte. If there are fewer than 26x26 records in the file most comparisons will terminate on the second byte, and so on. This works out to log<SUB>26</SUB>(<I>N</I>) primitive operations for each comparison. The number of comparisons is at least <I>N</I>log<SUB>2</SUB>(<I>N</I>). So the total primitive operation would be <I>N</I>log<SUB>2</SUB>(<I>N</I>)log<SUB>26</SUB>(<I>N</I>).<P>
For this file the Postman's Sort will be faster than the comparison sort by the following factor:<P>
<IMG SRC="equat2.gif"><P>
or almost 16 times faster for a 100,000 record file.<P>
<h4><FONT COLOR="#000080"><A name="018A_00C7">Just How Fast Is It?<A name="018A_00C7"></FONT></h4></P>
The above analysis is rather crude in that it makes a number of assumptions to simplify the calculations. It assumes that all types of primitive operations take the same amount of time to complete, and it doesn't allow for the fact that a practical program spends a lot of time in storage management overhead.<P>
To form a more concrete comparison, I generated test files consisting of variable-length records of random alphabetic characters, with an average record length of 15 bytes. The files were 1,000, 10,000 and 100,000 records long (15KB, 150KB, and 1.5MB). For comparison purposes, I used the sort program from the MKS Toolkit from Mortice Kern Systems, assuming that it uses some sort of comparison sort. The results are summarized in <A href="tab1.htm">Table 1</a>.
<P>
My machine is a 12-MHz AT-compatible with two 28ms Seagate 251-1 disk drives. One drive was used for temporary files. The number of drives used affected greatly the time for comparison sort of a large file, but it had little effect on the time required for the Postman's Sort.<P>
The test shows that while the Postman's Sort isn't as fast my theory predicts, it's still twice as fast at the next best thing.<P>
<h4><FONT COLOR="#000080"><A name="018A_00C8">Final Observations<A name="018A_00C8"></FONT></h4></P>
One of the most gratifying features of the Postman's Sort is that the first records are produced on the standard output before the file has even completed reading! In the test file, records that contain just a newline character are output as they are read in. When the last record is read in, the first non-null records appear almost immediately. In a multitasking system with pipes, much time can be saved because the subsequent process can proceed parallel with the sorting process. So, even though the sort itself is only twice as fast, jobs that use it may be improved much more.<P>
&copy; 1991 by Robert Ramey, all rights reserved.<P>

<h4><a href="../../../source/1992/aug92/ramey.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
