


<HTML>
<HEAD>

<TITLE>August 1992/Illustrated C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Illustrated C<A name="019D_00CE"><A name="019D_00CE"></font></h2><P>
<h3 align="center"><A name="019D_0000"><A name="019D_0000">A Portable Menu Compiler, Part 5: CMENU</h3><P>
<h3 align="center"><font color="#800000">Leor Zolman</font></h3><hr><blockquote><P>
<P><i><A name="019D_0000"><A name="019D_0000">Leor Zolman has been involved with microcomputer programming for 15 years. He is the author of BDS C, the first C compiler targeted exclusively for personal computers. Leor's first book, Illustrated C, is now available from R&amp;D Publications, Inc. Leor and his family live in Lawrence, KS.</i></P><P>
This is the fifth (and final!) installment of my series on CMENU, a small, portable pseudo-compiled language for implementation of full-screen menus. This month we'll examine how <I>rmenu</I>, the runtime menu interpreter, executes actions selected by the user. We'll also see how the machine-dependent portions of the <I>rmenu</I> program are isolated from the more generally portable code modules.<P>
<h4><FONT COLOR="#000080"><A name="019D_00CF">Running an Item<A name="019D_00CF"></FONT></h4></P>
The beginning of <I>rmenu3.c</I> (<A href="list1.htm">Listing 1</a>)
 is where an action item selected by the user begins execution. The <I>do_item</I> function takes parameters identifying the item to be executed and the current default path, and constructs the new incremental path from that information. Then, depending upon the type of action required, it dispatches control to one of several secondary functions: <I>do_cmnd</I> to execute a system command action, <I>do_emenu</I> to run an external menu, or <I>sub_menu</I> (covered earlier) to run a local menu.<P>
<I>do_item</I> supplies <I>do_cmnd</I> with pointers to an <I>ITEM</I> structure and the new incremental path. The system command that executes the specified action is constructed by the call to <I>make_cmd</I> in line 101.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D0">Constructing the System Command<A name="019D_00D0"></FONT></h4></P>
<I>make_cmd</I> contains system dependent code, so it has been placed in <I>rmenu4.c</I> (<A href="list2.htm">Listing 2</a>,
 lines 252-285).<P>
<I>make_cmd</I> takes two string parameters, <I>path</I> and <I>action</I>. Under DOS, any forward slash characters (/) in the <I>path</I> string are converted into backslash (\) characters, for compatibility with the standard DOS command processor. A static character array named <I>cmd_line</I> will contain the constructed command string.<P>
If the supplied path is non-null, then a <I>cd</I> command with the given path as the argument is written to the beginning of <I>cmd_line</I>. If running under DOS, a drive selection command is appended (lines 272-278) to make sure the drive specified in the path string is selected as the current drive. This step is unnecessary under UNIX, since UNIX does not maintain "current drives" the way DOS does. After selecting the new current path, the last thing appended onto <I>cmd_line</I> is the action text itself (line 279).<P>
When the supplied path is null, then the action text is directly copied to <I>cmd_line</I> with no further processing (line 282.)<P>
Back at <I>do_cmnd</I> (<A href="list1.htm">Listing 1</a>,
 line 103), it is time to prepare for execution of the new command string. First the <I>pre_clear</I> flag is tested to see if the screen needs to be cleared before running the command. There are two conditions under which the screen gets cleared. Either <I>pre_clear</I> has been explicitly set by a <I>preclear</I> option in the item specification, or there were no explicit instructions given about clearing the screen and the default action is to clear it (if <I>DEF_PRECLEAR</I> is <I>YES</I>).<P>
The screen cursor is then moved to the home position and the screen is refreshed. Before executing the system command, the <I>pre_shell</I> function is called to prepare for the excursion. <I>pre_shell</I> (lines 184-195) calls <I>push_path</I> to save the current path (DOS only) and calls <I>tty_shell</I> to set the terminal to normal interactive mode (all environments).<P>
Finally, in line 114, the <I>system0</I> function is called to execute the constructed command string.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D1">Running the System Command<A name="019D_00D1"></FONT></h4></P>
<I>system0</I> (<A href="list2.htm">Listing 2</a>,
 line 288) is another system dependent function. First, note there are two complete versions of this function. The UNIX/XENIX version is so trivial that I wrote it out separately to keep from cluttering the DOS version with conditional directives. All shells under UNIX/XENIX (sh, csh, etc.,) already support multiple commands and preservation of the parent process' current directory. So, all <I>system0</I> needs to do is pass the command string directly to a new command processor instance via the <I>system</I> function.<P>
Under DOS, these mechanisms must be simulated. The current path has already been saved by <I>pre_shell's</I> call to <I>push_path</I>. All that remains is to detect the presence of multiple commands, and to feed each individual command in sequence to DOS's command processor.<P>
The way I handled multiple commands is cheap and effective. First, the original command string is replicated (so as not to butcher the original) and the pointer <I>cp</I> is set to point to the beginning of the copy. In the main loop, any leading semicolons are first skipped (lines 320-321) and the pointer <I>cmdp</I> is set to the start of the next command. Then <I>cp</I> is advanced to the end of that command by scanning for one of two possible terminating characters: either a semicolon or a null. When one of these is found, its value is saved in <I>lastc</I> and the original character is forced to a null ('\0'). Now <I>cmdp</I> points to a single null-terminated system command, and in line 327 that command is finally passed to the DOS command processor.<P>
Upon return from the command processor, the original terminating character is restored and the loop continues on to process the remaining commands (if any).<P>
The value returned by <I>system0</I> is the return value of the last <I>system</I> call. This value cannot be trusted under DOS, however, since many DOS programs do not return any meaningful value for the command processor to pass back.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D2">Running an External Menu<A name="019D_00D2"></FONT></h4></P>
When <I>do_item</I> encounters an external menu, it calls upon the <I>do_emenu</I> function (<A href="list1.htm">Listing 1</a>,
 line 159) to process that external menu. <I>do_emenu</I> checks if we're already at the maximum level of external menu nesting; if so, it aborts with a fatal error.<P>
If not already at the maximum level of external menu nesting, a <I>make_path</I> call combines the current default path and the action text into the complete pathname for the new external menu. That pathname is stored in <I>filename</I> (line 174). The global nesting level variable <I>nestlev</I> is then incremented, and <I>do_menu</I> is called, recursively, to begin processing the external menu.<P>
After the <I>do_menu</I> call, <I>do_emenu</I> decrements the nesting level and passes back the value that was returned by <I>do_menu</I>.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D3">More System-Dependent Functions<A name="019D_00D3"></FONT></h4></P>
<I>rmenu4.c</I> (<A href="list2.htm">Listing 2</a>)
 contains most of the <I>rmenu</I> code that is system dependent. The file is organized into three sections: Curses functions, path management functions, and the <I>system0</I> function.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D4">The Path Stack<A name="019D_00D4"></FONT></h4></P>
Two path management functions, <I>push_path</I> and <I>pop_path</I> (lines 154-191), maintain a path stack when running under DOS.<P>
Before doing a shell escape or executing any action command, <I>rmenu</I> always calls the <I>push_path</I> function.Under UNIX based systems, this function is a no-op, because there is no way for any child process to alter the parent's current directory.<P>
Under DOS there is no such security. While shelled out to a command processor like COMMAND.COM, a user may select a different disk drive or path. Upon return from the shell session that drive and path will remain selected, potentially confusing the parent program's idea of where the current directory is. To guard against that possibility, the <I>push_path</I> function saves the current drive and path in an internal path stack before any system call that might potentially change them. The <I>pop_path</I> function restores the drive and path saved in the last call to <I>push_path</I>.<P>
Each time <I>push_path</I> is called, the currently logged drive and current working directory are pushed on the stack represented by the static structure array named <I>path_stack</I>, and stack pointer <I>path_stackp</I>. The current drive and directory are obtained via calls to the DOS standard library functions <I>getdisk</I> and <I>getcwd</I>.<P>
<I>pop_path</I> pops the last pushed drive and directory off the path stack, and calls the DOS standard library functions <I>setdisk</I> and <I>chdir</I> to restore the current drive and path.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D5">Path Construction<A name="019D_00D5"></FONT></h4></P>
The <I>make_path</I> function (lines 215-249) glues two pathname specifications together to form a single pathname. <I>make_path</I> takes two parameters: <I>old_path</I> represents the current default path, and <I>incr_path</I> is the new incremental path to be merged with the current path. (Under DOS, both strings are run through <I>trans_slash</I> to convert forward slashes into backslashes.) The method of merging depends on the nature of <I>incr_path</I>: if <I>incr_path</I> is an absolute path (beginning with a slash character or, under DOS, with either a slash or a disk designator), then <I>make_path</I> returns <I>incr_path</I> as the final new path specification.<P>
If <I>incr_path</I> begins with anything other than a slash or drive designator, then it is treated as a relative path to be appended onto <I>old_path</I> to yield the new incremental path. This happens in lines 237-247.<P>
First, <I>old_path</I> is copied into <I>newpath</I> (the buffer to hold the result). If both the relative path <I>incr_path</I> and the old path (now stored in <I>newpath</I>) are non-null, a path delimiter character is appended onto <I>newpath</I>. Finally, the new relative path is appended onto <I>newpath</I> and the incremental path is complete.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D6">Setting Curses Modes<A name="019D_00D6"></FONT></h4></P>
The first two Curses functions, <I>init_win</I> and <I>close_win</I> (lines 39-80), are called at the beginning and end of an <I>rmenu</I> session, respectively, to initialize and close down Curses support. Under DOS, <I>init_win</I> also reads the name of the active command processor from the system environment.<P>
The next two Curses functions set the terminal mode for either Curses or non-Curses operation. <I>tty_shell</I> sets the mode for interactive, non-Curses use by calling the Curses library function <I>reset_tty. tty_curses</I> sets the mode for use with Curses by calling several Curses library functions to set things up as necessary. Since I've only been able to test this program under XENIX and DOS, I suspect that <I>tty_shell</I> and <I>tty_curses</I> will be the first functions to require some modifications when porting <I>rmenu</I> to other systems.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D7">The Mystery of the Missing Memory<A name="019D_00D7"></FONT></h4></P>
My brother-in-law from Boston, his wife and their five kids visited with us in Lawrence last Christmas. Knowing the kids enjoyed computer games, I created a CMENU menu to organize all the best game programs on my system for the kids.<P>
A few of those game programs, like Willy Beamish and Chessmaster 3000, wouldn't run when invoked from CMENU. Evidently, CMENU took up too much base RAM space when resident. Not having diddled very much with C's memory allocation faclilities under DOS, my first approach to this problem was to try to reduce <I>rmenu'</I>s memory requirements by tweaking some of the parameters in <I>cmenu.h</I>. I decreased the values of <I>MAX_MENUS</I>, <I>MAX_NEXT</I>, and <I>MAX_ITEMS</I>, and ran a <I>make</I>. To gauge the effect, I shelled out to DOS (using the <I>!</I> command) while running under both the old and new versions of <I>rmenu</I>, and ran DOS's <I>mem</I> command to check free memory. No difference! While shelled out to DOS, I got 530KB of free memory under both the old and new configurations. Hmmmmm... reducing <I>MAX_NEXT</I> alone should have had some impact. Clearly, there was something going on that I didn't understand.<P>
Next, I analyzed my memory usage. With nothing except my startup TSR's resident, running <I>mem</I> told me I have 627KB of free RAM (that's with QEMM386 and all its optional gizmos fully deployed on my VGA-based system.) The size of the <I>RMENU.EXE</I> executable module is about 33KB. If I was only getting 530KB free when running <I>rmenu</I>, then <I>rmenu</I>'s code plus its data were taking up a total of 97KB, and the data portion of that was therefore (97KB-33KB) = 64KB. Interesting number! Hunting through the Borland manuals, I located a reference to an external variable named _<I>heaplen</I>. This variable controls the allocation of the near heap, the default memory pool for small- and medium-model programs. If the initialized value of _<I>heaplen</I> is zero, then the system automatically allocates 64KB of memory for the near heap! I had never heard of _<I>heaplen</I> before, so of course my program never initialized it.<P>
I added the code in lines 18-20 and 29-31 of <I>rmenu4.c</I> to support the initialization of _<I>heaplen</I> to some arbitrary value. If <I>HEAPSIZ</I> is left undefined (as in the listing, where the definition line is commented out), then 64KB of heap space will be allocated. If <I>HEAPSIZ</I> is defined, either by removing the opening /* sequence from line 19 or by including an option such as<P>
<pre>    --DHEAPSIZ=20000</pre>
on the compiler command line, then the value specified for <I>HEAPSIZ</I> will be plugged into the _<I>heaplen</I> initialization in line 30.<P>
For memory-critical applications, the best value can be found by trial-and-error. I discovered that my memory-hogging games have just enough room to run when _<I>heaplen</I> is initialized to 20000. Sure enough, when shelled out from <I>rmenu</I>, the <I>mem</I> command now reports 574KB free.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D8">Getting This Code<A name="019D_00D8"></FONT></h4></P>
This concludes my series of columns on CMENU. If you would like to obtain the complete source code for the program in machine readable form, you may order the CUJ code disk for any of the issues in which a segment of this series has appeared. Each such code disk contains the combined CMENU source code from all installments.<P>
Another way to get the code is to download the appropriate code disk file from the UUNET CUJ code disk archives.Elsewhere in this issue of CUJ is a box explaining how to obtain CUJ code from UUNET using standard uucp software.<P>
<h4><FONT COLOR="#000080"><A name="019D_00D9">Exercises<A name="019D_00D9"></FONT></h4></P>
1) The symbolic constants having names beginning with <I>DEF</I>_ control the default behavior of CMENU language options that are not explicitly controlled in an item definition. Make these default options, presently hard-wired at compile time, into CMENU language options that may be specified as part of a menu source file's options section (that is, at the same level as the <I>title</I> and <I>spacing</I> options).<P>
2) A bit tougher: extend the scope of the default specifications created in 1) above, as well as the <I>escape/noescape</I> permission status, to any and all submenus that may be invoked. Hint: you'll need to add parameters specifying the current state of all the affected options to the <I>sub_menu</I> function's parameter list.<P>
3) Extend the <I>rmenu</I> memory-allocation strategy to include <I>COORDS</I> structure information as part of the dynamic <I>ITEM</I> allocation scheme (i.e., make it so that storage for the <I>COORDS</I> data is only allocated when necessary). After doing that, calculate how much memory is saved, and contrast the value of saving that memory with the price of the added complexity necessary to support the savings. Was it worth it? The answer probably will depend on how neatly the mechanism has been incorporated into the existing framework.<P>
4) Remove the hardwired aspect of the screen characteristic definitions, so that <I>rmenu</I> does not have to be recompiled to support different terminal sizes. There are at least two ways to accomplish this: a) extend the CMENU language to allow screen dimensions to be written into menu specification files (this approach will most likely require major changes to all portions of the system); b) allow some or all of the screen characteristics to be specified at <I>rmenu</I> run time. This may be implemented in terms of individual command line options to <I>rmenu</I>, or perhaps just one option that gives the name of a special ASCII initialization file that <I>rmenu</I> can read at the beginning of a session to determine what screen characteristics to use.<P>
5) Under DOS, any semicolon characters found in action strings are treated as delimiters between multiple commands. Thus, the semicolon character is precluded from being part of any actual system command. Extend the <I>system0</I> function to support a method for "escaping" semicolons.<P>

<h4><a href="../../../source/1992/aug92/zolman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
