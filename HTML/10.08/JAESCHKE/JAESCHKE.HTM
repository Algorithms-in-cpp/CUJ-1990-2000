


<HTML>
<HEAD>

<TITLE>August 1992/Doctor C's Pointers</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Doctor C's Pointers &reg;<A name="019B_00CC"><A name="019B_00CC"></font></h2><P>
<h3 align="center"><A name="019B_0000"><A name="019B_0000">Data Structures, Part 15: Trees (continued)</h3><P>
<h3 align="center"><font color="#800000">Rex Jaeschke</font></h3><hr><blockquote><P>
<P><i><A name="019B_0000"><A name="019B_0000">Rex Jaeschke is an independent computer consultant, seminar leader, and author of several books, including The Dictionary of<I></I> <I></I>Standard C (Professional Press, Horsham, PA). Readers are encouraged to submit column topics and suggestions to Rex at 2051 Swans Neck<I></I> <I></I>Way, Reston, VA, 22091 or via UUCP at rex@aussie.com.</i></P><P>
Last month, I introduced tree structures and represented them in statically-allocated arrays of structures. Of course, this is rather limiting. In most cases the number of nodes in the tree will be unknown at compile-time. So this month, I provide for dynamic allocation and removal of nodes along the same lines as I did for linked lists earlier in this series.<P>
The new program has several other enhancements. Each node contains a pointer to a string so the length of the string is not limited by the node size. The program can also determine the number of nodes in the tree at any time, display the contents of any given node, determine the maximum depth of the tree, and print out the nodes in alphabetical order. The only tree-traversal option provided is infix order. (The other traversal methods from last month's column could easily be adapted as well.)<P>
By maintaining a tree in some sorted order of node value, you can locate any given node by value much easier on average than if you were using a sorted linked list. And if the tree is reasonably well balanced, each node will be approximately mid-way between each of its subtrees. That is, when the value being searched for is less than that of any node, you follow the left branch. And, when the value is greater than that of any node, you follow the right branch. Eventually, you'll find a match or a NULL pointer which indicates no such node exists. At every node that does not match you follow only the subtree to the left or right. As such, the number of levels you have to search in the worse case depends directly on the depth of the subtree you traverse. In a completely balanced tree, the depth of all possible branches is the same.<P>
<A href="list1.htm">Listing 1</a>
contains the first part of the program to manage a dynamically-allocated binary tree.<P>
<A href="fig1.htm">Figure 1</a>
shows some input and corresponding output when the program was run. To trace what is happening, draw a binary tree and show what happens as each node is added. When the tree is printed, a hyphen (-) indicates a node has no child in a given (left or right) direction.<P>

<h4><a href="../../../source/1992/aug92/jaeschke.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
