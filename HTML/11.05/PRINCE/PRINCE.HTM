

<HTML>
<HEAD>

<TITLE>May 1993/Performance Tuning a Complex FFT</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Performance Tuning a Complex FFT<A name="0116_0079"><A name="0116_0079"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0116_0000"><A name="0116_0000">Tim Prince</font></h3><hr><blockquote><P>
<P><i><A name="0116_0000"><A name="0116_0000">Tim Prince has a B.A. in physics from Harvard and a Ph.D in mechanical engineering from the University of Cincinnati. He has 25 years of experience in aerodynamic design and computational analysis. He can be reached at Box 3224, Rancho Santa Fe CA 92075.</i></P><P>
<h4><FONT COLOR="#000080"><A name="0116_007A">Introduction<A name="0116_007A"></FONT></h4></P>
Much of the current lore on how to program in C and other languages for best execution speed is based on older architectures such as PDP, VAX, and 8088, and early compilers. Modern compilers for RISC architectures must do a good job of automatic register allocation and instruction scheduling or lose the benchmark wars. While much excellent literature on algorithms is available, published code often falls short on performance. In this article, I show step-by-step performance enhancements for a commonly-used algorithm, the complex fast Fourier transform. This algorithm is taken as a typical example of resolution of performance bottlenecks, as much as for its practical interest.<P>
<h4><FONT COLOR="#000080"><A name="0116_007B">Basic Code<A name="0116_007B"></FONT></h4></P>
The starting point is the complex FFT code given by Press et al. (1988), slightly modified for compatibility with their earlier FORTRAN version. (The original is credited to N. Brenner.) Using single precision (<I>float</I>) data, the overhead of trig function evaluations is minimized by calculating <I>sin</I> only in the outer loop, using <I>double</I> arithmetic to prevent error accumulation from degrading the results.<P>
The modifications consist of passing arguments by reference, using zero-based arrays, and not using shift operators when multiplication is meant, as modern compilers make these conversions internally.<P>
Each version has been tested using the test drivers published by the same authors. Timing tests are performed on batches of 1,000 transforms using 1,024 data points, using <I>clock</I>. The published version took 4.6 milliseconds for a 1,024 transform on an HP730.<P>
<h4><FONT COLOR="#000080"><A name="0116_007C">Precision Conversions Outside Inner Loop<A name="0116_007C"></FONT></h4></P>
The code was originally written for K&amp;R compilers. Some of these compilers did not round the <I>tempr</I> and <I>tempi</I> results down to <I>float</I> precision, as they tried to promote all floating-point arithmetic to <I>double</I>. Declaring all local variables <I>double</I> produces slightly better accuracy than the original code, at least when Standard C compilers are used. If more than seven significant digits are required, everything including the <I>data[]</I> arrays must be typed <I>double</I>.<P>
Placing <I>(float)</I> casts on the <I>double</I> variables in the inner loop permits the compiler to move these data conversions to the pre-loop setup code block, helping architectures that do not perform operations of mixed precision efficiently. This change does not reduce the accuracy significantly. The 1,024 transform now takes 3.85 milliseconds.<P>
<h4><FONT COLOR="#000080"><A name="0116_007D">Help Compiler Optimize Data Fetches<A name="0116_007D"></FONT></h4></P>
Sufficient information is contained in the code to prove that <I>j</I> is always greater than <I>i+1</I> where the data arrays are accessed, enabling a hypothetical optimizing compiler to determine that the <I>j</I> subscripts cannot point to the same data as the <I>i</I> subscripts. Existing compilers do not perform such an analysis. In the original version, the generated code allowed for the possibility that modifying <I>data[j]</I> and <I>data[j+1]</I> (which were stored first) might change <I>data[i]</I> and <I>data[i+1]</I>. This prevents the use of register values of<I> data[i]</I> and <I>data[i+1]</I>. Most compilers do take advantage of the non-overlap of pointers that differ by a known constant.<P>
The cure is simple &#151; copy the data into a local register-eligible variable that is not affected by assignments to array elements. With this change, the compiler is free to generate code that fetches the data sooner. Earlier data fetches reduce the impact of cache misses, although this should not be a factor in the present application. Now the same FFT is performed in 3.6 milliseconds.<P>
<h4><FONT COLOR="#000080"><A name="0116_007E">Simplify Use of Trig Functions<A name="0116_007E"></FONT></h4></P>
As the published code calculates <I>cos(theta)</I> from <I>sin(theta/2)</I>, and <I>sin(theta/2)</I> is a value that will be used in the next outer loop iteration, rearrangement allows just one computation of <I>sin</I> per outer loop iteration. The published code, rather than adding 1 in this calculation of <I>cos</I>, delays the addition to the end of the recursion formula in the middle loop. This is a standard technique for preservation of accuracy, but it is unnecessary since the recursion formulae are already coded in higher precision than the inner loop.<P>
With <I>cos</I> calculated in the outer loop, the benchmark timing is 3.5 milliseconds. Numerical results were not affected by this substitution. By tinkering with the assembly code, it is possible to get this down to 3.3 seconds. Since the cache hit rate is higher than normal, certain load instructions may be delayed to places where an instruction requires the result of the previous instruction, so that all instructions are given two cycles to execute. The final source code is shown in <A href="list1.htm">Listing 1</a>.
<P>
<h4><FONT COLOR="#000080"><A name="0116_007F">Pipeline Priming (Partial Unrolling)<A name="0116_007F"></FONT></h4></P>
All of the modifications discussed previously should be helpful or at least neutral on any modern computer. We have gained 30% in speed on the HP computer, without doing anything specific for that architecture. As most instructions on the HP take more than one instruction clock cycle to execute, the compiler attempts to schedule instructions so that operations can overlap. In several places, the generated code does not have the optimum number of instructions between an instruction that changes the contents of a register and one that uses the new contents of the register.<P>
Because of the sequential nature of the code, only two of the four multiplication operations are executed in parallel with addition operations. Two of the last four add and subtract operations are capable of being written as two-operand operations, without introducing an extra register copy. These are eligible to be executed in parallel with a multiply operation on the HP. If you want to get more parallelism and allow more cycles for completion of each instruction, you need loop unrolling. Loop unrolling techniques performed by many current compilers increase the time required to start up the loop. This is unsatisfactory, as the average inner loop count for an FFT of order 1024 is only 5.<P>
You can prime the pump, so to speak, by rearranging the code to permit pipelines to fill sooner. As the code normally is written, the only operations that are ready to be performed at the top of the loop are data fetches from memory to register. You need enough data in registers to permit the floating-point arithmetic pipelines to start immediately. On the HP architecture, you need to perform the first two multiplications also at the end of the previous iteration of the loop, so that they may be performed in parallel with addition or subtraction operations. This keeps the pipelines full closer to the end of the loop body.<P>
One copy of the first part of the loop body is placed ahead and the other at the end of the iterated part of the loop. The remainder of the original loop body is copied after the iterated part of the loop. All of the data used in the new loop body are copied into registers before any results are stored in the data arrays, in order to get around the lack of compiler analysis for data overlap. Changing the way <I>j</I> is calculated for the next loop iteration saves us from having to calculate it in the post-loop body, but makes no difference otherwise. Arranging the conditions to run one less iteration of the loop, you end up performing exactly the same job, except that there are two copies of all of the loop body code and, in effect, one iteration of the loop is always performed. The unrolled inner loop is shown in <A href="list2.htm">Listing 2</a>.
<P>
If it were necessary to allow for a zero iteration case, the whole unrolled inner loop could be placed within an <I>if</I> block. In this application, the original inner loop could have been written as a<I> do-while</I>, to emphasize the fact that at least one iteration is always taken. Although this saves a couple of instructions, there is no measurable change in performance. Current compilers transform a <I>while()</I>{} loop into <I>if() do{} while()</I> when that will improve performance.<P>
The code will perform nearly as well if the inner loop is allowed to iterate once more, so that the duplicate code for the latter part of the original loop is not needed. The data array must be made large enough to avoid picking up data outside the array. Zero values will do in the extended part of the array. Values that generate underflows or exceptions will take a long time even though they do not affect the results.<P>
For the FFT algorithm, arrangements similar to <A href="list2.htm">Listing 2</a>
are useful on a range of architectures. The benchmark now executes in 3.1 milliseconds, a 45% improvement over the original code. The effect of unrolling will be greater on an architecture that takes more advantage of parallelism than the HP 7x0 series. While the code generated by the HP compiler does not appear to be optimum, no significant additional performance has been achieved by tinkering with it.<P>
<h4><FONT COLOR="#000080"><A name="0116_0080">Conclusion<A name="0116_0080"></FONT></h4></P>
A published implementation of the complex FFT can be speeded up 30% by simple changes in the source code that eliminate unnecessary data conversions and redundant memory access. Execution speed can be increased another 12% by appropriate source code unrolling techniques on a typical pipelined RISC workstation. These performance increases are larger when cache hit rate is reduced. The unrolling technique shown performs well even with a small number of loop iterations.<P>
<h4>References</FONT></h4></P>
Press, Flannery, Teukolsky, Vettering. 1988. <I>Numerical Recipes in C.</I> Cambridge University Press.<P>
Vettering, Teukolsky, Press, Flannery. 1985. <I>Numerical Recipes Example Book (FORTRAN)</I>. Cambridge University Press.<P>

<h4><a href="../../../source/1993/may93/prince.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
