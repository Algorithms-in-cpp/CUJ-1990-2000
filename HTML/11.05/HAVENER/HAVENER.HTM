

<HTML>
<HEAD>

<TITLE>May 1993/An Object-Oriented Frog Pond</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Object-Oriented Programming</FONT></H2>

<hr><h2 align="center"><font color="#800000">An Object-Oriented Frog Pond<A name="010E_0077"><A name="010E_0077"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="010E_0000"><A name="010E_0000">Charles Havener</font></h3><hr><blockquote><P>
<P><i><A name="010E_0000"><A name="010E_0000">Charlie Havener is a software engineer at Epsilon Data Management in Burlington, MA, where he is developing a custom query language compiler in C++ for the CM5 Connection machine super computer. He holds two masters degrees in EE and CS and teaches an advanced C++ lab course in the Northeastern University State-of-the-Art program. He may be reached on the Internet, cdh@world.std.com or cdh@epsilon.com</i></P><P>
<h4><FONT COLOR="#000080"><A name="010E_0078">Introduction<A name="010E_0078"></FONT></h4></P>
In this very special frog pond you will encounter objects that change. A <I>Tadpole</I> will change into a <I>Bullfrog</I> even as an external pointer to it on a linked list does not change. The implementation technique that permits this bit of magic to happen is the powerful C++ "envelope and letter class" idiom. You can find it presented by James Coplien in his book <I>Advanced C</I>++ (Coplien 1992). To construct the various kinds of creatures that are the <I>letter</I> classes, you need a <I>virtual constructor</I> in the <I>Creature</I> base class.<P>
You can implement this special kind of constructor by making use of an enumeration type, as in:<P>
<pre>enum type{
   BULLFROG, TADPOLE, ...};</pre>
But that is rather unsatisfying. The job can be better accomplished using a variation on the clone technology presented by Tom Cargill in his article "Virtual Constructors Revisited" (Cargill, Sept. 1992).<P>
Here there be magic. Watch carefully and see if you can keep your wits, sanity, and sense of humor intact as we all go for a swim in the object-oriented frog pond.<P>
<h4><FONT COLOR="#000080"><A name="010E_0079">A Boring Little Frog Pond<A name="010E_0079"></FONT></h4></P>
<A href="fig1.htm">Figure 1</a>
shows a first attempt at a class hierarchy to represent various creatures in a pond. I will concentrate on frogs, but you can imagine extending it to different kinds of fish, bugs, and other slimy things. <A href="list1.htm">Listing 1</a>
shows how a <I>Pond</I> can be instantiated and populated with creatures.<P>
The <I>Pond</I> class consists of an embedded singly-linked list of pointers to creatures as the only data object (see <A href="fig2.htm">Figure 2</a>)
, and two member functions. The <I>Pond::insert</I> function sticks freshly created creatures into the linked list by calling the list's <I>insert</I> function. I have chosen to use the generic singly-linked list from the Rogue Wave tools.h++ library, but anything you have available will do. This list just contains pointers to the objects it controls. It does not "own" the objects themselves just because you inserted them. You still own them.<P>
The <I>Pond::activate</I> function is a bit trickier. You can imagine the creatures having several member functions, like <I>move</I> and <I>soundoff</I>, that have the same signature. They take no arguments and return nothing. Then, using the weird but useful C++ pointer-to-member syntax, you can bind a pointer to a virtual <I>move</I> or <I>soundoff</I> function in the <I>Creature</I> base class. You pass this pointer as an argument to the <I>activate</I> member function of <I>Pond</I>.<P>
The <I>activate</I> function iterates over the list, using the generic singly-linked list iterator in the case of Rogue Wave. That's how you broadcast the desired function activation request to all creatures in the pond. Simple huh?<P>
It is easy to imagine storing lots of additional information about the frogs in the <I>Frog</I> base class. Some examples are gender, color, and age. But what about age? Remember, as tadpoles age they turn into frogs.<P>
<h4><FONT COLOR="#000080"><A name="010E_007A">Changing an Object in Situ<A name="010E_007A"></FONT></h4></P>
Say the <I>Creature</I> base class contained a pointer to a creature as a data member and <I>Creature::move</I> forwarded the <I>move</I> operation through this pointer. Then you could alter the pointer somehow and thus effectively change the body of the creature at runtime.<P>
This interesting technique is called the "envelope and letter class" idiom (depicted in <A href="fig3.htm">Figure 3</a>)
, as I mentioned earlier. The "letter" is one of a set of classes publicly derived from the base or "envelope" class. The outside world accesses the letter only through the envelope. <A href="list2.htm">Listing 2</a>
shows how the <I>Creature</I> base class has been fleshed out with a data member that points to a creature. The virtual <I>move</I> member function merely passes the work along to the letter object through the pointer.<P>
Note that the constructor now takes an enumerated type as one of its arguments. Using an enumerated type is not considered good style. It means the base class must know about all of its derived children and must be modified any time a new derived class is invented. To add different kinds of fish, you have to alter the base class enumerated type. You also have to alter the so-called virtual constructor for class <I>Creature</I>. It has an ugly <I>case</I> statement, the <I>goto</I> of object-oriented programming.<P>
Another interesting new aspect of <A href="list2.htm">Listing 2</a>
is the protected constructor in class <I>Creature</I>. This or some similar mechanism is needed to initialize the <I>Creature</I> class when it is part of the letter class. That is, when a <I>Frog</I> is instantiated, some constructor for the base class <I>Creature</I> must be invoked. In this example you don't need a default constructor for <I>Creature</I>. It is not meant to be instantiated by itself. Bruce Eckel shows a good approach in his article "Virtual Constructors" (Eckel Mar/Apr 1992). A protected default constructor does the job nicely.<P>
Each <I>Creature</I> now has an envelope with the object pointer set to the letter, and a letter with its object pointer set to zero. This approach wastes some space. Attempts to reuse data that is common to the envelope and letter by placing it in a union requires the utmost care. If we needed a default constructor in the base class, then we just make a constructor in the base <I>Creature</I> class that takes a funny argument such as a <I>class Noop</I>{}. (See Coplien's polymorphic <I>Number</I> example in <I>Advanced C</I><I>++</I>.)<P>
The constructors, especially the copy constructor, of the derived classes must be sure to invoke the special base constructor or there can be infinite recursion. Clearly <A href="list2.htm">Listing 2</a>
is less than perfect. It shares the defect with <A href="list1.htm">Listing 1</a>
of using plain old pointer to <I>char</I> instead of a <I>const</I> pointer to <I>char</I>. Furthermore, copy constructors are needed everywhere or utter failure at runtime is guaranteed. And we have not yet done any object changing in place. So let's move on.<P>
<h4><FONT COLOR="#000080"><A name="010E_007B">A Complete Solution<A name="010E_007B"></FONT></h4></P>
<A href="list3.htm">Listing 3</a>
combines everything I have discussed, together with an extension to the clone technology presented by Cargill in "Virtual Constructors Revisited" to eliminate the need for an enumerated type and a case statement. Cargill optimizes away the very need for an envelope and letter class, but here I want to keep it. So the clone techniques have to be carefully applied.<P>
Careful attention has been paid to getting all the copy constructors properly implemented, an essential part of success. Not to beat a dead horse, but copy constructors are frequently left out when the class has either no data or only simple predefined types such as integers. However, when inheritance is involved, as here, explicit copy constructors are needed to invoke the base-class copy constructors. Even Coplien accidently left out the copy constructors from an "envelope and letter" example in the first edition of <I>Advanced C</I>++. Let's consider how things change in place before looking closer at the clone technique.<P>
The first thing to notice is that the <I>Creature</I> base class has sprouted quite a few additional functions and a static data member, <I>altered</I>, which is also a pointer to <I>Creature</I>. This pointer is needed so the <I>move</I> member function in the envelope <I>Creature</I> base class can test it after the letter class <I>move</I> is called.<P>
If the letter class has decided to change itself into another object, it must communicate this desire to the envelope in some way. It can't do so itself. That is like pushing on a string. The letter class has absolutely no way of communicating to the envelope except through a return value from a function, such as <I>move</I>, or through a global variable. The static <I>Creature</I> variable <I>altered</I> is a restricted global variable. It serves the purpose so long as the class doesn't have to be re-entrant. It must be static or the letter class would just be setting the variable called <I>altered</I> in its own base and not in the envelope base. Remember, there are two copies of all the data in the <I>Creature</I> base class.<P>
Rather than do anything complicated for this example in terms of time and ageing, the <I>Tadpole::move</I> function just increments the age each time it is called. It makes a new <I>Bullfrog</I> when the time comes and sets the static class variable <I>altered</I> for use by the envelope class. The <I>move</I> member function in the envelope class tests <I>altered</I>. If the variable is non-zero, the function deletes the existing pointer to <I>Creature, Tadpole</I> for example, and replaces it with <I>altered</I>, which in this case is a pointer to <I>Bullfrog</I>. Finally the function resets <I>altered</I> to zero.<P>
The clone technique uses a static class member <I>newCreature(const Creature&amp;)</I> of class <I>Creature</I> to make new creatures. Every class now has a <I>clone</I> member function which returns a pointer to <I>Creature</I>. These <I>clone</I> functions return pointers to objects that will be letter objects.<P>
The static <I>newCreature(Creature &amp;)</I> function requires a <I>Creature</I> constructor that takes a pointer to a creature as its argument. This is absolutely essential because the <I>newCreature</I> function must return a pointer to an envelope <I>Creature</I>, not a letter <I>Creature</I>. If you think you've been having a bad day, just try debugging an envelope/letter program when you accidently pass around pointers to letter objects instead of envelope objects! Recall that the Creature pointer in the letter object is set to zero. Trying to pass work off through a null pointer does bad things. C++ does an outstanding job of finding bugs at compile time by enforcing type checks. However, the envelope/letter idiom moves a program into the realm of runtime type modification. It is much easier to get in trouble.<P>
The main program creates new creatures of any kind by invoking the static <I>Creature::newCreature</I> function and passing it a reference to some creature to be cloned. If the kind of creature you want is not already extant, make an anonymous one, as shown in <A href="list3.htm">Listing 3</a>,
 which the compiler will arrange to delete at its convenience. Presumably, it would be desirable to modify the attributes of the new clone using various member functions in a straightforward fashion. This example merely maintains the name.<P>
<h4><FONT COLOR="#000080"><A name="010E_007C">Conclusion<A name="010E_007C"></FONT></h4></P>
You have seen a cute but usable example of the "envelope and letter class" idiom. You have also seen how it can be combined with clone technology to provide an extendable framework for situations that require objects that change in place at runtime. It's not an easy idiom to understand or to get right. But once you master it, you will find it to be a powerful addition to your kit of C++ tools.<P>
(C) 1993 Charles Havener<P>
<h4>References</FONT></h4></P>
Cargill, Tom. September 1992. "Virtual Constructors Revisited," <I>C</I>++ <I>Report</I>.<P>
Coplien, James O. 1992. <I>Advanced</I> <I>C</I>++. Reading, MA: Addison-Wesley.<P>
Eckel, Bruce. March/April 1992. "Virtual Constructors," <I>C</I>++ <I>Report</I>.<P>

<h4><a href="../../../source/1993/may93/havener.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
