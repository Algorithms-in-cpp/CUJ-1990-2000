

<HTML>
<HEAD>

<TITLE>May 1993/Writing a UNIX Device Driver, Second Edition</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Book Reviews</FONT></H2>

<hr><h2 align="center"><font color="#800000">Writing a UNIX Device Driver, Second Edition<A name="0126_0087"><A name="0126_0087"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0126_0000"><A name="0126_0000">Reviewed by Sydney S. Weinstein</font></h3><hr><blockquote><P>
<P><i><A name="0126_0000"><A name="0126_0000">Sydney S. Weinstein, CDP, CCP is a consultant, columnist, lecturer, author, professor, and President of Datacomp Systems, Inc., a consulting and contract programming firm specializing in databases, data presentation and windowing, transaction processing, networking, testing and test suites, and device management for UNIX and MS-DOS. He can be contacted care of Datacomp Systems, Inc., 3837 Byron Road, Huntingdon Valley, PA 19006-2320 or via electronic mail on the Internet/USENET mailbox syd@DSI.COM (dsinc!syd for those that cannot do Internet addressing).</i></P><P>
Janet Egan and Thomas Teixeira have updated their book <I>Writing a UNIX Device Driver</I> to encompass the newer versions of UNIX including BSD 4.3 and USL System V Release 4.0. Their goal was to lead the experienced programmer who has never written a device driver or one who has written device drivers for non-UNIX systems or older UNIX systems through the steps necessary to write both a character (raw) and a block (buffered) device driver for UNIX. They tried to accomplish this by explaining the input/output subsystem, describing a device driver, what it must handle, how the device driver and the hardware interact, and then how the device driver and UNIX interact.<P>
Writing a device driver has never been a simple task. There are many performance, reliability, and debugging obstacles to overcome. In this book, Egan and Eixeira have tried to show programmers experienced in writing device drivers for non-UNIX systems and for older UNIX systems, or experienced programmers who have never written a device driver before, how to write a device driver for the current UNIX systems. However, they fall short of that goal.<P>
<h4><FONT COLOR="#000080"><A name="0126_0088">Content<A name="0126_0088"></FONT></h4></P>
The book is divided into 11 chapters and five appendices. All chapters include code examples to illustrate the chapter topic. The subject matter of the chapters is:<P>
<UL><li>Chapters 1 and 2 &#151; introduction to the UNIX I/O subsystem, with the emphasis on the underlying data flows through the operating system to satisfy the users I/O requests.</li>
<li>Chapter 3 &#151; introduction to the UNIX device driver by discussing the required entry points.</li>
<li>Chapter 4 &#151; how a driver interacts with the various types of I/O hardware.</li>
<li>Chapter 5 &#151; configuring the UNIX operating system and installing a new device driver.</li>
<li>Chapters 6 and 7 &#151; the device driver and its various options including Interrupt, Synchronous, and DMA drivers.</li>
<li>Chapter 8 &#151; hints on debugging your new driver.</li>
<li>Chapter 9 &#151; a template that can be used in writing your own driver.</li>
<li>Chapter 10 &#151; the special aspects of SCSI drivers</li>
<li>Chapter 11 &#151; streams</li></UL>
The appendices provide a tour of the header files used for drivers, a list of the kernel support routines available, a template character device driver, a template block device driver, and a table of considerations in porting existing UNIX/XENIX drivers to the current UNIX versions.<P>
Using this book requires having a copy of a UNIX device driver manual handy. It does not present the information contained in that manual. For System V Release 4, having a copy of the DDI/DKI (Device Driver Interface/Driver-Kernel Interface) manual is essential because the options, arguments, and calling sequences to each kernel interface routine are not explained in the book. For other UNIX operating systems, access to the appropriate volume for your vendor is also necessary.<P>
<h4><FONT COLOR="#000080"><A name="0126_0089">Commentary<A name="0126_0089"></FONT></h4></P>
The introductory text for each chapter flows well, but lacks detail, and sometimes correctness. When the authors discussed matters of the UNIX operating system outside the realm of writing device drivers, I found myself saying, "That's not how it works," several times as I read the book. However, these oversights and incorrect statements are only in the sidebar-type information on the functioning of the rest of the UNIX operating system around the device driver, and don't detract from the discussion of the device driver itself.<P>
The authors did not do a thorough job of revising the book. There are often subtle mistakes in some of the text, which sometimes is the older method that never got completely updated for the second edition.<P>
The examples offered in the book are short and present the bare minimum needed to explain each concept. Although explained action by action, the examples are so minimal that the explanations seem shallow and simplistic, presenting only the basics of the problems. The authors cover none of the useful and often required extra details, such as error recovery, timeouts, status tracking, or the interfaces into the systems performance monitoring routines.<P>
Overall, I think this book relies too heavily on prior knowledge of the reader, without explicitly stating special requirements for comprehension. First, it seems to require the reader to have read the first edition. Too many times the book refers to how things used to be or to the text in the first edition, but never presents the old way or text, leaving a description hanging without the sample code or a proper reference.<P>
In addition, the book seems to require the reader to have written a UNIX device driver, in spite of its stated goal of helping the programmer who has never written a UNIX device driver learn to write a UNIX driver. It would be easy for people to get lost if they have never written a UNIX driver before. The book meets its goal of bringing a prior-UNIX device driver writer up to speed on SVR4 and BSD4.3 (if one overlooks the editing mistakes). However, it falls short of its goal of teaching programmers not experienced with writing UNIX device drivers to write one.<P>
<h4><FONT COLOR="#000080"><A name="0126_008A">Conclusion<A name="0126_008A"></FONT></h4></P>
If you have written a UNIX device driver for an older UNIX system and need to get up to speed for a newer version such as System V Release 4 or BSD 4.3, this book could be of some use to you. But if you have never written a UNIX device driver before, don't expect this book to help much.<P>
<B>Title:</B> <I>Writing a UNIX Device Driver second edition</I><br>
<B>Author:</B> Janet I. Egan<br>
Thomas J Teixeira<br>
<B>Publisher:</B> John Wiley &amp; Sons, Inc.<br>
605 Third Avenue<br>
New York, NY 10158-0012<br>
<B>Price:</B> $29.95<br>
<B>ISBN:</B> 0-471-53574-5<P>
</BLOCKQUOTE>
</BODY>
</HTML>
