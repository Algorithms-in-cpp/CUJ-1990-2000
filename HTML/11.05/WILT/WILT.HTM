<HTML>
<HEAD>
<TITLE>May 1993/Templates in C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Object-Oriented Programming</FONT></H2>

<hr><h2 align="center"><font color="#800000">Templates in C++<A NAME="010C_0075"><A NAME="010C_0075"></font></h2><P>
<h3 align="center"><font color="#800000"><A NAME="010C_0073"><A NAME="010C_0000">Nicholas Wilt</font></h3><hr><blockquote><P>
<P><i><A NAME="010C_0074"><A NAME="010C_0000">Nicholas Wilt is a software engineer currently residing in eastern Massachusetts. His interests include photorealistic computer graphics, 80x86 assembler and C++ programming. Mr. Wilt welcomes constructive feedback about his work; he can be reached via CompuServe [75210, 2455] or in care of the editorial offices of CUJ.</i></P><P>
Templates are a recent addition to the C++ programming language. By providing a way to define parameterized data types, they complement the mechanisms for reusability provided by inheritance. Templates come in two related flavors: function templates and class templates.<P>
<h4><FONT COLOR="#000080"><A name="010C_0076">Function Templates<A NAME="010C_0076"></FONT></h4></P>
The function template in <A HREF="list1.htm">Listing 1</A> implements Insertion Sort as described by Bentley (1986). <A HREF="list2.htm">Listing 2</A> contains a program to test the Insertion Sort template.<P>
A few points are worth mentioning about the <I>InsertionSort</I> function template. First, it does not declare a function called <I>InsertionSort;</I> rather, it describes a family of over-loaded functions named <I>InsertionSort</I>. If you call <I>InsertionSort</I> with an <I>int</I> *, the compiler generates an instance of the <I>InsertionSort</I> function template that sorts integers. If you call <I>InsertionSort</I> with another pointer type, the compiler generates another instance of the function that can sort that type. This approach to a generic implementation of Insertion Sort compares favorably to the <I>qsort</I> library function's approach, which requires a function call for every comparison. Templates let you implement a sorting routine that is both generic and efficient.<P>
<I>InsertionSort</I> can be called for any user-defined class, as well as the primitive data types. If you call it with a user-defined class, you must be sure the copy constructor and assignment operator work properly, and you must overload <I>operator&lt;</I> for the class.<P>
Function templates can resolve many issues of code reusability. Insertion Sort is not a very involved algorithm (hence its use as an example), but template implementations of more complicated algorithms such as Quicksort pay off handsomely in reduced maintenance costs. Templates are useful in less generalized contexts as well. Template-based numerical algorithms allow the fast implementation that uses <I>float</I> and the stable implementation that uses <I>double</I> to share the same source code.<P>
All the function template does is save you typing and maintenance. Unfortunately, every time you call a function template with a different argument for the parameter, the compiler generates another instance of the function template. As far as the resulting executable is concerned, you might as well have implemented separate <I>InsertionSort</I> functions. For applications where you apply a large variety of types to a function template, this can be an overwhelming use of space.<P>
<h4><FONT COLOR="#000080"><A name="010C_0077">Class Templates<A NAME="010C_0077"></FONT></h4></P>
Class templates offer even greater potential for code reuse than function templates. They let you describe a family of related classes generically, then provide specific parameters later, as needed. This approach to generality is called a <I>parameterized data type.</I> The template defines a family of related classes, all with members and member functions of the same name that behave similarly. Here is a partial definition of a linked list class template to introduce you to the syntax:<P>
<pre>template&lt;class T&gt;
   class LinkedList {
     void Insert(const T&amp;);
     T *Query(const T&amp;) const;
   };</pre>
Like function templates, the template definition itself does not define any classes. Classes result from instantiating the class template. The above template would be instantiated using the same angle brackets that were used to define it; that is, <I>LinkedList&lt;int&gt;</I> is a <I>linked list of integers</I> class, <I>Linked-List&lt;UserDefinedType&gt;</I> is a <I>linked list of UserDefinedTypes</I> class. Barring their origin, classes that result from instantiating a class template are just like other classes.<P>
Templates are especially well-suited to implementing container classes. As an example, I have implemented a balanced binary tree class template. Balanced binary trees are tremendously useful data structures for keeping track of dynamic collections of ordered objects. Almost all operations on a balanced binary tree require only <I>O</I>(log<I>N</I>) time where <I>N</I> is the number of nodes in the tree. These operations include insertion, deletion, query, minimum, and maximum. In addition, if you have a pointer to a node in the binary tree, you can find the predecessor or successor of that node in <I>O</I>(log<I>N</I>) time. The balanced binary tree in this article is a red-black tree as described by Cormen et al. (1990).<P>
The binary tree implementation makes use of three class templates: <I>BinaryNode, Binarytree,</I> and <I>BinaryTreeIter. BinaryNode</I> implements the node of a binary tree. Since a binary tree node is really the root of a subtree, <I>BinaryNode</I> implements most of the functionality required for binary trees. It contains some member functions that are <I>protected</I>, including <I>LeftRotate, RightRotate,</I> and <I>DeleteFixup.</I> These functions are used to balance the tree after an insertion or deletion, so they are usable only by classes that inherit from instances of <I>BinaryNode.</I><P>
<I>BinaryTree</I> encapsulates a single, balanced binary tree. It contains a pointer to a <I>BinaryNode</I> (the root of the tree), and makes available member functions such as <I>Insert</I> that are implemented in terms of <I>BinaryNode.</I><P>
<I>BinaryTreeIter,</I> an iterator class for <I>BinaryTree,</I> makes it unnecessary for users of <I>BinaryTree</I> to deal directly with <I>BinaryNodes.</I> Its constructors take a tree as input; the iterator then has a pointer to the root node of the binary tree. Subsequent operations operate on the subtree pointed to by this root node; the <I>Min</I> function, for example, finds the minimum node in the subtree and points the iterator at it. The <I>Contents</I> member function returns a pointer to the contents of the root node in the subtree, or 0 if the iterator is not pointing at anything.<P>
<I>BinaryTree,</I> like the <I>InsertionSort</I> function template given earlier, has been designed to work with any class as long as <I>operator&lt;</I> is defined.<P>
<A HREF="list3.htm">Listing 3</A> contains <I>btree.h</I>, the definitions for the three class templates <I>BinaryNode, BinaryTree</I> and <I>BinaryTreeIter.</I> (The code to maintain a red-black tree is extensive, so the source code listing has not been provided in its entirety. Rather, <A HREF="list3.htm">Listing 3</A> contains the <I>btree.h</I> header, where the class templates are defined.)<P>
<A HREF="list4.htm">Listing 4</A> contains the program that tests the three class templates that implement binary trees. It thoroughly exercises the <I>BinaryTree&lt;int&gt;</I> class by inserting, querying and deleting integers, and checking the invariants for the binary tree between operations. It also uses the <I>BinaryTreeIter&lt;int&gt;</I> class to traverse the nodes and ensure that they appear in the right order.<P>
As with function templates, class templates save you typing and maintenance. But every time a class template is instantiated with different arguments, the compiler generates another whole instance of the class. Again, in situations where the compiler instantiates the template many times, this can be an overwhelming use of space.<P>
<h4><FONT COLOR="#000080"><A name="010C_0078">Class Templates And Inheritance<A NAME="010C_0078"></FONT></h4></P>
Class templates work best when combined with inheritance. In the case of the <I>BinaryTree</I> template, you can extend its capabilities by having another class template inherit from it. This declares a family of classes who all inherit from related members of another family of classes. As an example, I'll develop a template implementation of the order statistics tree, an augmentation of the balanced binary tree as described by Cormen et al. (1990).<P>
An order statistics tree supports all the operations that a binary tree supports, plus a very efficient Selection operation. The Selection operation chooses the <I>i</I>th element in the sorted order of an <I>N</I>-element array. For example, numbering from zero, the median of an array for odd <I>N</I> is the (<I>N</I>&#151;1)/2th element. For a single selection operation, optimal <I>O</I>(<I>N</I>) algorithms have been derived. The order statistics tree supports selection in <I>O</I>(log<I>N</I>) time, where <I>N</I> is the number of elements in the tree. Since <I>N</I> elements must be inserted into the order statistics tree before performing selection, the order statistics tree takes <I>O</I>(<I>N</I>log<I>N</I>) time for a single selection operation. This asymptotic runtime is not efficient compared to the linear algorithms; however, when the number of selection operations grows, the advantage offered by the <I>O</I>(log<I>N</I>) time for a single selection gets more noticeable.<P>
The order statistics tree works well when the data sets from which it selects do not change very much between selections. A good application is the <I>median</I> neighborhood operation in image processing. The median operation performs noise reduction by replacing each pixel with the median of its neighbors (including itself, so a total of nine pixels are considered). You might implement this algorithm by reading the pixel values for each pixel of its neighbors and itself, computing the median, and replacing the pixel value. But the data set for the next pixel is similar to the data set for the pixel just computed. (They share three elements.) If you maintain an order statistics tree to compute the median values, pseudocode for a single pixel would look like:<P>
<pre>Compute median using O(lgN) selection of the OS tree
Delete leftmost 3 pixel values from OS tree
Insert rightmost 3 pixel values from OS tree</pre>
The 3x3 median problem has been studied extensively, and the above technique is probably not the most efficient. See Paeth (1990) for an implementation that requires at most 19 comparisons per pixel. For larger neighborhoods, however, more of each pixel's neighborhood is shared with those of its neighbors. At some point the order statistics tree becomes a good way to solve large-kernel median problems.<P>
<h4><FONT COLOR="#000080"><A name="010C_0079">Implementing the Order Statistics Tree<A NAME="010C_0079"></FONT></h4></P>
To implement the order statistics tree, I derive <I>OSNode</I> and <I>OSTree</I> class templates from the <I>BinaryNode</I> and <I>BinaryTree</I> templates. The syntax is:<P>
<pre>   template&lt;class T&gt;
   class OSNode : public BinaryNode&lt;T&gt; {
   // class definition
   };</pre>
This declares a template for a family of classes called <I>OSNode.</I> All of the classes in the family inherit publicly from <I>BinaryNode&lt;T&gt;. OSNode</I> is a binary tree node that incorporates the necessary modifications to make it a node in an order statistics tree. Whenever possible, it calls the <I>BinaryNode</I> implementations of its member functions to maintain the order statistics tree.<P>
This implementation is inconvenient because the left, right, and parent pointers are declared as <I>BinaryNode&lt;T&gt;</I> *s in the <I>BinaryNode</I> class template. C++ will not automatically promote a pointer to an inherited class to a pointer to its base class. So, because the <I>OSNode</I> class template considers these pointers to point to <I>OSNode&lt;T&gt;</I>s, the code for <I>OSNode</I> member functions contains many typecasts from <I>BinaryNode&lt;T&gt;</I> * to <I>OSNode&lt;T&gt;</I> *.<P>
<I>OSTree</I> inherits from <I>BinaryTree</I> just like <I>OSNode</I> inherits from <I>BinaryNode. OSTree</I> does not need to overload as many functions, however, since the node templates do most of the work. For example, the <I>BinaryTree</I> version of <I>DeleteItem</I> works just fine for <I>OSTree</I>.<P>
<A HREF="list5.htm">Listing 5</A> gives <I>os.h</I>, the header for the order statistics tree implementation. <A HREF="list6.htm">Listing 6</A> gives <I>os.cpp</I>, the C++ program that tests <I>OSTree</I>.<P>
<h4><FONT COLOR="#000080"><A name="010C_007A">Conclusion<A NAME="010C_007A"></FONT></h4></P>
Function and class templates offer a clean way to write reusable, highly maintainable code, while retaining the efficiency of reimplementing the functions or classes as the need arises. Templates are by no means a panacea, especially when a large number of instances are needed, but they can be a viable option among the innumerable options presented by C++.<P>
(C) 1993 Nicholas Wilt.<P>
<h4><FONT COLOR="#000080"><A name="010C_007B">Bibliography<A NAME="010C_007B"></FONT></h4></P>
Arvo, J. and D. Kirk. 1989. <I>In An Introduction to Ray Tracing</I>. Boston: Academic Press.<P>
Bentley, J. 1986. <I>Programming Pearls</I>. Reading, MA: Addison-Wesley.<P>
Cormen, T., C. Leiserson and R. Rivest. 1990. <I>Introduction to Algorithms.</I> Cambridge, MA: MIT Press.<P>
Paeth, A. 1990. "Median finding on a 3x3 grid,". <I>Graphics Gems</I>. Boston: Academic Press.<P>
Preparata, F. P. and M. I. Shamon. 1985. <I>Computational Geometry</I>. New York: Springer-Verlag.<P>

<h4><a href="../../../source/1993/may93/wilt.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
