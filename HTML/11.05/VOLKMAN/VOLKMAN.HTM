

<HTML>
<HEAD>

<TITLE>May 1993/CUG Library Editors</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   User Reports</FONT></H2>

<hr><h2 align="center"><font color="#800000">CUG Library Editors<A name="0124_0085"><A name="0124_0085"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0124_0000"><A name="0124_0000">Victor R. Volkman</font></h3><hr><blockquote><P>
<P><i><A name="0124_0000"><A name="0124_0000">Victor R. Volkman received a BS in Computer Science from Michigan Technological University. He has been a frequent contributor to The C User Journal since 1987. He is currently employed as Senior Analyst at H.C.I.A of Ann Arbor, Michigan. He can be reached directly at the HAL 9000 BBS (313) 663-4173 or as sysop@hal9k.ann-arbor.mi.us on Usenet.</i></P><P>
The C Users Group (CUG) Library offers several complete text editors with full source code supplied, including STEVIE (CUG313), RED (CUG318), and SE (CUG331). Each of these editors has been released into the public domain without any licensing or usage requirements. As such, you can use them in their original condition, modify them as the basis of your own text editor, or embed them into your existing applications where you need text-editing capabilities. I'll discuss the benefits and limitations of each editor and how you can take advantage of them. For a quick overview of their basic statistics and advanced features, see <A href="tab1.htm">Table 1</a>
and <A href="tab2.htm">Table 2</a>.
<P>
<h4><FONT COLOR="#000080"><A name="0124_0086">STEVIE (CUG313)<A name="0124_0086"></FONT></h4></P>
The STEVIE editor by Tony Andrews (Boulder, CO) is a highly-portable clone of the popular UNIX <I>vi</I> editor. STEVIE first appeared on the Atari ST platform and its name stands for "ST Editor for VI Enthusiasts." However, the current version of STEVIE can be compiled for the Atari ST running TOS or Minix, UNIX System V or BSD, and PCs running MS-DOS or OS/2. Others have reported success in porting STEVIE to the Amiga and Data General machines, although platform-specific code for those ports is not included in this release. My own testing covered STEVIE implementations in MS-DOS v5.0 and OS/2 v2.0.<P>
I received STEVIE v3.71 (released 06/08/89) from CUG on a single 5-1/4 inch 360K diskette for the PC. CUG can also supply releases on a 3-1/2 inch diskette. In any case, CUG distribution does not include any binary executables so you must compile it yourself before you can run it.<P>
STEVIE displays text with ANSI terminal emulation escape sequences. These escape sequences were popularized by the DEC VT-100 series of terminals. Ideally, ANSI terminal support provides maximum display portability with minimum programming effort. However, the MS-DOS implementation (<I>ANSI.SYS</I>) is notoriously slow and impedes the performance of STEVIE. I found STEVIE to be incompatible with both <I>ANSI.SYS</I> in MS-DOS v5.0 and <I>DVANSI.COM</I> in DESQview/386. Specifically, <I>scroll-down</I> (<I>CTRL-D</I>) and <I>scroll-up</I><I> </I>(<I>CTRL-U</I>) (keystrokes fail to refresh about half the screen. Although the STEVIE documentation does not mention this problem, it does suggest <I>NANSI.SYS</I> by Daniel Kegel (Altadena, CA) for ANSI emulation. Accordingly, I tested <I>NANSI.SYS</I> v3.3 which worked without problems and clocked screen refreshes 40 percent faster than <I>ANSI.SYS.</I><P>
STEVIE does not check for the presence of ANSI emulation, and will render an illegible set of escape strings if it is missing. If STEVIE had used the ANSI Device Status Report (<I>ESC[6n</I>), then it could have reported the absence of ANSI support and recommended corrective action.<P>
STEVIE indirectly supports the EGA/VGA 43- and 50-line display mode because of its configurability. However, you will need both an <I>ANSI.SYS</I> that supports 43-line mode (like <I>NANSI.SYS</I>) and a utility to switch your graphics card into 43-line mode. After setting up the display mode while still in DOS, you must start STEVIE and then issue the command <I>:set lines=43</I>. Scrolling and refreshing worked smoothly on my ATI VGA/Wonder+ (1024K RAM) using <I>L43.COM </I>and <I>NANSI.SYS</I>. I also tried the proprietary ATI 132-column x 44-line mode and found it usable although STEVIE still enforced line wrapping at 80 columns.<P>
Because STEVIE v3.71 was released in 1989, the documentation only claims compatability with Microsoft C v5.1 in the MS-DOS environment. However, I compiled the STEVIE source code without errors using the Microsoft C v6.00A. The quality of the source code could be improved with the addition of ANSI function prototypes.<P>
The source code ships configured for UNIX and must be modified to build under other platforms. The documentation omits the exact procedure for building on MS-DOS, so I'll describe it here. Specifically, you must comment out both the <I>#define UNIX</I> and <I>#define TERMCAP</I> and uncomment <I>#define DOS</I> in the file <I>ENV.H</I>. Once built, the Microsoft <I>EXEHDR</I> utility reported that <I>STEVIE.EXE</I> was 105K in length and required 129K to run.<P>
Building STEVIE for OS/2 v2.0 required more modification. Around the time STEVIE was released, OS/2 v1.1 was current, so some incompatiblities with v2.0 were to be expected. Kevin Nickerson (Ann Arbor, MI) lent me his expertise in porting STEVIE to OS/2 v2.0 using the C/2 compiler. Specificially, he reported the following changes required to correctly build STEVIE:<P>
<UL><li>Uncomment <I>#define OS2</I> in <I>ENV.H</I></li>
<li>Remove declarations like <I>extern char *malloc;</I> which collided with the ANSI headers in all files.</li>
<li>Add <I>STDLIB.H </I>to ANSI headers included in <I>STEVIE.H</I></li>
<li>Change <I>inchar</I> to call <I>KbdCharln </I>instead of <I>getch</I> in <I>OS2.C</I></li>
<li>Add handling for <I>EOF</I> <I>case</I> to <I>inchar</I></li>
<li>Change the <I>write</I> and <I>read</I> calls to <I>fwrite</I> and <I>fread</I> in<I> OS2.C</I></li></UL>
Once built, STEVIE for OS/2 v2.0 behaved well in an OS/2 command window.STEVIE was friendly in its CPU usage and had no noticeable impact when idle.<P>
The main STEVIE documentation consists of the 12-page <I>User Reference</I> in both plain ASCII and <I>nroff</I> text formats. The ASCII version of the manual is formatted to exactly 66 lines per page with no formfeeds. The documentation clearly states that it is intended for users already familiar with the <I>vi</I> editor. Since <I>vi</I> is already well-documented both in print and online tutorials, this seems reasonable. (See bibliography.) For an idea of which advanced features STEVIE supports, see <A href="tab2.htm">Table 2</a>.
 The <I>User Reference</I> does provide brief one-line descriptions of all <I>:set</I> commands, and single and double-letter commands (e.g. <I>yy</I>). Additionally, an online listing of these commands appears when you issue the <I>:help</I> command in STEVIE.<P>
The STEVIE documentation also provides a few additional pages of information in <I>Porting Notes</I> and <I>Source</I> <I>Notes</I>. The <I>Porting Notes</I> provide general tips on how to move STEVIE to an unsupported environment. However, specific instructions for compiling in each individual supported environment are missing. The <I>Source Notes</I> cover the most important data structure in STEVIE &#151; the doubly-linked list of text line structures. STEVIE allocates to each line buffer the exact number of characters needed to hold it.<P>
Since STEVIE is freeware, without any remuneration to the author, one normally does not expect extensive support. In the documentation, Andrews concedes that since STEVIE is stable, new releases may not be forthcoming. He goes on to say that he will accept bug reports and enhancements to the source code from time to time. Nevertheless, since three years have elapsed since the last release, it may be unrealistic to expect active support at this time.<P>
<h4><FONT COLOR="#000080"><A name="0124_0087">RED (CUG318)<A name="0124_0087"></FONT></h4></P>
<P>
The RED editor by Edward Ream (Madison, WI) is an extremely compact editor that uses virtual memory techniques to handle files bigger than memory alone would allow. RED is also notable for its interrupt-driven displays and pattern-matching search and replace. RED first appeared in an article in the January 1983 issue of <I>Dr. Dobb's Journal</I>. CUG318 contains RED v7.0 as released on January 26th, 1990. This version claims compatability with both Microsoft C and Borland Turbo C.<P>
RED can edit very large files, yet only needs 56K of memory to run. The secret behind this is the work file that RED creates as it loads your file. The work file is an indexed set of doubly-linked 1K blocks. Each block contains the actual text associated with lines in the edit file. The resulting temporary file is at least as big as the original file. RED keeps at least 10 of these 1K blocks in memory at any time. When the user scrolls out of the region of the file that is in memory, RED swaps out the least recently used blocks.<P>
In an attempt to push RED to its limits, I asked it to load a 691K file containing 32,767 lines of text. Although it required several seconds to load up, RED was then able to rapidly traverse the file. Next, I increased the file up to 34,000 lines of text and tried RED again. RED reported several internal errors in building the temporary file and refused to load the file. This problem is due to RED using 16-bit signed integers rather than 32-bit <I>longs</I> to represent line numbers.<P>
Although RED will handle very long text files well, none of the lines can be longer than 79 characters. RED simply reports <I>line truncated</I> after feeding it a file with lines up to 255 characters wide. RED will prevent you from entering a line longer than 79 characters as well. If you enable line wrap, then it will move the last word on a line as a word processor would.<P>
Another technical innovation of RED is its interrupt-driven screen refresh. Screen refreshes most often occur when you scroll up or down an entire page of text. Rather than simply allowing MS-DOS to buffer keystrokes while the screen is refreshing, RED reads each keystroke and interrupts the refresh. The main benefit is that you can traverse the file much quicker than if you had to wait for every single screenful of text to be painted. Many commercial word processors use such a scheme to defer the reformatting of paragraphs until you are done typing, for example.<P>
Since RED is so compact, its command set is quite limited. (See <A href="tab2.htm">Table 2</a>
and <A href="tab3.htm">Table 3</a>.
) The block move, copy, and delete functions are cumbersome because they require you to keyboard the actual line numbers affected. The undo handling is limited to the current line and disappears if you leave the line. However, RED does provide pattern matching search and replace. The patterns supported are a small subset of regular expressions. Specifically, you can set up patterns with ? for single character matches, ^ to match only at the beginning of a line, and <I>$</I> to match only at the end of a line. Since RED does not have a Kleene * operator to match zero or more characters, it falls short of complete regular expression handling.<P>
I found RED to be in good working order with the exception of the <I>quit</I> command. The <I>quit</I> command, which is supposed to exit to MS-DOS, would report the error <I>Too many ?s in mask</I> and hang the system. I tried running it on both MS-DOS v3.3 and v5.0 and achieved identical results. With some detective work, I discovered <I>#ifdefs</I> and comments indicating that the<I> quit</I> command was only an experimental alternative to the <I>exit</I> command. As such, I only needed to comment out the <I>#ifdef SUSPEND</I> to remove the <I>quit</I> command.<P>
Since rebuilding <I>RED.EXE</I> correctly took some additional effort, I will report on the process. I first had to remove many hardcoded pathnames from the makefile and some of the <I>#includes</I>. The makefile expects a particular subdirectory structure but the files on the distribution disk were all in one flat directory. I corrected the makefiles and continued to build.<P>
Compiling RED with Microsoft C v6.00A uncovered numerous warnings about trying to use the <I>NULL</I> constant (<I>OL</I>) in conjunction with 16-bit <I>int</I> variables. I had to edit <I>REDMAIN.C</I> to prevent an error message where <I>NULL</I> was used as a case in an <I>int switch</I> statement. I encountered many <I>long/short</I> mismatch warnings where the compiler was forced to do a type promotion. Microsoft MASM v5.1 warned that the symbol <I>NEAR</I> in <I>REDOUTA.ASM </I>duplicated a reserved word. I changed the symbol <I>NEAR</I> to <I>USENEAR</I> to avoid the conflict.<P>
Upon completing the build, I soon discovered runtime stack errors on exiting RED. I eventually increased the stack from its initial value of 3,000 bytes up to 8,000 bytes to prevent stack overflows. After this final fix, RED performed all functions without complaint.<P>
The documentation for RED consists mainly of the 15-page <I>Reference Guide </I>provided in plain ASCII format. The <I>Reference Guide</I> covers each command and special keystroke in detail. The manual is organized well enough for even a novice to understand the behavior of the editor. The supplementary four page <I>Technical Notes</I> provide some porting hints, commentary on programming styles, and a description of how to use the SHERLOCK debugging macros.<P>
Since RED is freeware, one normally would not expect a formal support program. Rather than requiring a fee for support, Ream offers a bounty of $5.12 that is "cheerfully paid to the first person who finds any bug." He also offers a bounty of $1.28 for each typographical error found in documentation or source code.<P>
<h4><FONT COLOR="#000080"><A name="0124_0088">SE (CUG331)<A name="0124_0088"></FONT></h4></P>
The Stack Editor (SE) by Gary Osborn (Yorba Linda, CA) provides complete command and text stacking rivalling commercial products such as Brief. SE also contains a powerful built-in virtual memory manager for editing files up to 3MB long. SE buffers very large files with as little as 6K additional RAM and as much as 500K RAM depending on available memory. SE also includes an embedded <I>nroff</I> dot command processor for added word processing functionality. CUG331 contains SE vl.0 as released on June 12th, 1990.<P>
The SE editor originates from a distinguished lineage of editors with a decade of development behind it. It all began with G. Nigel Gilbert's groundbreaking E editor for CP/M released between 1981 and 1983 (CUG133). In the days of CP/M, which had a 64K memory limit, the virtual-memory aspect was even more important than today. James W. Haefner built on Gilbert's initial design and eventually released Q.E.D. v4.6b for PCs in 1985 (CUG157). Mel Tearle in turn built on Haefner's code to produce GED vl.05 in 1986 (CUG199). The GED editor was the first of the line that could run on the new PC clones, such as Compaq. Last, Gary Osborn put his mark on the code in 1990 to produce the advanced command and text stacking capabilities comprising SE.<P>
SE provides a complete set of block editing operations: <I>move, copy, delete, shift</I> (indent/outdent), and <I>print</I>. SE is notable in that it actually highlights the block of text as you define it by moving the cursor. The block of text must begin and end on line boundaries. The shift operation is especially nice in that you move the block left and right with each keystroke. All block operations can be undone and redone in accordance with the stack metaphor.<P>
SE's stack operations provide an easy way of moving a line of code, of transposing lines, and of duplicating lines. Pushing several lines, then popping them elsewhere is a convenient way to move a small block. The text stack shares the same area as the command stack (used for <I>undo</I> and <I>redo</I>). Pops can be undone, but if the editing operation that did the push is undone, then the associated pop will find the stack empty. You can either pop directly from the stack or pop a copy of the top of the stack. A few editing operations other than delete (such as line concatenation) affect the stack also and can result in unexpected items on the stack. Don't do too much editing if items are to be popped from the stack.<P>
The <I>nroff </I>(or runoff) commands provide simple directives for basic word processing functions. You can imbed these commands in your plain ASCII text file or ignore them completely. These commands always start with a dot in column one and are abbreviated to two letters. Specifically, SE supports left margin (<I>.in</I>), right margin (<I>.rm</I>), top margin (<I>.m1</I>), disabled formatting (<I>.nf</I>), lines per page (<I>.pl</I>), page headers (<I>.he</I>), page footers (<I>.fo</I>), page breaks (<I>.bp</I>), page break override (<I>.ne</I>), center text (<I>.ce</I>), underline text (<I>.ul</I>), and line spacing (<I>.ls</I>). Many of these commands can be run from within SE, rather than requiring you to generate an output file to activate them.<P>
Building SE required some additional effort, as I will describe. Since SE was last released for Microsoft C v4.0, I had to adjust the <I>BUILD.BAT</I> file to call <I>CL.EXE</I> rather than <I>MSC.EXE</I>. Compiling the 15 source files produced more than 118 warning messages at the lowest warning level (<I>/W1</I>). Fortunately, about 100 warnings were due to implicitly defined <I>int</I> functions which returned no particular value. There were three warnings regarding case values of more than 1,000 being compared in a <I>switch</I> statement where the operand was an unsigned <I>char</I>. An unsigned <I>char</I> can only assume values from 0 to 255, so 1,000 is clearly out of range.<P>
Once compiled, I needed to adjust the linker response file to handle the format of Microsoft Linker v5.10. I quickly discovered a multiply-defined external called <I>clock</I>. The MSC run-time library provides a function called <I>clock</I> which returns the amount of time the application has been running. This <I>clock</I> function conflicted with a global <I>int</I> called <I>clock</I> defined in <I>GED.H</I>. The variable <I>clock</I> serves as a counter for the LRU paging mechanism in SE. I resolved the situation by renaming the <I>clock</I> variable to <I>se_clock</I> in <I>GED.H</I>, <I>SWAP.C</I>, and <I>STORE.C</I>. After resolving this conflict, I encountered no further problems. The Microsoft <I>EXEHDR</I> reported that <I>SE.EXE</I> was 43K in length and required 64K to run. All editing functions worked just as well as in the executable distributed on diskette.<P>
The SE documentation consists of two separate eight-page overviews entitled simply <I>The SE Editor</I> and <I>SE Stack Editor</I>. Both documents are formatted with some <I>nroff</I> dot commands, but are still quite readable in source form. The first document discusses the architectual tradeoffs taken in the virtual memory and screen refresh implementation. Other topics include the motivation for stack-based editing, handling partially binary files, and embedded <I>nroff</I> commands. The second document provides a keyboard quick reference, detailed dot command reference, and command-line parameters. Although there are no detailed discussions of algorithms or data structures, the C source code is fairly well documented.<P>
Since SE has been released into the public domain without compensation to the author, the absence of a formal support plan should not be surprising. Even though Osborn devotes several paragraphs to outlining ideas for future work, there is no release schedule attached. The documentation does not mention a host where the latest version may be found nor is there an e-mail address for the author.<P>
<h4><FONT COLOR="#000080"><A name="0124_0089">The Best Editor for the Job<A name="0124_0089"></FONT></h4></P>
Choosing between the STEVIE (CUG313), RED (CUG318), and SE (CUG331) can be difficult. If you need cross-platform compatibility or prefer the <I>vi</I> command set, then STEVIE is your best choice. If you need a very compact editor that can handle reasonably large files (~700K) or require interrupt-driven screen refresh, then RED is your best choice. If you need a small editor with strong block operations, the ability to handle very large files (3,000K), or <I>nroff</I> support, then SE is your best choice. All are public domain with full source code and available at minimal cost directly from the C Users Group Library.<P>
<h4>Reference</FONT></h4></P>
Lamb, Linda. 1988. <I>Learning the vi editor</I>. Sebastopol, CA: O'Reilly &amp; Associates. Contact <I>nuts@ora.uu.corn or uunet!ora!nuts.</I><P>
</BLOCKQUOTE>
</BODY>
</HTML>
