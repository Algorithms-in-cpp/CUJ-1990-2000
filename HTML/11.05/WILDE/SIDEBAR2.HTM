<HTML><HEAD><TITLE>May 1993/Testing Your Objects/Sidebar</TITLE></HEAD><BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">Parser Generators</FONT></h3><hr>
<BLOCKQUOTE>
A parser generator produces programs that read input that is described by a grammar and perform specified actions based on what they find in that input. The earliest application of parser generators was in compiler writing and the best-known parser generator is the early UNIX tool <I>yacc</I> ("yet another compiler compiler"). PC versions of <I>yacc</I> are available from MKS (519-884-2251) and Abraxas (503-244-5353). The examples in this article use the <I>AnaGram</I> grammar-based programming system from Jerome T. Holland (508-358-7968), which provides an integrated PC environment for developing, testing, and debugging grammars, as well as some very useful extensions to conventional parsing techniques.<P>
<A href="fig3.htm">Figure 3</a>
shows how a parser generator works. The syntax file contains "productions," which describe the input that the generated program will handle, and "reduction procedures," which say what actions will be taken or output produced when each production is matched in the input.<P>
<A href="list3.htm">Listing 3</a>
is an example of part of a syntax file. The productions for a <I>runtest</I> statement give a good example of how the generated parser works. <I>runtest</I> statements look like the following:<P>
<pre>runtest "r1" combining someClient theInvoice numItems someItem
{
   ...
}</pre>
that is, they consist of the keyword <I>runtest</I>, a run name in quotes, the key word <I>combining,</I> a list of the variables to be used in the run, and finally a C++ block that will be executed for each combination of the variables. The syntax file of <A href="list3.htm">Listing 3</a>
declares a <I>runStatement</I> consisting of a <I>runHeader,</I> one or more spaces, and a <I>testSpec</I>. Then <I>runHeader</I> and <I>testSpec</I> are described on the following lines.<P>
The production for <I>runHeader</I> shows that it starts with the <I>runtest</I> keyword, followed by spaces and the string with the run name (<I>string</I> is declared elsewhere in the syntax file). This production shows how a user-supplied reduction procedure called <I>setRunName</I> can manipulate the data collected during parsing. A local variable called <I>n</I> is declared to hold the semantic value of the string, in this case a character pointer to the string characters. When a complete <I>runHeader</I> has been identified, the parser will call <I>setRunName</I> (which is coded like any C or C++ function) and pass it this pointer. In this particular case, <I>setRunName</I> simply stores the string into a global variable for later use.<P>
The production for <I>testSpec</I> is similar but illustrates more generally how reduction procedures can get the data they need. When a complete <I>testSpec</I> is identified, the <I>makeComb</I> reduction procedure is called (in this case the procedure writes all the code needed for one set of tests). The semantic values it uses are a pointer to the block and a pointer to the variable list; it also makes use of the global run-name string previously saved by <I>setRunName.</I><P>
The production for <I>variableList</I> illustrates recursion, which is very useful for lists of things, and also shows how typed semantic values are created. The <I>variableList</I> production has two rules, saying that a <I>variableList</I> can be either a single variable or a <I>variableList</I> followed by a variable. This is just a recursive way of saying that a <I>variableList</I> is one or more variables.<P>
The single variable rule will be the first to be matched during parsing. When it is matched, the next call is to the <I>listNew</I> reduction procedure, which creates a new <I>STRLIST</I> (string list) and returns a pointer to it. The <I>AnaGram</I>-generated parser makes this pointer the semantic value of the <I>variableList</I>; note that the type of the pointer is declared in the first line of the <I>variableList</I> production so that normal C type checking can be enforced. When a second variable is encountered, the second rule will match, since there is now a <I>variableList</I> followed by a variable. Both are passed to the <I>listAdd</I> reduction procedure, which appends the new variable to the list and returns a pointer to the new list. When all variables have been encountered and the complete <I>variableList</I> has been built, the last pointer generated will be passed up to the <I>testSpec</I> production as variable <I>vl.</I><P>
Parser generators can thus be used for a wide range of problems in which a program's main purpose is to operate on structured input. Their big advantage is that the structure of the input is explicit in the syntax file and not distributed through the program, so that changes in input requirements tend to be far easier to accommodate.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
