<HTML><HEAD><TITLE>January 1993/Template Classes for the iostreams Library/Sidebar</TITLE></HEAD><BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">Templates and Virtual Functions</FONT></h3><hr>
<BLOCKQUOTE>
Template classes allow a generic class to be defined. Individual objects can be declared from it by filling in type information in the individual declarations. The classic template example is the array-class. Once the array class template is defined somewhere, various types of arrays can be declared:<P>
<pre>// an array of ints:
Array&lt;int&gt; ArrayOfInts;
// an array of doubles:
Array&lt;double&gt; ArrayOfDoubles;</pre>
The compiler will generate the code needed for access and initialization of each of the above arrays. If the compiler/linker can optimize, it will automatically remove similar code from different modules. Be aware that each of these <I>Array</I> declarations will produce its own code. This may be more code then you might want. There are ways around this, but that is the general limitation of templates.<P>
Virtual functions can be seen as alternatives to templates. While templates provide generic source code, virtual functions provide generic object code. Where templates are generally faster, virtual functions generally produce less code. This trade off is not always true, and there are other disadvantages on both sides. I have found however that virtual functions and templates often complement one another, and that very good solutions can be found in the mixture of the two. In the above example one might define:<P>
<pre>// an array of anything derived from Numerics:
Array&lt;Numerics *&gt; ArrayOfNumbers;</pre>
Then if <I>Numerics</I> is used as a base class, anything derived from <I>Numerics</I> can be used in this array, and <I>Numerics</I> provides the least-common-denominator for operations available for <I>ArrayOfNumbers</I>.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
