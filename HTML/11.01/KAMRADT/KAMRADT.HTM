

<HTML>
<HEAD>

<TITLE>January 1993/Template Classes for the iostreams Library</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Portability</FONT></H2>

<hr><h2 align="center"><font color="#800000">Template Classes for the iostreams Library<A name="0024_0007"><A name="0024_0007"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0024_0000"><A name="0024_0000">Randal Kamradt</font></h3><hr><blockquote><P>
<P><i><A name="0024_0000"><A name="0024_0000">Randy has been programming since 1984, and is working for Bordart Automation where he develops CD-ROM based applications for libraries. His special interests include object-oriented programming/design and C/C++ programming in general.</i></P><P>
One of the nicer additions that C++ made to C is the<B> </B><I>iostreams</I> facility. Even if you only use C++ as "a better C,"<B> </B><I>iostream</I> provides an elegant method of I/O and allows easy<B> </B>extensions for user-defined types. This ease of extension only<B> </B>works one way, though, as creating new stream types that work<B> </B>with existing code can be fairly complicated, and requires a<B> </B>complete understanding of the streams hierarchy.<P>
When I first got my hands on a C++ compiler I wanted to<B> </B>create a streams class that would work with a compact disk. My compact disk driver provided basic read routines, and I<B> </B>already had a class that I used as an interface to the driver. To<B> </B>provide seamless integration with existing code I needed to<B> </B>create new classes that fit in with the existing <I>iostreams</I><B> </B>hierarchy. (See the sidebar <a href="sidebar1.htm">"iostreams Hierarchy"</a> for a discussion of this class and virtual inheritance.)<P>
The first step was to copy the definitions of the <I>ifstream,</I><I><B> </I></B><I>fstreambase</I>, and <I>filebuf</I> classes and rename them to<B> </B><I>cdstream, cdstreambase</I>, and <I>cdbuf</I> classes. (I was not<B> </B>concerned with output classes since I was working with CDs.)<B> </B>Then I changed the open parameters and constructor<B> </B>parameters to suit the class I used to interface with the CD<B> </B>driver. Within the <I>cdbuf</I> class I replaced the file-handle<B> </B>integer with a pointer to the CD interface class, and added<B> </B>appropriate <I>new</I> and <I>delete</I> statements in the open and close<B> </B>routines of <I>cdbuf</I>. Finally, I replaced the calls to the global<B> </B><I>open, close, read</I>, and <I>seek</I> with ones that used the CD <I>clas</I><I>s</I><B> </B>pointer. After doing all that and then fixing the few bugs I let<B> </B>creep in, I was convinced that there had to be a better way.<P>
A few months after creating these classes I was faced with<B> </B>doing it again. By this time we had a new version of Borland<B> </B>C++ with templates. After thinking about it for a while, I<B> </B>decided that templates could be the better way I wanted. By<B> </B>creating generic versions of the classes I had copied before, I<B> </B>could create an endless number of different stream types for<B> </B>anything that resembled a stream. In this article, I will present<B> </B>these template classes, and a serial port stream class as an<B> </B>example. These classes were compiled and tested with Borland<B> </B>C++ v3.1. The portability of the templates depends on<B> </B>consistency in the <I>iostreams</I> facility across compilers.<P>
<h4><FONT COLOR="#000080"><A name="0024_0008">Template Classes<A name="0024_0008"></FONT></h4></P>
To avoide duplicating classes unnecessarily, I created templates for the classes. (See the sidebar <a href="sidebar2.htm">"Templates"</a> for more information.) The classes I made templates of included <I>filebuf, fstreambase, fstream, ifstream,</I> and <I>ofstream</I>, I call the template classes <I>tbuf&lt;T&gt;, tstreambase&lt;T&gt;, tstream&lt;T&gt;, itstream&lt;T&gt;,</I> and <I>otstream&lt;T&gt;</I>. The <I>&lt;T&gt;</I> suffix indicates a templeate class. The replaceable type is a basic class that has <I>open, close, read, write,</I> and <I>seek</I> member functions. (I will call this class <I>T</I> when referrring to this replaceable type.) When creating a class for an entity that does not have one or more of these functions, you can either create a dummy function that does nothing, or one that calls an error routine. See <A href="list1.htm">Listing 1</a>
for all template class definitions.<P>
The first template class, <I>tbuf&lt;T&gt;</I> is the most complex. It contains one object of the variable type, and controls the operation of that object. <I>tbuf&lt;T&gt;</I>'s <I>open, close</I>, and <I>seek</I> member functions directly call <I>T</I>'s <I>open, close</I>, and <I>seek</I> member functions. The <I>overflow</I> and <I>underflow</I> member functions call <I>read</I> and <I>write</I>, along with setting the various buffer pointers. It also has the ability to attach an already open <I>T</I> to itself. <I>tbuf&lt;T&gt;</I> is derived from <I>streambuf</I>, which provides it's interface. Some of the member functions of <I>tbuf&lt;T&gt;</I> override the virtual functions of <I>streambuf</I>. Since <I>ios</I> contains a pointer to <I>streambuf, ios</I> has access to these virtual functions, and is able to read and write <I>tbuf&lt;T&gt;</I>.<P>
The second template class, <I>tstreambase&lt;T&gt;</I> contains a <I>tbuf&lt;T&gt;</I>. It is derived (virtually) from <I>ios.</I> In its constructor <I>tstreambase&lt;T&gt;</I> initializes <I>ios</I> with a pointer to its <I>tbuf&lt;T&gt;</I> object. It can also open its <I>tbuf&lt;T&gt;</I> object if called with the necessary parameters. Otherwise, it has an <I>open, close</I>, and <I>attach</I> call that map directly to the <I>tbuf&lt;T&gt; open, close</I>, and <I>attach</I> member function.<P>
The last set of template classes are <I>tstream&lt;T&gt;, itstream&lt;T&gt;</I>, and <I>otstream&lt;T&gt;</I>. These are multiply derived from <I>istream/ostream</I> and <I>tstreambase&lt;T&gt;</I>. They are shell classes that simply combine the capabilities of the two inherited classes. The only thing necessary in the definition is the duplication of the constructors, and an <I>open</I> and <I>rdbuf</I> member function, that calls the <I>tstreambase open</I> and <I>rdbuf</I> member functions. The <I>open</I> function is redefined to give default mode values to <I>itstream&lt;T&gt;</I> and <I>otstream&lt;T&gt;</I>. The <I>rdbuf</I> function is redefined to avoid ambiguities with <I>ios</I> which contains its own <I>rdbuf</I> function.<P>
Note that when creating a deep hierarchy, constructors need to be defined for all classes, even if they don't change from the base class's constructor. Duplicating numerous constructors, or constructors with long parameter lists, can be a nuisance. There are four constructors for <I>itstream&lt;T&gt;/otstream&lt;T&gt;</I> that are duplicates of the <I>tstreambase&lt;T&gt;</I> constructors:<P>
<pre>tstream()
tstream(const char *name, int mode, int prot)
tstream(T &amp;f)
tstream(T &amp;f, char *buffer, int length)</pre>
The default constructor, <I>tstream()</I> initializes the buffer using default parameters for buffer size. The stream is considered closed. <I>tstream(const char *name, int mode, int prot)</I> initializes the buffer, and opens the named stream. <I>tstream(T &amp;f)</I> initializes the buffer with the <I>T</I> parameter. <I>tstream(T &amp;f, char *buffer, int length)</I> initializes the buffer with <I>T</I>, and sets the buffer to the <I>char</I> * with the length specified. These four constructors are duplicated in the three classes <I>itstream&lt;T&gt;, otstream&lt;T&gt;</I>, and <I>tstream&lt;T&gt;</I>. In all of these cases, the parameters are passed on directly to <I>tstreambase&lt;T&gt;'s</I> constructors.<P>
The constructors for <I>tstreambase&lt;T&gt;</I> call the constructors either for the default <I>tbuf&lt;T&gt;</I> constructor, or in the case of constructors <I>tstream(T &amp;f)</I> and <I>tstream(T &amp;f, char *buffer, int length)</I> it passes the parameters to <I>tbuf&lt;T&gt;'s</I> constructors. It then calls the <I>ios init</I> function to set <I>ios</I> pointer to its <I>T</I> data member. For constructor <I>tstream (const char *name, int mode, int prot)</I>, it calls T's <I>open </I>function.<P>
<I>The tbuf&lt;T&gt;</I> class has three constructors:<P>
<pre>tbuf()
tbuf(T &amp;f)
tbuf(T &amp;f, char *buffer, int length)</pre>
<I>tbuf()</I>, the default constructor, builds a buffer of default size. The <I>T</I> stream is considered closed. <I>tbuf(T &amp;f)</I> builds a default buffer, but attaches <I>T</I> as its stream. The <I>T</I> stream is considered open for read or write. <I>tbuf(T &amp;f, char *buffer, int length)</I> builds a buffer using the buffer and length parameters, and attaches <I>T</I> as its stream.<P>
<h4><FONT COLOR="#000080"><A name="0024_0009"><I>SerialStream</I><B> and </B><I>ComBuffer</I><B> classes<A name="0024_0009"></B></FONT></h4></P>
As an example of how to use these templates, I decided to use a serial port stream. In MS-DOS you can access the serial port as a stream, but it is not interrupt driven, so it is nearly useless without special drivers. The serial port stream is divided into two classes, <I>SerialStream</I>, and <I>ComBuffer</I>. The <I>ComBuffer</I> provides an interrupt-driven circular buffer for input, and passes output directly to the port. The <I>Serial-Stream</I> class uses the <I>ComBuffer</I> class to do its I/O, and has the correct interface to plug into the template. I split the classes in two in case there was more then one stream per port. However, <I>ComBuffer</I> needed to be mapped directly to a port.<P>
The only instance of <I>ComBuffer</I> is a static global (see <A href="list2.htm">Listing 2</a>
and <A href="list3.htm">Listing 3</a>)
 <I>CommPorts</I> which is an array of two, one for each port. Since it is a static global, it is initialized before <I>main</I>. It uses the static data member <I>initPort</I> to ensure the correct port number is initialized. In the constructor and destructor for <I>ComBuffer</I> I included a print statement to visually assert the order of the construction. <I>ComBuffer</I> is not a safe or complete class that could be used anywhere in a program, so I made the definition <I>private</I> to the module. I could alternatively have made the definition <I>private</I> to the <I>SerialStream</I> class definition.<P>
The <I>SerialStream</I> class uses <I>ComBuffer</I> to communicate with the physical ports, via a pointer. When a <I>SerialStream</I> is opened, the name parameter is decoded to give the port number. The port number is used as an index into the <I>CommPorts</I> array, and the pointer to that index is saved. During reading and writing the request is passed on to <I>ComBuffer</I> via that pointer. Only one character is read or written at a time. This inefficiency does not concern me, since the <I>iostream</I> should be unbuffered, and should only request one character at a time anyway.<P>
Any class that is to be used in the streams templates must meet certain requirements. First it needs a default constructor. This constructor should leave the stream in a closed state. It needs a open function that takes a <I>const char</I> *, and two <I>ints</I> for parameters. This is perhaps the most extreme restriction, as not all streams will be able to map these parameters. For streams that take fewer parameters, as my <I>SerialStream</I> class does, it is easy enough to ignore the rest. For a class that needs more information to get started, this can be a problem. One alternative could be to use the name parameter to pass in additional information:<P>
<pre>x.open("COM1, INT=7, SPEED=2400",ios::in);</pre>
Although this appears sloppy, and requires character translation in the open function, it is not without precedent. Another alternative is to access the <I>T</I> class directly:<P>
<pre>x.open("COM1",ios::in);
x.rdbuf()-&gt;fd()-&gt;setspeed(1200);
x.rdbuf()-&gt;fd()-&gt;setint(7);</pre>
The stream class must also define a <I>close</I> function that takes no parameters. A read and write function that takes a <I>char</I> * and an <I>int</I>, as well as a seek function that takes a <I>long</I> and a <I>ios::seek_dir</I> type must be present. Finally, a <I>const</I> <I>void</I> * conversion operator needs to return the open/close state, as the <I>this</I> pointer or a null pointer. The open, close, read, write, and seek function can all be dummied up if not needed. If seek is dummied, you need to make sure the stream is unbuffered.<P>
I mentioned previously that the portability of the templates depends on how similarly different libraries implement the internals of the <I>iostreams</I> classes. This code was made with the Borland C++ v3.1 libraries in mind, and might need to be changed for other implementations. In the header files, Borland mentions minor differences with the AT&amp;T library, so I assume that the templates will work as well under AT&amp;T and any other vendor that follows them. If the internals of <I>iostreams</I> are not under discussion in the ANSI X6J16 commitee, then perhaps vendors should include a set of templates similar to these in the C++ library to allow different streams types to be portable from one implementation to another.<P>

<h4><a href="../../../source/1993/jan93/kamradt.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
