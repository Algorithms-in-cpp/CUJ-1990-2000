

<HTML>
<HEAD>

<TITLE>January 1993/An Essential String Function Library</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">An Essential String Function Library<A name="002C_000D"><A name="002C_000D"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="002C_0000"><A name="002C_0000">William Smith</font></h3><hr><blockquote><P>
<P><i><A name="002C_0000"><A name="002C_0000">William Smith is the engineering manager at Montana Software,<I></I> <I></I>a software development company specializing in custom<I></I> <I></I>applications for MS-DOS and Windows. You may contact him by mail<I></I> <I></I>at P.O. Box 663, Bozeman, MT 59771-0663.</i></P><P>
The include file <I>&lt;string.h&gt;</I> in the Standard C library defines 22 functions for manipulating character strings. Seventeen of these functions begin with the prefix <I>str</I> and another five begin with the prefix <I>mem</I>. The functions that begin with the prefix <I>str</I> work on null-terminated strings. They accomplish such critical tasks as finding the length of a string, concatenating strings, or comparing strings, to name just a few of the tasks. The functions that begin with <I>mem</I> work on any buffer of memory. These functions do not interpret a null character as a terminator.<P>
At first, the functions in <I>&lt;string.h&gt;</I> appear to offer a broad smorgasbord of functionality. I originally expected them to satisfy most string-processing requirements I would encounter. In actuality, I repeatedly encountered situations where what I needed to do I could not accomplish with a single call to one of the Standard C functions. But they are good building blocks. I found myself using and grouping them to accomplish what I really needed.<P>
Most of the string processing tasks I am faced with center around manipulating text data for input and output. I nearly always have to parse and convert some text script file or user input into a data structure and vice versa. Over time, in just about every program I wrote, the specific needs for text processing started to repeat themselves. I frequently needed to delete and insert strings, or trim leading and trailing tabs and spaces from text. These and many other requirements were common to nearly every project I would work on. After almost ten years of programing in C, a group of about an additional 20 functions has precipitated and become a crucial part of my C function library. I am going to share with you the most recent incarnation of my bare bones but essential string function library. These functions complement the Standard C functions defined in <I>&lt;string. h&gt;</I><P>
<h4><FONT COLOR="#000080"><A name="002C_000E">Dynamic Memory Issues<A name="002C_000E"></FONT></h4></P>
When writing string functions, you can go in a couple of different directions with regards to dynamic memory. You can dynamically allocate memory to store the string that results from a function's execution of a task. This approach allows you to avoid modification of the original string passed to the function. For example, when performing search and replace, you can use dynamic memory to store the string that contains the modifications. The function can then leave the original string unchanged. However, when using this approach, the programmer must keep track of memory allocation and make sure to release the allocated memory eventually. This can be a challenge in certain situations. Use of dynamic memory may be more suitable in C++. C++ is better organized to provide object creation and deletion. This helps with dynamic memory management and relieves some of the burden on the programmer.<P>
Since the functions presented here are pure Standard C, I choose to avoid dynamic memory. In fact, I also choose to avoid creating buffers on the stack as a scratch or work space. Some of the editing functions require a temporary work space, but I get around this by using the <I>memmove</I> function defined in <I>&lt;string.h&gt;</I>. <I>memmove</I> provides safe memory copying of overlapping buffers. You would need a temporary copy of the source buffer to do it yourself. Although convenient, using <I>memmove</I> has the disadvantage of being more costly with respect to processor time. This varies from system to system, but generally there are usually faster ways to accomplish the same task as <I>memmove</I>. Modifying the functions to avoid the use of <I>memmove</I> can wring a bit more performance and efficiency out of them.<P>
In the future, it might be worthwhile to create object wrappers in C++ for these string functions. For now, I will leave them in standard C. This means that all the functions assume that the strings that you pass to them are NULL-terminated. The functions also assume that the strings are pointers to memory areas that are large enough to accommodate the resulting string generated by the function. The burden of avoiding buffer overflows rests on the programer.<P>
<h4><FONT COLOR="#000080"><A name="002C_000F">Implementation<A name="002C_000F"></FONT></h4></P>
I break the string functions up into two categories. I group functions for extracting or finding a substring in a string into the file named <I>STR_NGET.C</I> (<A href="list1.htm">Listing 1</a>
and <A href="list2.htm">Listing 2</a>)
. The second group, in <I>STR_EDIT.C</I> (<A href="list3.htm">Listing 3</a>
and <A href="list4.htm">Listing 4</a>)
, contains functions that I use for editing strings.<P>
<h4><FONT COLOR="#000080"><A name="002C_0010">Functions for Getting Substrings<A name="002C_0010"></FONT></h4></P>
<I>STR_NGET. C</I> contains the functions <I>str_nleft, str_nmid, str_nright</I> and <I>str_rstr</I>. The first three functions extract a specified number of characters from a string. These functions modify the string itself by moving the desired characters into it. <I>str_nleft</I> extracts the <I>n</I> left- most characters. <I>str_nright</I> extracts the <I>n</I> right-most characters. <I>str_nmid</I> extracts <I>n</I> characters from a specified position.<P>
<I>str_rstr</I> resembles the function <I>strstr</I> defined in <I>&lt;string.h&gt;</I>. But instead of finding the first occurrence of a substring, <I>str_rstr</I> finds the last occurrence of the substring. The relationship between <I>strstr</I> and <I>str_rstr</I> is analogous to the relationship between <I>strchr</I> and <I>strrchr</I>. I have seen a function called <I>strrstr</I> in some libraries that come with commercial compilers. It is equivalent to my function <I>str_rstr</I>. It is not a part of the standard.<P>
<h4><FONT COLOR="#000080"><A name="002C_0011">Functions for Editing Strings<A name="002C_0011"></FONT></h4></P>
All the 13 functions in the file <I>STR_EDIT.C</I> do some type of modification or editing to a string. The functionality ranges from the simple padding of strings to a fixed length for justification to complete search and replace.<P>
<I>str_center, str_ljust</I>, and <I>str_rjust</I> justify strings. These functions first trim leading and trailing spaces and tabs from a string. They then move the string so it is either centered, left-justified, or right-justified within a specified length.<P>
The trimming functions, <I>str_ltrim, str_rtrim</I> and <I>str_trim</I> execute the trimming tasks required by the justification functions mentioned above. These functions trim all characters from the end or ends of a string that match a list of characters to trim.<P>
The function <I>str_delete</I> removes a specified number of characters from a string starting at a designated location within the string. The function <I>str_insert</I> inserts a string into a string at a designated location in the string. The function <I>str_rplc</I> uses both <I>str_delete</I> and <I>str_insert</I> implement a search and replace capability. <I>str_mrplc</I> does search and replace for all matches. <I>str_rplc</I> just replaces the first match. The function <I>str_repeat</I> builds a string of desired length by repeating a string.<P>
The function <I>str_vcat</I> is a variable-argument version of the Standard C function <I>strcat</I>. This function concatenates a list of strings. The last string or parameter passed to <I>str_vcat </I>must be a null-pointer. <I>str_ocat</I> is a version of <I>strcat</I> that can handle overlapping strings. An example of overlapping strings would be a single string with multiple pointers to different locations in the string. Depending on the compiler vendor, sometimes <I>strcat</I> will work with overlapping strings, sometimes it will not. For safety and constancy I created the function <I>str_ocat. str_ocat</I> is just wrapper for <I>memmove</I>.<P>
<h4><FONT COLOR="#000080"><A name="002C_0012">Conclusions<A name="002C_0012"></FONT></h4></P>
Nearly every major program I have written has involved text processing in some form. The Standard C library provides a useful, but shallow group of string-manipulation functions. Over time and out of need, I have come up with the group of string functions presented here. These functions build upon the standard library functions and provide the functionality that I have found important in practice.<P>
There are an endless number of more functions you can invent. And you can probably find more efficient ways to implement the functions demonstrated here. Nevertheless, these are the functions I have found useful and essential in my work with C.<P>

<h4><a href="../../../source/1993/jan93/smith.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
