

<HTML>
<HEAD>

<TITLE>January 1993/Programming Guidelines and C ++ Programming Guidelines</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Book Reviews</FONT></H2>

<hr><h2 align="center"><font color="#800000">C Programming Guidelines and C ++ Programming Guidelines<A name="003C_001D"><A name="003C_001D"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="003C_0000"><A name="003C_0000">Reviewed by Dwayne Phillips</font></h3><hr><blockquote><P>
<P><i><A name="003C_0000"><A name="003C_0000">The author works as a computer and electronics engineer with the U.S. Department of Defense. He has a PhD in Electrical and Computer Engineering from Louisiana State University. His interest include computer vision, artificial intelligence, software engineering, and programming languages.</i></P><P>
<I><B>C Programming Guidelines</I></B> and <I>C++ Programming Guidelines</I> are comprehensive style manuals that list specific standards for all aspects of C and C++ programming. They are good books for any group of programmers trying to work together to produce consistently high-quality, portable software. <I>C Programming Guidelines </I>covers standard ANSI C while <I>C++ Programming Guidelines</I> covers general C++. <I>C++ Programming Guidelines</I> repeats large parts of <I>C Programming Guidelines</I>, but it covers C++ specifics and has excellent material concerning migrating from C to C++.<P>
<h4><FONT COLOR="#000080"><A name="003C_001E">Purpose<A name="003C_001E"></FONT></h4></P>
These books list coding standards, that is, rules governing the details of how to write source code. C and C++ are flexible languages and programmers can write correct, working programs using a wide variety of "styles" (including the obfuscated style). A coding standard offers rules and guidelines that help different developers to produce programs in the same style. The authors give three primary reasons for using a coding standard: reliability, readability/maintainability, and portability. If programmers follow a sound coding standard, the result will be more reliable, readable, and portable software. Some programmers argue that while noble, these attributes ruin program speed and efficiency. Although a legitimate argument in some special situations, long-term performance and monetary costs support the authors' reasons for advocating a coding standard.<P>
<h4><FONT COLOR="#000080"><A name="003C_001F">Audience<A name="003C_001F"></FONT></h4></P>
Most C and C++ programmers could use these books. For example, if you are starting a software company, these books could aid your quality control program. In a university research lab, these books could help standardize the work of the beginners. A government employee wanting to specify software standards to a contractor could simply hand these over. A programmer working alone could use these to minimize the tendency to drift into a personal programming style.<P>
The publisher offers machine-readable versions of both books. This enables you to place them online as ready references or fold them into your group's own coding standard.<P>
<h4><FONT COLOR="#000080"><A name="003C_0020">Organization<A name="003C_0020"></FONT></h4></P>
Because both books are references, the they are organized along similar lines. The chapters contain one- to ten-page sections with the majority being two pages long. These sections resemble <I>man</I> pages on UNIX systems. Each section has subsections titled STANDARD or GUIDELINE, JUSTIFICATION, EXAMPLE, ALTERNATIVES, and REFERENCES. The authors use STANDARDs as rules that you must follow while GUIDELINEs are suggestions.<P>
The subsections contain short, direct paragraphs about the subject at hand that resemble cohesive subroutines. This style of writing is appropriate for such reference books. These are not the types of books you cuddle up with in front of the fire and read from cover to cover. Nevertheless, the authors do an excellent job of tying all the sections together around the three primary reasons for using a coding standard.<P>
Sometimes the authors are too efficient. They often refer to other books published by Plum Hall for details. I prefer reading the information in the book at hand over holding my place with one finger while thumbing through a different book.<P>
The programming guidelines in the books fall into one of two categories. The first category comprises syntax rules (use of tabs, spaces, lines per function, lines per file). The second category comprises style rules (functional cohesiveness, functions per file, program and problem structure). This may seem to be a lengthy statement of the subject since most books on programming devote only one chapter to programming style. The subject, however, is more complicated than most people realize and does require one book per language.<P>
One criticism of the text is a shortage of code examples. The authors do give code examples, but not in every section. Programmers sometimes do not translate words into action well. They do, however, understand code and I wish the these books had more source code.<P>
<h4><FONT COLOR="#000080"><A name="003C_0021">Highlights<A name="003C_0021"></FONT></h4></P>
There are several sections in each deserving special attention.<P>
<h4><FONT COLOR="#000080"><A name="003C_0022"><I>C Programming Guidelines</I><A name="003C_0022"></FONT></h4></P>
In <I>C Programming Guidelines</I>, the author discusses byte order and how this affects program portability. When you venture outside the PC world, you find the different machines store numbers with a different byte order. This is especially true with floating-point numbers. <I>C Programming Guidelines</I> suggests converting data to a canonical form before storing to disk and converting back immediately after reading from disk.<P>
One section discusses the different methods of placing braces ({}) in C programs. The author gives three different methods with many examples. This may sound trivial, but the author claims this is a highly-charged issue with most programmers.<P>
Another section states how to use a local standard header for a project to improve portability. I have been the victim of this mistake. Someone once gave me a program that had 40 C files and each started with <I>#include /usr/users/dave/all.h</I>. When we moved the program to a new environment we had to replace each of these with <I>#include all.h</I>. This may sound trivial, but it can be very time-consuming.<P>
Plum advocates the use of code reviews to ensure correctness and portability. Plum describes a "first-order correctness review" that produces a list of test cases for the software. You use these for first-order correctness testing and later for regression testing.<P>
A final section to note covers the environment of Standard C. In this section Plum defines a "strictly portable" C program as producing "identical behavior in any Standard C environment." Strictly portable programs must be careful of word sizes and number representations. Plum lists several dozen rules that make your program strictly portable.<P>
<I>C Programming Guidelines</I> concludes with a description of all the library functions in Standard C. This will not replace a vendor's reference manual. It is, however, a good, concise description of the standard library.<P>
<h4><FONT COLOR="#000080"><A name="003C_0023">C++ Programming Guidelines<A name="003C_0023"></FONT></h4></P>
<I>C++ Programming Guidelines</I> repeats several dozen sections from <I>C Programming Guidelines</I>. Nevertheless, <I>C++ Programming Guidelines</I> contains significant additions about C++ items.<P>
<I>C++ Programming Guidelines</I> dedicates considerable attention to migrating from C to C++, a very important topic given that most of us C programmers will be using C++ in five years if not sooner. We would all like the luxury of not having to produce anything of value for six months while we learn C++, but that will not happen. We must remain productive while migrating.<P>
The authors describe three levels in the migration: Typesafe C, Object-Based C++, and Full C++. <I>Typesafe C</I> is the common subset of Standard C and C++. You should use it when the target platform currently supports C and will support C++ by the time you field your system. <I>Object-based C++</I> is a form of beginner's C++ using basic classes and other C++ extensions. It is not full C++ in that you do not use class derivation and virtual functions. The authors describe these levels amply and as a programmer and manager of programmers I endorse their slow but sure approach to this problem.<P>
<I>C++ Programming Guidelines</I> does not dodge the issue of portable C++ programs. The ANSI C standard makes portable C possible. C++ does not yet share such a standard, so portable C++ programs are more difficult to realize. The authors discuss how to work around this throughout the text and recommend using Ellis and Stroustrup's text as a <I>de facto</I> standard (see reference below).<P>
<I>C++ Programming Guidelines</I> has several sections that discuss code reuse and management of reusable code. One of the selling points of full C++, object-oriented programming is reusable code. You do not receive the full advantages of reusable code without following certain rules in coding and managing code. The authors do a commendable job of explaining this subject and sprinkling tips through the entire book.<P>
<I>C++ Programming Guidelines</I> has one short but vital page on the importance of design in object-oriented, C++ programming. In C++ you create base classes from which you derive many other classes. If you change a base class, then this change can ripple through many derived classes and you have a quandary. The solution is design. You must spend a much larger proportion of time and effort when designing your base classes. You need more reviews and more outsiders asking questions about your design. The result is shorter overall development time and higher quality software.<P>
The authors conclude <I>C++ Programming Guidelines</I> with two benchmark programs. These programs produce a table of execution times for basic operations in C and C++. They also provide you with a sense of execution times for basic operations so you can estimate program performance.<P>
<h4><FONT COLOR="#000080"><A name="003C_0024">Conclusion<A name="003C_0024"></FONT></h4></P>
These are working books that spell out coding standards. A coding standard will help improve the quality and portability of your group's software by helping you to have consistent source code in all your projects. If your group does not have a coding standard, it needs one. If your group needs a coding standard, start with one of these books. You may not agree with everything in the books, but that's not necessary. Use the books as a foundation and cut, paste, add, and delete until you have a standard that will work for you. This will improve the quality of your software, and we all need to do that.<P>
<h4>Reference</h4>
Ellis, Margaret A. and Bjarne Stroustrup. 1990. <I>The Annotated C++ Reference Manual</I>. Reading, MA: Addison-Wesley.<P>
<B>Book Information</B><P>
<I>C Programming Guidelines</I>, 2nd Edition<br>
by Thomas Plum<br>
<B>Price:</B> $30.00<br>
<B>ISBN:</B> 0-911537-07-4<P>
<I>C</I>++<I> Programming Guideliness</I><br>
by Thomas Plum and Dan Saks<br>
<B>Price:</B> $34.95<br>
<B>ISBN:</B> 0-911537-10-4<br>
<B>Publisher:</B> Plum Hall Inc.<br>
<B>To order:</B> (913) 841-1631 (books),<br>
(808) 885-6663 (machine-readable text)<br>
</BLOCKQUOTE>
</BODY>
</HTML>
