<HTML>   
     <HEAD>
<TITLE>December 1999/C++ For Java Programmers</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Book Review</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">C++ For Java Programmers</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Reviewed by Marc Briand</FONT></H3>
<HR>

<BLOCKQUOTE>

<UL><P><FONT COLOR="#004080"><B>Title: <I>C++ for Java Programmers</I><br>
Author: Timothy Budd<br>
Publisher: Addison-Wesley, 1999<br>
Pages: 289, paperback<br>
ISBN: 0-201-61246-1<br>
Price: $32.00</B></FONT></p></UL>

<p>No matter how they get started, most new programmers will probably reach a point where they want to learn C++. Increasing numbers of them may actually come to C++ with backgrounds in Java, not C. Saying that these people are in for a rude awakening would be an understatement. This book tries to ease the pain for programmers moving from Java to C++.</p>
<p>The book begins by discussing the history and philosophy behind Java, C, and C++. Much of spirit behind C carried over into C++, so it makes sense for the book to explain the decisions that went into C. In this section we are reassured that the framers of C were not just being perverse to leave so many things unspecified &#151; things like order of evaluation of function arguments, for example. The designers of C avoided specifying behaviors that would execute well on some machines, poorly on others. Already C (and by inheritance, C++) appear a little less tame than Java.</p>
<p>Although the chapters of this book are not organized exactly in this fashion, they can be roughly classified as Concepts Known in Both Java and C++, Features Found Only in Java, Features Found Only in C++, and Case Studies. Case studies include projects to compute fractions, solve the shortest path problem, create a concordance, play card games, and combine separate classes into one. These case studies exercise some of the more powerful features of C++, such as inheritance and STL. The last case study is not as simple as it may sound. For one thing, it assumes that the classes to be combined are provided by different vendors and cannot be modified. So this study does a few fancy things combining operator overloading, templates, and inheritance.</p>
<p>Learning C++ by way of Java does not look to be easy. When I first saw this book, I thought the author had a good idea; now I think it's half a good idea. The problem is that for Java programmers moving to C++, there are a host of things to learn before we take them off the "armed and dangerous" list. The situation is not all that different from that of a C programmer learning C++, or a non-programmer learning C. While Java does give programmers a head start in understanding things such as classes and polymorphism, it does little to prepare them for the wild world of pointers, memory management, and operator overloading. A book such as this cannot cover all those topics in great detail. What it can do is give programmers a pretty good idea what they're in for, and in that respect, the book does very well.</p>
<p>Even so, a book of this sort might dip down into the depths for a good cause. I can think of no better cause than in explaining the syntax of C/C++ declarations. Consider the following, for example:</p>

<pre>
const int *p; // pointer to const int
int const *p; // pointer to const int
int * const p; // const pointer to int
const int * const p; // const pointer to const int
</pre>

<p>Java programmers are not used to "seeing stars" in their declarations, much less keywords that mean different things in different positions. Although the author does explain what each of these statements mean, he gives no guidance in interpreting the syntax of such declarations in general. Why does <B>const</B> seem to modify the thing to its right when it begins a declaration, but modify the thing to its left otherwise? Why isn't a pointer to <B>int</B> declared as <B>* int</B>? Our hapless Java programmers are left to infer whatever syntax rules they can.</p>
<p>Where this book seems to be at its best, and at its most useful, is in pointing out the subtle differences between Java and C++ in the places they seem to be most the same. Thus, the section on Java inner classes vs. C++ nested classes are enlightening, as are the sections on polymorphism and exception handling. The author is generally candid about which language he thinks implements a feature better &#151; and it isn't always Java.</p>
<p>Skimming through this book will dispel the notion that Java is a "friendly subset" of C++. It quickly becomes clear how different Java and C++ are beneath their syntactic skins. It is also interesting to step outside the C++ programmer's perspective and see how C++ appears to the Java programmer. Big, bad, and mean, I would imagine. Maybe if this book does well the author will take a notion to write its evil twin &#151; <I>Java for C++ Programmers.</I> o</p>

<p><i><B>Marc Briand</B> is Editor-in-Chief of <I>C/C++ Users Journal</I>. He loves programming, writing, and too many other things for his own good. However, he hates to work, which is why he is an editor. He may be reached at <B>mbriand@mfi.com</B>.</i></p>


</BLOCKQUOTE>
</BODY>
</HTML>
