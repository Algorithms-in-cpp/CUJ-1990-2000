


<HTML>
<HEAD>

<TITLE>May 1992/Illustrated C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Illustrated C<A name="0101_0077"><A name="0101_0077"></font></h2><P>
<h3 align="center"><A name="0101_0000"><A name="0101_0000">A Portable Menu Compiler, Part 3</h3><P>
<h3 align="center"><font color="#800000">Leor Zolman</font></h3><hr><blockquote><P>
<P><i><A name="0101_0000"><A name="0101_0000">Leor Zolman has been involved with microcomputer programming for 15 years. He is the author of BDS C, the first C compiler<I></I> <I></I>targeted exclusively for personal computers. Leor's first book, Illustrated C, is now available from R&amp;D Publications, Inc. Leor and his<I></I> <I></I>family live in Lawrence, KS.</i></P><P>
This is the third in a series of columns describing the implementation of CMENU, a general-purpose menu specification language. The system is composed primarily of two programs: <I>cmenu</I> compiles CMENU source files into an intermediate object format, and <I>rmenu</I> interprets the precompiled files. The first two installments provided an overview of the system and covered the <I>cmenu</I> program in detail. For the rest of the series, I'll be discussing the construction of the <I>rmenu</I> program.<P>
<h4><FONT COLOR="#000080"><A name="0101_0078">Introducing <B><I>rmenu</I><A name="0101_0078"></B></FONT></h4></P>
When a CMENU specification file has been successfully compiled by <I>cmenu</I>, the menu is ready to be run (or interpreted, to be more precise) by the <I>rmenu</I> program. Interpretation of intermediate code often carries a connotation of inefficiency. Perhaps this is based on many experiences with early BASIC interpreters that were inefficient when compared with compiled programs. Interpretation, however, can be implemented efficiently when<P>
1) the primary objects of manipulation are addressed directly (as opposed to symbolically or associatively), and<P>
2) the primary operations on those objects are I/O bound rather than computation intensive.<P>
Based upon those criteria, I chose to implement the CMENU system as a pseudo-compiler/interpreter program pair. Now, we'll take a closer look at the <I>rmenu</I> interpreter.<P>
<h4><FONT COLOR="#000080"><A name="0101_0079"><I>rmenu</I><B> Basic Operation: An Overview<A name="0101_0079"></B></FONT></h4></P>
From the user's perspective, <I>rmenu</I> runs a precompiled menu system made up of one or more menu specification files (having the filename extension <I>.mnc</I>). While any single <I>.mnc</I> file may contain more than one menu definition, it is always the first menu in the file named on the <I>rmenu</I> command line that appears on the user's screen at the start of an <I>rmenu</I> session. Other menus of the system, if any, can only be accessed by making the appropriate selections from that top level menu.<P>
The command line syntax for invoking <I>rmenu</I> is:<P>
<pre> rmenu [menufile]</pre>
<I>menufile</I> is the name of the <I>.mnc</I> file that is the root node of a compiled menu system (i.e., all other menus of the system may be accessed through that file). If the filename is omitted altogether, <I>rmenu</I> looks for a specification file named <I>menu.mnc</I> in the current directory. If found, it runs that file by default.<P>
Once the root specification file has been found, the first menu contained therein is displayed on the screen.<P>
The menu title appears at the top of the screen. The menu items are arranged in a rectangular array. The exact configuration depends upon the number of items present and the options specified in the menu definition. The items are numbered sequentially, and a highlight bar is placed on the first menu item. A prompt line at the bottom of the screen lists the general user commands and the keys to invoke them. At the end of the prompt line, the number associated with the highlighted item (1, for starters) is shown with the cursor sitting to its immediate right.<P>
If the first menu item has any help text associated with it, then the message <I>HELP</I><I>:</I> appears on the screen below the item array, and the help text associated with that item appears, highlighted and centered, on the following line.<P>
After displaying the initial screen configuration, <I>rmenu</I> waits for the user to make a menu selection. The user does this by moving the highlight bar to the desired item and pressing the ENTER key. There are several ways the highlight bar may be moved:<P>
1) using the arrow keys<P>
2) using the space bar (equivalent to the down-arrow)<P>
3) entering an item number directly through the numeric keys.<P>
The arrow keys and space bar work as might be expected. When they reach the end of a row or column, they wrap around to the opposite side of that row or column.<P>
The direct numeric addressing option tries to be intelligent about the selection value entered. A string of digits is considered part of a single selection value as long as there is an item on the screen labeled by that value. As soon as a key is pressed that would make the cumulative selection value too large, the old selection value is discarded and the new digit alone becomes the new selection value. If even that single digit is greater than the number of items on display, the bell is rung and the key has no effect on the current selection value.<P>
Every time the selection value changes, the highlight bar is moved from the item represented by the old selection value over to the item represented by the new one. To execute a menu item, the user presses the ENTER key when the highlight bar is positioned on the desired choice.<P>
There are four types of menu items:<P>
1) an executable system command<P>
2) a local menu<P>
3) an external menu<P>
4) an exit item.<P>
The last type of menu item, the <I>exit</I> item, need not explicitly appear because there are built-in commands (<I>e</I> and <I>x</I>) for exiting the current menu. It is provided only for supporting additional help text to describe the exit option (for example, a reminder to the user of the parent menu's content).<P>
When an executable action command is run, <I>rmenu</I>'s exact behavior is controlled by option specifications on two different levels. On one level, the CMENU specification file may contain item options to explicitly determine:<P>
1) how <I>rmenu</I> handles screen clearing before a menu action is executed<P>
2) whether <I>rmenu</I> prompts for a keystroke after the item completes execution<P>
3) which menu item is the next to be highlighted after all processing for the current item is completed.<P>
On another level, the source code to <I>rmenu</I> itself contains a configuration section that specifies defaults for the behavior of the above mechanisms. These defaults apply whenever any of the options that control those mechanisms are omitted from an item specification (i.e., most of the time if the defaults are chosen appropriately).<P>
When a local or external menu is chosen, the specified submenu is called with the state of the current menu preserved. Upon return from the submenu, processing of the current menu resumes. There is no apparent difference to the user between a call to a local menu (one specified within the same physical <I>.mnc</I> file as the currently active menu) and a call to an external menu (a separate <I>.mnc</I> file).<P>
The general user interface commands available on every menu screen, besides the ones described above to move the highlight bar, are:<P>
<I>e</I> Return to the previous menu, or exit <I>rmenu</I> if currently in the root menu<P>
<I>x</I> Exit <I>rmenu</I> immediately, no matter how deeply nested in submenus<P>
<I>!</I> Escape to a system prompt (this may be optionally disabled)<P>
There are two additional commands available to the user but not documented anywhere on the screen. These commands are intended more for use by the system administrator than the end user. The commands are:<P>
<I>v</I> Display CMENU's version number<P>
<I>a</I> Display the action text associated with the currently highlighted item. If that item is an action, all <I>cd</I> statements that would be executed, and the action text itself, are shown. If the item is an external menu, then its full pathname is shown. If the item is a local menu, then a message announcing that fact is displayed and no additional inoformation is given.<P>
<h4><FONT COLOR="#000080"><A name="0101_007A">Beyond the User Interface<A name="0101_007A"></FONT></h4></P>
The above description of <I>rmenu</I> could serve as a user's guide. Now, we'll delve into <I>rmenu</I>'s implementation.<P>
First, some guideposts to the source code; the <I>rmenu</I> source consists of four major program files (<I>rmenu1.c</I> through <I>rmenu4.c</I>), <I>rmenu</I>'s personal header file <I>rcmenu.h</I> and the CMENU system header file <I>cmenu.h</I> (shared with the <I>cmenu</I> program).<P>
The <I>rmenu</I> specific header file, <I>rcmenu.h</I> (<A href="list1.htm">Listing 1</a>)
 defines all configuration options and data structures for the program. The data structures build upon the elementary <I>MENU</I> and <I>ITEM</I> types defined in <I>cmenu.h</I> (see CUJ, 1/92). Both header files rely upon the specification of the target operating system, supplied on the C compiler command line through use of the -<I>D</I> compiler option. This is handled automatically by the <I>makefile</I>.<P>
<I>rmenu1.c</I> contains the <I>main</I> function, several utility functions, and the code to load a compiled menu file into memory for interpretation. Most of the code to handle the user interface, including all the display logic and keyboard command processing, resides in <I>rmenu2.c</I>. <I>rmenu3.c</I> contains routines to execute a selected menu item. <I>rmenu4.c</I> is the file where as much as possible of <I>rmenu</I>'s system dependent code has been localized.<P>
<h4><FONT COLOR="#000080"><A name="0101_007B">Configuration<A name="0101_007B"></FONT></h4></P>
The first several sections of <I>rcmenu.h</I> contain an abundance of customization options affecting screen layout and menu behavior.<P>
While most terminals are laid out in a 24 row by 80 column format, other screen configurations are easily supported by changing the symbolic constant values in lines 69-90.<P>
<I>MAX_IROWS</I> controls the size of the menu item block, telling how many physical screen lines are to be used for menu items alone. The value I use, 18, supports either nine double spaced menu items or eighteen single spaced ones. The value of <I>MAX_IROWS</I> should always be even, so the screen placement algorithms do not become confused by double spacing.<P>
The <I>HOME_X</I> and <I>HOME_Y</I> symbols specify the upper left hand corner of the menu item block. <I>SCREEN_COLS</I> specifies the physical number of columns on the screen. Note that the last column is never used (to avoid wrap-around problems). The last five constants in this section (lines 74-78) specify row and column values for several key features of the menu system, and are self documenting.<P>
Lines 14-38 allow <I>rmenu</I> to work with both new and older variations of the UNIX Curses library. Older versions of Curses did not contain predefined mappings for the cursor motion keys, among other minor differences. To test which flavor of Curses is available, the conditional preprocessor directive in line 14 tests to see if a symbol named <I>KEY_UP</I> has been defined. If so, we're running under a newer Curses library, if not, it's an old one. For old Curses, EMACS movement controls are used to define the cursor motion keys. This is my personal choice; any four key code values may be substituted.<P>
Lines 81-90 define some additional system-dependent terminal characteristics. The number of lines available on the screen is one such characteristic. On a standard DOS screen, there are twenty-five lines available; serial terminals under UNIX typically support only twenty-four lines. The <I>LAST_ROW</I> symbol is set accordingly.<P>
Lines 95-104 define the appearance of various portions of <I>rmenu's</I> general command prompt string. Depending on whether shell escapes are enabled at any particular time during the interpretation of a menu system, the prompt string seen by the user may or may not mention the availability of the shell escape (<I>!</I>) command.<P>
When shell escapes are enabled and the user selects that command, another compile time option comes into play. If the <I>SHELL_PROMPT</I> symbol (defined in line 56) has a value of <I>TRUE</I>, then the prompt string represented by the <I>SH_PROMPT_STR</I> symbol is shown, giving the user the opportunity to abort the she11 escape. This feature is provided for the benefit of users who might not know how to handle an accidental foray into "shell-land" under DOS.<P>
The system command to invoke a subordinate shell under non-DOS systems is defined in lines 106-109. A special system prompt is constructed to remind the user that the menu system is still active. This prompt is then active during the lifespan of the subordinate shell.<P>
Under DOS, the command to invoke a subordinate command interpreter is taken directly from the <I>COMSPEC</I> environment variable during the <I>init_win</I> call at the start of an <I>rmenu</I> session. This code will be covered in a later installment of this series.<P>
<h4><FONT COLOR="#000080"><A name="0101_007C">Data Structures<A name="0101_007C"></FONT></h4></P>
To support recursive menu interpretation, <I>rmenu's</I> data structures begin with <I>LMenus</I>, an array of structures of type <I>levels</I>. Each structure of type <I>levels</I> completely describes an active <I>.mnc</I> file. Within it are a number of substructures of type <I>menu2</I>. Each of these substructures describes a single menu definition from the parent <I>.mnc</I> file. Going one level deeper, the contents of each <I>menu2</I> structure includes a copy of the <I>MENU</I> header structure (named <I>Menu</I>), and an array (named <I>Items</I>) containing pointers to all the <I>ITEM</I> structures in the current menu. Additional information controlling the display of those individual menu items on the screen is included in an array of structures named <I>coords</I>.<P>
To shorten definitions and declarations of pointers to these varying structure types, I've created <I>typedef</I> aliases for them in lines 147-149.<P>
The placement information in <I>coords</I> is computed at the time the <I>.mnc</I> file is first loaded into memory and remains constant throughout the period of that menu file's interpretation (i.e., until the user exits from the top level menu in the file). This information includes the item's position on the screen, and the quantity of filler characters (spaces) needed to clear the trailing portion of the item text field when the text length is less than the maximum field width. Figuring all those values for each menu item is a computationally intensive task; it is done just once for each menu invocation at the time the menu is loaded into memory. The reason this is done by <I>rmenu</I> at all, rather than by <I>cmenu</I> at compile time, is to support the ability to use the same compiled <I>.mnc</I> file(s) under different terminal configurations. In other words, the <I>.mnu</I> source to a particular menu system would not require recompilation if some characteristic of the user terminals, such as number of lines, ever changes. Only <I>rmenu</I> would need to be recompiled. Or, if rmenu were ever adapted for network use, then this strategy allows for straightforward extension to support different kinds of user terminals while sharing the same <I>.mnc</I> files among all users; instead of hard-coding the terminal parameters in <I>rcmenu.h</I>, those parameters could be obtained from each user's personal environment variables.<P>
<h4><FONT COLOR="#000080"><A name="0101_007D">Memory Allocation Strategy<A name="0101_007D"></FONT></h4></P>
The memory blocks for storage of <I>MENU2</I> structures are allocated dynamically, as is the storage for each <I>ITEM</I> structure to be represented within them.<P>
One possible way to implement memory management for recursive menu files would be to allocate storage for each of an <I>.mnc</I> file's <I>MENU2</I> and <I>ITEM</I> structures when the file is opened, and to later free all that storage when the user exits the top level menu. If, however, the menu system spans several files, then each transition across compiled units would generate a number of <I>alloc</I> and <I>free</I> calls, proportional to the number of menus and items involved.<P>
Rather than having <I>rmenu</I> fully allocate and release these blocks of memory on every external submenu call, I chose to add a bit of complexity to the allocation scheme in the interests of efficiency. First, note that every <I>MENU2</I> structure takes up exactly the same amount of storage. The same consistency applies to <I>ITEM</I> structures. Since <I>Menus</I> and <I>Items</I> are arrays of pointers each already dimensioned to the largest possible number of elements, there is no reason why storage allocated for one set of menus cannot be reused for every subsequent set that might require it. Additional memory would only be allocated when the previous maximum number of menus or items in a menu is exceeded, and then only the incremental number of memory blocks would have to be allocated. Also, none of the memory would ever have to be freed until the <I>rmenu</I> program terminated. At that point, all the memory could be freed at once.<P>
That is the strategy employed in <I>rmenu</I>. In each nesting level, represented by a <I>LEVELS</I> structure in the <I>LMenus</I> array, an integer counter named <I>max_menus</I> keeps track of the largest number of menus in any single <I>.mnc</I> file loaded into that nesting (recursion) level during the current <I>rmenu</I> session.<P>
Then, within each of the <I>MENU2</I> structures of each nesting level, a counter named <I>most_items</I> tracks the most <I>ITEM</I> structures loaded into the <I>Items</I> array during the entire <I>rmenu</I> session.<P>
In a later section, we'll look at how the <I>ld_menu</I> function maintains these counters during the process of loading a menu file into memory.<P>
<h4><FONT COLOR="#000080"><A name="0101_007E">Other Shared Data<B><A name="0101_007E"></B></FONT></h4></P>
Most menu information is maintained in the large data structures described above. To support seamless recursion, a few items of data are made available globally for convenience.<P>
The <I>nestlev</I> variable indicates the current nesting, or recursion, level of the menu system. Level 0 indicates the master <I>.mnc</I> file is active, in <I>LMenus[0]</I>; the first execution of the <I>emenu</I> action bumps the nesting level to 1 and loads the specified external <I>.mnc</I> file into <I>L-Menus[1]</I>, and so on. Maintaining this value as a global eliminates the need to keep passing it "up and down" through the recursive <I>sub_menu</I> calls.<P>
The <I>SysShell</I> string (line 157) holds name of the system command to be invoked when the user requests a shell escape with the <I>!</I> command. At the start of an <I>rmenu</I> session, the <I>init_win</I> function initializes <I>SysShell</I> with the value of the <I>COMSPEC</I> environment variable if running under DOS, or else the value of the SHELL_ESC string as defined in <I>rcmenu.h</I>.<P>
The other global data includes two state variables used with the Curses functions to save the screen coordinates of the user input echo area, and a debugging flag that I used during development (lines 154-155).<P>
<h4><FONT COLOR="#000080"><A name="0101_007F">A Menu Is Run<A name="0101_007F"></FONT></h4></P>
When <I>rmenu</I> is invoked to interpret a menu system, there are three major subsystems, or categories of functionality:<P>
1) screen display management (via the Curses library)<P>
2) menu nesting management (memory allocation, data management and path construction, all supporting recursive submenus)<P>
3) user input processing (responding to keyboard commands).<P>
These subsystems are distributed so that not every function in the program necessarily belongs to one specific subsystem, although many functions can be classified in one or another of the categories. To explain how <I>rmenu</I> works, I'll focus first on each conceptual subsystem individually then show how they all interact.<P>
<h4><FONT COLOR="#000080"><A name="0101_0080">Screen Management<A name="0101_0080"></FONT></h4></P>
One very powerful feature of the Curses library is delayed screen refresh. This means that updates made to an internal screen image do not show up on the user's terminal automatically. One of several special functions (e.g., <I>refresh</I>) must be called to update the screen to match the internal memory image.<P>
There are many benefits to this scheme. Curses can optimize the refresh process to require as few I/O operations as possible to update the screen image. For example, a program deletes some portion of text from the memory image, then later restores it to the original form before ever calling the refresh function. If the refresh were then immediately performed, nothing would have to be written to that portion of the screen at all. A side effect of this mechanism is that there is no need to worry about the order in which a set of related screen updates is performed. During the refresh, a set of chaotic updates becomes a smoothly executed repaint.<P>
There is one aspect of delayed refresh that takes some getting used to: you need to remember to call the refresh function. As I began to debug <I>rmenu</I> (my first project using Curses), I kept trying to figure out why some of my screen updates weren't happening. They were done with Curses calls, but I had forgotten to refresh the screen...<P>
Curses requires initialization at the beginning of a session and some housecleaning at the session's end. If the screen is ever to be manipulated by software other than the Curses library while a Curses session is in progress (for example, when a user requests a system shell escape during an <I>rmenu</I> session), special calls must then be made to switch the user's keyboard and screen characteristics between Curses mode and normal interactive mode, as necessary. For example, the Curses library uses "raw" tty mode under UNIX, while normal shell interaction requires the tty mode be set to "cooked."<P>
Unfortunately, I have not been able to find any single, universally portable set of system calls that switch back and forth between these terminal modes correctly under both XENIX Curses and PC Curses for DOS. The closest I've come is to write a pair of functions, named <I>tty_shell</I> and <I>tty_Curses</I>, employing one conditional compilation directive in the <I>tty_shell</I> function. The functions work as written for both DOS and XENIX, but I haven't tried them elsewhere. XENIX's Curses is purported to be nonstandard. My guess is that a little bit of tweaking will be necessary for other kinds of UNIX systems. Such nonportable tweaking, however, should not be required outside of these two functions, since all the other Curses calls I use are supposed to be portable.<P>
<h4><FONT COLOR="#000080"><A name="0101_0081">Menu Memory Management<A name="0101_0081"></FONT></h4></P>
The trickiest parts of maintaining a recursive menu structure have been described above. Look at some key points in the menu perusal code to get a sharper picture of how recursion is implemented.<P>
In <I>rmenu1.c</I> (<A href="list2.htm">Listing 2</a>)
, the top level menu processing function <I>do_menu</I> begins on line 73. The <I>main</I> function calls <I>do_menu</I> just once per <I>rmenu</I> session, to process the menu file named on the command line (or <I>menu.mnc</I> if a menu name was omitted). <I>do_menu</I> is also used to process <I>emenu</I> (external menu) action statements.<P>
<I>do_menu</I> takes two strings as function parameters, representing the path and filename of the <I>.mnc</I> file to be run. Lines 85-92 construct the full pathname and attempt to load the file into memory with the <I>ld_menu</I> function. If <I>ld_menu</I> experiences an error in opening the file, then <I>do_menu</I> returns the <I>EXITALL</I> value to its calling function, signalling a fatal error condition and forcing the program to unravel all recursive calls and terminate.<P>
If <I>ld_menu</I> loads the <I>.mnc</I> file successfully, then the <I>sub_menu</I> function (top of <I>rmenu2.c,</I> Listing 3) is called to run the main menu of the new file. <I>sub_menu</I> calls always run a menu at the current menu file nesting level (i.e., within the active <I>.mnc</I> file). Since all menus in a single <I>.mnc</I> file are loaded at once when the file is opened, calls to <I>sub_menu</I> never require any memory management services (except, of course, for the normal stack operations always generated automatically by the C compiler as part of the standard function calling sequence).<P>
<I>sub_menu</I> is the function that interprets user keyboard commands. <I>sub_menu</I> takes two parameters: the index number of a local menu to be executed, and the current default path specification. When the user selects an item for execution, a call is placed to the <I>do_item</I> function for execution of the item's action clause.<P>
So as not to displace all other material in this issue of CUJ, the listings for the action-processing functions (including <I>do_item</I> as mentioned above) are being deferred to the next installment of this series. However, I'll need to refer to some of the functions in that code in order to complete my discussion on recursion. Please bear with me; if you're really anxious to see the remainder of the code right away, however, it is available right now on the CUJ 10.3 code disk.<P>
In <I>do_item</I>, we finally see recursion in action. The first case occurs when an <I>lmenu</I> clause is encountered. In line 36 of <I>rmenu3.c</I>, <I>do_item</I> places a direct call back to the <I>sub_menu</I> function to run the local menu that was specified in the <I>lmenu</I> clause.<P>
The next case of recursion involves the <I>emenu</I> action clause. In line 41 of the same listing, a special function named <I>do_menu</I> (line 102) is called to set up the external menu call, and <I>do_emenu</I> in turn calls <I>do_menu</I> &#151; the function that started it all.<P>
I've skipped the nitty-gritty details of these key functions so far, to highlight the design's recursive flow. These functions will be more fully illustrated in a later installment.<P>

<h4><a href="../../../source/1992/may92/zolman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
