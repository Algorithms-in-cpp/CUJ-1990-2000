


<HTML>
<HEAD>

<TITLE>May 1992/malloc-Related Errors</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">malloc-Related Errors<A name="00F7_006D"><A name="00F7_006D"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="00F7_0000"><A name="00F7_0000">Steve Halladay</font></h3><hr><blockquote><P>
<P><i><A name="00F7_0000"><A name="00F7_0000">Steve Halladay currently works for StorageTek in<I></I> <I></I>Louisville, CO. He has over 10 years experience<I></I> <I></I>developing products like CSIM and Multi-C in<I></I> <I></I>C++. Steve received his MS in computer science in<I></I> <I></I>1982 from Brigham Young University. You can each<I></I> <I></I>Steve at StorageTek (303) 673-6683.</i></P><P>
Though <I>malloc</I> and <I>free</I> can make a program more flexible and extensible, using these functions improperly can create subtle errors. This article enumerates several types of <I>malloc</I> and <I>free</I> misuse so that C and C++ programmers can identify and rectify these errors more quickly.<P>
<h4><FONT COLOR="#000080"><A name="00F7_006E">Using Freed Memory<A name="00F7_006E"></FONT></h4></P>
A most serious and difficult error to track occurs when you deallocate a properly allocated data item, and then continue to use the item normally. This error can produce three types of symptoms depending on how the program uses and accesses the freed data item on the heap.<P>
If the program <I>frees</I> the data item (see <A href="list1.htm">Listing 1</a>)
, the contents of the data item may change. The heap manager (i.e., <I>malloc</I> and <I>free</I>) may use the item's memory to link it onto a <I>free</I> list as a variant record. If the program immediately attempts to read the item, it will appear to the programmer, who is not aware the data item has been freed, that the item's contents have mysteriously changed. Fortunately, a debugger can help identify and solve this bug by tracking the data item through the program.<P>
If the heap manager does not write over a portion of the data item, freeing the item and reading its contents will not immediately reveal this error. Porting the code from one compiler to another or even adding additional unrelated code will often cause these masked errors to surface. The inexperienced programmer might then blame the compiler or the individual who introduced the unrelated code.<P>
Another symptom of using freed memory occurs when the program attempts to modify the freed memory (see <A href="list2.htm">Listing 2</a>)
. If the memory is still on the heap, and the modification conflicts with the way the heap manager is using the memory, the error will go unnoticed until a future call to <I>malloc</I> or <I>free</I>. At this point you can expect an access violation or related error, or what appears to be a call to <I>malloc</I> that never returns. This is a painful death because the effect of the error is not in the vicinity of the error.<P>
The worst scenario for this type of error is where a program reallocates the freed memory before the previous owner accesses it (see <A href="list3.htm">Listing 3</a>)
. Multiple program sections then believe they each own the same memory location. Each part of the program sees the contents of its data structure change mysteriously. This behavior is probably the most common symptom for this kind of error.<P>
Probably the most discouraging side effect from this type of bug occurs in the debugger. Some debuggers use the heap to keep track of breakpoints, etc. The symptoms of the bug can therefore change (or even disappear) while in the debugger. These bugs render the debugger nearly useless since it cannot identify the bug locality.<P>
<h4><FONT COLOR="#000080"><A name="00F7_006F">Magic Numbers<A name="00F7_006F"></FONT></h4></P>
A simple yet effective approach for diagnosing heap-related errors is the use of a <I>magic number</I>. A magic number is a unique, arbitrary value the program stores in the allocated data structure. Each data-structure type has a field that contains a specific, predetermined value. The program sets the data structure's field when it allocates the data structure, and resets the field when it deallocates the data structure. Object-oriented or abstract data type approaches lend themselves easily to this mechanism. Each of the object's methods checks the magic number to verify its contents. Since you can use any number, a byte value is sufficient. I personally prefer to use a value that is the address of a static string that identifies the data structure type. This scheme can help debug these heap-related errors. For magic numbers to be useful, they must be used <I>religiously</I>.<P>
<A href="list4.htm">Listing 4</a>
(and the associated files, <A href="list5.htm">Listing 5</a>
and <A href="list6.htm">Listing 6</a>)
 implements a stack abstract data type that uses magic numbers. The <I>static</I> pointer named <I>magic</I> is the magic value for the stack abstraction. The three macros <I>MAGIC_ON, MAGIC_OFF</I> and <I>MAGIC_CHECK</I> set and reset the magic number as well as verify its value. <I>StkConstruct</I> is the stack constructor, which allocates and initializes an instance of the stack. Notice that this routine sets and checks the magic number just before returning the stack handle (the handle is the pointer that references the stack). <I>StkConstruct</I> employs <I>MAGIC_CHECK</I> as a minor sanity check to ensure <I>MAGIC_CHECK</I> and <I>MAGIC_ON</I> are consistent.<P>
All other member functions first validate the stack handle by using <I>MAGIC_CHECK</I>. This check guarantees that the data structure in question was created by <I>StkConstruct</I>. <I>StkDestroy</I> also uses <I>MAGIC_OFF</I> just before it <I>frees</I> the stack data structure to prevent member functions from inadvertently manipulating the data structure after it has been released. While abstractions like this stack object require a few more lines of code, they provide bullet-proof code.<P>
<h4><FONT COLOR="#000080"><A name="00F7_0070">Forgetting to Declare <B><I>malloc</I><A name="00F7_0070"></B></FONT></h4></P>
When C programs reference a function before declaring it, the compiler assumes the function to be of type <I>int</I>. Errors result when a function appears to return an <I>int</I>, but the actual item returned is of a different size. Since <I>malloc</I> returns a pointer value, a potential error exists when a program uses <I>malloc</I> before it declares <I>malloc</I>. Some compilers will flag the error only in environments where the size of an integer differs from the size of a pointer.<P>
This error is common for PC programmers who experiment with various memory models (I personally cause this error annually whether I need to or not). Symptoms of this error include a call to <I>malloc</I> that hangs the program, or the program runs to completion but DOS cannot be reloaded because the program trashed some system memory, such as the interrupt vector.<P>
This error can be especially annoying because the same program may run without a hitch using other compilers or memory models. Again the inexperienced programmer may blame the compiler, the runtime or some other library, and sometimes even the hardware. The fallacious proof for these indictments is that the program runs fine elsewhere.<P>
The cure is to include an external definition for the heap routines in a system header file. Unfortunately the name of the system file may vary from compiler to compiler. <I>stdlib.h</I> contains the external definitions for ANSI C. Other environments might include definitions in <I>alloc.h</I>, <I>malloc.h</I> or even <I>stdio.h</I>.<P>
Including the appropriate file with the declaration is preferable to simply externally declaring the functions in the code. Usually, including the system definitions will not cause type conflicts with the actual function in the library. Some compilers define <I>malloc</I> as returning a character pointer (i.e., <I>char</I> *), while others define it as returning a <I>void</I> pointer (i.e., <I>void</I>  *). Strict type checking notifies the programmer when he or she forgets to declare <I>malloc</I>. However, a programmer can experience hours of aggravation if he or she declares the function differently from the runtime library definition and the compiler enforces strict type checking.<P>
<h4><FONT COLOR="#000080"><A name="00F7_0071">Memory Leakage<A name="00F7_0071"></FONT></h4></P>
A less catastrophic but potentially serious error results from failing to <I>free</I> unused allocated heap memory. For smaller programs with little memory utilization, this type of error may go unnoticed for the life of the program. However, these errors become visible as the program consumes greater amounts of heap memory. Even so, such programs often run for a while before running out of memory.<P>
When a program on a PC runs out of memory, <I>malloc</I> will generally return a <I>NULL</I> pointer. If the programmer did not bother to check the <I>malloc</I> return value for <I>NULL</I>, the program will probably step on the interrupt vector in low memory and eventually cause the machine to hang. Experienced programmers recognize that identifying bug locality is worth the additional effort required to check return codes from library routines such as <I>malloc</I>. On a machine with virtual memory, this type of memory leakage has a different symptom. As the program continues to run, it chews up virtual memory until the swap space is full. One can discern this situation by an inordinate amount of I/O activity. Increased I/O slows the program to a glacial grind. If the program continues, it also will eventually return a <I>NULL</I> from <I>malloc</I>. On most virtual memory machines, if the program does not check the return value from <I>malloc</I>, the program will dereference the <I>NULL</I> pointer and cause an access violation.<P>
Sound program design will prevent memory leakage errors. Generally, you should allocate and deallocate memory at the same level in a program.<P>
You can employ many diagnostic tricks to identify this error. One approach builds a housekeeping layer between the application and the heap manager. The housekeeping layer keeps track of the allocated and deallocated memory. <A href="list7.htm">Listing 7</a>
and <A href="list8.htm">Listing 8</a>
show how such a layer might be built for <I>malloc</I> and <I>free</I>. The concept is easily extensible to additional heap routines such as <I>calloc, realloc, strdup</I>, etc. Notice the use of the preprocessor definitions of <I>malloc</I> and <I>free</I>. Using the preprocessor to redefine <I>malloc</I> and <I>free</I> allows the layer to be retrofitted to existing code, as well as disabled for final release code. Being able to turn off the housekeeping layer is vital because of its impact on program performance. Robert Ward covered "<I>malloc</I> wrappers" in detail in the October 91 issue of <I>The C Users Journal</I>.<P>
<h4><FONT COLOR="#000080"><A name="00F7_0072">Using Unallocated Memory<A name="00F7_0072"></FONT></h4></P>
A serious but less common error is dereferencing a pointer to a structure that the program never allocated. This amounts to trying to use an uninitialized pointer. Many current compilers will flag these errors with warning messages; more traditional compilers will not. Since C does not specify the value of uninitialized <I>auto</I> variables, this error can produce symptoms that vary significantly.<P>
Using an uninitialized pointer in a PC program can have drastic effects. Since there is generally no memory protection, wild pointers let a programmer step on program and system memory. Wild pointers can corrupt areas of memory containing program code, the system configuration, and even the current date and time.<P>
On machines with memory protection, this error commonly results in an access violation. But when, by chance, the uninitialized pointer points to a valid memory address, the symptoms are similar to those observed when dereferencing a deallocated memory section (i.e., data item values mysteriously change). The previously discussed magic numbers are an effective means of debugging programs.<P>
<h4><FONT COLOR="#000080"><A name="00F7_0073">Freeing Unallocated Memory<A name="00F7_0073"></FONT></h4></P>
A bug that occurs less frequently results from attempting to <I>free</I> a pointer that the program never allocated. Since <I>free</I> usually does not return a value, the programmer is not gracefully notified when this error occurs. Fortunately this error is the rarest of any mentioned in this article.<P>
Symptoms are similar to those seen when inadvertently freeing the same location more than once. The next call to <I>malloc</I> may result in an access violation, a <I>NULL</I> pointer assignment or even in <I>malloc</I> hanging in an infinite loop.<P>
Some more intelligent implementations of <I>free</I> use a hidden magic number to verify that the pointer originated from <I>malloc</I>. If the pointer was never <I>malloc</I>ed, <I>free</I> prints a message and returns, or even exits. This seems the exception (no pun intended) rather than the rule since additional checking adds unavoidable overhead.<P>
Using a housekeeping layer is also an effective way to shoot these bugs. The <I>malloc/free</I> housekeeping layer helps the program recognize that it has not allocated a particular address. The housekeeping layer then raises an exception.<P>
<h4><FONT COLOR="#000080"><A name="00F7_0074">Conclusion<A name="00F7_0074"></FONT></h4></P>
As programs become more dynamic, it is critical that programmers understand how to defend themselves against the pitfalls of heap abuse. Knowing the symptoms and reasons for heap-related errors can save a programmer significant time and aggravation.<P>

<h4><a href="../../../source/1992/may92/halladay.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
