


<HTML>
<HEAD>

<TITLE>November 1990/A Flexible Dynamic Array Allocator</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">A Flexible Dynamic Array Allocator<A name="0251_014C"><A name="0251_014C"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0251_0000"><A name="0251_0000">Dick Hogaboom</font></h3><hr><blockquote><P>
<P><i><A name="0251_0000"><A name="0251_0000">Dick Hogaboom has an M.S. in Physics from Boston College. He currently works for Telos Consulting Services and is contracted to MIT Lincoln Laboratory. You can reach him at MIT LL, Air Traffic Surveillance, Group 42/L165, 244 Wood St., Lexington, MA 02173-0173; Work phone: 617-981-0276, Home phone: 508-435-4091.</i></P><P>
Many C applications require the dynamic allocation of memory, as lists, queues, stacks, or arrays. To be useful some of these structures require initialization. Lists, for example, usually require a defined structure for link pointers. Stacks, on the other hand, are fundamentally structureless and require only a few position pointers. Arrays are typically implemented as a series of pointers [[[to pointers] to pointers] etc.]to data. Your compiler usually handles all this statically at compile time. On occasion, however, you'll need more memory than you've got. If you don't need all the structures simultaneously, you can circumvent memory limitations by a heap space dynamic allocation/free sequence.<P>
I ran into this problem when I integrated several complex FORTRAN subroutines into a C code control skeleton on a Sun 3/260 system. The subroutines were based on an algorithm that set up temporary multidimensional arrays in a well-defined sequence &#151; a perfect candidate for dynamic allocation. I was running out of space fast and had several more modules to integrate, when I decided to redesign the application with a dynamic array allocator.</FONT></FONT><P>
The C language doesn't support raw memory allocation, much less dynamic array allocation. However, the newly finalized ANSI C standard provides functions for raw heap space memory allocation, <I>malloc()</I>, <I>calloc()</I>, <I>realloc()</I> &#151; and in this case <I>valloc()</I> &#151; provide raw space that can be initialized with the necessary array pointer structure.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The usual approach is to <I>malloc()</I> separately the space for the array pointer structure and the array data area. Each call to <I>malloc()</I> returns the necessary pointer that must be stored in the previous level of pointer indirection. The disadvantage of this approach is that multiple <I>malloc()</I>s result in an array structure whose component levels of pointers and data elements are not necessarily contiguous. Each invocation of <I>malloc()</I> may seize space at widely non-contiguous points in virtual memory, worse yet, if you are on a paged virtual memory managed machine, the memory may reside on different virtual pages. Any array reference can thus result in the trapping of one or more pages, depending on the number of levels of indirection, into real memory &#151; very inefficient compared to simple pointer indirection calculations on a single page. Another disadvantage of the multiple <I>malloc()</I> scheme is backing out upon allocation failure. Freeing memory upon allocation failure is complicated.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
If you know the number of dimensions, dimension limits, and data size, you can calculate memory requirements for both the data and pointers and allocate it with a single call. If the allocation fails, you don't need to worry about freeing memory. A successful allocation, however, will yield an optimal array structure with the maximum of locality of reference. SunOS provides <I>valloc()</I>, similar to <I>malloc()</I>, to position the beginning of the allocated memory on a virtual page boundary. Arrays of less than a page will either be entirely in or out of memory. Beware, though &#151; the <I>valloc()</I> function is not an ANSI standard, and you sacrifice portability.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0251_014D">Function Overview<A name="0251_014D"></FONT></h4></P>
I know that a good number of dynamic array allocation routines already exist, but most have limitations, like allocating only a certain C type or limiting you to a fixed number of dimensions. I wanted an efficient and flexible routine, and <A href="list2.htm">Listing 2</a>
is the result. See <A href="list1.htm">Listing 1</a>
for the function declaration.<P>
<h4><FONT COLOR="#000080"><A name="0251_014E">Function Parameters<A name="0251_014E"></FONT></h4></P>
Size refers to the size in bytes of the basic data type to be allocated. Normally you'll obtain it by using the <I>sizeof</I> C operator. You can use any data type that <I>sizeof</I> can be applied to &#151; I've tested arrays of <I>int, double, float, struct, enum, union, </I>and<I> typedef</I>. The second parameter is the number of dimensions, from one to ten. I chose the ten cutoff arbitrarily, since it seemed unlikely that anyone would want anything larger. At any rate, the choice only impacts the error check routine. The third parameter is a single dimensional array of dimension sizes corresponding to each of the array dimensions. If the array is to be a<I>[10][10][5]</I>, then the first three elements of <I>dimensions[]</I> would be <I>10</I>, <I>10</I>, and <I>5</I>. The fourth parameter, <I>start[]</I>, is the starting dimension subscript for each dimension. If all dimensions are to start at zero, as is usual in C, then this array would be initialized to zero for each dimension. However, you can individually subscript each dimension from an arbitrary integer starting subscript. Thus, using the array a<I>[10][10][5]</I> with <I>start[]</I> set to <I>-1, 0, 1</I> results in subscripts running from <I>-1</I> to <I>8, 0 to 9,</I> and <I>1</I> to <I>5</I>. The fifth parameter, <I>err_code</I>, returns zero upon no error and a positive integer on error. I describe the possible errors and their associated codes in the preamble of <A href="list2.htm">Listing 2</a>.
</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The sixth parameter, <I>free_ptr</I>, is a pointer used to free the allocated space. Don't free on the function return pointer, since arrays of non-zero subscripted first dimensions will not point to the allocated space, but to some offset based on the subscript offset of the first dimension. The last parameter, <I>init_ptr</I>, is a pointer to the basic data type that contains initialization data to be replicated throughout the elements of the array, or to <I>NULL</I> if you prefer not to initialize. The initialization argument pointer should point to something corresponding to the size given in the first argument. If the first argument was <I>sizeof(int)</I>, then the last argument should point to <I>int</I>. If the first argument was <I>sizeof(struct s)</I>, then the last argument should be a type pointer to <I>struct s. daa( )</I> will use the first argument to get the size in bytes of whatever <I>init_ptr</I> points to.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The return value is a pointer to the start of the array, returned as <I>NULL</I> upon error. To reference the array with the desired number of subscripts, you need to cast this pointer to the type of the array. The rule is simple: first comes the array type and then a number of stars equal to the number of dimensions. If you need a two-dimensional integer array, then cast to <I>(int **)</I>. If you're making a ten-dimensional array, then use <I>(int **********)</I>. The declaration is very unusual, but correct! The pointer variable you use to reference the array will need to be declared similarly, e.g. <I>int **********array</I>. Your ten-dimensional array reference would be <I>array[i][j][k][l][m][n][o][p][q][-]</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<A href="list2.htm">Listing 2</a>
gives you the complete <I>daa( )</I> source code. You'll find examples of argument setup, <I>daa( )</I> invocation, array usage and error codes in the documentary preamble. For brevity I've omitted the check for a <I>NULL</I> return, but you should not.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0251_014F">Dissecting The Code<A name="0251_014F"></FONT></h4></P>
The code in <I>daa.c</I> starts off with some error-checking and proceeds to the array setup required for the linked pointer structure. Then I calculate the total size of the raw space necessary for the array (pointer structure plus data storage), and allocate it with <I>valloc()</I>. I obtain both the last parameter address, and the size of the basic data type. I use the data type size to get that number of bytes from the stack and initialize the part of the just allocated array space that is basic data type storage. Finally, the actual work of pointer structure setup is done with a call to <I>al(0, dim_ind)</I> which returns the final array pointer returned from <I>daa()</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The real meat of <I>daa()</I> is the recursive routine <I>al()</I> and two other recursive routines that <I>al()</I> calls &#151; <I>off()</I> and <I>doff()</I>. The basic allocation routine, <I>al()</I>, repeatedly calls itself with each new invocation descending to a lower level in the pointer array hierarchy. The first argument, <I>level</I>, is incremented by one for each successive array dimension. For a three-dimensional array, the level would go from <I>0</I> to <I>2</I>. The <I>dim_ind[]</I> array tells each recursive invocation of <I>al( )</I> exactly where within each level the pointers returned from the next level are to be stored. <I>dim_ind[]</I> will have, in some recursive call, every combination of array values. Initially <I>dim_ind[]</I> will be zeroed. Successive calls will increment each dimension level by one from zero to the maximum subscript. Thus, a two-dimensional array dimensioned <I>10x10</I> will see <I>dim_ind[0]</I> go from <I>0</I> to <I>9</I> and <I>dim_ind[1]</I> go from <I>0</I> to <I>9</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Every pointer is composed of the sum of three parts: 1) the constant base of the array, 2) the offset of the arrays of pointers for a given level, calculated by <I>off()</I> and 3) the data offset of the arrays of pointers within each level, calculated by <I>doff()</I>. The last level is different since it's the data element level which has a different element size, and because no further levels are called. To accommodate non-zero starting subscripts, I had to make adjustments to the pointers in three places. Each recursive call to <I>al()</I> has its return value adjusted by an amount based on that level's desired starting subscript from the <I>start[]</I> array. Basically, I adjust the level zero pointer returned by <I>daa( )</I> by the desired starting subscript of the first dimension. I also adjust the passed-back pointer for one-dimensional arrays when no pointer structure is needed.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The easiest way to verify the accuracy of the algorithm is to put a <I>printf()</I> statement just before or after the recursive call to <I>al()</I>, and print out the level, the <I>dim_ind[]</I> array, and the difference of the returned pointers and the base pointer. The pointer difference gives the offset into the raw space of each level and sublevel of pointer. This way, you can verify that the correct number of pointers for each level is being allocated.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0251_0150">Conclusion<A name="0251_0150"></FONT></h4></P>
I've tested this routine in many environments and am confident in its accuracy. It is as efficient as array access goes and flexible enough to allocate arrays of anything, with the added wrinkle of non-zero subscripting. You're still responsible for using the proper range of subscripts. To do otherwise results in the same usage error as misaccessing traditional zero-based C arrays. This routine is not strictly ANSI-conforming. Converting <I>daa</I> to ANSI-compatible code requires changing several features, among them the call to <I>valloc()</I> and the use of a pointer to <I>void</I> instead of a pointer to <I>char</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>

<h4><a href="../../../source/1990/nov90/hogaboom.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
