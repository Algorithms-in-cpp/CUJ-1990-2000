


<HTML>
<HEAD>

<TITLE>November 1990/Interprocess Communication: A VAX/VMS Example</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocnov.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Operating Systems</FONT></H2>

<hr><h2 align="center"><font color="#800000">Interprocess Communication: A VAX/VMS Example<A name="0249_014A"><A name="0249_014A"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0249_0000"><A name="0249_0000">Michael J. Gilson</font></h3><hr><blockquote><P>
<P><i><A name="0249_0000"><A name="0249_0000">Mike Gilson is a senior system test engineer for the Allen-Bradley Co. and is responsible for developing test software on VAX/VMS and UNIX platforms. You may contact him at 747 Alpha Drive, Highland Heights, Ohio 44143.</i></P><P>
This article describes the design and VAX/VMS implementation of interprocess communication (IPC) primitives that allow processes to share information. It also describes an architecture that reduces the number of IPC links between processes but still allows any process to communicate with any other. The implementation uses VAX/VMS I/O services and mailboxes as the IPC mechanisms.<P>
<h4><FONT COLOR="#000080"><A name="0249_014B">Mailboxes: A VAX/VMS IPC Mechanism<A name="0249_014B"></FONT></h4></P>
Mailboxes are virtual I/O devices that can be used for communication among processes. Unlike other I/O devices, which are hardware devices, mailboxes are implemented in software. Mailbox operations include receiving mail, sending mail, and rejecting mail. The receive and send operations may be performed synchronously or asynchronously through a variety of system services. In this application, data transfer is performed by a call to the <I>SYS$QIO</I> system service. VAX/VMS provides higher level I/O system services, but all of them eventually call <I>SYS$QIO</I> or <I>SYS$QIOW</I> (the synchronous version of <I>SYS$QIO</I>).</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Mailboxes are flexible in size, message format, and protection. When a mailbox is created, the programmer may specify the mailbox's size (in bytes) or use the system default. Mailboxes place no restriction on message format, so the programmer may read/write any structure to a mailbox as long as the message is within the mailbox's size restrictions. Mailbox access is controlled through the usual VAX/VMS protection strategies.<P>
Although a mailbox may be used for two-way communication, this is not always convenient, especially if asynchronous communication is desired. If process A and process B are communicating through a single mailbox, both processes will be notified that a message is in the mailbox regardless of which process sent the message. Applying mailboxes as if they were one-way devices is often easier. Using this approach, two mailboxes link processes A and B: one for A-to-B transfers, another for B-to-A.<P>
<h4><FONT COLOR="#000080"><A name="0249_014C">Architecture<A name="0249_014C"></FONT></h4></P>
When designing an IPC solution, the programmer needs to consider the tradeoffs between minimizing the number of IPC links and maximizing performance. Mailboxes require memory, which is deducted from process resources. Too many mailboxes will slow down a system by eating up memory. Minimizing the number of links requires more processing overhead. Two of the designs I'll discuss in this article aim for maximum performance, and for minimum links. Our implementation, which is a compromise of the two, is a third design.<P>
When a link is established from each process to every other process in the IPC network as in <A href="fig1.htm">Figure 1</a>,
 the total number of links for <I>n</I> processes is <I>n * (n - 1)/2</I>. This solution obtains a constant, minimum transfer time but requires a large number of links. If the links are to be bidirectional, two mailboxes will be required for each link: a total of <I>n * (n - 1)</I> mailboxes.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The minimum link design, shown in <A href="fig2.htm">Figure 2</a>,
 yields <I>n - 1</I> links for <I>n</I> processes. Since the links are bidirectional, <I>2 * (n - 1)</I> mailboxes are required. In this scheme, messages are passed from one process to another until the destination is eventually reached. This approach requires message handling by each process in the path between sender and receiver. The number of links is minimized, but transfer time now depends on the number of processes that handle the message. One transfer in the best case, <I>n-2</I> transfers in the worst case, <I>n/2</I> in the average case.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The architecture used in our application requires near-minimum links and provides fast transfer time (see <A href="fig3.htm">Figure 3</a>)
. For <I>n</I> processes, this solution requires <I>n</I> + <I>1</I> links and <I>n</I> + <I>1</I> mailboxes. IPC between client processes <I>0</I> and <I>1</I> requires a transfer from the client <I>0</I> to the server, then from the server to client <I>1</I>. This architecture minimizes mailboxes since all clients write to a single server mailbox.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0249_014D">Server Functions<A name="0249_014D"></FONT></h4></P>
The server provides pass-through and broadcast functions to perform IPC between any two processes. The pass-through function allows any process <I>A</I> to send a message to any process <I>B</I> via the server, assuming both <I>A</I> and <I>B</I> have established IPC links with the server. The broadcast function allows any process to broadcast a message to all other processes linked to the server.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0249_014E">Server Startup<A name="0249_014E"></FONT></h4></P>
During startup, the server creates its receive mailbox (see <A href="list2.htm">Listing 2</a>)
 by calling the <I>open_comm_link()</I> primitive shown in <A href="list3.htm">Listing 3</a>.
 <I>open_comm_link()</I> creates a VAX/VMS mailbox using the <I>SYS$CREMBX</I> system service, which returns the completion status code. The mailbox is created with the following attributes: it is temporary and both protection and access mode are set to lowest levels. If the mailbox already exists, the <I>SYS$CREMBX</I> service assigns a channel to that mailbox. Thus cooperating processes need not consider which process must execute first to create the mailbox. <A href="tab1.htm">Table 1</a>
shows arguments passed to <I>open_comm_link()</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The server then calls the <I>SYS$DCLAST</I> system service to enable the asynchronous receipt of messages. <I>SYS$DCLAST</I> causes an interrupt, declares the <I>receive()</I> primitive as the interrupt handler, and passes <I>rcvmbx</I> as an argument to <I>receive()</I>. The server maintains a message queue for buffering incoming messages. The queue is a fixed length array which is treated as a ring buffer or circular queue. Messages sent to the server's mailbox are received and placed in the queue asynchronously by <I>receive()</I>. The <I>SYS$QIO</I> system service is the key to the <I>receive()</I> routine. <A href="tab2.htm">Table 2</a>
shows the parameters passed to <I>SYS$QIO</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The example makes use of two powerful features of <I>SYS$QIO</I>, receiving I/O asynchronously and calling a user-defined interrupt service routine when the I/O completes. The server calls <I>receive()</I> (through <I>SYS$DCLAST</I>) immediately after creating its receive mailbox. <I>Receive()</I> posts a read request and returns control to the main loop. When the mailbox receives a message, the <I>SYS$QIO</I> sets the <I>RCVEF</I> local event flag, copies the message and the final I/O completion status into the message queue, and calls the interrupt service routine, passing it <I>mbxid</I> as a parameter. In this case, the interrupt service routine is <I>receive()</I>. Every time the mailbox receives a message, <I>receive()</I> places it in the messge queue and posts a new read request. It might appear to create an infinite loop, but it posts a new read request only after the last request is completed.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0249_014F">Establishing The IPC Link<A name="0249_014F"></FONT></h4></P>
After startup, the server places itself in a wait state. When the server receives a message, its <I>RCVEF</I> event flag is set and the server drops into the main processing loop. The first message a client process sends is an <I>ADDMBX</I> command (see <A href="list4.htm">Listing 4</a>)
. This message requests that the server assign a channel to the server-to-client mailbox created by the client process in <A href="list4.htm">Listing 4</a>.
 The name of this mailbox is <I>CLIENTMBX</I> concatenated with the client process' process number. Before assigning the channel to the mailbox, the server first examines its client list, which is a linked list of processes that it is serving. If the process is not in the client list, it adds it to the list and assigns the channel, storing the <I>mbxid</I> in the new list entry.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0249_0150">Pass-through<A name="0249_0150"></FONT></h4></P>
When client A wants to send a message to client B (and only client B), client A initializes <I>MSGBUF</I> variable and sends it to the server. In the following code fragment, assume that A's process number is <I>0</I>, that B's is <I>1</I>, and that the message type is <I>TEXT</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>msgbuf.cmdtyp = PASSTHRU;
msgbuf.msgtyp = TEXT;
msgbuf.xmt_prcnum = 0;
msgbuf.rcv_prcnum = 1;
strcpy(msgbuf.msg.text,
"\nTesting");
send(xmtbmx, sizeof(MSGBUF),
msgbuf);</pre>
The server first checks to see that B is a valid destination. If it is, then the server sends the message to client B by calling the <I>send()</I> primitive (see <A href="list3.htm">Listing 3</a>)
.</FONT></FONT><P>
<I>Send()</I> uses the <I>SYS$QIOW</I> system service to write a message to a mailbox. <I>SYS$QIOW</I> waits for completion of the write transaction and returns completion status in the variable's status and <I>iosb</I>. In this example, the status returned in <I>iosb </I>is used for debugging purposes only. <I>Send()</I> expects</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<UL><li><I>mbxid</I>:   the mailbox identification.</FONT></FONT></li>
<li><I>msg:      </I>address of the message to be sent.</FONT></FONT></li>
<li><I>msgsiz</I>:  the size (in bytes) of the message.</FONT></FONT></li></UL>
<h4><FONT COLOR="#000080"><A name="0249_0151">Broadcast<A name="0249_0151"></FONT></h4></P>
A client may broadcast a message to all processes linked to the server. A message is initialized as above, with the <I>cmdtyp</I> set to BROADCAST. <I>rcv_prcnum</I> need not be assigned a value. The server passes the message, message size, and a pointer to the beginning of the client list to the <I>broadcast()</I> primitive shown in <A href="list3.htm">Listing 3</a>.
 <I>broadcast()</I> simply traverses the client list, passing the <I>mbxid</I> for that entry in the linked list to <I>send()</I>, which performs the actual I/O. <I>broadcast()</I> sends the message to all the clients, including the originator of the request.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0249_0152">Deleting The IPC Link<A name="0249_0152"></FONT></h4></P>
When a client performs a graceful shutdown, it should notify the server of its impending shutdown. Once notified, the server can remove the client from its client list and close its corresponding mailbox. Both client and server call <I>close_comm_link()</I> to close the mailbox. The client closes both of its mailboxes after sending the server a <I>DELMBX</I> request.</FONT></FONT></FONT></FONT><P>
<I>Close_comm_link()</I> deassigns the channel between a process and the specified VAX/VMS mailbox using the <I>SYS$DASSGN</I> service. In this application, mailboxes are created with the <I>TEMPORARY_MBX</I> attribute, which allows the system to automatically delete the mailbox when all channels to the mailbox have been deassigned. Channels may be deassigned explicitly using <I>close_comm_link()</I> or implicitly upon process termination. The mailbox identification, <I>mbxid</I>, is the only argument passed to <I>close_comm_link()</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0249_0153">Server Shutdown<A name="0249_0153"></FONT></h4></P>
The server performs a graceful shutdown when it receives a <I>SHUTDOWN</I> command from a client. The server broadcasts a <I>SHUTDOWN</I> command to all its clients, closes all mailboxes in the client list, and closes its received mailbox. It then exits.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0249_0154">Flexible Messages<A name="0249_0154"></FONT></h4></P>
VAX/VMS mailboxes make no restriction on message format. A programmer can take advantage of this flexibility through the <I>union</I> data structure. The <I>MSGBUF typedef</I> may be logically divided into three parts: the message header, the <I>msgtyp</I> field, and the message body (see <A href="list1.htm">Listing 1</a>)
. The clients and the server use the message header for routing. The message body is a <I>union</I> of whatever types of data may be transferred between processes. The <I>msgtyp</I> field allows the receiving process to intelligently process the data.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<A href="list4.htm">Listing 4</a>
demonstrates the message format's flexibility. The client process switches on the <I>msgtyp</I> field, which may be either <I>TEXT</I> or <I>INT_ARRAY</I>. In either case, the receiver can access the correct member of the <I>union</I>. This allows the programmer to create any number of message types by declaring a<I> union </I>that includes each message type and by using a corresponding definition that identifies each <I>union</I> member.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0249_0155">Conclusion<A name="0249_0155"></FONT></h4></P>
VAX/VMS mailboxes offer the programmer a powerful and flexible solution in IPC applications. These primitives provide the programmer with basic IPC functionality. The server architecture offers the advantages of a near-minimum number of links and reduced message passing, yielding predictable performance and good use of resources.<P>

<h4><a href="../../../source/1990/nov90/gilson.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
