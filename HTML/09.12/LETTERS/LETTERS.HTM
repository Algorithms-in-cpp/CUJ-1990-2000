


<HTML>
<HEAD>

<TITLE>December 1991/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="028C_015F"><A name="028C_015F"></font></h2><hr>
<BLOCKQUOTE>
<A name="028C_0000"><A name="028C_0000">Dear PJ:<P>
I read Bob van der Poel's letter in the <I>CUJ</I>, August 1991 and can appreciate the define versus declare problem he mentions. A simple solution is to let the preprocessor handle the details. First, suppose there are two source files. The first contains <I>main</I>, which we will call the main module, and the second contains various support functions. A header file named <I>globals.h</I> holds the global data. If there is only one global variable (<I>maclevel</I>), the <I>globals.h </I>looks like<P>
<pre>#ifndef MAIN
   extern
#endif
   char maclevel;</pre>
In the file that contains <I>main</I>, we write<P>
<pre>#define MAIN 1
#include "globals.h"</pre>
In the support modules, we simply <I>#include</I> <I>"globals.h"</I>. Because we have defined <I>MAIN</I> in the main module, the preprocessor causes the global to be defined as<P>
<pre>char maclevel; /* In module with main() */</pre>
Because <I>MAIN</I> is not defined in any of the support modules, the declaration becomes:<P>
<pre>extern char maclevel; /* Modules without main() */</pre>
The advantage of this approach is that both the data definitions and declarations appear in only one place. This makes finding and editing the globals a snap.<P>
Sincerely,<P>
Jack Purdum, Ph.D.<br>
President, Ecosoft Inc.<br>
8295 Indy Court<br>
Indianapolis, IN 46214<P>
<I>I find this running debate about how to declare global data objects puzzling. I have always declared such data with the </I>extern<I> keyword (and no initializer, of course) in a header file.</I> <I>I include that header file in every C source file that cares about the name, even the one that defines it.</I> <I>The defining instance simply redeclares the data object without the</I> extern <I>keyword and with an initializer.</I> <I>This scheme is blessed by the C Standard and works on every C compiler I have ever used.</I><P>
<I>We all know you're a smart guy, Jack. Am I missing something? &#151; pjp</I><P>
Dear Mr. Plauger,<P>
I am a long-time programmer. I have recently taught myself C, and your magazine has been quite useful in my education. The articles are mostly excellent. But I have found a bug. It is a bug found in numerous articles and advertisements in your magazine and in others. The bug is "C++."<P>
When I first heard of C++, I thought it was an odd name, but not knowing the C language, I didn't know the origin. Now that I know C, I understand the intended meaning of the name. The increment operator, ++, is intended to denote that C++ is an incremental improvement of C; that C++ does C one better. But as I said, there's a bug.<P>
By using the post-increment form, "C++" says (figuratively) "enhance the C language, and then use the unenhanced language." Clearly the intent is to use the enhancements; the language is enhanced before it is used. This should be denoted by the pre-increment operator, thus the language name should properly be "++C."<P>
Changing the established name of a language is a major undertaking, but clearly the current name is erroneous. With your influence in the C community, you could change the name from "There's something better than this" to "This is something better."<P>
Randall Bart<br>
9950 Reseda Blvd. #13<br>
Northridge, CA 91324<P>
<I>You've rediscovered one of my favorite snarky observations.</I> <I>I am often asked in public seminars how C++ differs from C.</I> <I>I explain that the notation C++ means that you have added to the content of C after you have extracted its useful value.</I> <I>Neither sticks nor stones nor ill-chosen names will stop C++ if it truly is an</I> <I>improvement, however.</I> <I>Sit back and enjoy the ride. </I><I></I>&#151;<I> pjp</I><P>
Dear Editor:<P>
Your comments in the September 1991 Editor's Forum concern me. I'm not really sure what you are trying to say...I hope you're not saying "Ok, we'll run more PC- and Mac-oriented articles." I also hope you are not saying "We will tone down the content of our articles."<P>
This is my second season with <I>CUJ</I>, and so far I'm very pleased. I spend my time in UNIXland, so I skip just about every article that is specific to some other platform/OS. Up until now, I think <I>CUJ</I> has done a fair job of balancing the articles for various specific platforms/OSs. Everyone deserves to be served. What I'm afraid of is that <I>CUJ</I> will change the balance, or reduce the number of platform/OS independent articles. In my opinion, there are already too many PC, Mac, and UNIX 'rags.' Also, I recently subscribed to some IEEE publications <I></I>&#151; <I>CUJ</I> is definitely not academic! Again, there are plenty of mags for beginners as well.<P>
I hope, as you stated in a previous editorial, that <I>CUJ</I> will continue to focus on the state and future of C. As far as I know, there isn't another magazine of this kind. Keep up the good work.<P>
Thanks,<P>
Sean<P>
<I>Don't worry.</I> <I>I certainly do NOT</I> <I>intend to water down CUJ.</I> <I>All I meant to say was that we need more articles of the kind that Leor Zolman likes to write.</I> <I>Nobody can accuse him of watering down ANYTHING.</I> <I>He just has a pragmatic slant that appeals to many of the old timers who read CUJ.</I> <I>I have a different pragmatic slant.</I><P>
<I>The balancing act is never-ending.</I> <I>My editorial was merely a comment on the latest concern gleaned from letters written by concerned readers.</I> <I>Thanks for your input.</I> <I></I>&#151;<I> pjp</I><P>
Dear Editor,<P>
As a long-time reader of <I>CUJ</I>, I would like to applaud Nick Busigin for his excellent article concerning the QNX operating system (<I>CUJ</I>, September 1991). But I want to amplify his comments. More than a server-oriented architecture, QNX is a peer-to-peer system. The term 'server-oriented' suggest that a dedicated server is always needed, as in many MS-DOS network systems. QNX needs no server <I></I>&#151; the whole network is one system tied together by virtual circuits, a natural extension to the message passing mechanism. Distributed processing is possible, proved par example by the free MandelbroT package running parallel on several nodes of the network. Shared memory and shared files are themselves leading to shared libraries and dynalibs or DLLs. For any given software packet the code of individual tasks can be very small.<P>
Taking into account that such a powerful operating system like QNX is not as easy to understand, the originator, Quantum Software Systems, Ltd. Canada, distribute for free an excellent demo-diskette running on all 8080 and 80x86 systems, starting under MS-DOS, QNX not needed. You simply will miss the fun by not seeing this very plausible demonstration.<P>
QUICS, Quantum's Update and Interactive Conference System, operating 24 hours per day may be reached by modem via phone lines. Canada 613-591-0934, -0935, -0940 and x25 address 3020 85701416. For all C fans there is a very interesting library of all sorts of C programs and applications not only for QNX, partly a delight for real real-time hackers.<P>
Hans G. W.Mueller<br>
Consultant Real Time Systems<br>
Hamburg, Germany<P>
<I>Thanks for the information.</I> <I></I>&#151;<I> pjp</I><P>
Dr. Plauger:<P>
This letter concerns your articles in March and April 1991 on The <I>LOCALE</I> header.<P>
I am an experienced analyst and programmer of 20 years working on DEC pdp 11-01 to 11-70s, Vaxen, Intelbased PCs and IBM mvs and VM mainframes. However I am currently a C beginner/novice.<P>
I was looking for a good tool to allow me to format a string to allow me to display a readable number in a Microsoft Windows application. To learn C and C++ and Windows, I purchased the BORLAND C++ compiler. I found your article seemed to fit the bill so I tried it out. I scanned in the code and hand-verified it. Then with the default C<I> Locale.h</I> from Borland executed it. This worked fine, however as we know it does not format anything since the parameters are essentially set to a simple default set.<P>
I created from scratch what I thought was the <I>Locale.h</I> function for locale <I>conv</I>. The standard as show in the March issue of <I>The C Users Journal</I> was not clear to me. I seem to run into trouble around both the grouping and <I>mon_grouping</I> pointers. I do not really understand the contents. With the aid of the Borland debug facility I was able to get the <I>p</I> structure in your program <I>Fmtval </I>to be populated. However as soon as it started to process the second <I>memmove </I>statement in the <I>V</I> case the screen on my DEL 333D cleared and the machine hung.<P>
So much for my "sob" story. What I learn from most is examples. Could you mail me a <I>Locale.h</I> file that works with the code I was hoping to have the ability to have comma'd thousands as well as <I>$</I> processing? Since the US and Canadian formats are so close, your help would be appreciated.<P>
This is my first connect through Internet so hope all works out. I left phone and home addresses at the top in case you have any trouble returning mail to me.<P>
Sincerely<P>
John D. Nourse<br>
Oakville, Ontario<P>
<I>You are taking quite a few risks in mixing code so freely between two library implementations.</I> <I>The statement that is bombing assumes that </I>p-&gt;decimal_point[0]<I> (from the locale) *must* be present in the converted field.</I> <I>That's true only if you initialized that field properly in the locale structure so that it matches the decimal point generated by Borland's conversion function.</I> <I>My bet is that you have an error here, given your uncertainty over how to construct a</I> <I>locale.</I><P>
<I>You will find a reasonable "USA"</I> <I>locale on page 114 of </I>The Standard C Library<I>.</I> <I>That should serve as a good starting point for a Canada locale.</I> <I>It won't do you much good, however, unless you pick up much more machinery from the book.</I> <I>I don't see how you can get very far just mucking with </I>locale.h<I>.</I><P>
<I>The code diskette for this book is available from The C Users' Group.</I> <I>If you still want to pursue the matter, you might want to start with that.</I> <I>It should save you considerable typing and</I> <I>debugging.</I> <I>On the other hand, you might be better off altering </I>_Fmtval<I> so it doesn't mess with the locale machinery.</I> <I>You can, for example, pass the locale structure to use as an additional argument.</I><P>
<I>Good luck.</I> <I></I>&#151;<I> pip</I><P>
Dear Editor:<P>
First, I'd like to say that I'm pleased at the amount of reader feedback present in <I>The C Users Journal</I>; this is, I think, one of the things that distinguishes a good magazine from the rest.<P>
Second, I'd like to propose yet another possibility for distribution of program sources: the Usenet. As one of the largest and most widely-distributed (and definitely world-wide) networks around, it could serve as an excellent way to get the source out. In addition, though there are commercial providers of Usenet access, one can get access to it for the price of an often local phone call. While access to the Usenet generally requires special software (at a minimum, the ability to receive e-mail), all of the requisite software is available in freely-distributable form.<P>
If the idea seems reasonable but you lack the resources to do this yourself, it might be possible for me to post the sources to the Usenet on your behalf.<P>
A couple of minor nits: you indicate that the code disk for your standard C library can be found by looking for an ad near the middle of the magazine; I was unable to find the appropriate ad. (Unless it was hidden in the CUG ad. I didn't see it there.) Since I'm rather interested in such a library I was a bit disappointed. No doubt I'll clear this up with a phone call, but....<P>
Also, one page (99) of the magazine had several parts of the text faded to illegibility, apparently from a printer problem. Smaller areas were faded on some other pages. It isn't a big deal since the unreadable text was not in something. I was interested in but I thought you'd want to know.<P>
T. William Wells<br>
239B Willow Turn<br>
Mt. Laurel, NJ 08054<br>
<I>bill@twwells. com</I><P>
</BLOCKQUOTE>
</BODY>
</HTML>
