


<HTML>
<HEAD>

<TITLE>August 1991/Doctor C's Pointers&reg;</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Doctor C's Pointers&reg;<A name="01E3_00E8"><A name="01E3_00E8"></font></h2><P>
<h3 align="center"><A name="01E3_0000"><A name="01E3_0000">Data Structures, Part 5</h3><P>
<h3 align="center"><font color="#800000">Rex Jaeschke</font></h3><hr><blockquote><P>
<P><i><A name="01E3_0000"><A name="01E3_0000">Rex Jaeschke is an independent computer consultant, author and seminar leader. He participates in both ANSI and ISO C<I></I> <I></I>Standards meetings and is the editor of The Journal of C Language Translation, a quarterly publication aimed at implementors of C<I></I> <I></I>language translation tools. Readers are encouraged to submit column topics and suggestions to Rex at 2051 Swans Neck Way, Reston,<I></I> <I></I>VA 22091 or via UUCP at rex@aussie.com.</i></P><P>
Last month in Part 4 I showed the first half of a program to implement a singly linked list in an array of structures. This installment presents the rest of that example. See <A href="list1.htm">Listing 1</a>.
<P>
<h4><FONT COLOR="#000080"><A name="01E3_00E9">Some Commentary<A name="01E3_00E9"></FONT></h4></P>
Maintaining a linked list requires more work than maintaining a simple array. Not only must you allocate memory for the links between nodes, must also make sure these links are correct when nodes are inserted or deleted. However, such insertions and deletions typically only affect their immediate neighbor nodes and not the whole list.<P>
One property you lose by going the linked list route is the ability to index into a given node directly. To get to the nth node, you must traverse the list starting from the root, counting nodes as you go. This makes the <I>Change</I> node, <I>Display</I> node, <I>Insert</I> node, and <I>Remove</I> node operations more expensive in terms of coding, program size, and execution time.<P>
I have made the node pointer's type <I>signed int</I>. Standard C guarantees that an <I>int</I> can represent values at least in the range <I>-32767</I> to <I>32767</I>. Consequently, lists up to 32K entries are allowed, which should be adequate for most applications. Because the value stored in a link pointer is actually an array subscript, the 32K negative possibilities are never used. I have chosen a value of <I>-1</I> to represent <I>EOLIST</I>, although I could have chosen any negative value. If, however, you wish to make these pointers an <I>unsigned</I> integer type, you can no longer use <I>-1</I>. Instead, you must chose something like the value <I>all bits set</I>, and make sure your array never actually contains this many elements.<P>
You could maintain the nodes in ascending sorted order, thereby eliminating the need for the <I>Sort</I> node option. This would also eliminate the need for the <I>Insert</I> node option, and change the <I>Add</I> node to mean "add this new node in the correct place." Currently, duplicates are treated as different entries. Instead, you could insert them in the order they arrived or based on the value of some secondary key. Alternatively, you could add a duplicate count field to each node. Then, when a duplicate value arrived, you would increment the counter rather than insert a new node. However, this would only work for fixed data. If data values can change at runtime, each duplicate must be maintained in separate nodes because their values may change independently. (This is also true for nodes containing more than one data member.)<P>
The array <I>ary</I> has automatic storage duration. It could just have easily been static. It could also have been allocated dynamically at runtime via <I>malloc</I>. As noted in Part 1 (<I>CUJ</I>, April 1991), with careful design the timing of allocation should be transparent. One interesting aspect is that if you allocate the array using <I>malloc</I> and you fill it up you could extend it using <I>realloc</I>. If necessary, <I>realloc</I> will move the old block of memory to a new location. Because all your node forward pointers are relative offsets from the array base you shouldn't care. (This would <I>not</I> be true if these were real C pointers.) If you need more dynamic memory than you can get , you may try writing the list to disk and recycling the memory it occupies. If you do this repeatedly, you finish up with a set of disk files, each containing a sorted subset of nodes. By merging these files you can get one sorted list, as a file.<P>
A major advantage of more advanced linked lists is that the nodes can be linked in more than one list. You can have several lists threading their way through the same set of nodes, but in different orders. Only one copy of the node data need exist. If you update a node's data by locating that node via one list, the change is immediately reflected when that node is located via any other lists that include it. In fact, the number of links leading to and from a node in a list depends entirely on your requirements. Implementation is simply a matter of adding more links to each node's structure definition and making them point to the right place.<P>
The functions that maintain the free node list could easily be made more general. Instead of dealing with fixed names for the array of nodes and the various pointers, all this information could be passed in via arguments. As such, these functions can maintain any list they are asked to. Similarly, the options to manipulate the used node list can also be made general.<P>
<h4><FONT COLOR="#000080"><A name="01E3_00EA">Still To Come<A name="01E3_00EA"></FONT></h4></P>
You could revise this example in a number of other interesting ways. For example, instead of using a fixed size array of structures to represent the list you could allocate each node at runtime as it was needed. Then when a node is removed instead of freeing it, you simply add it to the free node list. Also, depending on the amount and type of data stored in each node, you might wish to store the actual data elsewhere and only store a pointer to it in the node directly.<P>
We will look at these and other issues such as doubly linked lists, circular lists, and lattice constructs in future installments.<P>


<h4><a href="../../../source/1991/aug91/jaeschke.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
