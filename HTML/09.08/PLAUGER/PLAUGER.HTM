


<HTML>
<HEAD>

<TITLE>August 1991/Standard C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Standard C<A name="01E1_00E6"><A name="01E1_00E6"></font></h2><P>
<h3 align="center"><A name="01E1_0000"><A name="01E1_0000">Math Primitives</h3><P>
<h3 align="center"><font color="#800000">P.J. Plauger</font></h3><hr><blockquote><P>
<P><i><A name="01E1_0000"><A name="01E1_0000">P.J. Plauger is senior editor of The C Users Journal. He is secretary of the ANSI C standards committee, X3J11, and convenor<I></I> <I></I>of the ISO C standards committee, WG14. His latest book is Standard C, which he co-authored with Jim Brodie. You can reach him at pdp@plauger. uunet.</i></P><P>
<h4><FONT COLOR="#000080"><A name="01E1_00E7">Introduction<A name="01E1_00E7"></FONT></h4></P>
Last month, I began a discussion of the functions declared in &lt;<I>math.h</I>&gt;. I gave a brief history of the evolution of the C math library. I outlined the goals I set myself when I wrote my own set of math functions. I ended that column with a brief sampler of code.<P>
I present a much heavier dose of code this month. My goal is to show you the underpinnings of a math library. These are the functions that isolate most of the numerical code from the actual representation of floating-point values on a given computer. They make possible a combination of precision, portability, and speed that you could not otherwise hope to achieve. These functions also form a handy collection of nuts and bolts. You may have occasion to write a function not already in the math library. Knowing how to use the low-level functions can save you a lot of grief.<P>
You don't have to like numerical programming to benefit from a study of these functions. Programming abounds with interfaces. An important skill to master is encapsulating the peculiarities of an interface in an economical set of type definitions and functions. That's the essence of designing good objects in languages like C++. Even without all the trappings of an object-oriented language, however, you can encapsulate and isolate to advantage.<P>
The Standard C library contains a number of explicit encapsulations. Most of the 15 standard headers provide collections of related types, macros, and function declarations. &lt;<I>stdarg.h</I>&gt; holds everything you need to walk a variable argument list. &lt;<I>ctype.h</I>&gt; has a comprehensive set of character classification and mapping functions. A few headers are catchalls, to be sure. (&lt;<I>stddef.h</I>&gt; and &lt;<I>stdlib.h</I>&gt; are the worst offenders.) The rest form respectable "objects," even if they lack the discipline that C+ + imposes.<P>
The library also contains a few <I>implicit</I> encapsulations. Consider the storage allocation functions &#151; <I>calloc</I>, <I>free, malloc</I>, and <I>realloc</I>. They cooperate to maintain a heap from which you can allocate data objects on the fly. They also conspire to hide details of the implementation from the program. You can identify a handful of the functions declared in &lt;<I>stdio.h</I>&gt; as fundamental. Get them working and you can write all the rest of the library in terms of calls to those low-level primitives. (UNIX programmers know that you can get a lot of mileage out of the system calls <I>close, lseek, open, read</I>, and <I>write</I>.) The math library is built atop a similar implicit encapsulation.<P>
You don't have to even <I>know</I> numerical programming to benefit from a study of the math primitives. Here is where the numbers meet the bits. These functions do more masking and shifting than any sort of arithmetic. At that, the arithmetic involves integer operations, not floating-point. The whole idea is to depend as little as possible on how the implementation performs floating-point, particularly with extreme values. You want to avoid overflow, underflow, and zero divide at all costs. Otherwise, you have to master how each machine generates special codes or causes traps.<P>
<h4><FONT COLOR="#000080"><A name="01E1_00E8">The Primitives<A name="01E1_00E8"></FONT></h4></P>
The C math library includes quite an assortment of semi-numerical functions. You would expect these to be the set of primitives we're looking for. Indeed, the earliest implementations of C used these visible functions to construct many of the others.<P>
Those functions predate the IEEE 754 floating-point standard, however. They have no provision for handling infinities and NaNs (for not-a-number). I found it more convenient, therefore, to build on a different set of primitives. The existing semi-numerical functions become mostly simple calls on the lower-level functions.<P>
A good way to illustrate what the primitives do is to show them in conjunction with their visible counterparts. I began that process last month with the function <I>fabs</I>. That trivial function is not so trivial when you have to worry about the special codes of IEEE 754. I simplified it as much as possible, and made it more portable in the bargain, by having it call the primitive <I>_Dtest.</I><P>
<A href="list1.htm">Listing 1</a>
is a repeat of the function <I>_Dtest</I>. It classifies its <I>double</I> argument broadly as a NaN, an infinity, zero, or some finite value. For space considerations, I won't repeat <I>fabs</I> or the relevant portions of the header <I>"xmath.h"</I>. See last month's column if you're curious.<P>
<A href="list2.htm">Listing 2</a>
shows the function <I>ceil</I> and <A href="list3.htm">Listing 3</a>
shows the function <I>floor.</I> They are the next simplest semi-numerical functions after <I>fabs</I>. Each function requires that any fraction part of its argument be set to zero. Moreover, each needs to know whether the fraction part was initially nonzero. Each function then adjusts the remaining integer part in slightly different ways. The common operation is to clear fraction bits and test whether any bits got cleared. That's what the primitive <I>_Dint</I> is for.<P>
<A href="list4.htm">Listing 4</a>
shows the function <I>_Dint</I>. If *<I>px</I> has a finite value, the function tests and clears all fraction bits less than a threshold value. That threshold is effectively two raised to the power <I>xexp.</I> (Other functions have occasion to call <I>_Dint</I> with values of <I>xexp</I> other than zero.) The code for clearing fraction bits is a bit tricky.<P>
Note the use of an index within an index in the term <I>ps[sub[xchar]]</I>. The index <I>sub[xchar]</I> corrects for differences in layout of floating-point values on different computer architectures. The <I>switch</I> statement contains a cascade of <I>case</I> labels, a practice that is generally misleading and unwise. I indulge in both practices here in the interest of performance.<P>
<A href="list5.htm">Listing 5</a>
shows the file <I>modf</I>, which is only slightly more ornate than <I>ceil</I> and <I>floor</I>. Like those functions, <I>modf</I> relies on the function_<I>Dint</I> to do the hard part.<P>
<A href="list6.htm">Listing 6</a>
shows the function <I>frexp</I> that unpacks the exponent from a finite argument <I>x</I>. Once again, a reasonably simple function is complicated by the presence of the various special codes. And once again, a more flexible low-level function does most of the hard work.<P>
<A href="list7.htm">Listing 7</a>
shows the function <I>ldexp</I>, which faces problems similar to <I>frexp</I>, only in reverse. Once it dispatches any special codes, it still has a nontrivial task to perform. It too calls on a low-level function. Let's look at the two low-level functions.<P>
<A href="list8.htm">Listing 8</a>
shows the function _<I>Dunscale</I>, which combines the actions of _<I>Dtest</I> and <I>frexp</I> in a form that is handier for several other math functions. By calling_<I>Dunscale</I>, the function <I>frexp</I> is left with little to do.<P>
_<I>Dunscale</I> itself has a fairly easy job except when presented with a gradual underflow. In the IEEE 754 representation, a normalized value has a non-zero characteristic and an implicit fraction bit to the left of the most-significant fraction bit that is represented. Gradual underflow is signaled by a zero characteristic and a nonzero fraction with <I>no</I> implicit leading bit. Both these forms must be converted to a normalized fraction in the range [0.5, 1.0), accompanied by the appropriate binary exponent. The function _<I>Dnorm</I>, described later, handles this messy job.<P>
<A href="list9.htm">Listing 9</a>
shows the function _<I>Dscale</I>. It, too, frets about special codes, because of the other ways that it can be called. Adding the <I>short</I> value <I>xexp</I> to the exponent of a finite *<I>px</I> can cause overflow, gradual underflow, or underflow. You even have to worry about integer overflow in forming the new exponent. That's why the function first computes the sum in a <I>long</I>. Most of the complexity of the function _<I>Dscale</I> lies in forming a gradual underflow. The operation is essentially the reverse of _<I>Dnorm</I>.<P>
<A href="list10.htm">Listing 10</a>
shows the function _<I>Dnorm</I>. It normalizes the fraction part of a gradual underflow and adjusts the characteristic accordingly. To improve performance, the function shifts the fraction left 16 bits at a time whenever possible. That's why it must be prepared to shift right as well as left one bit at a time. It may overshoot and be obliged to back up.<P>
<A href="list11.htm">Listing 11</a>
shows the function <I>fmod</I>, which is the last of the semi-numerical functions declared in &lt;<I>math.h</I>&gt;. It is also the most complex. In principle, it subtracts the magnitude of <I>y</I> from the magnitude of <I>x</I> repeatedly until the remainder is smaller than the magnitude of <I>y</I>. In practice, that could take an astronomical amount of time, even if it could be done with any reasonable precision.<P>
What <I>fmod</I> does instead is scale <I>y</I> by the largest possible power of two before each subtraction. That can still require dozens of iterations, but the result is reasonably precise. Note the way <I>fmod</I> uses _<I>Dscale</I> and _<I>Dunscale</I> to manipulate exponents. It uses _<I>Dunscale</I> to extract the exponents of <I>x</I> and <I>y</I> to perform a quick but coarse comparison of their magnitudes. If <I>fmod</I> determines that a subtraction might be possible, it uses _<I>Dscale</I> to scale <I>x</I> to approximately the right size.<P>
<h4><FONT COLOR="#000080"><A name="01E1_00E9">Conclusion<A name="01E1_00E9"></FONT></h4></P>
That's the complete set of low-level primitives you need to isolate machine-dependencies in the math library. They work well for a broad range of floating-point representations. (They need work if a <I>double</I> is not a 64-bit quantity representable as four 16-bit <I>shorts</I>. They fail miserably if the floating-point base is not a power of two.) On some machines, you can replace many of them with assembly-language versions that are much faster. But you don't have to.<P>
The representation still affects the rest of the code in subtle ways. For example, a sixth-order polynomial may be a good approximation for IEEE 754 arithmetic with 53 bits of precision. That would be overkill on a machine that retains only 32 bits of precision. It would fail on a machine that retains much more than 53 bits. You have similar issues in dealing with the range of exponents the machine can represent.<P>
Still, having a narrow interface like this helps tremendously. It gives you a language in which to describe the higher-level math functions. As you will see, that can make higher-level math functions not just more portable, but more readable as well.<P>

<h4><a href="../../../source/1991/aug91/plauger.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
