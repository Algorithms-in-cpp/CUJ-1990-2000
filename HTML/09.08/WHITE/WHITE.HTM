


<HTML>
<HEAD>

<TITLE>August 1991/Copy-On-Write Objects For C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Copy-On-Write Objects For C++<A name="01D5_00E2"><A name="01D5_00E2"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="01D5_0000"><A name="01D5_0000">Ronald G. White</font></h3><hr><blockquote><P>
<P><i><A name="01D5_0000"><A name="01D5_0000">Ronald G. White has an M.S. in computer science and 20 years of programming experience. He is the author of Tempo for Windows and founder of Tesuji Technology, where he does consulting and custom programming. He specializes in scientific, system, and graphical user interface programming. You may reach Ronald at Tesuji Technology, P.O. Box 4305, Boulder, CO 80306, or at 71500,3566 on CompuServe.</i></P><P>
To learn C++, I began working on a large project that I hoped would force me to learn more than I could ever learn just from reading books. During this work, I came up against a problem that seemed ideal for a C++ solution. After several attempts, I came up with what seemed to be a reasonable solution. In this article, I present the problem and my solution. I hope that those of you who are also new to C++ can learn something from it and that those of you who are more sophisticated C++ programmers will take it as a challenge to show me how I could have done it better.<P>
First, the problem: For the project on which I was working, I wanted to maintain multiple generations of many data objects, some of which were quite large. (The project is a program to play the game of Go. Each generation represents a move on the board, and the data objects contain information about the situation on the board. I wanted to maintain multiple generations so the player could undo some number of plays and get back to an earlier situation.) Each generation of objects might differ from the last by changes, additions, and deletions of only a small percentage of the objects. To keep the functions simple, I was copying all of the objects for each new generation. Consequently, there were often multiple copies of the same, unchanged object. As the complexity of this data increased, I realized that I was in danger of running out of memory.<P>
Like many problems in writing software, there is more than one way to solve this problem. Virtual memory is one solution, but I didn't want to deal with the overhead associated with reading from or writing to disk (although I may eventually need to use virtual memory). I could keep track of which object was associated with which generations, but this adds complexity at too high a level in the code. I wanted objects that would only copy themselves when necessary. I think of these as Copy-On-Write, or COW, objects.<P>
This idea comes from a scheme I had read about years ago for keeping multiple generations of data files while using up a minimum amount of disk space. In this scheme, each block in the data file is found via pointers in the header of the data file. A new generation of the file is made by duplicating the header but not the data blocks. Only when the data in a particular block gets changed and must be written back to disk is it necessary to make an actual copy of that data block and modify the header to point to this new block.<P>
Instead of data blocks in a file, I wanted objects in memory that would only get copied when necessary and a solution in which the objects themselves would know when to split into two exact replicas. This proved to be more complicated than I had expected.<P>
Suppose I have three generations of the object <I>A</I>. I haven't made any changes to <I>A</I> since it was originally created in generation one. If I have actually made copies of <I>A</I>, I would have the situation depicted in <A href="diagram1.htm">Diagram 1</a>.
 I have three pointers, <I>pA1</I>, <I>pA2</I>, and <I>pA3</I> pointing to three separate copies of the same object: <I>A1</I>, <I>A2</I>, and <I>A3</I>. On the other hand, if I had not made copies of <I>A</I> for each generation, I might have the situation in <A href="diagram2.htm">Diagram 2</a>.
 The three pointers all point to the same object &#151; the original <I>A1</I>.<P>
Now suppose that in generation three I call a function of <I>A</I> that would change the data in <I>A</I>. For example, <I>pA3</I>-&gt;<I>add(new_data)</I>. In <A href="diagram1.htm">Diagram 1</a>,
 this is no problem. <I>A1</I> and <I>A2</I> will be unaffected. For the situation in <A href="diagram2.htm">Diagram 2</a>,
 however, the object <I>A1</I> would have to duplicate itself, creating a new object, <I>A3</I>, which could then safely be modified without affecting the version pointed at by <I>pA1</I> and <I>pA2</I>. The problem arises because <I>pA3</I> still points to <I>A1</I> and the object <I>A</I> cannot access this pointer or easily change it.<P>
My solution was to add a layer of indirection. As shown in <A href="diagram3.htm">Diagram 3</a>,
 the generation pointers point to virtual objects <I>vA1</I>, <I>vA2</I>, and <I>vA3</I>. This virtual object is small, possibly no more than a pointer, and inexpensively copied. It points to the actual object, <I>A1</I>. All access to the actual object is through the virtual object, and the functions that use the generation pointer (e.g., <I>pA1</I>) need never know that the virtual object is not the actual object.<P>
The virtual object knows which functions cause changes to the real object and has a way of checking if other virtual objects are pointing to the same real object (I use a counter in the real object). If both of these are true, the virtual object can duplicate the real object, change its pointer to point to the new copy (decrement the counter in the old copy), and proceed with the requested change.<P>
<A href="list1.htm">Listing 1</a>,
 <I>cow.h</I>, is the header that defines the two base classes. The first class, <I>Obj_COW</I>, is the base for the actual, or Copy-On-Write, objects. The second, <I>Obj_Virt</I>, serves as a base class for virtual objects.<P>
The only data associated with <I>Obj_COW</I> is <I>count</I>. <I>count</I> keeps track of how many virtual objects are pointing at this real object. <I>Obj_Virt</I> is declared a friend class so it can manipulate the count and any other data stored in the actual object. A pure virtual function, <I>dup</I>, must be defined for each instance class. This function is used by <I>Obj_Virt</I> when an actual copy of the real object must be made.<P>
The <I>Obj_Virt</I> base class is more complicated. The only data it maintains is <I>po</I>, a pointer to the real object, but it defines a number of functions. The void constructor sets <I>po</I> to <I>NULL</I> instead of creating a real object. If this constructor created an <I>Obj_COW</I> object, it would be the wrong type of object for the derived classes. Instead, the derived virtual object must be responsible for creating an instance of the derived real object. A copy constructor and copy operator are provided, but the derived virtual class must redefine these so the parameter type is correct. The default copy constructor and copy operator definitely cannot be used because they would only copy the virtual object, including the pointer, without updating the real object's <I>count</I> field.<P>
The <I>Obj_Virt</I>'s destructor calls the function <I>release</I>, which decrements the real object's <I>count</I> field and deletes the real object if the count is zero. The function <I>set_ptr</I>, which is called by the copy constructor and the copy operator, makes a virtual copy. It calls <I>release</I> in case the virtual object is currently pointing to a real object, sets the pointer to the real object, and increments the <I>count</I> field.<P>
The function <I>print</I> is only provided here for debugging. The functions <I>get_ptr</I> and <I>set_ptr</I> are provided so derived classes do not have to access the pointer directly. The last function, <I>split</I>, is called by functions of the derived virtual class that intend to change the real data. It checks if the real object is being used by multiple virtual objects. If so, it calls the real object's <I>dup</I> function to get a real copy of the object and adjusts the <I>count</I> fields of both the original real object and the new real object.<P>
<A href="list2.htm">Listing 2</a>
gives an example of the use of the COW base classes. <I>Foo_COW</I> is the real class derived from <I>Obj_COW</I>. As data, it contains three integers, <I>a</I>, <I>b</I>, and <I>c</I>. The virtual class, <I>Foo</I>, is declared a friend class so it can access the data here. The <I>Foo_COW</I> constructor takes three integers and initializes the corresponding data fields. The <I>dup</I> function, which is required for any class derived from <I>Obj_COW</I>, creates a new <I>Foo_COW</I> object with the data values from the current object. (Note that <I>dup</I> must cast the pointer value it returns.)<P>
The virtual class <I>Foo</I> is derived from <I>Obj_Virt</I>. Its constructor, which also takes three integers, creates a new <I>Foo_COW</I> object with the three integers and sets the pointer to point to this new <I>Foo_COW</I> object. The copy constructor casts its parameter so the <I>Obj_Virt</I> copy constructor can then be used. The copy operator is necessary, as mentioned, to avoid the default operator. The <I>Foo</I> class defines a private function, <I>actual</I>, to more easily access the real data object, <I>Foo_COW</I>. This is used in the functions <I>get_a</I>, <I>get_b</I>, and <I>get_c</I> to return the current data values. The function <I>print</I> is, as before, only for debugging. Finally, the function <I>reset</I> resets the data values. Because <I>reset</I> will change the real object, it calls the function <I>split</I> before doing so to ensure that it changes only its own copy of the real object.<P>
The <I>main</I> function contains code that creates some <I>Foo</I> objects, manipulates them, and prints out their data. <A href="list3.htm">Listing 3</a>
shows the output of running this test program (built using Turbo C++ and the small memory model). The three virtual objects all have different addresses, but, correctly, the real objects to which they point are sometimes the same. Also note that the use of the copy operator deletes the original real object and the <I>reset</I> function causes a new allocation of a real object that just happens to have the same address as the object deleted.<P>
My solution to the original problem seems to be workable. I don't find it particularly elegant, however. The fact that there are two base classes, requiring two derived classes for every object type, seems overly complicated. It is also unfortunate that the derived classes must redefine many of the base class functions. I don't doubt that there are more sophisticated C++ programmers out there who could do a better job. If you're one of them, let me know how you would do it &#151; I'm still learning.<P>
<h4><FONT COLOR="#000080"><A name="01D5_00E3">Notes<A name="01D5_00E3"></FONT></h4></P>
The syntax <I>if (0 == - -po-&gt;count)</I>, with the constant fIrst, in the function release, may seem odd to experienced C programmers. I write comparisons this way as a result of a suggestion I read in a <I>CUJ</I> article. It allows the compiler to catch the common error of mistakenly using = instead of ==.<P>
In the definition of classes, I have put private data last instead of first. It makes more sense to me that someone looking at a header full of class definitions see the public information first. Often it would be better if they couldn't see the private information at all.<P>
Experienced C++ programmers may wonder why I didn't redefine the -&gt; operator for virtual objects so that it would return the address of the real object to deal with the indirection. I thought about this but could not figure out how to make it work so the real object was duplicated only when necessary. Perhaps one of you can write another article explaining how to make it work.<P>

<h4><a href="../../../source/1991/aug91/white.zip">Get Article Source Code</a></h4>


</BLOCKQUOTE>
</BODY>
</HTML>
