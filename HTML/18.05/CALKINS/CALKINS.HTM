<HTML>   
     <HEAD>
<TITLE>May 2000/Integrating Threads with Template Classes</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Multithreading</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Integrating Threads with Template Classes</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Charles Calkins</FONT></H3>

<BLOCKQUOTE>
<p>It's obviously a good idea to encapsulate a thread as an object. It is less obvious how to get all the interfaces right.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p>Developing software for modern systems can be a complex undertaking. Software systems are large, have many components, and are often multithreaded, especially as multiprocessor systems become more and more common. To help manage this complexity, object-oriented strategies, and object oriented-languages such as C++, have been developed.</p>
<p>C++ has no language constructs for threading, so developers must use system libraries such as pthreads on UNIX-like systems or functions such as <B>CreateThread</B> as part of the Win32 API. These libraries and functions, however, are not class-based but contain C-style mechanisms. In order to more easily apply an object-oriented design methodology, it is desirable to treat threads as objects, so some method of encapsulating thread API functions is needed. Once encapsulated, active objects containing threads can be used much the same way as passive objects.</p>
<p>One such encapsulation is shown in <a href="list1.htm">Listing 1</a>. I omit the code usually needed in a production system, such as thread control or error checking. Including it would only complicate this discussion.</p>
<p>Class <B>Thread</B> contains a public member function <B>Create</B>, a protected member function <B>Run</B>, and a destructor. <B>Create</B> calls the pthread function <B>pthread_create</B> to create a new thread in the joinable state and start it running by invoking the function <B>thread_func</B>. A pointer to the <B>Thread</B> object is the last argument to <B>pthread_create</B>. It is passed as the pointer argument to <B>thread_func</B>. You can later synchronize with a thread in the joinable state by calling <B>pthread_join</B>, as is done here in the destructor. A thread may also be created in the detached state, or later changed to that state, which does not require a join to be performed.</p>
<p>The <B>thread</B> function plays an important role in thread encapsulation. Instead of containing the thread behavior, it makes use of the object pointer to call member function <B>Run</B> in class <B>Thread</B>. This allows the behavior of the thread to be determined by the thread object, not separately. Here, <B>Run</B> is implemented by class <B>Thread</B>, though it could also be made virtual and implemented by subclasses of <B>Thread</B> if only one thread in the object is desired. If the object requires multiple threads, it may be more convenient to directly implement multiple <B>Run</B>-style member functions as needed, rather than use <B>Thread</B> as an abstract base class.</p>
<p>It is important to note that the <B>thread</B> function must be a C-style function, not a member function. Hence the need for the roundabout way of calling <B>Run</B>. To reduce namespace pollution, <B>thread_func</B> could be a static function in class <B>Thread</B>, but the same problem remains. It cannot be an ordinary member function.</p>
<p>This structure is fine for a basic thread class, but suppose the class requires a template parameter. Just such a case occurred when I developed a particular object for a code library for my company. A problem now arises, since the encapsulation above no longer works, as shown in <a href="list2.htm">Listing 2</a>.</p>
<p>In the non-template case, the thread function uses the passed <B>this</B> pointer of the object to call its <B>Run</B> member function. This pointer is received as a <B>void *</B>, which is safely cast to a <B>Thread *</B> to make the call to <B>Run</B>. In the template case, it must be cast to a <B>Thread&lt;T&gt; *</B> and this is where the problem lies. The thread function must now become a template function itself (as it needs a generic type parameter <B>T</B>). But as I pointed out above, the thread function must be a C-style function to be compatible with the thread library.</p>
<p>One way to overcome this problem is to use an intermediate object to wrap the <B>Thread</B> pointer, as shown in <a href="list3.htm">Listing 3</a>. The <B>Thread</B> pointer wrapper is composed of two parts, a base class and a subclass. The base class <B>Wrapper</B> contains a single method <B>Wrap</B> and a virtual destructor. <B>Wrap</B> is pure virtual, which is the basis of the trick.</p>
<p><B>WrapperSub</B> inherits from <B>Wrapper</B>, but unlike its base class, it is a template class with the same template parameters as <B>Thread</B>. The purpose of <B>WrapperSub&lt;T&gt;</B> is twofold. It first stores Thread's <B>this</B> pointer when it is constructed for later use. Since it has the same template parameters, storing a <B>Thread&lt;T&gt; *</B> can be done without difficulty. It also provides a means to call the <B>Run</B> member function in <B>Thread</B>. That is, <B>WrapperSub&lt;T&gt;</B> implements a function <B>Wrap</B> which now has the same code as <B>thread_func</B> had previously. It uses the stored <B>this</B> pointer to call <B>Run</B> in <B>Thread</B>. It is important to recognize that <B>Wrap</B> in class <B>WrapperSub&lt;T&gt;</B>, even though <B>WrapperSub&lt;T&gt;</B> is a template class, still overloads <B>Wrap</B> from its non-template base class <B>Wrapper</B>.</p>
<p>The call to <B>pthread_create</B> is modified to not pass <B>this</B> directly, but instead a dynamic instantiation of <B>WrapperSub&lt;T&gt;</B>. Keep in mind that <B>WrapperSub&lt;T&gt;</B> stores the <B>this</B> pointer of <B>Thread</B>.</p>
<p>The thread function has also changed. The pointer received is to an instance of class <B>WrapperSub&lt;T&gt;</B>, but the pointer is safely cast to one pointing to class <B>Wrapper</B>, syntactically eliminating the template parameter and allowing <B>thread_func</B> to remain a C-style function. The function <B>Wrap</B> is called from that pointer, but as the <B>Wrap</B> function in <B>WrapperSub&lt;T&gt;</B> overrode the <B>Wrap</B> function in <B>Wrapper</B>, it is <B>Wrap()</B> of <B>WrapperSub&lt;T&gt;</B> that is called. This function then uses the stored <B>this</B> pointer and calls <B>Run</B> in <B>Thread&lt;T&gt;</B> as is desired. When <B>Run</B> returns, <B>Wrap</B> returns, and the instance of <B>WrapperSub&lt;T&gt;</B> is freed.</p>
<p>Although slightly cumbersome, this method does solve the template problem and relies on the language features of C++ to do it. This trick is also applicable to other C-based threading libraries. For instance, you can use the same structure to encapsulate Win32 API thread creation by eliminating <B>pthread_join</B>, replacing <B>pthread_create</B> with <B>_beginthread</B>, and changing the return type of <B>thread_func</B> to <B>void</B> instead of <B>void *</B>. I'm certain this isn't the only way to address the problem, and I'd be interested in learning of others.</p>

<p><i><B>Charles Calkins</B> is Vice President of Applied Intelligence, Inc. a St.Louis-based consulting company specializing in software development. In the last few years he has written software for a range of products including 3-D model navigators, a telephony system, and an information kiosk while working in St. Louis. He can be reached at <B>calkinsc@applied-intelligence.com</B> and via his web site at <B>http://www.applied-intelligence.com/~calkinsc</B>.</i></p>

<h4><a href="../../../source/2000/may00/calkins.zip">Get Article Source Code</a></h4>


</blockquote></body></html>
