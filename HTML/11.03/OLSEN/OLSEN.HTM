

<HTML>
<HEAD>

<TITLE>March 1993/Three-Dimensional Modeling Under Windows 3.1</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Three-Dimensional Modeling Under Windows 3.1<A name="00B5_0045"><A name="00B5_0045"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="00B5_0000"><A name="00B5_0000">Thomas W. Olsen</font></h3><hr><blockquote><P>
<P><i><A name="00B5_0000"><A name="00B5_0000">Thomas writes a variety of Windows and DOS software for a major insurance company. He can be reached on the CompuServe Information Service at (76450,1767).</i></P><P>
Nothing communicates an idea better than a picture. It's the defining principle behind the popularity of Microsoft Windows and other graphical environments. Not long ago, though, you might recall serious debate over whether Windows would ever meet the performance demands of a graphical user interface. Much of the trepidation resulted, no doubt, from the tremendous freedom of MS-DOS programs to directly access video hardware. However, faster CPUs, accelerated video adapters, local bus connections, multimedia, and a mature Graphical Display Interface (GDI) have since conspired in favor of Windows.<P>
These changes pose significant opportunities in 3-D modeling software development. Three-dimensional modeling has become increasingly important over time because it mimics elements in the real world. This article focuses on simple strategies for 3-D modeling. The accompanying source code was compiled and linked with the Microsoft C/C++ Optimizing Compiler Version 7.0 and Microsoft Windows 3.1 Software Developer Kit (SDK). Every effort has been made to ensure compatibility with other compilers. Compile instructions are provided in comments at the top of each listing. The bitmaps were created with Microsoft Paintbrush.<P>
This article barely scratches the surface of 3-D graphics. Rendering, shading, ray tracing, and texture mapping get a more thorough treatment from the references in the bibliography. This article will present a building block for such advanced features.<P>
Do not confuse 3-D modeling with Windows metafiles. A metafile is a binary-encoded collection of GDI function calls. You create one by sending the output from various GDI function calls to a special device context. A recorded metafile can be played back by passing its associated resource handle to <I>PlayMetaFile</I>. The resulting picture may look three-dimensional but it's just a two-dimensional facade.<P>
<h4><FONT COLOR="#000080"><A name="00B5_0046">Vector Graphics<A name="00B5_0046"></FONT></h4></P>
Microsoft Windows derives its characteristic look and feel primarily from raster-based or bitmapped graphics technology. Most fonts, controls, and icons are nothing more than bitmaps &#151; two-dimensional blocks of pixels &#151; that appear three-dimensional due to varying color gradients. Bitmaps look great but generally experience some kind of image distortion when rotated, stretched, or scaled onto devices of varying resolutions. To address such deficiencies Microsoft incorporated so-called TrueType font technology into Windows 3.1. TrueType is a form of vector-based graphics, in which images are constructed with individual graphical primitives such as lines, points, rectangles, ellipses, and curves rather than bitmaps. Vector graphics are scalable, require less memory than bitmaps, and enable us to model three-dimensional objects with relative ease.<P>
<h4><FONT COLOR="#000080"><A name="00B5_0047">Coordinate Systems<A name="00B5_0047"></FONT></h4></P>
The Windows GDI does not contain explicit support for 3-D modeling, but it is not difficult to build a suitable framework atop existing primitive functions. Nearly any 3-D object can be drawn with a set of interconnected points or vertices. For example, a simple cube has eight vertices (one for each corner) while the General Dynamics F16 Falcon aircraft in <I>3D.C</I> in <A href="list1.htm">Listing 1</a>
(along with the files in <A href="list2.htm">Listing 2</a>
and <A href="list3.htm">Listing 3</a>)
 contains literally hundreds of vertices. Of course, a collection of points is worthless without some frame of reference, so they are placed in a domain called the World Coordinate System (WCS). You can change the object's orientation in WCS by multiplying each vertex by a series of transformation matrices. There are distinct transformation matrices for rotation, reflection, shearing, scaling, and translation operations, respectively.<P>
Try to imagine yourself floating in space around a motionless object. As you change position, each WCS vertex is transformed with respect to an Eye Coordinate System (ECS) that emanates from your eye and points toward the object (<A href="fig1.htm">Figure 1</a>)
. To complicate matters even more, the resulting ECS vertices must be transformed from three-dimensional to two-dimensional screen coordinates (SCS) before the object can be displayed. Once these screen positions are known, you can connect-the-dots to produce a transparent wireframe model, or use filled polygons for a more realistic solid model (<A href="fig2.htm">Figure 2</a>)
. Three-dimensional objects are drawn one surface at a time, so vertices are generally grouped in that order.<P>
<h4><FONT COLOR="#000080"><A name="00B5_0048">Hidden-Surface Removal<A name="00B5_0048"></FONT></h4></P>
Hidden-surface removal is one of the more complicated and computation-in-tensive facets of 3-D modeling. The most popular method of hidden-surface removal is called backplane elimination. Basically, it involves computing whether a normal (perpendicular) vector emanating from a given surface points away from or toward the viewer's line of sight. Those surfaces facing away from the viewer cannot be seen and, therefore, need not be drawn. It does have its drawbacks, too. Objects with irregular or overlapping surfaces will not be drawn properly. One quick-and-dirty solution is to sort the surfaces in terms of decreasing distance from the viewer (ECS z-coordinate). Surfaces lying farther away from the viewer are drawn first and subsequently masked by closer surfaces. Depth sorting has its flaws but performance-conscious applications usually don't mind.<P>
<h4><FONT COLOR="#000080"><A name="00B5_0049">Constructing Models<A name="00B5_0049"></FONT></h4></P>
<I>3D.C</I> (<A href="list1.htm">Listing 1</a>)
 supports both wireframe and solid models. It first creates a window with horizontal and vertical scroll bars, and uses <I>SetScrollRange</I> to lock the thumb between 0 and 360 degrees. Depressing the scroll bars changes the angular position of the viewer relative to the object. This is especially convenient because the viewer's position is given in spherical coordinates (distance, <I>theta, phi</I>). All measurements are given in device units. The F16 object "database" has been optimized to keep code size to a minimum.<P>
<I>3D.C</I> calls <I>DrawObject</I> whenever the viewer depresses the scroll bars or resizes the window. <I>DrawObject</I> determines the center point of the window and creates a compatible work bitmap. Using an intermediate bitmap prevents the flashing effects that occur while drawing straight to a display context. <I>DrawObject</I> also precalculates sine and cosine values for global variables <I>theta</I> and <I>phi</I>. These values are needed when <I>f16.vertex[].world</I> vertices are transformed to <I>f16.vertex[].eye</I> vertices and, finally, to <I>f16.vertex[].screen</I> coordinates. <I>DrawObject</I> clears the work bitmap and loops through each surface in the <I>f16.info[]</I> array. For solid models, <I>DrawObject</I> performs a depth sort on the <I>f16.vertex[].eye</I> vertices, removes hidden surfaces with backplane elimination, selects a brush color from <I>f16.info[].brushColor</I>, and calls <I>Polygon;</I> otherwise, it calls <I>PolyLine</I> for a wire-frame surface. <I>DrawObject</I> then updates the client area with the completed work bitmap and deletes unused resources.<P>
<h4><FONT COLOR="#000080"><A name="00B5_004A">Computations<A name="00B5_004A"></FONT></h4></P>
Floating-point computations incur a considerable amount of overhead &#151; even with a math coprocessor installed &#151; but you can improve performance significantly by substituting fixed-point integers for floating-point numbers. Fixed-point integers incorporate both the whole and fractional components of floating-point numbers but can be manipulated in single arithmetic operations, such as <I>IMUL</I> and <I>IDIV</I>. For example, it is possible to represent the floating-point number 12.345 with integer 12345 by shifting the decimal place three positions. There are certain problems with this technique, as well. Integers can only represent so many digits before overflowing, so you must strike a balance between the scale and precision of the 3-D model.<P>
NASA's Jet Propulsion Laboratories unveiled a computer-generated film several months ago that depicted the surface topography of some distant planet. JPL had downloaded countless bits of radar imaging data from a distant probe into three Cray super computers and rendered the surreal landscape frame-by-frame over the course of three solid weeks. The resulting bitmaps were finally transferred to videotape and made available for public consumption. There's a lesson hiding behind this madness. Even though real-time 3-D graphics were out of the question, JPL eventually got what it paid for by blending vector and raster technologies.<P>
<h4>References</FONT></h4></P>
Adams, Lee. 1986. <I>High-Performance CAD Graphics in C</I>. Blue Ridge Summit, PA: Windcrest/Tab.<P>
Microsoft Corp. 1991. <I>Microsoft Windows Multimedia Authoring and Tools Guide</I>. Redmond, WA: Microsoft Press.<P>
Microsoft Corp. 1991. <I>Microsoft Windows Multimedia Programmer's Reference</I>. Redmond, WA: Microsoft Press.<P>
Microsoft Corp. 1991. <I>Microsoft Windows Multimedia Programmer's Workbook</I>. Redmond, WA: Microsoft Press.<P>
Park, Chan S. 1985. <I>Interactive Microcomputer Graphics</I>. Reading, MA: Addison-Wesley Publishing Company.<P>
Petzold, Charles. 1990. <I>Programming Windows</I>. Redmond, WA: Microsoft Press.<P>
Wilton, Richard. 1987. <I>Programmer's Guide to PC &amp; PS/2 Video Systems</I>. Redmond, WA: Microsoft Press.<P>

<h4><a href="../../../source/1993/mar93/olsen.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
