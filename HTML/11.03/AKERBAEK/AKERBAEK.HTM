

<HTML>
<HEAD>

<TITLE>March 1993/C++, Coroutines, and Simulation</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">C++, Coroutines, and Simulation<A name="00C2_0049"><A name="00C2_0049"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="00C2_0000"><A name="00C2_0000">Trond Akerbaek</font></h3><hr><blockquote><P>
<P><i><A name="00C2_0000"><A name="00C2_0000">Trond Akerbaek is teaching at a college in Halden, Norway. Current interests include computer communications, neural networks, and fuzzy systems. He can be contacted at Ostfold DH; N-1757 Halden; Norway; <I>e-mail:tronda@dhhalden.no.</I></i></P><P>
<h4><FONT COLOR="#000080"><A name="00C2_004A">Introduction<A name="00C2_004A"></FONT></h4></P>
Object-oriented programming is not a new concept. The Simula67 Language, developed in the late sixties, contains all the basic concepts found in modern object-oriented languages such as C++. An important part of Simula not found in C++ is the support for quasi-parallel processes and simulation. Very few programmers ever use  parallel functions or coroutines in their programs, even if it will lead to more elegant designs. There are several reasons: few languages have ample support, coroutines may otherwise be cumbersome to implement, and it is possible to solve most problems without.<P>
C programmers may use <I>setjmp</I> and <I>longjmp</I> and functions based on these to implement quasi-parallell routines. With C++ and some assembly instructions it is possible to create a set of functions which makes coroutines easier to comprehend and use. Using coroutines, implementing simple tools for simulation modelled after the Simula67 tools, is a fairly easy matter.<P>
In this article I will give a brief introduction to coroutines and describe an implementation in Borland C++ 2.0, with a single assembly function in Turbo Assembler. Based on the coroutine concept, the article will discuss simulation and how to implement it in C++.<P>
<h4><FONT COLOR="#000080"><A name="00C2_004B">Quasi-Parallel Functions and Coroutines<A name="00C2_004B"></FONT></h4></P>
Due to the single-processor constraint, computer programming has traditionally been sequentially-oriented with a single thread of operations. Multitasking operating systems give us the opportunity to create programs consisting of several sequential processes operating in parallel on a timesharing basis. The operating system controls the task switching, with little or no influence from the programmer. <P>
The object-oriented approach is still basically sequential, even if it makes it easier to describe real processes which are interacting and operating in parallel. Parallel processes cannot directly be modelled in a sequential language. The process descriptions are running on a single processor, and must switch back and forth, imitating real parallel behavior, hence the expression quasi-parallel.<P>
It would be another situation if the model were running on a multiprocessor machine, with one processor for each process. In that case the model would be described in a language designed for such environments.<P>
<h4><FONT COLOR="#000080"><A name="00C2_004C">The Coroutine Extensions<A name="00C2_004C"></FONT></h4></P>
In order to support the coroutine concept I have created a few extensions to C++:<P>
<UL><li>A base-class coroutine for all classes describing coroutines.</li>
<li>A virtual function <I>main</I> in coroutine subclasses containing the actions of the coroutine.</li>
<li>The primitive <I>resume(coroutine*)</I> which freezes the current coroutines actions, and transfers control to the indicated coroutine, resuming its actions at the freesing point.</li>
<li>A new coroutine instance is initially frozen at the start of its <I>main</I> function.</li>
<li>A primitive <I>detach</I> is available, which freezes the current coroutine actions and transfers control to the main program.</li>
<li>A coroutine is terminated when its <I>main</I> function is terminated normally (not frozen by <I>resume</I> or <I>detach</I>). Resuming a terminated object leads to a runtime error.</li></UL>
Automatic variables declared in a class method and alllocated on the stack are not availablee outside the couroutine instance. A variable declared in the <I>main</I> function of the program, is not available within the other coroutines. The main program is in fact a coroutine with the <I>main</I> function defining its actions.<P>
There must be no register variables, because registers will not be preserved changing coroutines. <P>
<h4><FONT COLOR="#000080"><A name="00C2_004D">Implementation<A name="00C2_004D"></FONT></h4></P>
The implementation consists of the coroutine class, the two primitives <I>resume</I> and <I>detach</I>, and a few functions for internal use. Each coroutine, as the main program, has its own stack. Switching between coroutines is done by switching stacks. Whenever a coroutine is activated, the activating coroutine's stack is saved in memory, and the activated coroutine's previously stored stack is copied to the stack segment.<P>
<A href="list1.htm">Listing 1</a>
contains the definitions. The variables of the coroutine class are used for keeping track of the passive stack. <I>stkSegment</I> and <I>stkOffset</I> are the segment and offset address of the area where the stack is stored, while <I>stkSize</I> holds the size of the used part of the stack. <P>
<A href="list2.htm">Listing 2</a>
shows the implementation. There are three internal pointers in the implementation file: <I>PREVIOUS</I> referencing the coroutine to switch from, <I>CURRENT</I> referencing the new and active coroutine, and <I>MAINC</I> referencing the main program. <P>
When a new process is created as a coroutine subclass instance, the stack of the new process is initialized by <I>coroutine::coroutine()</I>. Space for the initial stack is allocated on the heap, and the addresses and the size are stored in the base class variables. This stack is initialized, so that on activation, the stack is copied from the heap, and control is passed to the <I>superMain</I> function.<P>
The trick is to store the address of the starting function (<I>startProcess</I>) on the stack as a return address. When the stack-switching function terminates, control returns to this address as if it was calling the function. This function in turn starts the <I>superMain</I> function, which calls the <I>main</I> function of the subclass. The <I>superMain</I> function also takes care of necessary terminating actions. A coroutine may be deleted. In that case the <I>coroutine::~coroutine()</I> method releases the stack area.<P>
The <I>resume</I> primitive switches control from the active coroutine to the new <I>current</I> specified as parameter to the primitve. At first, the size of the current stack is computed, and space for storage is allocated on the heap. The <I>PREVIOUS</I> and <I>CURRENT</I> variables are set, pointing to the two coroutines involved. The assembler function <I>ctxtswc</I> is callled to do the actual stack chnge. On return, the new coroutine is <I>CURRENT</I> and active, and the area for stack storoage is released. The <I>detach</I> primitive resumes <I>MAINC</I>, the main program.<P>
You find <I>ctxtswc</I> in <A href="list3.htm">Listing 3</a>.
 The global variables <I>CURRENT</I> and <I>PREVIOUS</I> are imported by <I>ctxtswc</I>. Through these pointers, the stack storage area of the two coroutines involved, are accessible.<P>
<I>ctxtswc</I> works by copying the current system stack to the area referenced in the <I>PREVIOUS</I> coroutine instance. This copy of the stack now contains the return address from the <I>ctxtswc</I> call. Then the stack of the new <I>CURRENT</I> coroutine is copied from the storage area to the system stack area, and the <I>SP</I> register is reset. This stack now contains the return address from the <I>ctxtswc</I> call, last time it was called by the coroutine. Therefore, when <I>ctxtswc</I> returns, program execution continues where the resumed coroutine was stopped.<P>
This version is written for the compact memory model. Minor changes in <I>ctxtswc</I> and some of the C++ functions are necessary for other memory models.<P>
<h4><FONT COLOR="#000080"><A name="00C2_004E">Simulation<A name="00C2_004E"></FONT></h4></P>
With the tools described in the previous sections it is possible to model interacting real-world processes in a quasi-parallel program. In such a model you can experiment. By changing the number of processes, the behavior of each, and the input data you can test the model to gain insight into how the real system would perform under different circumstances.<P>
Simulating real processes in a computer model is often cheaper than doing real life experiments. In some cases it is not even possible to experiment with the real system. Consider the case of a nuclear reactor. In order to study the behavior of the reactor operators in stress situations, e.g. when serious problems occur, it would be necessary to induce problems in the reactor. We cannot do that, for obvious reasons. Instead a control room connected to a computer model, simulating the reactor, is used in experiments and training.<P>
Real systems are often very complex. When creating a model, it is necessary to include those features that are crucial to the model's operation, and avoid insignificant details. Otherwise the simulation results may be of no value.<P>
The time aspect of simulation, which is very important in most real systems, is not handled within the coroutine concept. In the next sections, I will introduce a set of tools for modelling processes in simulated time with C++.<P>
<h4><FONT COLOR="#000080"><A name="00C2_004F">An Example<A name="00C2_004F"></FONT></h4></P>
This is a hypothetical system consisting of a number of physicians working together in a clinic receiving patients. The system is simplified in order to keep the example reasonably small in size. <P>
The physicians receive patients from 8 A.M. until 4 P.M. Then the physicians work until no more patients are waiting. The patients arrive one at a time. On arrival the patient goes to the waiting room. If there is a physician in the lunchroom, he is summoned at once. Otherwise the patient waits for his turn. When a patient leaves the clinic, the physician will see the next patient. If nobody is waiting, he will go to the lunchroom for a coffee break.<P>
The physicians, observing that most of the day the waiting room is full, want to know if another physician should be invited to join the group. They are losing business because the patients must wait too long, but they are not sure if this might lead to an increasing number of coffee breaks.<P>
The model of this system consists of a clinic object, a number of physician objects, and the patients. For each of these objects, there is a set of actions controlling the objects and their interactions. As the objects operate in simulated time, their classes are derived from the <I>class</I> process, a subclass of the <I>class</I> coroutine, which contains the information necessary to support the time concept. Instead of the <I>resume</I> and <I>detach</I> primitives, a small set of more advanced primitives will be used. These are based on <I>resume</I> and <I>detach</I>, but are more suitable for simulations in time.<P>
Most simulation models depend on some kind of input data that specifies when the significant events occur. In this case, the important events are the arrivals of patients, and the duration of a consultation. It is possible to collect real data and use the information directly as input to the simulation model. Another solution is to analyze the input data and find the events' probability distributions. Input data may then be generated using random generators. The physicians have observed the arrival pattern of patients and found that patients arrive according to a Poisson distribution, and they have found the expected number of patients each minute. They have also found that the duration of each consultation is uniformly distributed over an interval.<P>
A simulation model should always be validated by comparing the results of a simulation with real input data to real system results. If there are discrepancies, the model must be modified.<P>
The implementation of the clinic system is found in <A href="list4.htm">Listing 4</a>.
 The implementation consist of three kinds of processes, defined by the classes <I>clinic, physician</I>, and <I>patient</I> derived from the process base class. Each class has a constructor, and a <I>main</I> function describing the process actions. There is a main program which creates the process instances, starts the simulation and presents the results. This example just finds the average waiting time of the patients. Two functions are used to generate input to the model. The <I>treatmentPeriod</I> function returns a randomly-chosen value indicating the duration of a consultation, while <I>periodBeforeNextArrival</I> returns the randomly-chosen period between two arrivals.<P>
The <I>clinic</I> class references two FIFO queues, chain <I>lunchRoom</I> and <I>waitingRoom</I>, where the physicians and patients are kept while waiting. In addition, there are variables used for collecting statistical data. The physician and patient classes have a pointer to the clinic, and variables for statistical data.<P>
The physician and patient constructors set the clinic pointer. The clinic constructor creates the physician processes and schedules them to run at once. The constructors also initialize statistical variables.<P>
The clinic <I>main</I> function describes the clinic actions. The main task is generating new patients. Its main loop will run until simulated time (<I>currentTime</I>) reaches the clinic's closing time. In the loop a new patient is created, sent to the waiting room, and activated. If there is a physician in the <I>lunchRoom</I> she is summoned and activated. Then the clinic process reschedules itself and waits until the next patient arrives, with the <I>hold</I> primitive.<P>
The <I>physician</I> process is an eternal loop. Each time the <I>physician</I> process checks if the <I>waitingRoom</I> is empty. If so, she goes to the <I>lunchRoom</I> and has a break by calling the <I>passivate</I> primitive. This primitive will suspend the process until some other process activates it. If there are patients in the <I>waitingRoom</I>, the physician gets the next patient, activates him and suspends herself with the <I>hold</I> primitive while helping the patient. When the consultation ends, she will see the patient out, activating him, and repeat the loop. <P>
The <I>patient</I> process is simple. It is activated three times, first by the <I>clinic</I> process when the patient is sent to the <I>waitingRoom</I>, then by the physician on leaving the <I>waitingRoom</I>, and last by the physician when the consultation is over. Each time, the patient process records the time of the event for statistical purposes before passivating itself. (When the patient <I>main</I> function terminates, there is an implicit passivate call.) <P>
The main program of the system first initializes the random generator functions and the process library by calling <I>initProcesses</I>. Then it suspends itself until opening hours when a <I>clinic</I> process is created and activated. The main program again suspends itself for a long period, until the clinic is closed and all patients have left. At last statistical data are processed and displayed.<P>
In this model, each process acts on its own, performing actions. Between events, the processes are suspended waiting to be restarted, either automatically as with the <I>hold</I> primitive, or by another process with the activate primitive. It is much easier to understand the sequence of events for each process and to describe each process separately as in this example, than to describe the whole system in one piece. Besides, you can modify the model to include other objects such as secretaries, surgeons, several patient types, and other action sequences.<P>
After validating the model, you can simulate and investigate different scenarios by changing the number of physicians, the arrival pattern of patients, consultation time etc. It is easy to include statements to collect other types of statistical data, such as the number of minutes spent in the lunchroom, and the distribution of patient waiting times.<P>
<h4><FONT COLOR="#000080"><A name="00C2_0050">The Process Extensions<A name="00C2_0050"></FONT></h4></P>
I created the following extensions supporting processes:<P>
<UL><li>Each process is defined as a subclass of the process base class.</li>
<li>A function <I>initProcesses</I> initializes the process library.</li>
<li>A virtual function <I>main</I> in descendants of the process class contains the actions of the process.</li>
<li><I>activate(process*,float)</I> schedules the indicated process to run at the specified point of time. If it is already scheduled to run, it is rescheduled. If the current process is activated, it is suspended and rescheduled.</li>
<li><I>hold(float)</I> suspends and reschedules the current process to run after the indicated period of time.</li>
<li><I>passivate</I> suspends the current process without rescheduling.</li>
<li><I>currentTime</I> returns current simulated time.</li></UL>
Whenever the current process is suspended, simulated time is increased to the time of the next scheduled process, and this process is restarted. If no process is scheduled to run, a runtime error occurs. In this way simulated time grows from 0 in varying steps as controls are switched from process to process.<P>
In addition, a few primitives not used in this example, are available<P>
<UL><li><I>cancel(process *)</I> deschedules the process indicated. Cancelling the current process is the same as <I>passivate</I>.</li>
<li><I>currentProcess</I> returns a pointer to the current process object. </li>
<li><I>mainProcess</I> returns a pointer to the main program process object. The main program in itself is a process, and can be treated as such. </li>
<li><I>resume(coroutine*)</I> and <I>detach</I> may be used with processes as the <I>process</I> class is derived from the coroutine class. Avoid this, it might lead to unexpected activation sequences.</li></UL>
<h4><FONT COLOR="#000080"><A name="00C2_0051">Implementation<A name="00C2_0051"></FONT></h4></P>
In <A href="list5.htm">Listing 5</a>
you find the <I>process</I> class definition. The <I>process</I> class is a coroutine subclass with a single time variable which contains scheduled time to run. It is initially set by the process constructor. <P>
<A href="list6.htm">Listing 6</a>
contains the implementation of the process library. The data structure of the process module is a priority queue SOS (The Sequence Set) where the scheduled processes are kept sorted in ascending order on the time variable. The current executing process is always the first object in the SOS. There is a <I>process* MAINP</I> which is used for referencing the main program as a process. <I>CURRENT</I> and <I>MAINC</I> are imported from the coroutine module. The <I>initProcesses</I> function initializes the data structure. A process object referencing the main program is created and inserted at the head of the SQS. <I>MAINC</I> and <I>CURRENT</I> used for referencing the main program and the current coroutine, are set to reference this main program process. <P>
The four scheduling primitives <I>activate, hold, passivate</I>, and <I>cancel</I> are implemented as functions manipulating the SQS. <I>activate</I> inserts a process in the priority queue, <I>hold</I> removes and reinserts the current process, <I>cancel</I> removes any process, and <I>passivate</I> removes the current process. Whenever the current process is suspended, control is transferred to the next. <P>
The three information primitives <I>mainProcess, currentProcess</I>, and <I>currentTime</I> just return state information: which is the main program process, which is currently executing, and what is the current simulated time. <P>
The internal <I>superMain</I> function is called from <I>startProcess</I> to manage the user-defined <I>main</I> function. On termination, the process is removed from the SQS and cannot be activated again. <P>
<h4><FONT COLOR="#000080"><A name="00C2_0052">Some Comments on the Code listings<A name="00C2_0052"></FONT></h4></P>
As shown, the implementations of the process primitives are very simple, once the coroutine primitives are in place. If the need arise, you can create other scheduling primitives of your own design. <P>
The code shown in the listings has been compiled and tested using Borland's Turbo C++ 2.0 and Turbo Assembler 2.5, compact memory model. It is easy to modify the system for other memory models. I have removed some <I>include</I> statements referring to system functions and the description of the priority type class <I>chain</I>. You may implement this yourself, otherwise a complete system is available from the author on request. <P>
<h4>References</FONT></h4></P>
Birtwistle, Dahl, Myhrhaug, Nygaard: "SIMULA BEGIN," Auerbach, Phil., 1973. (contains an introduction to the SIMULA programming language)<P>

<h4><a href="../../../source/1993/mar93/akerbaek.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
