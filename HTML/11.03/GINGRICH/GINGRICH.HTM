

<HTML>
<HEAD>

<TITLE>March 1993/The Art of Programming Embedded Systems</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Book Reviews</FONT></H2>

<hr><h2 align="center"><font color="#800000">The Art of Programming Embedded Systems<A name="00D5_0055"><A name="00D5_0055"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="00D5_0000"><A name="00D5_0000">Reviewed by Mark Gingrich</font></h3><hr><blockquote><P>
<P><i><A name="00D5_0000"><A name="00D5_0000">Mark Gingrich has been employed in the medical device industry for the past nine years. Presently he serves as a software engineer for Baxter Healthcare Corporation's Novacor division. He can be reached at 355 Estabrook St., Apt. 403, San Leandro, CA 94577.</i></P><P>
The series of books by Donald Knuth called <I>The Art of Computer Programming</I> may be the archetype of its genre. So I approach recent epics leading with "The Art of" title with elevated expectation. <I>The Art of Programming Embedded Systems</I> is among the latest (though unrelated to Knuth's trilogy). Its author, Jack Ganssle, checks in with good credentials: a contributing editor for <I>Embedded Systems Programming</I> magazine, a designer and purveyor of in-circuit emulators, and a veteran practitioner of said "art."<P>
But why a book on coding embedded systems? Perhaps because the topic is so woefully treated in the engineering/computer science curricula. More often it's a trade learned on the job &#151; the hard way &#151; at no small expense to our employers. And many of us drift into this sea having cast off on the purely hardware or purely software oceans. The luckiest benefit from a mentor helping to steer around obstacles: how to coerce the compiler to accept writeable variables distinct from RAM; how to debug optimized code sans print statements; how to configure the emulator to trap bugs which occur only during neap tides on Groundhog Day; how to do this; how <I>not</I> to do that. Don't have a mentor as such? Well, then, this book may be a reasonable alternative.<P>
Only don't expect a tutorial from square zero. Gannsle's approach is more casual &#151; rather like talking shop with colleagues. He assumes that you've already served your software apprenticeship; now your goal is to fill those gaps of wisdom which have postponed your transition to true embedded systems programming enlightenment. The parallel path to this state of being entails time-consuming and costly mistakes (the euphemism is called "experience").<P>
And experience is seldom acquired in each and every aspect of embedded design. For example, chief among my own gaps of wisdom is one in memory management techniques, having never employed bank switching on a project. Ganssle comes through in chapter six with a clear depiction of the camouflaged snake pits lurking in this area. Reading this chapter made it plainly apparent that I would have pathetically underestimated the time required to implement a bank-switching scheme.<P>
Likewise, a good introduction to real-time operating systems is found in chapter nine. Although not the be-all, end-all word on the subject, it's an appropriate diving-in point for the novice before swimming through the voluminous sales literature and spec sheets from the umpteen RTOS-to-go vendors. Of particular value is the small &#151; but functional &#151; real-time executive supplied in source listing form.<P>
Ever need a lone transcendental function in your system? Instead of calling the compiler's bloated, glacier-speed floating-point math library routine (which returns a result with three digits of precision more than you require), why not roll your own? Ganssle shows how &#151; illustrated with C &#151; in chapter seven.<P>
In addition, there are chapters on interrupt management; on signal smoothing and curve fitting (especially intriguing is the Savitsky and Golay technique); on software design which allows for civilized debugging; on designing to permit simplified production test &#151; always guaranteed to endear you with the harried, under-appreciated manufacturing folk.<P>
And interspersed with the lucid, here's-the-way-it-is writing style are snippets of reality &#151; flashbacks from Ganssle's eventful past:<P>
"It always seems that just before a demo everything falls apart. After a late night of removing the final bugs from microcontroller-based design, I unplugged the emulator and installed the computer chip. On power up the unit did nothing &#151; it was completely dead. Fortunately the code had a simple test routine that blinked an LED before any other initialization took place. Since the LED didn't blink, I knew immediately that the code was not starting and indeed found that a floating DMA request line was keeping the processor idle. The emulator's slightly different DC characteristics masked the problem during weeks of code development."<P>
Such anecdotal digressions in the prose are welcome. They add realism. And they underscore that the proffered advice is not rarefied academic theory; these are eyewitness war stories from the front.<P>
Occasionally, too, Ganssle opines on the softer issues of software development: programming style and professional improvement. And he confronts business issues so often avoided like the plague by the technical staff. This holistic approach is commendable. The still-too-pervasive image of "proglodytes" (wearing pocket protectors, of course) hacking away in the back room, oblivious to the rest of the world, has been a hindrance to our collective professional advancement. There is a bottom line, and Ganssle steps back to point out our role and responsibilities within the big picture.<P>
Reading widely is among our responsibilities, we're admonished. So Gannsle supplies an eclectic bibliography: from techy Intel application notes to Alvin Toffler's <I>Powershift</I>. (Though I would have preferred a more exhaustive reference section &#151; pointers to the richest embedded systems lore. Indigenous software types, for instance, may need to "speak" electronic more proficiently; another "art of" book, <I>The Art of Electronics</I>, by Horowitz and Hill, is an appropriate text. Those of the hardware stripe would benefit from, say, Kernighan and Plauger's <I>The Elements of Programming Style</I>.) An appendix with recommended periodicals for the cognizant embedded programmer is also offered. (<I>The C Users Journal</I> makes the list; but somehow <I>Dr. Dobb's Journal</I> is omitted, a conspicuous oversight considering it is cited elsewhere in the book.)<P>
Be advised, however, that the "art" presented is not the state of the art. Embedded systems are described as they've existed over the past few years, with 4-, 8-, and 16-bit processors. There are no visits from the ghost of Embedded-Programming-Yet-To-Be. One must look elsewhere for coverage of fuzzy logic, neural nets, and DSP chips as embedded controllers.<P>
Mind you, I heartily recommend this book, but there are a few too many warts, most of which should have been removed with scrupulous copy editing. On page 152 the definitions of accuracy and precision are confused, as is the described behavior of the sine function, and the constant pi/2 is termed a "round" number. (Ironically, these blunders occur on a page with the subhead "Errors.") Elsewhere, the repeated misspelling of "kernel," the missing arrowhead in the state diagram in Figure 3.2, and the interchanged <I>x-y</I> coordinates in Figure 7.4 are annoying flaws. The state diagram in Figure 9.1 is simple, but it could have been drawn without the confusion-adding crossed lines.<P>
Then there are the source listings. Yes, there's enough source in this book (but, alas, no companion disk) to satisfy your minimum daily requirement of real code: much of it in C, a few in sundry assembly languages, and one listing in Basic. But the art of software book publishing demands faithful reproduction of listings. Just a cursory scan caught a missing right parenthesis in the <I>for</I> loop on page 31; the <I>phex</I> routine on page 95 lost a curly bracket somewhere; page 96 contains a commented-out source line, which is somewhat disconcerting. These typos along with the schizophrenic indentation style hint of manually-typeset code listings &#151; a dangerous practice. My overall impression: Academic Press skimped on (or rushed) the proofreading and the illustrations.<P>
These are nitpicking complaints. I'm being a bit harsh because such a valuable work deserves better handling. And pricey books with lofty titles justifiably receive more intense scrutiny. But I'll apply a more pragmatic rule of thumb: If a book's cost and the invested reading time is more than compensated by the added quality and productivity of my work, or to the improved quality of my company's product, it's an unequivocable bargain. Without question, <I>The Art of Programming Embedded Systems</I> hits this critical breakpoint.<P>
<B>Title:</B> <I>The Art of Programming Embedded Systems</I><br>
<B>Author:</B> Jack G. Ganssle<br>
<B>Publisher:</B> Academic Press<br>
<B>Price:</B> $49.00<br>
<B>ISBN:</B> 0-12-274880-8<P>
</BLOCKQUOTE>
</BODY>
</HTML>
