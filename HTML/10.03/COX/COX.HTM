


<HTML>
<HEAD>

<TITLE>March 1992/Building An Embedded System</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Real-Time/Embedded Systems</FONT></H2>

<hr><h2 align="center"><font color="#800000">Building An Embedded System<A name="008E_0033"><A name="008E_0033"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="008E_0000"><A name="008E_0000">Keith W. Cox</font></h3><hr><blockquote><P>
<P><i><A name="008E_0000"><A name="008E_0000">Keith Cox is currently employed at NH Research<I></I> <I></I>Inc. of Irvine, CA, where he is the software lead for the<I></I> <I></I>S6000 project. He has over six years experience with<I></I> <I></I>ATE-oriented embedded systems based on Motorola<I></I> <I></I>8-and 16-bit microprocessors. Keith was a member of<I></I> <I></I>Who's Who in the Computer Industry in 1989-90 and<I></I> <I></I>is the president of Perfect Circle Computing, a private<I></I> <I></I>San Diego consulting firm.</i></P><P>
For the conventional C programmer, creating an<B> </B>application consists of sitting at a keyboard, editing<B> </B>some code, compiling to an executable, typing the<B> </B>filename, and pressing <I>ENTER</I>. The operating<B> </B>system takes control, loads the program into memory<B> </B>where it belongs, and executes. The program relies<B> </B>heavily on library functions written by someone else<B> </B>to perform such tasks as interfacing with the<B> </B>hardware and communicating with the user. It is<B> </B>completely normal for the programmer to have little<B> </B>or no knowledge of how these tasks are actually<B> </B>accomplished. If there is a problem, the underlying<B> </B>support platform in most cases will announce it by<B> </B>sending a descriptive error message to the monitor.<B> </B>The bug can be edited out, the code recompiled,<B> </B>and program promptly executed again, in search of<B> </B>the next run time error.<P>
If this describes your current software<B> </B>development method, creating an application to run on an<B> </B>embedded system may pose a particular challenge.<B> </B>If you now face the prospect of working in this<B> </B>environment, gone are the days when the flip of a<B> </B>switch and a few seconds of power on testing would<B> </B>allow you to begin computing to your heart's<B> </B>content. In an embedded system, turning on the switch<B> </B>will do little for you. The best you can hope for is<B> </B>that the microprocessor and its peripheral chips will<B> </B>receive a reset pulse of the proper duration. After<B> </B>that, you become the proud operator of a collection<B> </B>of warming silicon devices, many of them in an<B> </B>unknown state. If there is a display, it will taunt you<B> </B>with gibberish. You can press the keys on the<B> </B>keyboard (again, if there even is one), and nothing will<B> </B>change. Where do you go from here?<P>
Embedded systems programming is a unique niche in the<B> </B>software development field. Most of today's embedded<B> </B>applications are sophisticated enough that a well meaning but<B> </B>improperly trained hardware engineer is not up to the task of<B> </B>implementing the system's intricate control schemes. On the<B> </B>other hand, a programmer familiar only with data structures<B> </B>and control statements, oblivious to the world of digital<B> </B>electronics, who knows little about the inner workings of a<B> </B>microprocessor and cares less, will find himself scratching his<B> </B>head in bewilderment when the time comes to make the<B> </B>hardware do something. The embedded systems programmer<B> </B>must have his feet firmly planted in both the hardware and<B> </B>software worlds to be successful.<P>
I have suffered through many a long night laboring over<B> </B>unforgiving components and their unintelligible<B> </B>documentation, trying to conjure up the exact micro-incantation that<B> </B>would bring the inanimate chips to life. From my mistakes I<B> </B>have learned a few secrets I wish I had known when I started.<B> </B>My purpose here is to present some some basic techniques of<B> </B>embedded systems programming by way of describing the<B> </B>implementation of a recently completed project, so that you who<B> </B>must now make the transition to this hybrid world might have<B> </B>at least some idea of where to start.<P>
<h4><FONT COLOR="#000080"><A name="008E_0034">The S6000 Power Subsystem<A name="008E_0034"></FONT></h4></P>
The instrument I will use to illustrate the process of<B> </B>programming an embedded system is the S6000 Power<B> </B>Subsystem recently released by NH Research Inc. of Irvine, Ca. The<B> </B>S6000 provides modular AC and DC power and DC loads at<B> </B>precisely programmable levels and states for Automated Test<B> </B>Systems. Included in each production system is at least one<B> </B>and up to six chassis that communicate with the modules and<B> </B>each other via an RS422 serial protocol. Each of these chassis<B> </B>may contain up to six separate power devices.<P>
There is one CPU board per system, which contains the<B> </B>main control firmware. The board is populated by a Motorola<B> </B>68000 family microprocessor, RAM, EPROM, EEPROM,<B> </B>serial and GPIB interface chips, and timers. Interface is<B> </B>provided for an optional front panel keyboard and 40<B> </B>character by eight line LCD display.<P>
<h4><FONT COLOR="#000080"><A name="008E_0035">Defining The Project<A name="008E_0035"></FONT></h4></P>
In any software development project one must first<B> </B>determine exactly what is expected of the envisioned executable.<B> </B>From consulting the engineers responsible for the hardware<B> </B>design, I learned that the CPU firmware was required to<P>
1. Provide the system with an orderly power on sequence.<P>
2. Perform a power on self test and report the results via<B> </B>front panel indicator lights.<P>
3. Determine the installed system configuration, compare it<B> </B>with the configuration stored in EEPROM, and report<B> </B>discrepancies via the IEEE 488 (GPIB) bus.<P>
4. Command all installed modules to initialize and perform<B> </B>self test.<P>
5. Enter a continuous loop whose purposes would be<B> </B>primarily to maintain system status information and<B> </B>supervisory control and secondarily to relay command data from the<B> </B>outside world to the modules and status information from the<B> </B>modules to the outside world.<P>
<h4><FONT COLOR="#000080"><A name="008E_0036">The Development Environment<A name="008E_0036"></FONT></h4></P>
At the beginning of a project the programmer is faced with a number of fundamental design questions, some of which are faced by all software designers, and some which are unique to embedded systems. In the former category, a programming environment and its related tools must be selected, and in the latter it must be determined whether to use a real time kernel.<P>
While embedded systems as recently<B> </B>as four or five years ago were written<B> </B>almost exclusively in assembly language<B> </B>for the host microprocessor, C has in<B> </B>recent years gained a great deal in<B> </B>popularity among embedded firmware<B> </B>designers. There is good reason for this<B> </B>increased acceptance. C can be easily<B> </B>adapted to embedded systems. It is<B> </B>versatile enough to make possible the<B> </B>development of low-level hardware<B> </B>drivers in assembly language where<B> </B>necessary, while executing the bulk of<B> </B>the code in a high-level language. This<B> </B>makes development and debugging of<B> </B>firmware faster and easier than was possible when writing<B> </B>exclusively in assembly language, while providing the speed and<B> </B>control available only with assembler.<P>
Today there are many excellent C programming tools<B> </B>available from a variety of vendors for embedded programming. A<B> </B>rule of thumb to follow when investigating the choices is to<B> </B>select an environment that is either intended for or makes<B> </B>specific provision for firmware development. The environment<B> </B>chosen for the S6000 project was the Microtec ANSI C<B> </B>compiler for the Motorola 680X0 family microprocessors, but<B> </B>there are many others available for not only the Motorola<B> </B>microprocessors but those of other manufacturers as well. The<B> </B>firmware designer will find that for his purposes using one of<B> </B>these will be much less baffling than using a C environment<B> </B>created for a specific platform. In addition, such compilers<B> </B>generally come with Documentation<B> </B>directed specifically to problems<B> </B>encountered in implementing embedded<B> </B>firmware.<P>
One question a firmware designer is<B> </B>bound to encounter is whether to use a<B> </B>real-time kernel. A real-time kernel is<B> </B>software developed by a third party that<B> </B>provides some of the basic features of<B> </B>an operating system such as task<B> </B>prioritization and management,<B> </B>interrupt handling, and basic I/O. There are<B> </B>several of these available for use on a<B> </B>variety of host microprocessors. The<B> </B>decision to use one must be weighed<B> </B>between their high cost (both in initial<B> </B>expense and in licensing fees) and the<B> </B>complexity of the firmware system to be<B> </B>implemented. In a relatively simple<B> </B>system such as the S6000, which must<B> </B>switch between only two or three tasks,<B> </B>the expense of the real time kernel is<B> </B>unjustified. On the other hand, in a<B> </B>system where tens or maybe hundreds of<B> </B>events must be managed, the cost of<B> </B>implementing algorithms to handle them<B> </B>might easily exceed the cost of a<B> </B>packaged real-time operating system. My<B> </B>own experience with these systems is<B> </B>that they are expensive in terms of<B> </B>RAM, ROM, and dollars, are<B> </B>impossible to troubleshoot, and that their<B> </B>vendors provide less than adequate<B> </B>technical support. In my opinion, for small to<B> </B>medium applications such as the S6000<B> </B>they are not worth the trouble and<B> </B>expense. With that in mind, no kernel was<B> </B>included in the S6000 design.<P>
<h4><FONT COLOR="#000080"><A name="008E_0037">The C/Assembly Language Interface<A name="008E_0037"></FONT></h4></P>
It is rare for a completed embedded system to be programmed entirely in C. Usually, assembly language is used at least to enter the vectors, and often to perform the system startup and device initialization routines. Why use assembly language instead of C? In many cases the code directly interfacing with the hardware is required to be compact and fast. Depending on the tools used and the expertise of the programmer, it may be possible to accomplish this in C, but in reality the compiler is rarely able to provide assembly language output as tight as the code you can produce yourself. Additionally, with assembly language you have full control over the hardware and the data presented to it, something you may not have, or that you must be very careful to achieve, using C.<P>
When implementing a mixed language system, the assembly-language code is entered in separate files from the C code. Since compilation is generally a two-step process (from C to assembler, then from assembler to object code), the assembler simply skips the first part of the process when producing the object code. Your <I>makefile</I> should be set up to instruct the development tools how to process the assembly code. The linker will act on the object output of the assembler in exactly the same way as the output from the C compiler, because they are in exactly the same format.<P>
Something to keep in mind when calling functions written in assembly from the C code is that the compiler will often add an underscore (or in some cases a dot) to the names of functions located in and called from a C program. For example, a call to the function <I>write_char()</I>, located in an assembly language file, will cause the instruction<P>
<pre>jsr _write_char</pre>
to be contained in the C module's assembly-language output. If your routine in the assembly-language file is named <I>write_char</I> instead of <I>_write_char</I>, the linker will not know where to find it, and will generate an error. To overcome this difficulty, equate the name of the assembly-language routine with the name the compiler will generate to call it. For example, the line<P>
<pre>_write_char equ write_char</pre>
at the end of the <I>write_char</I> routine would enable the linker to find the correct address. An even simpler method is to merely add the underscore to the routine's declaration in the assembly-language file.<P>
There may be some instances when you would rather write some of the low-level access in C, and in this case it will be necessary to know how to perform direct memory reads and writes. The code fragment below illustrates the task of writing a character to a hardware address.<P>
<pre>void func(char c)
{
char *ch;
ch = (char *) 0xFFFF0400;
*ch = c;
}</pre>
Here, a pointer variable named <I>ch</I> has been declared. This variable could have been a pointer of any type, depending on the width of the hardware port being written (for example, <I>short  </I>* for a 16 bit port, or <I>long  </I>* for one that is 32 bits wide). The first code line causes the variable <I>ch</I> to point to address <I>0xFFFF0400</I>, an arbitrary address that could be any address in your memory map. The second code line causes the value of <I>c</I> to be written to the selected address.<P>
Reading a memory address is performed following a similar process, as shown below.<P>
<pre>char func()
{
char *ch;
ch = (char *) 0xFFFF0400;
return(*ch};
}</pre>
In this case the variable <I>ch</I> is declared and assigned as in the write operation. The last code line returns the 8-bit value located at address <I>0xFFFF0400</I> to the calling function.<P>
<h4><FONT COLOR="#000080"><A name="008E_0038">The Memory Map<A name="008E_0038"></FONT></h4></P>
To aid in understanding the topics that follow it may be instructive to consider the memory map of the S6000 CPU board, which is representative of many 680X0 implementations. <A href="fig1.htm">Figure 1</a>
shows that the memory map can be divided into three sections: EPROM, RAM, and Hardware Ports. The EPROM, beginning at the lowest physical address, contains the initial vector table and all of the program code. The RAM, using all of the populated address space between the EPROM and the I/O ports, contains the final vector table, all of the static data, the <I>ZEROVARS</I> RAM section (which is used by the C runtime libraries), the heap, and the stack.<P>
For those who may be unfamiliar with the operation of the heap and stack, the stack provides temporary storage during runtime (such as for local variables), and grows from the highest address in RAM down toward the end of the static data. The heap consists of all unused RAM space and grows up from the end of the static data area toward the stack. The heap is the dynamic memory area managed by such functions as <I>malloc()</I> and <I>free()</I>. Improper management of this area may result in the infamous and unrecoverable <I>Heap/Stack Collision</I> error, for obvious reasons.<P>
<h4><FONT COLOR="#000080"><A name="008E_0039">The Vector Table<A name="008E_0039"></FONT></h4></P>
When programming an embedded system the first code to be written is normally the vector table. This table is a series of pointers in a specific location in the microprocessor's address space. The vector table defines the system's fundamental behavior. The beginning of the 680X0's vector table is always located at physical address <I>0x00000000</I>. Microprocessors are designed in such a way that when certain events occur control is passed to code pointed to by one of the vectors. For example, after the power-on reset pulse is applied to the 68000 microprocessor's reset pin, the Program Counter (PC) will automatically be filled with the contents of address <I>0x00000004</I> (the second vector, since each vector is four bytes wide), and program execution will begin at that address. The microprocessor will know where the initial stack is located, and where to find code to execute in case of such events as bus error, address error, illegal instruction, and divide by zero, by values located at predetermined addresses in the vector-table. A description of the vector table contents can be found in the documentation provided with the microprocessor.<P>
Although the vector table is located at address <I>0x00000000</I> in the physical address space and must initially be located in EPROM, many hardware designers redirect the vectors (other than the first two) to addresses in RAM. This allows the firmware designer to change the contents of the vector table on the fly, a feature which can be useful in a variety of cases, one of which is described later in this article.<P>
How do you actually write the vector table? The easiest way is to write it in assembly language as shown in <A href="list1.htm">Listing 1</a>.
 At the top of the assembly language file, statements instruct the assembler that certain names (of functions and interrupt service routines) are to be found elsewhere. With most 680X0 assemblers, this is done using the <I>xref</I> directive. Thus the assembler makes space for the vector table without actually knowing the actual data that will ultimately reside there. The linker will fill in the details at link time.<P>
After listing all external references, the <I>ORG</I> statement is used to tell the assembler where to put the code it is about to encounter (0x00000000). Following the <I>ORG</I> statement, all the vectors are defined using the <I>define long</I> <I>constant</I> directive or its equivalent for the assembler in question. At compile time, this module is assembled to a <I>.obj</I> or equivalent file which the linker can include in the final executable.<P>
<h4><FONT COLOR="#000080"><A name="008E_003A">The Application Startup Code<A name="008E_003A"></FONT></h4></P>
The startup code begins at the address pointed to in the <I>Initial PC</I> vector. The purpose of this code will vary between applications. In the S6000, the startup process performs various self tests and initializes the hardware ports and devices.<P>
Because the hardware is in an unknown state at power on, it is wise before performing any other task to mask out external interrupts while initializing the system. This is accomplished by the first instruction in the startup code. The contents of the vector table are then copied to the first 400 (hex) addresses in RAM so that they can be changed as needed. Once this has been accomplished, a check is made to see how much RAM is installed in the system.<P>
The CPU board is designed in such a way that the amount of RAM it can hold varies between 16K bytes and 256K bytes in 16K byte blocks. It is important to know the actual amount installed so that the address of the top of the stack can be registered in the microprocessor. Determining the amount of RAM present is accomplished by writing a value to the first address of each 16KB boundary. If RAM is present, the address counter is incremented by 16KB and the operation repeated until the maximum address is reached. If there is no RAM present at any address being written to, a bus error occurs, and code at the address entered in the <I>Bus Error</I> vector is executed. In the S6000 this interrupt service routine assigns the stack pointer in the SP (A7) register to the value found by this process and changes the bus error vector (now located in RAM) to the value of the real <I>Bus Error</I> interrupt service routine.<P>
The startup code then performs a check of RAM and EEPROM memory, reporting any errors, and each of the initialization routines for the specific hardware devices are called. These routines might be provided by the hardware vendor or a third party, but most likely the system designer will have to create them. For the S6000, initialization and I/O routines were designed and implemented in assembly language for GPIB I/O, serial I/O, timer interrupt management, keyboard input, and display output.<P>
Finally, the external interrupts are unmasked, and control is passed to routines that will initialize the C runtime environment.<P>
<h4><FONT COLOR="#000080"><A name="008E_003B">The C Runtime Environment<A name="008E_003B"></FONT></h4></P>
When programming for a platform such as a PC, which conforms to a hardware standard and for which the operating system is known to be present, a C compiler will add code at compile time that defines an environment for the C program to work in. This code performs initialization of the heap and makes assumptions about where data is likely to come from (the keyboard) and go to (the screen). Using these suppositions the compiler provides elementary code fragments to handle memory allocation, keyboard input, and screen output (the devices <I>stdin</I> for standard input, <I>stdout</I> for standard output, and <I>stderr</I> for standard error). In an embedded system, these presumptions cannot be made, since there may not be a keyboard, screen, or heap. Therefore, in order to be able to use standard library functions such as <I>malloc</I> and <I>printf</I> the programmer is obliged either to provide these routines or modify those provided with the environment.<P>
To take full advantage of the C run-time library it will be necessary to accomplish the following steps:<P>
1. The heap pointer must be assigned to tell the compiler where the heap is located.<P>
2. The <I>ZEROVARS</I> section must be cleared.<P>
3. The standard input, output, and error devices must be initialized. Additionally, if file I/O is to be accomplished, the file structures must be assigned and initialized.<P>
4. Code must be provided to access the devices which input and output characters, and the library routines must know where to find it.<P>
To locate the initial heap pointer in the S6000 a four-byte variable is declared in a section called <I>HEAP</I>. Using almost any linker the order of the code and data sections can be specified. In the case of the Microtec tools this is done using a linker command file. In this file, the <I>HEAP</I> section is declared to be last, after the <I>ZEROVARS</I> section, since the highest addresses the linker will be concerned with are located in RAM. This will cause the address of the variable declared in this section to be located at the end of the static variables used by the program. Thus, the address of this variable is in reality the first address of the unassigned memory between the static data area and the stack, or the heap. This address is assigned to a constant variable (called <I>????HEAP</I> in the Microtec environment) that tells the compiler where the dynamic memory area begins.<P>
Static variables that need to be cleared at the beginning of the program are located in the <I>ZEROVARS</I> section. Among them are various heap-management pointers. In the Microtec environment, if the application intends to use dynamic memory allocation it is important that this area be filled with zeros, otherwise memory allocation will not work properly, probably with disastrous results. The <I>ZEROVARS</I> section is cleared as a matter of course in systems where the program startup code is provided by the compiler. Although the code to do this is usually available to the embedded system programmer, it is not automatically included in the program or invoked. It is up to the programmer to locate the code and incorporate it in the program. If the development environment selected is meant for embedded systems programming, the compiler's documentation should tell how to do this. If not, the code to do this will be among the startup code fragments provided with the compiler, and the system developer will need to peruse these files to find it and include it in the final executable. In the Microtec environment, this code is located in a file called <I>ENTRY.S</I>.<P>
In the Microtec compiler for the 68000 family there is a file called <I>CSYS68K.C</I> which contains the code for performing the rest of the startup sequence. The <I>_START</I> routine in this file initializes the heap pointers for <I>malloc()</I> and opens the <I>stdin</I>, <I>stdout</I>, and <I>stderr</I> devices. If different compiler tools are being used, there should be a file or files that will perform these same functions, again, hopefully described in the documentation.<P>
Additional skeleton functions must be provided for handling character input and output. The tasks consist of extracting characters from the proper hardware address and returning them to the calling function, or receiving characters for output from the library routines and actually writing their value to the proper address in memory. These routines are used by such library functions as <I>printf</I> and <I>getch</I>. Without them the library functions cannot work properly. It is possible to bypass the library functions, however this generally will make the programmer's job more difficult instead of less, because he will have to provide routines that perform tasks that have already been implemented.<P>
<h4><FONT COLOR="#000080"><A name="008E_003C">The Main Program<A name="008E_003C"></FONT></h4></P>
At the end of the startup activities, control is finally passed to the program's <I>main()</I> function. The programmer may assume that if the above steps have all been done correctly and the code can be traced to the address of <I>main()</I>, writing the rest of the program will be very much the same as writing any other C program. Nevertheless, certain precautions should be adhered to which the programmer may not (but probably should) observe in other programming environments.<P>
Make sure that no variable is used that has not been explicitly initialized. The startup code cannot be relied on to zero all of the data space unless the programmer specifically directs it. Also, initialize variables in the body of the code rather than in the declaration. Some complex variables that are initialized in the declaration may be considered to be constants and placed in ROM, an unhappy situation that can be difficult to troubleshoot.<P>
A last word of advice to the would-be embedded systems programmer is to become familiar with the hardware involved. The idea of learning digital hardware is often distasteful to software engineers but the knowledge can be indispensable when debugging embedded code. All hardware devices are documented, some better than others, and most programmable chips contain sections aimed specifically at firmware developers. Because hardware designers are often unfamiliar with the devices themselves, and because errors frequently occur in preparing prototypes, becoming familiar with the hardware in question can save the embedded systems programmer countless hours of debugging a problem which may in the end be caused by improper hardware implementation.<P>
Embedded systems programming, while perhaps not as glamorous as other aspects of software development, can be an interesting and rewarding experience. With the knowledge gained from this endeavor the software designer will become more articulate with the actual inner workings of computers, which will make even unrelated programming tasks easier to understand and implement.<P>

<h4><a href="../../../source/1992/mar92/cox.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
