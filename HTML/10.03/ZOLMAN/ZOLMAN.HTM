


<HTML>
<HEAD>

<TITLE>March 1992/Illustrated C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Illustrated C<A name="00A0_0043"><A name="00A0_0043"></font></h2><P>
<h3 align="center"><A name="00A0_0000"><A name="00A0_0000">A Portable Menu Compiler, Part 2: The cmenu Translator</h3><P>
<h3 align="center"><font color="#800000">Leor Zolman</font></h3><hr><blockquote><P>
<P><i><A name="00A0_0000"><A name="00A0_0000">Leor Zolman has been involved with microcomputer programming for 15 years. He is the author of BDS C, the first C compiler targeted exclusively for personal computers. Leor's first book, Illustrated C, is now available from R&amp;D Publications, Inc. Leor and his family live in Lawrence, KS.</i></P><P>
This is the second installment in a series of columns describing the CMENU menu compiler system. Last time I introduced the CMENU specification language's syntax, and described the data structures used by the <I>cmenu</I> translator (pre-compiler). This month I'll present the entire procedural section of the <I>cmenu</I> program.<P>
<h4><FONT COLOR="#000080"><A name="00A0_0044">Doing Files<A name="00A0_0044"></FONT></h4></P>
<I>cmenu</I>'s main function passes the name of each file to be processed, in sequence, to the <I>dofile ( )</I> function.<P>
<I>dofile( ) </I>(beginning at line 40 of <A href="list1.htm">Listing 1</a>)
 processes a <I>cmenu</I> specification file from start to finish. The first few lines chop off the <I>.mnu </I>extension in case the user included it in the filename. Two copies are then made of the base filename. One (<I>src_name</I>) gets the source file extension appended onto it, and the other (<I>obj_name</I>) gets the object file extension.<P>
If opening the source file succeeds, lines 62-65 initialize some global modes and counters. The file is entirely processed within the token loop described earlier.<P>
After an <I>EOF</I> is encountered and the main loop terminates, the file is closed and several checks for possible error conditions are performed. In line 85 we make sure that at least one menu was defined, or there wouldn't be much point in writing an output file.<P>
Lines 88-93 check if the last menu terminated correctly. If the value of global <I>in_menu</I> is <I>TRUE</I>, then there was an <I>endmenu</I> keyword missing. At this point, we also call the <I>itemcheck( )</I> function to see if the last item in the last menu was similarly incomplete. (An item isn't complete until both text and action clauses for that item have been processed.)<P>
The last piece of error checking is performed in lines 95-101, a test for unresolved forward menu references. The <I>MInfo</I> array is scanned for entries having a <I>Processed</I> flag still set to <I>FALSE</I>. Menu entries are created as soon as they are first referenced (unlike item entries, for the reasons given above). It is, therefore, possible that a menu entry referenced in an <I>lmenu</I> statement was never defined or the identifier was misspelled somewhere. Either way we get an unresolved menu reference.<P>
Finally, if there weren't any fatal errors encountered, the object file for the current menu is written to disk and <I>dofile( )</I> returns.<P>
<h4><FONT COLOR="#000080"><A name="00A0_0045">Utilities, Utilities<A name="00A0_0045"></FONT></h4></P>
The remaining functions in <I>cmenu1.c</I> provide support for creating entries in the menu and item info tables, searching for those entries by label name, checking for item completeness, writing the output file, string matching, and reporting errors and warnings.<P>
Menu info table management is performed by <I>create_menu( )</I> and <I>find_menu( )</I>. Because <I>MENU</I> structures are stored directly, there is no need to worry about memory allocation when creating a new <I>MINFO</I> entry. <I>create_menu( )</I> defines a local <I>MINFO</I> structure, initializes it appropriately, and returns it by value to the calling routine. To find a given <I>MINFO</I> entry, <I>find_menu ()</I> iterates through the <I>MInfo</I> array, comparing the name of each registered entry with the name string supplied. When a match occurs, a pointer to the structure having the matching name is returned.<P>
The item info table is managed by <I>create_item( )</I> and <I>find_item( )</I>. <I>find_item( )</I> works like <I>find_menu( )</I>. Because <I>IINFO</I> structures are stored by reference (to reduce memory requirements), <I>create_item( )</I> must allocate a memory block for the new <I>IINFO</I> structure and return a pointer to that block. Provided there wasn't any problem with obtaining the memory, both the <I>IINFO</I> structure and its member <I>INFO</I> structure get initialized with all the default values appropriate to an unprocessed item entry.<P>
The <I>itemcheck( )</I> function is called from a few places in <I>cmenu</I> to make sure both required portions of an item definition, the text and an action clause, have been specified.<P>
When a menu specification file has been completely processed and no fatal errors occurred, the <I>write_file( )</I> function is called to create the output file on disk. After creating the output filename and opening the file for writing (in binary mode), the first thing <I>write_file( )</I> actually writes is the value of the global menu count, <I>n_menus</I>. Each menu is then written to the file in a format consisting of the <I>MENU</I> structure first, then each associated <I>ITEM</I> structure. There is no need to write an explicit item count for each menu because that information is already part of the <I>MENU</I> structure, and <I>rmenu</I> can obtain that value dynamically when the <I>.mnc</I> file is loading for execution. To insure portability across machines with different storage requirements for various variable types, all reads and writes involving the <I>.mnc</I> file are performed using the <I>sizeof</I> operator to determine how many bytes to transfer. Even writing a simple integer value, such as the menu count (line 273), should employ <I>sizeof</I> rather than a constant byte count value such as 2 or 4.<P>
After each item is written to disk, its memory block is freed (line 299). If there are many menu definitions in a single menu specification file, then many blocks of item memory will end up having been allocated and freed repetitively. Since, however, <I>cmenu</I> is only run occasionally, the extra overhead this repetition entails isn't enough to have a noticeable effect on performance.<P>
In <I>rmenu</I>, realtime efficiency is far more critical because many processes may be active simultaneously. (I often see between ten and fifteen <I>rmenu</I> processes running concurrently at the office.) Later we'll see how <I>rmenu</I> employs a slightly more complex allocation strategy to avoid the memory thrashing problem.<P>
<h4><FONT COLOR="#000080"><A name="00A0_0046">Error Reporting<A name="00A0_0046"></FONT></h4></P>
The next set of functions in <I>cmenu1.c</I> are <I>warning( )</I>, <I>error( )</I>, and <I>fatalerr( )</I> (lines 307-394). These represent variations on a single theme: display a diagnostic message on the standard error device (usually the user's terminal). All three functions take a variable number of arguments, allowing format conversions like <I>printf( )</I> to be supported. Since pre-ANSI and post-ANSI C differ in their provisions for functions that accept a variable number of arguments, I found it necessary to include two different versions of the starting sequence in each of the three error reporting functions.<P>
ANSI C function headers allow the specification of ellipses (...) to indicate a variable number of arguments in a function header or prototype. The macros <I>va_list</I> and <I>va_start</I>, used in the processing of the variable length argument list, are taken from the <I>&lt;stdarg.h&gt;</I> standard header file (see line 16).<P>
Pre-ANSI C, on the other hand, cannot handle ellipses in function definitions. Before the existence of ellipses and <I>&lt;stdarg.h&gt;</I>, functions taking a variable number of arguments were processed with the macros defined in <I>&lt;stdarg.h&gt;</I>'s predecessor, <I>&lt;varargs.h&gt;</I>. <I>&lt;varargs.h&gt;</I> contains alternate versions of the macros <I>va_list</I> and <I>va_start</I>, plus an additional macro named <I>va_alist</I> that is used in function headers as the placeholder for optional arguments.<P>
The usages of <I>&lt;varargs.h&gt;</I> and <I>&lt;stdarg.h&gt;</I> differ only up to (and including) the appearance of the <I>va_start</I> macro. After that, the methods are equivalent, so the conditional portions of the three error reporting functions end at that point.<P>
Each diagnostic function calls <I>fprintf( )</I> to send the name and current line number of the source file involved to the standard error stream. Then they call <I>vfprintf( )</I> to send the specific error information suppled in the call to the standard error stream. The only difference between the three functions is in the way they affect the global error flags. <I>warning( )</I> sets no flags. <I>error( )</I> sets only <I>err_flag. fatalerr( )</I> sets both <I>err_flag</I> and <I>fatal</I>. Setting the <I>fatal</I> flag causes processing of the current source file to be terminated immediately upon return to the main processing loop, while <I>err_flag</I> is sampled only after the current source file has been completely processed (without fatal errors) to determine if an object file should be written.<P>
<h4><FONT COLOR="#000080"><A name="00A0_0047">String Matching<A name="00A0_0047"></FONT></h4></P>
The <I>matchkey( )</I> function searches the keyword table to see if a keyword exists matching the given string, and returns the token value for that keyword if a match is found.<P>
The <I>strstr( )</I> function tests if one given string is a subset of a second given string. <I>strstr( )</I> is supplied in case your library does not already include it. Compilation of <I>strstr( )</I> is conditionally controlled by the <I>NEEDSTR</I> symbolic constant defined in the makefile.<P>
<h4><FONT COLOR="#000080"><A name="00A0_0048">Parsing The Input Stream<A name="00A0_0048"></FONT></h4></P>
The two major components of <I>cmenu</I> remain to be discussed: token parsing, and token processing. Because tokens must be recognized before they can be processed, I'll begin with a description of the token parsing process. I'll then tackle token processing to tie everything else together.<P>
Tokens are the basic syntactic objects manipulated by <I>cmenu</I>. Each token is represented by an integer value, sometimes in conjunction with the value of an auxiliary variable. If the token represents a keyword or special condition, then the integer value alone is sufficient to qualify it. If the token represents a string or a numeric value, then the token value <I>T_STRING</I> or <I>T_VALUE</I> in conjunction with the text in global array <I>tparam</I> (for strings), or the integer value of the global <I>vparam</I> (for values) is needed to fully qualify the token. You'll find definitions for <I>tparam</I> and <I>vparam</I> in <I>ccmenu.h</I> (see <I>CUJ</I>, January, 1992). The token values are defined in lines 41-99.<P>
The token parsing code resides in <I>cmenu3.c</I> (<A href="list3.htm">Listing 3</a>)
. There are three functions in this source file, two of which are called from other parts of the program: <I>gettok( )</I> to get the next token, and <I>ungettok( )</I> to "unget" a token. The last function, <I>getword( )</I>, is called only by <I>gettok( )</I>.<P>
<h4><FONT COLOR="#000080"><A name="00A0_0049"><I>getword( )</I><B>, The Workhorse<A name="00A0_0049"></B></FONT></h4></P>
<I>getword( )</I> does all the grunt work in the token parsing process. It recognizes and skips over comments and whitespace, keeps track of the current line number, recognizes both quoted and unquoted text strings, and maps unquoted text strings into lowercase. <I>getword( )</I> returns a pointer to a statically allocated text string containing the text of the next token from the input file without making any attempt to distinguish a keyword string from straight text. (That job is handled by <I>gettok( )</I>.) Starting in line 126 (of <A href="list3.htm">Listing 3</a>)
, <I>getword( )</I> checks for all the special cases just mentioned. Newlines cause the <I>lineno</I> global to be incremented, while other whitespace is ignored (including commas and semicolons). The only non-alphabetic keyword, the colon, requires a special case. This simplifies the code to recognize other tokens (lines 146-147).<P>
Comments are handled by <I>getword( )</I> in lines 149-162: all characters after the leading # are ignored until a newline is encountered (or <I>EOF</I>, should the trailing newline be missing). The line count is then incremented.<P>
Lines 164-200 process quoted strings. First, the <I>quoted_text</I> flag is set to <I>TRUE </I>so<I> gettok( )</I> will know a string has been found. Then the string is collected into the <I>tok</I> array, with appropriate action being taken when certain special characters are encountered. Because multiline strings are not supported, a newline in a string is treated as an error, as is an <I>EOF</I> condition. If a double quote is encountered, the string is terminated with a zero byte and a pointer to the string is returned to <I>gettok( )</I>.<P>
Finally, an unquoted string (probably a keyword or an identifier, but possibly a short action string or a pathname) is processed in lines 202-211. Any of the usual separators or a colon terminate such a string. While it is being collected up into the <I>tok</I> array, the string is converted to lowercase. As soon as an illegal character is found, it is "ungotten" and a pointer to <I>tok</I> is returned.<P>
<h4><FONT COLOR="#000080"><A name="00A0_004A">Back To <B><I>gettok( )</I></B> <B></B>And <B><I>ungettok( )</I><A name="00A0_004A"></B></FONT></h4></P>
At the top of <I>cmenu3.c</I> (lines 14-91), several items of static data are defined to support the unget feature for tokens.This is a necessary feature for a simple language processor like <I>cmenu</I>, because in some cases the code must scan past the end of a clause to determine that the clause has come to an end. The unget feature allows any token processing function to give back the extra token. Then, next time the <I>gettok( )</I> function is called to get a token from the input stream, the ungotten token will be returned again. Only a single level of ungetting is needed to process the CMENU syntax.<P>
When <I>gettok( )</I> is called it first checks for an active ungotten token. If found, all the saved static token detail variables are copied into th eir global counterparts and <I>gettok( )</I> returns the saved token value.<P>
If there wasn't an active ungotten token, it is time to get a new one. The global detail variables <I>tparam</I> and <I>vparam</I> are cleared, and <I>getword( )</I> is called to fetch the next syntactic object from the input stream. Lines 85-98 handle the easy kinds of tokens: <I>EOF</I>, quoted string, colon, or simple reserved word. (In the case of quoted text, the text needs to be copied into <I>tparam</I>.) Lines 100-104 process integer values by setting <I>vparam</I> if a leading digit is detected and returning <I>T_VALUE</I>. If we reach line 105, the token is treated as an unquoted string: the text is copied into <I>tparam</I>, and <I>T_STRING</I> is returned.<P>
The <I>ungettok( )</I> function (lines 29-49) first checks to make sure there isn't already a token pushed back. (There shouldn't ever be if the program is working correctly; this test was put here only to catch possible development bugs.) Then all the token detail values are saved in the static variables.<P>
<h4><FONT COLOR="#000080"><A name="00A0_004B">Token Processing<A name="00A0_004B"></FONT></h4></P>
The <I>cmenu</I> code discussed up to this point all plays a supporting role to the actual token processing functions in <I>cmenu2.c</I>. The call to each token processing function is placed indirectly through the function pointers stored in the <I>keywords</I> table. The dispatching takes place in the main processing loop in <I>cmenu1.c</I>.<P>
As each token processing function receives control, it can count on the availability of certain information through global variables. We've already seen how most of these global variables are managed. There's one more, named <I>token</I>, that contains the most recently scanned token value (responsible for arrival at a particular function in <I>cmenu2</I>). This variable is assigned in the main processing loop, immediately before the dispatch is performed. We need to know this value, because some token processing functions can handle more than one token, and they examine the value of <I>token</I> to determine which token they have been called to process.<P>
<h4><FONT COLOR="#000080"><A name="00A0_004C">The Menu Clause<A name="00A0_004C"></FONT></h4></P>
To start at the beginning, the <I>do_menu( )</I> function (<A href="list2.htm">Listing 2</a>,
 line 20) handles the start of a menu definition. The first thing that happens is a check to see if the previous menu in the program was properly terminated with <I>endmenu</I>. If it wasn't, then <I>do_endmenu ( )</I> is called and a warning is issued. If it was just a missing <I>endmenu</I> statement, the compilation will still (begrudgingly) succeed.<P>
<I>do_menu ( )</I> then checks for the existence of a menu label by calling <I>gettok( )</I> and seeing which token turns up next. If it is not a string, then no label was given. This is only tolerated at the start of the file, because the omission of a label in subsequent menus would prevent that menu from ever being accessible (via the <I>lmenu</I> action). If the first menu is missing a label, a dummy label is stuffed into <I>tparam</I>.<P>
If the label is too long it is truncated (lines 38-43), and then a check is made to see if the name appeared previously. If not, then we have the simple case of a new definition, and lines 47-49 create an entry for it in the <I>MInfo</I> array.<P>
If the name has been used before (i.e., there's already an entry in <I>MInfo</I> for it), then there are two possible explanations. Either it was used in a forward <I>lmenu</I> reference, which is legitimate, or the label has already been used in the definition of a previous menu, constituting an error (line 55). We can tell which case it is by examining the <I>Processed</I> flag associated with that <I>MInfo</I> entry.<P>
When we get to line 57, <I>MIp</I> points to the <I>MInfo</I> entry for the new menu. We now need to modify a group of elements of the <I>Menu</I> structure that is itself an element of the <I>MInfo</I> entry. So, we assign the address of the <I>Menu</I> structure to the pointer <I>Mp</I>, and then initialize everything in the <I>Menu</I> structure through that pointer. <I>Mp</I> remains a valid pointer to that <I>Menu</I> structure after return from <I>do_menu ( )</I>; several other functions will take advantage of it.<P>
After all the attendant mode and structure initialization, we check for a trailing colon in lines 68-69 and, if found, ignore it.<P>
<h4><FONT COLOR="#000080"><A name="00A0_004D">Menu Options<A name="00A0_004D"></FONT></h4></P>
The next six functions (lines 75-257) deal with all the possible menu option statements that, if present, must appear before the initial item clause.<P>
<I>do_title( )</I> and <I>do_path( )</I> are very similar, each verifying the existence of its required text string parameter, making sure the option hasn't appeared before, and stuffing the string into the appropriate element of the current <I>Menu</I> structure. (<I>Mp</I> comes in handy here.)<P>
<I>do_path( )</I> performs all the steps above, plus one more: it deletes any trailing path delimiter character (slash or backslash) found at the end of the path text. This prevents two consecutive path delimiter characters from appearing in a path string when incremental paths are glued together.<P>
The <I>do_align( )</I> function was originally intended to support alternative ways of aligning the item text on the screen. I later changed my mind about the usefulness that option and never taught <I>rmenu</I> how to recognize it. The <I>cmenu</I> code for processing the option remains, if someone thinks of a reason for <I>rmenu</I> to use it.<P>
<I>do_spacing( )</I> and <I>do_columns( )</I> are similar to <I>do_title( )</I> and <I>do_path( )</I>, but they take an integer instead of a text string for their parameter. I don't think they require any further annotation.<P>
The <I>do_escape( )</I> function handles both the <I>escape</I> and <I>noescape</I> options, checking for the usual error conditions and then setting the <I>escape</I> flag in the <I>Menu</I> structure to either <I>YES</I> or <I>NO</I>. If this option does not appear, the default value for the escape flag ends up being <I>DEFAULT</I>, which has a very different meaning from both <I>YES</I> and <I>NO</I>.<P>
The <I>do_endmenu( )</I> function pulls clean-up duty after a menu definition. If no items were found, that merits an error message. The forward reference table is then checked to make sure all references have been resolved. If an unresolved reference is found, then a little shuffle-play is performed involving the global line number variable, <I>lineno</I>. This forces the error message function to report the line number where the unresolved reference was made, instead of the current line number.<P>
Finally, global modes are reset in lines 284-287 with values indicating a "not in menu" status. The <I>Processed</I> flag is set to show that the menu has now been defined, and the number of items found is stashed away in the <I>Menu</I> structure (squeezing some final mileage out of old venerable <I>Mp</I>).<P>
<h4><FONT COLOR="#000080"><A name="00A0_004E">The Item Clause<A name="00A0_004E"></FONT></h4></P>
There is a lot of parallelism between the set of functions that process item related statements and the set we just saw for handling menu related ones. I suppose one could even describe the relationship between menus and items as fractal, because the structure somewhat repeats itself. There is an item clause with an optional identifier, followed by a set of item options, some of which are required and some are optional. In the case of item definitions, however, there is no requirement that the optional clauses precede the required ones (the way menu options must precede all menu items).<P>
There is no explicit keyword to mark the end of an item definition. The first thing, therefore, the <I>do_item( )</I> function (lines 291-357) must do is check that the last item, if any, defined in the current menu included its required clauses. The call to <I>itemcheck( )</I> in line 303 does this.<P>
Next, we test if a label is attached to the item definition. If not, a dummy name is constructed; if so, the identifier name used is checked for legality in lines 311-326.<P>
Lines 328-329 make sure that the label name has not been used before in the current menu. Even if a forward reference has been made to this label, it will not show up in a call to <I>find_item( )</I> because the forward reference information has all been segregated into the <I>fwd_refs</I> table (to be examined shortly).<P>
Now we can create an entry for the new item, and place a pointer to it in the <I>Items</I> array. The <I>create_item( )</I> function (<A href="list1.htm">Listing 1</a>,
 lines 160-192) allocates memory for the new item info  structure, initializes its members, and returns a pointer to the structure. If there is a problem creating the array, <I>create_item( )</I> returns <I>NULL</I> and the process is aborted.<P>
Having survived to line 335, the global mode <I>in_item</I> is set and a handy <I>ITEM</I> pointer, <I>Ip</I>, is set to point to the <I>ITEM</I> structure element of the <I>IINFO</I> structure just created. <I>Ip</I> may then be used throughout the remainder of this item's processing.<P>
Lines 338-340 resolve any possible forward references to the new item. The <I>fwd_refs</I> table is scanned for an entry whose name matches the new item's. If one is found, the <I>lmenunum</I> element of the item where the reference was made is set (indirectly, through the <I>refp</I> pointer) to reflect the new item's index value. This overwrites the previous item's <I>lmenunum</I> value of <I>UNDEF_FWD</I>, thereby resolving the forward reference.<P>
The last part of the <I>do_item()</I> function checks to see if the item text is present as part of the item clause. To prevent ambiguity, I've required a colon to precede any item text included directly in an item clause. Without this restriction, the parser couldn't know if text found after the <I>item</I> keyword was meant to be a label or an item text string. At this point in <I>do_item()</I> (line 344), anything other than a colon terminates the item clause processing.<P>
Even if a colon is spotted, there may not be any item text given. Lines 350-351 check for the item text and register it via <I>do_text2( )</I> if present.<P>
<h4><FONT COLOR="#000080"><A name="00A0_004F">Item Options<A name="00A0_004F"></FONT></h4></P>
The next six functions handle the various item options and the required action clause. By now the pattern of these token processing functions should be familiar. I'll skip the routine details and point out the highlights.<P>
The <I>do_opts( )</I> function handles a whole slew of trivial binary options by setting <I>Item</I> flags to values triggered directly by the option tokens. There are three functional categories processed by <I>do_opts( )</I>: prompting, pre-clearing and post-clearing. Only one option from each of those three categories is permitted to appear within any one item definition. The flag associated with each category is initialized to the value <I>DEFAULT</I>. It keeps that value until the appropriate statement forces the value to either <I>YES</I> or <I>NO</I>.<P>
The <I>do_nextitem( )</I> function processes the <I>nextitem</I> clause, so the user may alter the menu system's flow of control. One of four variations must be used. The last is to supply a label for the next item to be highlighted. If the next token after <I>nextitem</I> is a string, then <I>find_item( )</I> is called to see if the item has been defined. If it has, its index is inserted into the <I>nextitem</I> element of the <I>Item</I> structure and no forward referencing is involved. If <I>find_item( )</I> couldn't find it, lines 432-437 install the item reference into the forward reference table, for resolution when the item definition with the given label finally appears. If you missed it, see "The Item Clause" section above for related details.<P>
If the screen text for the menu item was not specified in the item clause, it must appear in a subsequent <I>text</I> clause. The <I>do_text( )</I> and <I>do_text2( )</I> functions process this option. After <I>do_text( )</I> has checked the basics, <I>do_text2( )</I> tests whether the string is too long to store in the available space. If it's too long, a message is printed and no attempt is made to copy the string into the <I>ITEM</I> structure.<P>
After copying a reasonable length string in through the <I>Ip</I> pointer, the flag named <I>widest</I> (in the <I>MENU</I> structure) is updated to reflect the length of the longest item text seen so far. This value will be used by <I>rmenu</I> when it comes time to decide how all the menu items will be arranged on the screen.<P>
<h4><FONT COLOR="#000080"><A name="00A0_0050">Springing Into Action<A name="00A0_0050"></FONT></h4></P>
There must be exactly one action associated with each menu item, from a choice of four possibilities. The <I>do_action( )</I> function is set to process all four actions, each using a different token sequence.<P>
The <I>exit</I> action may be specified either with or without the <I>action</I> keyword preceding it. Both forms are valid.<P>
The basic action clause is specified by the <I>action</I> keyword and a text string. The string represents an operating system command (or sequence of commands separated by semicolons). All <I>do_action( )</I> does is copy the string (through <I>Ip</I>) into the <I>action</I> element of the current <I>ITEM</I> structure (line 527). The <I>emenu</I> action, which calls an external menu, is processed in the same way, except that the <I>acttyp</I> element of the <I>ITEM</I> structure is set to identify the <I>action</I> string as an external menu name rather than a command to be passed to the system's command interpreter.<P>
The fourth type of action is the <I>lmenu</I> clause, specifying a local menu to run. If no menu by the given name is found in the file, a menu structure is created and added to the <I>MInfo</I> array, and the index number of the new menu entry is plugged into <I>lmenunum</I> element of the item being processed.<P>
There is nothing new to say about the <I>do_help( )</I> function, so I won't.<P>
The final function in the module, <I>do_err( )</I>, gets called whenever a keyword is encountered unexpectedly (for example when the <I>first</I> keyword is seen without a leading <I>nextitem</I>). In the keywords table array, any keyword that does not represent the beginning of a legitimate option sequence is assigned <I>do_err( )</I> as its processing function. By calling the <I>fatalerr( )</I> function to print its error message, <I>do_err( )</I> forces compilation to be terminated immediately after the error message is printed, allowing the user to fix the syntax without having to deal with additional spurious error messages.<P>
<h4><FONT COLOR="#000080"><A name="00A0_0051">Intermission: <B><I>dmenu</I><A name="00A0_0051"></B></FONT></h4></P>
This concludes my illustration of the <I>cmenu</I> program. Before delving into <I>rmenu</I> in the next installment, I'd like to introduce a little diagnostic utility named <I>dmenu</I>. I wrote this short program after eliminating the simple syntax errors from my initial stab at the <I>cmenu</I> code, but before <I>rmenu</I> was written. At that point, I needed a quick, easy way to examine <I>cmenu's</I> output files for debugging purposes. <I>dmenu</I> reads an .<I>mnc</I> file and disassembles it into human readable form, providing a complete picture of a compilation job performed by <I>cmenu</I>. With the help of <I>dmenu</I>, I was able to debug <I>cmenu</I> quickly, without even needing to have <I>menu</I> available. The code for <I>dmenu.c</I> is shown in <A href="list4.htm">Listing 4</a>.

<h4><a href="../../../source/1992/mar92/zolman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
