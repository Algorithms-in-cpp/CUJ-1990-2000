


<HTML>
<HEAD>

<TITLE>March 1992/OOP Without C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Real-Time/Embedded Systems</FONT></H2>

<hr><h2 align="center"><font color="#800000">OOP Without C++<A name="0092_0035"><A name="0092_0035"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0092_0000"><A name="0092_0000">Bill Bingham, Tom Schlintz, and Greg Goslen</font></h3><hr><blockquote><P>
<P><i><A name="0092_0000"><A name="0092_0000">Tom Schlintz has a BSEE from Virginia Polytechnic Institute and has been working as a software engineer for Logical Design group for the past four years. His Interests are embedded and VME bus-based applications. Greg Goslen has a BA in Physics from Appalachian State University and has been working as a software engineer for Cardiovascular Diagnostics for the past year. He has nine years of embedded systems experience, four of them working in C. Bill Bingham has a BA in Biology from The University of Virginia, an MSEE from Berkeley, and MEng Bioengineering from Berkeley. He is currently the senior research and development engineer at Cardiovascular Diagnostics, where he has worked for the past two years.</i></P><P>
When most programmers think of object-oriented programming (OOP), they think of object-oriented languages. What we often forget is that OOP is more than just using a type of compiler. It is a programming concept &#151; a way of thinking about the way we structure our code.<P>
We're writing this paper to demonstrate three things: first, that OOP isn't as scary as you may have been led to believe; second, that no one person, group, or manufacturer has an exclusive on the implementation of OOP; and third, how we addressed a small embedded systems project, using an OOP approach, and made it work.<P>
Several months ago we were struggling with the code for a new medical device. We required that the code be clear, modular, and thoroughly testable, an ideal candidate for object-oriented programming techniques. Unfortunately, it also had to perform a large number of tests in limited ROM (48KB), limited RAM (8KB), and on a processor built for small, embedded applications, the 68HC11. To further complicate matters there was neither an OOP compiler for our platform nor the code space to support a full-blown OOP strategy. Still, we wondered if we could use a standard, high level language to get some of the benefits of OOP without sacrificing too much space.<P>
Once we began this project, the first thing we noticed was that we already knew OOP, we just didn't know that we knew. The concepts are not difficult, we had all used some of them before. The major difference is that in an OOP language the constructs are supported by the compiler.<P>
<h4><FONT COLOR="#000080"><A name="0092_0036">Implementation<A name="0092_0036"></FONT></h4></P>
The classic object-oriented system creates objects in RAM, allows them to communicate with one another and selectively destroys them once they have finished their tasks. In an embedded system, RAM is precious, so we created object classes manually using <I>typedefe</I>d<I> struct</I>s, which we stored, along with object definitions and pointers to object methods, in ROM. In essence we did manually what an OOP compiler does for you.<P>
To further conserve ROM space we used the concept of inheritance to eliminate redundancies between tests. We began by creating a parent class, <I>TEST_CLASS</I> as a <I>typedefed struct</I>, to be the master template for our test objects. It is defined in the header file <I>class.h</I>, as shown in <A href="list1.htm">Listing 1</a>,
 and is fixed at compile time. <A href="list2.htm">Listing 2</a>
shows how, by creating variables of type <I>TEST_CLASS</I>, several objects, <I>test_a, test_b</I>, and <I>test_c</I>, inherit their basic structure from it.<P>
To further conserve ROM we created several subclasses of <I>TEST_CLASS</I>. We placed class specific methods and data into a common module and object specific methods and data into object specific modules. Objects of a given subclass inherit data and methods from that subclass.<P>
Thus, <I>test_a</I> and <I>test_b</I> are of the same subclass, <I>class 1</I>, and both use <I>class_1_display</I>, which is defined in <A href="list3.htm">Listing 3</a>,
 <I>class_1.c</I>. This is an example of inheritance from a subclass. <I>test_c</I> is of a different subclass, <I>class 2</I>, and so inherits <I>class_2_display</I>. All the test objects define their own public data, e.g., <I>Test_Name</I>, and public methods, e.g., <I>init_object</I>.<P>
Using our protocol the names of all methods are fixed when a class is created. When a subclass inherits method names from the parent class we manually attach one of several functions to the pointer associated with that method name. By using this form of polymorphism we reduce the complexity of the main program and force implementation specific details to remain encapsulated within the objects.<P>
Our project specified twenty different tests, and that adding, changing, or deleting a test be easy and have no impact on existing tests. To achieve this we created a master array of pointers, <I>test_ptr[]</I>, in the main program file. The elements of the master array point to the structure defining each test object. An index into <I>test_ptr[]</I> yields a pointer to the selected test object (see <A href="list4.htm">Listing 4</a>)
. The selected object then performs the test via its methods. In order to compile properly, <I>test_a, test_b</I>, and <I>test_c</I> must be declared as externals above the declaration of <I>test_ptr[]</I>. The last, null entry in <I>test_ptr[]</I> is used as a termination to allow any number of tests to be incorporated. The <I>Test_Name[]</I> entry in every object of type <I>TEST_STR</I> allows the main program to search for the correct object by matching <I>Test_Name</I> to a string.<P>
The invoking program doesn't need to know which routine it is using, only that, for example, it is calling a display method. The display method handles the details. This makes it easy to add tests. It may seem like this is a lot of work to go through, when it would be much simpler to completely define test objects as structures throughout the program. If, however, we wish to add a new test with new functionality, this approach allows us to create new methods without changing data flow.<P>
Since we were already using separate modules to implement inheritance we decided we could go further and use the C specification to implement information hiding. C forces knowledge of variables declared at the beginning of a file to be confined to the routines in that file. This allowed us to define static variables at the top of the file that are freely accessible to all routines within the file, while hiding these variables from routines outside. Outside access to the data can be tightly controlled by routines within the file. We used this aspect of C to treat the contents of a file as an object, and the routines and data within the file as methods and private data of that object. By defining an object as files only the methods defined in that file have access to the object data.<P>
We recognized that data hiding necessitated some form of messaging. What we needed was a flexible and not too test specific, messaging scheme. Each test expected a different set of inputs and produced a different set of results. If these parameters were declared explicitly in the test method argument list, each test would have had to be a separate class. On the other hand, if we had used <I>TEST_CLASS</I> to define all of the tests, all instances of a given method would have had identical argument lists.<P>
Our solution was to establish global, generic floating-point arrays that could be passed as parameters to any method of the current test object (see <A href="list5.htm">Listing 5</a>)
. In our case all data could be passed as floating point but a more generic interface could be constructed using an array of strings. Structures were <I>typedefed</I> at the top of each object file which described the format used by all the methods of that object. The objects used the structure to encode or decode the information stored in the arrays.<P>
The parameter array is allocated in global RAM and is bigger than the maximum number of parameters for any test. A similar array of <I>floats</I> is defined for passing results back from tests. The main program passes the pointers to the <I>params</I> and <I>results</I> arrays to the methods when it invokes them and never knows what is in these arrays. Its job is to coordinate the passing of the arrays from one method to the next. The arrays combined with the object specific template act like a secret decoder ring available only to the methods within the object and allowed us to use meaningful names instead of index numbers to refer to each parameter. The result was much clearer code.<P>
<A href="list6.htm">Listing 6</a>
shows a test called <I>test_a</I> which requires that quantities called <I>time</I> and <I>amplitude</I> be passed to it. Notice that the parameter template maps the first two elements of <I>params</I> to these names. This template resides in the class specific module file (<I>class_1.h</I> shown in <A href="list6.htm">Listing 6</a>)
.<P>
The methods shown in <A href="list3.htm">Listing 3</a>
take these pointers and cast them with the same class specific template into a pointer to a structure of type <I>PARAMETER_STR</I>. In <A href="list6.htm">Listing 6</a>
the method casts the <I>PARAMETER_STR</I> to the method specific pointer, <I>ps</I>. The method can now interpret the parameter string values according to its own definition and can refer to any of the parameters by name, as shown in <A href="list6.htm">Listing 6</a>.
 A similar mechanism is used to place results in the results array.<P>
<h4><FONT COLOR="#000080"><A name="0092_0037">Summary<A name="0092_0037"></FONT></h4></P>
The effort we expended to implement OOP in our system has been paid back by the ease of adding new tests to the system, the disappearance of cross-test interference, and greatly decreased debugging time. Once implemented, OOP techniques helped us to achieve a higher level of abstraction. Because implementation details were left up to the private methods within each of our objects, our code could ignore how things were implemented on lower levels. This freed us to concentrate on the design aspects of the problem.<P>
We would like to thank Murdock Taylor for developing the hardware platform we used in this project.<P>
<h4>Sidebar: <a href="sidebar1.htm">"Basic OOP Terms"</a></h4>

<h4><a href="../../../source/1992/mar92/bingham.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
