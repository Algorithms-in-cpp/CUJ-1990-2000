


<HTML>
<HEAD>

<TITLE>March 1992/The Device Driver As State Machine</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">The Device Driver As State Machine<A name="0094_0037"><A name="0094_0037"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0094_0000"><A name="0094_0000">Thomas Nelson</font></h3><hr><blockquote><P>
<P><i><A name="0094_0000"><A name="0094_0000">Tom Nelson is an independent author, consultant, and part-time artist. You can reach him at 5004 W. Mt. Hope Rd., Lansing, MI 48917.</i></P><P>
A state machine is a useful logical construct for writing device control code. By mirroring the device's actual operation, the state machine makes the code easier to comprehend and therefore modify. Since a state machine usually relies heavily on initialized data in tables, the amount of logical branching in the associated code is minimized, thus helping the programmer avoid "spaghetti" code. When properly employed, a state machine adds a layer of abstraction between the user and the controlled device. It also isolates device-dependent code within a limited number of functions.<P>
From the point of view of an operating system, a device driver must present a consistent interface to application programs that access devices you may upgrade at any time or even to devices not yet on the market. The standard, installable device driver does all this and more. It functions as an extensible, user-modifiable part of an operating system.<P>
This article attempts to combine what is necessary (the device driver) and what is desirable from a coding standpoint (the state machine). The result is a method of coding DOS device drivers (either PC-DOS or MS-DOS) that provide a programmatic interface to a finite-state machine. The article presents a working device driver that controls an idealized tape backup unit. I left out the specifics of controlling an actual device (such as port assignments and bit settings) to focus on the connections you must make between an actual device and your application program.<P>
<h4><FONT COLOR="#000080"><A name="0094_0038">Driver Design Considerations<A name="0094_0038"></FONT></h4></P>
Designing a DOS device driver is a relatively simple task, since any driver must follow a standardized design. Getting one to actually run is another matter. Many consider device drivers a specialized systems task, one to be tackled only by the programming elite. However, the art need not be mysterious, especially when you code mostly in C. I organized <A href="list1.htm">Listing 1</a>
and <A href="list2.htm">Listing 2</a>,
 which form the kernel of a DOS device driver, as a template from which you can build any device driver. The template lets you concentrate on the actual device controller code. If you use the Borland compiler/assembler combination, you don't even have to know assembly language, although some knowledge of it will help you follow the ensuing discussion. If you use another compiler and assembler, you will need to modify the code to some extent.<P>
I'll touch on a few basics of device drivers, but will concern myself mainly with some important design considerations in coding a driver in C, as well as some usage caveats. Many journal articles and book chapters deal with device drivers. I refer the reader to the References section.<P>
<h4><FONT COLOR="#000080"><A name="0094_0039">The Template<A name="0094_0039"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>,
 <I>start.asm</I>, presents the assembly language start-up code. At this level, you must use assembly language in raw form (even inline assembly won't do) because C can't provide the necessary control. All drivers consist of one segment up to 64Kb in length, forcing all code and data into a single segment. Some compilers can produce a tiny model <I>.COM</I> file that satisfies these requirements. However, a device driver is a binary image file with an origin of <I> </I> (i.e., no Program Segment Prefix block), the first bytes of which are not executable. I believe few compilers could deal with such a situation.<P>
<A href="list1.htm">Listing 1</a>
begins by defining segments common to both the Borland and Microsoft compilers. If your compiler uses different segment names, you must change them. The segments must also be defined in the proper order. You must place <I>start.obj</I> first in the link order so that segments declared in other modules will be ordered the way you specify here (see the <I>MAKE</I> file in <a href="list7.htm">Listing 7</a>). A compiler will usually define <I>DGROUP</I> (in the small model default) as a group of all data segments, keeping the code segment separate. Here I define <I>DGROUP</I> by combining both code and data segments, the same as for a tiny model <I>.COM</I> program.<P>
I also defined another segment called <I>ENDSEG</I>, which is also part of <I>DGROUP</I> and will be linked in behind all other segments. The offset to <I>ENDSEG</I> allows DOS to calculate the driver's size (the break address) when DOS loads another driver behind yours.<P>
As mentioned earlier, all drivers have an origin of <I>0</I>, specified by the <I>org 0</I> statement. You must place the driver's header block immediately after, at offset <I> </I> in <I> </I>. The four-byte pointer field in the header usually contains -<I>1L</I> (<I>0xffffffff</I>) unless your file contains code for more than one driver, in which case it points to the next driver's header block. Whatever the case, the pointer in the last driver's header block must contain -<I>1L</I>. DOS fills it with a pointer to the next driver's header in the chain at driver load time.<P>
DOS always communicates with its device drivers using a curious two-step call. Most authors assume this was intended as a bridge to the future when DOS would support full multitasking. In view of the present status of DOS, multitasking is at best a remote possibility. The first part of this two-step call, the <I>_dev_strategy()</I> routine, merely saves a pointer to the caller's request header block. To maintain backward compatibility, all DOS drivers must include this routine, which represents a bit of additional overhead.<P>
The real work of the driver is performed by the second of the two procedures called by DOS, the interrupt routine. Although not a true interrupt handler, it shares many characteristics with them. The main difference is that it terminates with a <I>far</I> <I>ret</I> rather than an <I>iret</I>. Like an interrupt handler, however, the routine saves the CPU state and performs other housekeeping chores. If you're going to support compiled C code, the startup procedures must occur here also. Your startup code must duplicate as closely as possible the environment created by the compiler's normal startup code. The difference is that startup occurs on every call to the driver, not just once when DOS executes an application.<P>
After saving the CPU state and caller's stack context, the interrupt routine reclaims its own data segment, contained in the <I>CS</I> register. Since code and data are contained in one segment, the routine loads the <I>DS</I> register with the same value. Loading <I>ES</I> is probably optional, since most DOS compilers seem to make no assumptions regarding <I>ES</I>.<P>
The interrupt routine sets up its own internal stack by loading the <I>SS:SP</I> register pair with the appropriate values. One difference here is that the driver's stack does not have its own segment, as is usually the case. The linker expects a separate stack segment, however, and will complain about it. This is one warning you can ignore. Although creating a separate stack for the driver is not strictly necessary, supporting a stack-intensive language like C makes separate stacks highly desirable. (I have seen attempts to program device drivers in C where all variables were declared global to avoid blowing the short stack provided by DOS, reportedly as short as 40-50 bytes.) Providing your device driver with its own stack is simple, and the benefits easily outweigh the small overhead in space. If you're really worried about memory usage, you should code the whole device driver in assembly language.<P>
Having set up the appropriate machine environment, the interrupt routine then branches into C code. It pushes a <I>far</I> pointer to the caller's request header (saved earlier by the <I>strategy</I> routine) and calls <I>exec_command()</I> in <A href="list2.htm">Listing 2</a>.
 <I>exec_command()</I> serves as a central dispatch point where the call branches to the appropriate function, or command code routine. <I>exec_command()</I> uses the jump table <I>(*Dispatch[])()</I>, an array of pointers to the command code routines. Using a jump table seems more elegant and less code intensive than the more cumbersome <I>switch</I> statement.<P>
<I>exec_command()</I> also makes the caller's request header, defined in <A href="list3.htm">Listing 3</a>,
 available globally, assigning it to the pointer <I>Rh. exec_command()</I> branches to the correct command code routine based on the command code <I>Rh-&gt;cmd</I> passed in the request header. The function uses the command code as an index into the <I>Dispatch</I> jump table.<P>
<I>exec_command()</I> expects all command code routines to return zero if they execute normally. If errors arise while a command code routine executes, the routine returns <I>IS_ERROR</I> plus the appropriate error code, defined in <A href="list3.htm">Listing 3</a>.
 On return from the command code routine, <I>exec_command()</I> assigns the routine's return code to the request header. <I>exec_command()</I> also sets the <I>done</I> bit in the same status field in the header. This bit seems something of an anachronism, but you should nevertheless set it before returning from the interrupt routine. The remainder of the interrupt routine restores the caller's CPU and stack context.<P>
After loading your driver, DOS immediately calls the driver initialization routine, command code <I>0</I> (see <I>init()</I> in <A href="list2.htm">Listing 2</a>)
. You must perform any driver setup procedures inside this routine. Note that you are restricted to DOS functions <I>0x01-0x0C</I> and <I>0x30</I>. Other than these functions, you should avoid making DOS calls anywhere in your driver code. In general, since device drivers serve as a bridge between applications and the BIOS, you should restrict your driver code to BIOS-level calls (or port in/out code if needed) and avoid DOS entirely. More to the point, any call your driver makes to DOS commits the sin of DOS re-entrancy, since DOS called your driver in the first place.<P>
To inform DOS where to locate the next driver in the chain, the initialization routine must return a break address in the request header that specifies the end of the driver image in memory. Here I simply label the <I>ENDSEG</I> segment (discussed earlier), a segment guaranteed to fall at the end of the driver image. <I>init()</I> passes the <I>far</I> address of the labeled segment to DOS as the break address. This quick and dirty method, however, means that <I>init()</I> remains in memory, where it becomes dead code once DOS has initialized your driver. To save memory, most drivers (those written in assembly language, that is) locate the break address above the <I>init()</I> code and any data that <I>init()</I> will use only once. DOS will then load the next driver over the unneeded parts.<P>
Although more difficult, this trick can be simulated in C. Since the code segment is located first, you can place all code and data in <I>_TEXT</I>, put <I>init()</I> in a separate module, and place <I>init.obj</I> last in the link order. You could then pass the (<I>void far</I> *) address of the start of <I>init()</I>'s code to DOS as the break address. The main obstacle is that most compilers will automatically place all data in the <I>_DATA</I> segment. In order to get your data into <I>_TEXT</I>, you must define all global data inside an assembly language module and make <I>extern</I> references to them in your C modules. Although this scheme works, it complicates making changes later. Unless you have particularly lengthy driver initialization code, attempting to drop <I>init()</I> is probably more trouble than it's worth. To repeat, you're programming a driver in C for C's relative ease of use, not primarily to save memory.<P>
<h4><FONT COLOR="#000080"><A name="0094_003A">Let The Programmer Beware<A name="0094_003A"></FONT></h4></P>
When choosing a name for your device, which goes in the last field of the header block, choose a name you won't use for a file. When DOS opens a file, it first checks the driver chain for a device driver with the same name. At this level, DOS treats devices and files in the same manner. If your file and a device name conflict, DOS will open the device instead of your disk file and you will get some unexpected results. To illustrate, create a file called <I>lpt1</I> with your text editor. Try writing some text to it using the DOS TYPE or COPY commands. The data will go to the line printer instead of the disk file. You won't be able to delete the file from the DOS command line either.<P>
It's difficult to incorporate many of the standard C library functions in device driver code. You must be absolutely sure you know what they do, since some depend on initialized data in other modules or may take actions that in some way compromise your driver code. Neither should you use standard library functions that call <I>malloc()</I>, because the driver has no heap. You should write your own versions of most standard library functions, unless you use only simple, compact ones like <I>strcpy()</I>.<P>
Most compilers put uninitialized global data in a special segment that the startup code initializes to zeros when a program executes. Many programmers write C code that relies on this behavior, but it's an assumption you can't make in a device driver written in C. Make sure all data is initialized in some way before you use it, the same as you would do when using automatic (stack-based) variables. Also, make sure you instruct the compiler to enforce byte-packing of structures. Borland enforces byte-packing by default, but I believe the Microsoft compiler uses word-packing unless instructed not to.<P>
Stack probing is a useful adjunct to program debugging, but it is difficult to implement a method in a driver that works with a variety of compilers. Though I have ignored stack probing in my driver code listings, you may find a way to implement it. If your compiler inserts stack probes by default, make sure you turn them off.<P>
<h4><FONT COLOR="#000080"><A name="0094_003B">State Machines<A name="0094_003B"></FONT></h4></P>
State machines are useful in the control of any rule-based system, and their application to device control is a prime example. Briefly, you can apply state machines to any system you can define in terms of a finite number of states (or "islands") with a definite set of rules for traveling or navigating between them. The state machine uses initialized data in tables (a <I>state table</I>) to organize these states and rules into a structure that reflects the actual operation of the system.<P>
The state machine knows only the current state of the system. Given a command or event, the state machine refers to the state table to determine whether that event is valid for that state. The event determines the state to which the system will travel next. The state table also contains a set of procedures (functions) that tell the system how to effect the transition to the next state. When the machine reaches the next state, it waits until it receives another event or command, then repeats the cycle.<P>
<h4><FONT COLOR="#000080"><A name="0094_003C">The State Table In C<A name="0094_003C"></FONT></h4></P>
To illustrate the basic concepts of device control using a state machine, I developed a simple example that controls a hypothetical tape backup unit. To build the state table, start with a list of the available device controller commands, as in the simplified list in <A href="fig1.htm">Figure 1</a>.
 These commands form the basis of a list of valid events, or user commands (see <A href="list4.htm">Listing 4</a>,
 <I>tape.h</I>). You may also need to define other user commands, formed from combinations of the basic device commands.<P>
Next, define the various states in which your device will exist at any one time. For my tape backup unit, I defined states such as <I>READY</I>,<I> PLAY</I>, and <I>RECORD</I> (see <A href="list4.htm">Listing 4</a>)
. Then, given a set of well-defined states, decide which events will be valid for each state. These valid events determine the subset of states to which you can move, given your current position. For instance, if the tape unit is currently in a <I>READY</I> state, meaning you just inserted a cassette, you can move directly to any other state. If you're currently in the <I>REWIND</I> state, however, you can only stop rewinding and return to a <I>READY</I> state.<P>
When you have defined all your states and the valid connections between them, you should end up with something like the table in <A href="tab1.htm">Table 1</a>,
 the State Transition Table. Along the way you may want to draw some simple diagrams. Such diagrams quickly become complex when the number of valid connections between states (represented by lines with arrowheads) averages more than two or three. You may also want to include a list of the functions needed to effect the transition from one state to the next, as I've done in <A href="tab1.htm">Table 1</a>.
<P>
You can translate the State Transition Table almost directly into a single array of structures. Although easy to understand, such an array will mean some degree of data repetition. I have instead used a series of cascading or multi-level tables connected by pointers, resulting in an efficient use of memory as well as reduced coding effort. Each valid state in the system uses an array of <I>S_TAB</I>s, the basic data element, to create an <I>event table</I> (<A href="list4.htm">Listing 4</a>)
. The last member of an event table must be the macro <I>END</I>, which indicates the end of the table. An event table defines the valid events for each state, the next state to move to, as well as a pointer to the list of functions to effect the transition. All the event tables are connected at the top by an array of pointers (the state table). Note that the current state of the system serves as an index into this array. The order of states in the array should correspond to the order in which you initially defined the states, as in <A href="list4.htm">Listing 4</a>.
<P>
<A href="list5.htm">Listing 5</a>
contains the state table. One of the most difficult tasks is finding descriptive names for all the tables, especially the lists of pointers to functions. At first this may seem overly complex, but working with initialized data in tables significantly reduces your coding effort. Without them, your code would be littered with logical branching statements.<P>
<h4><FONT COLOR="#000080"><A name="0094_003D">The IOCTL Interface<A name="0094_003D"></FONT></h4></P>
DOS device drivers make available at least two command code routines to control the driver itself. Applications use these IOCTL functions to pass control information directly to the driver to control the driver's other I/O functions. An IOCTL call does not necessarily result in any input/output interaction with the physical device. The control information's format is unspecified and is known only to the driver and the application program. DOS takes no part except to provide a standard interface for using the IOCTL functions. An application wishing to pass control data to a driver uses DOS function <I>44h</I>, sub-functions <I>2</I> and <I>3</I>, which read and write I/O control data, respectively.<P>
DOS passes requests for functions <I>44h</I>, subfunctions <I>2</I> and <I>3</I> directly to the device driver once you have obtained a device handle using the DOS open file/device function, <I>3Dh</I>. Calls to the DOS IOCTL functions end up in command code routines <I>3</I> and <I>12</I> inside the device driver, <I>ioctl_read()</I> and <I>ioctl_write()</I>, respectively ( <A href="list2.htm">Listing 2</a>)
. A developer can use these functions for any purpose since nothing is specified other than the calling protocol.<P>
As you can see in <A href="list5.htm">Listing 5</a>,
 I have used the DOS IOCTL interface as a direct channel to control the hypothetical tape drive. The driver uses only command routines <I>0</I>,<I> 3</I>, and <I>12</I>. Most of the unused routines deal with more "normal" device I/O, such as servicing DOS read/write requests. A real tape unit must protect itself from such actions, which could easily corrupt data already stored on the tape. Without this protection, anyone could write to the tape unit using the DOS TYPE command with command-line redirection. However, since command routine <I>8</I> <I>(device_write()</I> in <A href="list2.htm">Listing 2</a>)
 returns <I>0</I> on every call, DOS thinks it's writing to a real device, even though nothing is actually done.<P>
Note also that command routines <I>3</I> and <I>12</I> both call <I>tape_io()</I> in <A href="list5.htm">Listing 5</a>.
 In the interest of uniformity, I combined these two functions, since the only real difference between them is semantic. You can therefore use either subfunction <I>2</I> or <I>3</I> of DOS <I>44h</I> to make IOCTL calls to the tape unit.<P>
<h4><FONT COLOR="#000080"><A name="0094_003E">Putting It All Together<A name="0094_003E"></FONT></h4></P>
Function <I>tape_io()</I> serves as the entry point into the state machine driver. <I>tape_io()</I> receives a far pointer to the command IOCTL string. The pointer is passed in the request header's transfer buffer (<A href="list3.htm">Listing 3</a>)
. Since DOS does not specify the format of the command information, I defined it as a structure of type <I>CMDARG</I> (<A href="list4.htm">Listing 4</a>)
. This structure serves as the state machine's primitive memory. It contains the current state of the system, the command for the tape unit to execute, and the return status of the command and/or the tape unit hardware.<P>
<I>tape_io()</I> first points to the correct event table, using the <I>CMDARG</I> argument as an index into the <I>*s_table[]</I> array. <I>tape_io()</I> then enters a loop, attempting to match a valid event for the current state with the command code passed in <I>CMDARG</I>. If the function can find no match, it returns immediately with an error code. Otherwise,<I>tape_io()</I> updates <I>CMDARG</I>'s current state with the next valid state from the event table, then immediately executes the functions associated with the state transition. The array of function pointers doesn't arbitrarily limit the number of functions needed to effect the transition, nor does it require <I>null</I> padding to fill unused spaces in the array.<P>
Commands sent to the state machine driver, <I>tape_io()</I>, originate from a separate controller program that issues DOS IOCTL calls. The code in <I>ctl.c</I> (<A href="list6.htm">Listing 6</a>)
 acts as the tape unit's user interface, something the device driver controller code need not be concerned with.<P>
To use the DOS IOCTL functions, you must first obtain a device handle using <I>open ()</I> (<A href="list6.htm">Listing 6</a>)
. If <I>open ()</I> reports an error, the device driver wasn't installed. DOS next determines if the device driver is functioning correctly, using function <I>_dos_dev_info()</I>. Two possibilities exist here, one that the device name is actually a disk file, or that the "IOCTL" bit (<I>0x4000</I>) in the driver's header block was not set. In the latter case, DOS will not complete an IOCTL function call because it assumes the device driver doesn't have an IOCTL interface. The program uses functions <I>_dos_ioctl_read()</I> and <I>_dos_ioctl_write()</I> to actually communicate with the tape unit. As outlined earlier, using either function accomplishes the same result, since both end up in the state machine driver function, <I>tape_io().</I><P>
<h4><FONT COLOR="#000080"><A name="0094_003F">Alternatives To IOCTL<A name="0094_003F"></FONT></h4></P>
Several alternatives to using the DOS IOCTL functions exist. Since DOS serves only as an intermediary, you could dispense with the overhead of a DOS call entirely and set up the driver as a combination standard device driver and TSR, like the Expanded Memory Manager. When DOS initializes your driver (command code <I>0</I>), you would set up a software interrupt to point to the device controller code. Application programs would access the driver through the interrupt, using much the same command interface as described earlier. You're then free to make DOS calls from inside the controller code, since DOS is no longer involved up front.<P>
Continuing along these lines, you could do away with the device driver altogether and put the entire controller code inside a TSR. Since the tape unit driver doesn't have to service normal I/O requests via DOS, as device drivers usually do, you're free to do this.<P>
However, using a TSR involves a varying amount of risk since DOS never fully supported them. Using a state machine in a device driver, on the other hand, gives the device driver full support of DOS. By using standard DOS function calls, you also avoid potential conflicts over the use of software interrupts.<P>
<h4><FONT COLOR="#000080"><A name="0094_0040">Rolling Your Own Driver<A name="0094_0040"></FONT></h4></P>
I have presented the driver code in <A href="list1.htm">Listing 1</a>
and <A href="list2.htm">Listing 2</a>
as a sort of template, which you can use to get a head start past the coding basics. The template code allows you to concentrate on writing the actual device controller code in the language you probably know best. However, even with solid support behind you, you can still get stuck when testing and debugging your driver.<P>
Make sure you keep all device controller code in a separate module, as I did in <A href="list5.htm">Listing 5</a>,
 <I>tape.c</I>. You can easily convert the module into a transient <I>.EXE</I> test bed, using compile-time <I>#defines</I>. Leave the test bed code in place, inactivated, when you produce the finished driver. When you make changes and retest, simply unpack the test bed code.<P>
Testing your code as a normal <I>.EXE</I> program means you can easily use a software debugger. Your test code should include a means to load a request header with appropriate data, exactly as DOS would, and make calls to the <I>exec_command()</I> routine. You can then examine the data and status codes returned in the request header when the call completes. Making actual calls to the <I>strategy</I> and <I>interrupt</I> routines (<A href="list1.htm">Listing 1</a>)
, as DOS does, is probably unnecessary since this code is fully debugged.<P>
A driver still needs to be tested when linked into the DOS driver chain. To prepare for this, create a bootable floppy complete with a dummy <I>config.sys</I> that includes a command to load your test driver from the hard disk. Also include a dummy <I>autoexec.bat</I> that simply calls your normal <I>autoexec.bat</I> file on the hard disk.<P>
You'll probably find a software-only debugger difficult to use when testing a driver in place, although I have never tried it. You can set breakpoints within the body of the driver much as you normally would. However, most debuggers make DOS calls too. When they do so, they re-enter DOS, corrupting the DOS stack and leading directly to a system crash. Instead of using a debugger, you should rely as much as possible on testing the code thoroughly as an <I>.EXE</I> transient, as outlined above. To test the driver in place, you may find a "non-intrusive monitor" to be of some help (see reference [5]). You can then monitor the values of selected variables inside the driver during execution of a normal test program running in the foreground.<P>
<h4><FONT COLOR="#000080"><A name="0094_0041">Some Final Thoughts<A name="0094_0041"></FONT></h4></P>
If you've tinkered with device drivers before and gotten stuck, this article may give you new impetus to try again. Even if you know your way around DOS drivers, it always helps to have a fresh slant on them, if only to affirm that your own way of doing it is better.<P>
This article has also shown that a state machine approach to writing device control code can provide considerable benefits. Its table-driven strategy forms a natural, built-in Application Program Interface (API) for device control from an application program. Using the API, anyone can build a desired user interface to the tape unit. You're also able to modify the user interface at any time without touching the device driver.<P>
This arrangement is very flexible, since you can locate the user interface code in any situation. You could place such code in a normal <I>.EXE</I> application that includes tape backups as an option. Another possibility would be a TSR that uses the tape driver to make background saves of specified files when the TSR detects that the files have been modified.<P>
<h4>References</FONT></h4></P>
Duncan, Ray.<I> Advanced MS-DOS Programming, 2nd Ed..</I> Microsoft Press, Redmond, WA.<P>
Fischer, Paul. "State Machines in C," <I>The C Users Journal</I>, December 1990, pp. 119-122.<P>
Johnson, Marcus. "Writing MS-DOS Device Drivers," <I>The C Users Journal</I>, December 1990, pp. 41-57.<P>
Lai, Robert. S. and The Waite Group. <I>Writing MS-DOS Device Drivers</I>. Addison-Wesley.<P>
Naleszkiewicz, John R. "A Non-Intrusive TSR Monitor," <I>TECH Specialist</I>, June 1991, pp. 32-40.<P>

<h4><a href="../../../source/1992/mar92/nelson.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
