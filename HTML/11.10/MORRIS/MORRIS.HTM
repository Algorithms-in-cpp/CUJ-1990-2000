

<HTML>
<HEAD>

<TITLE>October 1993/The SPLASH Class Library</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">The SPLASH Class Library<A name="02DB_00F2"><A name="02DB_00F2"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="02DB_0000"><A name="02DB_0000">Jim Morris</font></h3><hr><blockquote><P>
<P><i><A name="02DB_0000"><A name="02DB_0000">Jim Morris is currently Director of ROM Software at The 3DO Company. Despite this he has been a professional programmer for over 17 years. He has been using C++ sporadically for about 2 years. He can be reached via EMail at morris@netcom. com, via compuserve Mail as 73200,2306 or by phone at (415) 578-6765.</i></P><P>
I have used Perl for many years and often wished that some of the data types and functions provided in Perl were available when I was writing my C programs. When I started writing C++ code, I realized that the list and string data types that I used in Perl scripts could be faithfully duplicated by a relatively simple class library. The reason for this is that C++ allows you to create user-defined types. Additionally C++ templates allow you to create a list class that can store any data type.<P>
Some benefits of basing this class library on the existing Perl language are that the behavior and functions of the data types are already defined, so I can concentrate on the implementation. Also the functions and data types are known to be useful and effective, as they have been in use for years.<P>
I am only going to talk about the string and list data types in this article; however, SPLASH implements associative arrays and array slices too.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00F3">A Brief Description of Perl<A name="02DB_00F3"></FONT></h4></P>
Perl is a public domain scripting language written by Larry Wall. It can run on most platforms, from UNIX to MS-DOS. Perl provides list, string, numeric, and associative array data types, and simplified file I/O. It also allows easy access to some very powerful regular expression (RE) functions. (See sidebar, <a href="sidebar3.htm">"What is a Regular Expression?"</a>)<P>
I call Perl a scripting language because, like UNIX csh or MS-DOS .BAT files, you don't have to compile the script, just edit and run. Perl is very useful for processing files and extracting information from them, or translating files in various ways. It is most often used by UNIX system administrators for writing scripts that run automatically at frequent intervals and do some relatively complex task, such as cleaning up log files or tracking accounting system usage. I have used Perl for varying tasks from a global search and replace script to calculating my monthly Compuserve bill from the dialing log generated by Procomm Plus.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00F4">A Brief Description of SPLASH<A name="02DB_00F4"></FONT></h4></P>
The SPLASH (Simple Perl-like String And List Handling) class library is a C++ implementation of the Perl list and string data types. It includes the regular-expression, substitute, and translate operations on strings. (For a function-by-function description of SPLASH, see the sidebar, <a href="sidebar1.htm">"SPLASH Function Reference."</a>)<P>
SPLASH provides a dynamic list template class (<I>SPList</I>) that allows you to add and extract data from the top of a list (<I>push</I> and <I>pop</I>), and from the bottom of the list (<I>unshift </I>and <I>shift</I>). For example, a FIFO (First In, First Out) list could be implemented by:<P>
<pre>SPList&lt;int&gt; mylist;
// put 1 and 2 onto the list
mylist.push(1); mylist.push(2);
y = mylist.shift(); // y gets 1
x = mylist.shift(); // x gets 2;</pre>
A list can be sorted by comparing the elements with <I>operator&lt;</I> (which must be defined for the data type being sorted). The list can also be reversed, as with:<P>
<pre>SPList&lt;float&gt; mylist, sortedlist;
// sorts the list, then reverses the
// the resulting list, and returns it
sortedlist= mylist.sort().reverse();</pre>
A list can be inserted anywhere within another list, or elements can be deleted from a list (with <I>splice</I>). Any individual element within a list can be randomly accessed using <I>operator[]</I>. The list is <I>dynamic</I>, which means it automatically shrinks and expands as necessary, without the user having to worry about memory management.<P>
The string class <I>(SPString) </I>implements a dynamic string data type. The offset of a substring can be found (with <I>index</I>). A substring may be extracted or assigned to, effectively overwriting or deleting the substring (<I>substr</I>). The string may be used anywhere a <I>const char*</I> can be used, so it can be passed as a parameter to the Standard C <I>str*</I> functions. The standard comparison operators (&lt;, &gt;, ==, etc.) are defined, so intuitive operations can be applied to the strings. String concatenation is implemented by defining <I>operator+</I> and <I>operator</I>+=.<P>
Some of the most powerful functions are the regular-expression matching operations, which allow a regular expression to be applied to a string, returning a Boolean on the success or failure of the match, or even returning a list of substrings that matched (<I>m</I>). The substitute and replace function (<I>s</I>) allows you to replace a successful regular-expression match within the string with an arbitrary substring. The translate function (<I>tr</I>) will replace all occurrences of a specific character, or range of characters. For example, <I>mystr.tr ("a-z", "A-Z"</I>) will convert each lowercase character in <I>mystr</I> with its corresponding uppercase character.<P>
The string list class (<I>SPStringList</I>) is basically an <I>SPList&lt;SPString&gt;</I> class with some added functionality specific to lists of strings. It lets you <I>grep </I>("globally look for a regular expression") within the list, returning a list of strings that match. You can generate a list of strings from a single string by splitting it on a given regular expression (<I>split</I>). The inverse operation (<I>join</I>) will generate a single string by concatenating a list of strings separated by a given string.<P>
All the classes have stream operators for input and output, to allow convenient file or stream processing.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00F5">The Design Process<B><A name="02DB_00F5"></B></FONT></h4></P>
The trap I always fall into when writing C++ programs is trying to be too object-oriented. I get carried away trying to make my programs fit exactly into the object-oriented design paradigm. I find concepts such as data hiding, or encapsulation, easier to use than things like inheritance. The <I>Regexp </I>class is a good example of where encapsulation really worked in SPLASH. The <I>Regexp</I> class effectively wraps itself around an existing C regular expression package.<P>
The reason this worked so well is that I used two different <I>regex</I> libraries during the design process. One was the standard <I>regex</I> library provided with most UNIX systems. The other one was Henry Spencers's public domain <I>regex </I>library. I ended up using the latter, because it matches Perl more closely. The interface to the <I>Regexp</I> class was such that when I changed the underlying C library I didn't have to change any of the implementations that used the <I>Regexp</I> class.<P>
While designing SPLASH, I did not always find it intuitively obvious when to use public inheritance, private inheritance, or layering. I found Scott Meyers's book <a href="#1">[1]</a> to be very helpful when deciding which method to use. In the first implementation of SPLASH, I derived both <I>SPList</I> and <I>SPString</I> from a dynamic array class called <I>MArray</I>, which I had written a year previously for another project. <I>MArray</I> (<A href="list1.htm">Listing 1</a>)
 is a very simple array class that will grow when elements are added to it. The only interface to it is the overloaded <I>operator[]</I> (for indexing), an <I>add</I> function, and a <I>remove</I> function.<P>
Even though its interface and implementation are definitely not optimal for either class, it did get me going pretty quickly. Once the functionality of SPLASH was frozen and tested, I wrote two new classes to replace <I>MArray</I>. These two classes (<I>SPListBase</I> and <I>VarString</I>) were tailored specifically to the <I>SPList</I> and <I>SPString</I> classes, thereby improving efficiency, and proving that encapsulation really works. None of the test programs using either <I>SPList</I> or <I>SPString</I> needed changing, even though the underlying implementation of the two classes changed radically.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00F6">The Implementation<A name="02DB_00F6"></FONT></h4></P>
It could be argued that neither <I>VarString</I> nor <I>SPListBase </I>needed to be written, and that the functionality of these classes could just as easily have been put directly into <I>SPString</I> and <I>SPList</I>. The reason I decided to use a separate class in each case was that the required interface to these classes was very well defined, and the mechanisms therein were completely self-contained. In addition, I could optimize the low-level implementation of each without having to change the more complicated <I>SPList</I> and <I>SPString</I> classes. For instance, I might decide to re-implement <I>SPListBase</I> as a linked list instead of a linear array. This may be better suited to some list applications. If I were to do this, I could effectively replace <I>SPListBase</I> with a linked-list class, with no changes needed to <I>SPList</I>.<P>
<I>SPListBase</I> (<A href="list3.htm">Listing 3</a>)
 implements the mechanism for the dynamic list. It is a minimalist implementation of a linear array very similar to <I>MArray</I>, with one optimization. Because elements can be added to the front or back of the list, room is kept at both ends, so that data doesn't have to be shuffled up each time an element is added to the front of the list. This is accomplished using an offset (the private variable <I>first</I>) to indicate where the beginning of the array is. <I>first</I> initially points to the middle of the array.<P>
For performance reasons the array never shrinks, although this would be trivial to implement if it was required. Also note the judicious use of <I>const</I> on all parameters which are never changed by the function. Other than reducing the chances of unexpected bugs, it also allows some compilers to do better optimization. I also make all functions which do not alter the state of the class (don't write to any variables in the class) <I>const</I> functions. This makes the intent of the functions clear to people reading the code. It also means that these functions can be called from within other <I>const</I> functions. The syntax for <I>const</I> functions can be seen in <A href="list3.htm">Listing 3</a>,
 on the <I>count </I>member function.<P>
<I>SPListBase</I> could be reused by any program that requires a dynamic array. This has some bearing on why I made some members private and some protected. I call any function that uses this class a client, whereas a class that inherits from this class I have called a derived class. <I>grow</I> is a private member because I don't want it used outside of the class. It implies a knowledge of how the list is stored, and this kind of knowledge needs to be hidden from any client or derived class. A client should be able to use this class without any knowledge of how the data is actually stored.<P>
Hence, the interface to <I>SPListBase</I> is very basic. There is a way to randomly access any element within the array, a way to find out how many elements there are in the array, and two ways to add an element to the array. There is only one way to remove an element from the array, and that is using the protected member <I>compact</I>. I decided to make this a protected member because if I were to reuse this class as a generic dynamic array, the <I>compact</I> function would not normally be used. But a derived class usually has more intimate knowledge about its base class than a client would. Protected member functions are only accessible within the class and by any derived class.<P>
There are two versions of <I>operator[]</I>. One is a <I>const </I>version and the other returns a reference to an element, which means that the element can be overwritten with new data. The <I>const</I> version implies that the data being indexed is constant data, and therefore must exist. So I generate an <I>assert</I> error if the index is out of range. The other version could be used for adding data to the array, so I silently expand the array if the index is out of range. I do this because it is the behavior of Perl lists.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00F7">Description of <B><I>VarString</I><A name="02DB_00F7"></B></FONT></h4></P>
<I>VarString</I> (<A href="list2.htm">Listing 2</a>)
 is similar to <I>SPListBase</I> in that it manages a variable-length array and is a minimal implementation. It has five constructors, which allow a <I>VarString</I> to be generated from different data types. Two of them allow a <I>VarString</I> to be generated from a <I>char</I> <I>*</I>, either a complete C string or a partial one. The latter is the mechanism used to implement substrings. The conversion operator (<I>operator const char *()</I>) allows a <I>VarString</I> to be converted to a <I>const char</I> <I>*</I>, so that it can be passed to any of the standard <I>str*</I> library functions.<P>
As you can see, all this does is return the address of the private array stored in <I>VarString</I>. This could be very dangerous if the client decided to overwrite the array, so I specifically return a <I>const char</I> <I>*</I>, which will stop this from happening. Again, a client of <I>VarString</I> should make no assumptions about how the string is stored internally to <I>VarString</I>, and I am trying to use the compiler to enforce this rule.<P>
An example of how the internal data representation may change is that if I wanted to store binary strings in <I>VarString</I>, the <I>'\0'</I> could no longer have any specific meaning, unlike in a C string where it marks the end of the string. So <I>VarString</I> could store a string with a separate length count in this case. Whenever the <I>VarString</I> needed to be converted to a C string, a <I>'\0'</I> could be appended to the array returned by the conversion operator.<P>
I have also added a member function called <I>remove</I> which by default will delete one character from the array. But if a second parameter is given, it will delete that number of characters.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00F8">The <B><I>TempString</I></B> Class<A name="02DB_00F8"></FONT></h4></P>
A useful but simple class is <I>TempString</I> (<A href="list7.htm">Listing 7</a>)
. This is a mechanism for allocating a string for temporary usage which will automatically destroy itself when it passes out of scope. It replaces the often used code sequence:<P>
<pre>char *astring, *tmp;
// ....
tmp= malloc(strlen(astring));
strcpy(tmp, astring);
// use tmp for something like strtok
free(tmp);</pre>
Because the compiler generates a destructor call when the <I>TempString</I> passes out of scope, the storage is automatically released. So it reduces the chance of a memory leak in your programs. Of course, you have to be careful to not pass the address of the <I>TempString</I> to something that will use it after it has been released, but even C++ can't save you from every logic mistake.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00F9">When to Inherit<A name="02DB_00F9"></FONT></h4></P>
The question of when to inherit and when to layer is a thorny one. The books say that inheritance implies that the relationship between the derived class and the base class is one of"IS A." When I applied this test to <I>SPList</I> and <I>SPListBase</I>, I decided that <I>SPList</I> "IS <I>NOT</I> A" <I>SPListBase.</I> Instead, it is "implemented in terms of" <I>SPListBase</I>.<P>
"Implemented in terms of" can be achieved in two ways. One is layering, where the object you are using is declared as a variable in the class that is using it. Another way is to privately inherit from the class. Private inheritance means that only the derived class will have access to the protected and publicmembers of the base class. In other words, it is exactly as if the base class were a private member of the deriving class. So which one to use? According to Myers, layering is the preferred method. He recommends you use that method, unless you need access to a protected member in the layered class. <I>SPListBase</I> does indeed contain a protected member (<I>compact</I>), so I used private inheritance in this case.<P>
One reason that I don't consider that <I>SPList</I> "IS A" <I>S-PListBase</I> is that I want users of <I>SPList</I> to see only the Perllike interface, not the raw interface to <I>SPListBase</I>.<P>
<I>SPString</I> also fails the "IS A" test with regards to <I>VarString</I>. <I>SPString</I> is "implemented in terms of" <I>VarString</I>. <I>VarString</I> is a raw interface to a dynamic string type, and <I>SPString</I> packages this up with a Perl-like interface. Accordingly, <I>SPString</I> doesn't inherit from <I>VarString,</I> Instead, it defines a <I>VarString</I> as a private member (layering). <I>VarString</I> is a private data member because I want to hide the actual datastorage method from users of <I>SPString</I>, in case I decide to change it in the future.<P>
A good example of an "IS A" relationship is that of <I>SPStringList</I> (<A href="list6.htm">Listing 6</a>)
 and <I>SPList. SPStringList</I> publicly inherits from <I>SPList</I> (<I>SPList&lt;SPString&gt;</I> to be exact) because it "IS A" <I>SPList.</I> It just adds some more functionality to <I>SPList</I>. A client of <I>SPStringlist</I> has access to all the functions in <I>SPList</I>. In addition, <I>SPStringList</I> offers a few functions that are specific to a list of <I>SPStrings</I>.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00FA">Description of <B><I>SPList</I><A name="02DB_00FA"></B></FONT></h4></P>
<I>SPList</I> (<A href="list4.htm">Listing 4</a>)
 implements the Perl-like list data type. What the user of <I>SPList</I> sees is an interface similar to the various operators that can be applied to a Perl list.<P>
<I>SPList</I> is privately derived from <I>SPListBase</I>. This means that all the member functions within <I>SPList</I> have access to the protected and public member functions of <I>SPListBase</I>, but the client of an <I>SPList</I> cannot use, or even see, any member functions within <I>SPListBase</I>.<P>
<I>SPList</I> is a template class. This means that when it is used in a declaration the client must specify a type in angle brackets. The compiler then generates the code for the class, substituting the given type where appropriate. This saves me having to rewrite the class four times to support four different data types in the list. For example:<P>
<pre>// Generate a list of Integers
SPList&lt;int&gt; intlist;
// Generate of list of pointers to char
SPList&lt;char *&gt; strlist;</pre>
The implementation of most of <I>SPList</I> is fairly straightforward, so I'll just mention a few of the more interesting features. <I>operator void *()</I>, which simply returns <I>count()</I>, is a trick that is used to allow the variable name to be used in an <I>if</I> statement as a Boolean test. The return value in this case is, of course, true only if the list is not empty &#151; so:<P>
<pre> SPList&lt;int&gt; alist;
if (alist)
   cout &lt;&lt; "I'm not empty" &lt;&lt; endl;
else // this will get executed
   cout &lt;&lt; "I'm empty" &lt;&lt; endl;
alist.push(1);
if(alist)// this will get executed
   cout &lt;&lt; "I'm not empty" &lt;&lt; endl;
else
   cout &lt;&lt; "I'm empty" &lt;&lt; endl;</pre>
Note, in <A href="list4.htm">Listing 4</a>,
 the two ways I have made functions in <I>SPListBase</I> available to users of <I>SPList.</I> The <I>operator[] </I>functions implicitly call the base class equivalent, whereas <I>count</I> uses another syntax which is given in the ARM (<I>Annotated C++ Reference Manual</I> <a href="#2">[2]</a>), page 244, section 11.3. However, I have found that many C++ compilers will not accept this syntax.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00FB">Description of <B><I>SPString</I><A name="02DB_00FB"></B></FONT></h4></P>
<I>SPString</I> (<A href="list5.htm">Listing 5</a>)
 implements the Perl string data type. It is more oriented towards processing data in files than manipulating strings, so it probably is not a good general purpose string data type. Because it has the conversion <I>operator const char *()</I>, an <I>SPString</I> can be used as a parameter to any of the Standard C string routines. In addition, the compare and equality operators have been defined three different ways, so a C string can be used in a comparison operation either on the right or the left of the operator, for example:<P>
<pre>SPString mystring, yourstring;
// ....
if(mystring != "Hello") ....
if("abcd" &lt; mystring) ....
if(mystring &gt;= yourstring) ...</pre>
In order for the C string (a <I>char</I> <I>*</I>) to be used on the left of a binary operator, it must be defined as a friend function, so:<P>
<pre>friend int operator&lt;(const char *s,
   const SPString&amp; sp)
   {return (strcmp(s, sp.pstr) &lt; 0); }</pre>
This puts the scope of this function outside of the class it is defined within, as described in the ARM, page 248, section11.4.<P>
As can be seen, the actual implementation just calls a regular C string compare function. This also demonstrates operator overloading, where <I>operator&lt;</I> is overloaded to take an <I>SPString</I> and a <I>const char</I> <I>*</I>. Similarly, <I>operator+</I> has been overloaded to do a concatenation of two strings. It can take an <I>SPString</I> and an <I>SPString,</I> an <I>SPString</I> and a <I>const char</I> <I>*</I>, an <I>SPString</I> and a <I>char</I>, and a <I>const char</I> <I>*</I> and an <I>SPString.</I> The last is implemented as a <I>friend</I> function, as I described above.<P>
Why define <I>operator&lt;(const SPString&amp; s)</I> and <I>operator&lt;(const char *s)</I> when a conversion operator from <I>SPString</I> to <I>const char</I> <I>*</I> is available? Why not just let the compiler generate the conversion, especially when it is going to take place anyway when it calls the <I>strcmp</I> function? The reason is the following compiler error message generated on the following lines of code:<P>
<pre>SPString s1, s2;
// ...
if(s1 == s2)
// ....
error: ambiguous call: operator==
   (class SPString, class SPString)
choice of operator ==()s:
   int operator ==(const class SPString, const char *);
   int operator ==(const char *, const SPString&amp;);</pre>
This very helpful error message explains the problem. Because we have a <I>friend</I> function to allow a <I>char</I> <I>*</I> to be on either side of the binary operator, the compiler is unable to decide which of the two <I>SPStrings</I> to convert to a <I>const char *</I>, so it gives this error message. I fixed the problem by disambiguating the call, by writing a specific operator for each case.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00FC">Substrings<A name="02DB_00FC"></FONT></h4></P>
I wanted to hide the substring class from the user, so I made it a nested class within the <I>SPString</I> class. This way the user has no access to the substring class. Unfortunately, not all C++ compilers support nesting of classes yet (where one class is defined within another class). And not all compilers handle the calling of member functions in the enclosing class from the nested class the same way. The Borland C++ 3.1 and cfront compilers do support nesting, so that is how I implemented it.<P>
An alternative method, which has a similar effect, is to define the class in the normal way, but put all the constructors in the private section and declare <I>SPString</I> to be a <I>friend</I> of <I>substring</I>. This means that a user will not be able to instantiate this class, but <I>SPString</I> will be able to use it. In either method, <I>SPString</I> must make <I>substring a friend,</I> so <I>substring</I> can access <I>SPString's</I> private variable <I>pstr</I>.<P>
Even though the user has no access to a substring, the <I>SPString</I> member function <I>substr</I> returns a <I>substring</I>. How can this work? By providing a constructor in <I>SPString</I> that can create an <I>SPString</I> from a <I>substring,</I> and by providing an assignment operator that allows a <I>substring</I> to be assigned to an <I>SPString</I>.<P>
The <I>substring</I> class basically just remembers the offset within the <I>SPString</I>, the length of the substring, and the address of the first character of the substring. This is necessary in order to allow the <I>substr</I> function to appear on the left hand side of an expression, so you can do the following:<P>
<pre>SPString mystr= "0123456789";
mystr.substr(3, 2)= "Ab";
// mystr becomes "012Ab56789"</pre>
The string will shrink or expand depending on whether the string being assigned is smaller or larger than the target substring. Thus, a problem to overcome is when the substrings overlap. So I check to see if the <I>SPString</I> I am assigning to is the same as the source string. If so, I make a copy of the source string, then copy it in. This way, I don't corrupt the source string as I copy it.<P>
<I>SPString::insert</I> is a private member function because it is only used by <I>substring.</I> It basically inserts a given length string into the current string, expanding or contracting the string array as required.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00FD">Stream Input for <B><I>SPString</I><A name="02DB_00FD"></B></FONT></h4></P>
The input stream operator for the <I>SPString</I> class is shown in <A href="list8.htm">Listing 8</a>.
 This will allow a line of text (terminated by a newline) to be loaded into an <I>SPString</I> variable. The input can come from any stream type, be it an in-memory stream (<I>strstream</I>) or the standard input stream (<I>cin</I>). For example:<P>
<pre>SPString instr;
while (cin){ // read until EOF
   cin &gt;&gt; instr; //read in line
// process line
   }</pre>
The tricky part is leaving the stream in a good state so that the typical syntax (above) used for reading a file will work. A line at end-of-file that is not terminated with a newline is considered a complete line, but the state the stream is left in is critical for the <I>while (cin)</I> test to work correctly. Specifically, the line must be read, but the stream must not be left in a fail state. The code in <A href="list8.htm">Listing 8</a>
will correctly return the last line if it is terminated by end-of-file, with the stream still in a non-fail condition. But the stream will be left at end-of-file, so the next call will fail as required, and the <I>while</I> loop will terminate at the proper time.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00FE">Class Interdependencies<A name="02DB_00FE"></FONT></h4></P>
When a class <I>A</I> references another class <I>B</I> as anything but a pointer or a reference, the class <I>B</I> must already have been defined. (The compiler must know what the size of the class is and what member functions it contains).<P>
This can be a problem if two classes refer to each other (a cyclic dependency). That could happen if class <I>A</I> contains a data member of class <I>B</I> and class <I>B</I> contains a data member of class <I>A</I>. The only way I know to get around this problem is to change one of the data members to a pointer. Then a forward declaration of one class is all that is needed to declare the other, which holds the pointer.<P>
I had many cyclic dependencies in SPLASH, and I was constantly shuffling declarations and definitions of classes around to solve them. In one case, I had to change the data member to a pointer, with the accompanying syntax changes in all the implementations that used that data member.<P>
The problem becomes even worse when templates are involved. Some compilers need to see the entire definition of a template member function before you can use it. Cyclic dependencies in this case can be very difficult to overcome. Thus, you should avoid cyclic dependencies in template classes, or use a compiler that is very intelligent in the way it handles templates. I am still trying to get SPLASH to compile with the GNU g++ and Zortech C++ compilers for exactly these reasons. Borland's C++ and the cfront compilers seem more tolerant in these cases, but now I have to rewrite some of the code to break these cyclic dependencies. If I had known of these problems ahead of time, it would have been easier to avoid them.<P>
<h4><FONT COLOR="#000080"><A name="02DB_00FF">Class Templates<A name="02DB_00FF"></FONT></h4></P>
One of the things to note when using templates is that all the implementation of template member functions should go into the header file. This is so the compiler can expand a template when it is needed. As I mentioned above, the compiler must have seen the template definition before it can expand the function, much like an inline function.<P>
Some compilers allow you to put the template definitions in a separate file and then it uses some technique to figure out what file to look at for the definition as it needs it. And some compilers seem to have difficulties finding a particular template, even though it appears to be staring them in the face. A work-around for this behavior is to specify the expansion in your program explicitly:<P>
<pre>// Pull in the output operator for
// a list of ints
ostream SPList&lt;int&gt;::operator&lt;&lt;
   (ostream&amp; os, int i);</pre>
This usually clears up any problems. Template handling currently varies considerably from compiler to compiler. It appears to be the least portable C++ construct I have used so far.<P>
<h4><FONT COLOR="#000080"><A name="02DB_0100">Summary<A name="02DB_0100"></FONT></h4></P>
The SPLASH distribution contains a number of examples of how to use the various features of this class library, including associative arrays and array slices which have not been covered here, and examples of how to use the stream operators for processing text files.<P>
I haven't been able to cover all the interesting things I discovered about C++ while I was writing this class library. I have pointed out some of the pitfalls and some useful techniques. I encourage you to get a copy of the source code and see how the various functions have been implemented. It is not the best and most efficient code, but then it wasn't designed to be; it was designed to work. I find the functions very useful for a wide range of applications, and reusability of classes is finally becoming a reality for me.<P>
<h4><FONT COLOR="#000080"><A name="02DB_0101">Bibliography<A name="02DB_0101"></FONT></h4></P>
<a name="1">1.</a>     Meyers, Scott, <I>Effective C++</I>. Reading, MA: Addison-Wesley, 1992.<P>
<a name="2">2.</a>     Ellis, Margaret A., &amp; Bjarne Stroustrup. <I>The Annotated C++ Reference Manual</I>. Reading, MA: Addison-Wesley, 1992.<P>
<h4><a href="sidebar2.htm">"How to Get SPLASH"</a></h4>

<h4><a href="../../../source/1993/oct93/morris.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
