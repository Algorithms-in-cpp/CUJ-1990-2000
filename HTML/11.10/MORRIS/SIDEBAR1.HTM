<HTML><HEAD><TITLE>October 1993/The SPLASH Class Library/Sidebar</TITLE></HEAD><BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">SPLASH Function Reference</FONT></h3><hr>
<BLOCKQUOTE>
<I>class SPList&lt;T&gt;</I> &#151; A list of any type specified by <I>T</I>.<P>
<I>T&amp; operator[n]</I> &#151; returns a reference to the element at index <I>n</I> (0-based). Generates an <I>ASSERT</I> error if <I>n &lt; 0</I>, can be used as an <I>lvalue</I>. Using an index greater than the current size of the list will cause the list to grow up to that index. The values in between will be undefined if <I>&lt;T&gt;</I> is a built-in type.<P>
<I>operator void*()</I> &#151; returns <I>NULL</I> if the list is empty, can be used like: <I>if(list) // not empty</I>.<P>
<I>int isempty()</I> &#151; returns <I>TRUE</I> if the list is empty, as an alternative for the previous technique.<P>
<I>void reset()</I> &#151; clears all elements in the list, but doesn't actually free up the storage until it is destroyed.<P>
<I>int count()</I> &#151; returns the number of elements in the list<P>
<I>int scalar()</I> &#151; Perl-like Synonym (alias) for <I>count ()</I>.<P>
<I>T pop()</I> &#151; removes and returns the last element on the list. If the list is empty the value returned is usually undefined.<P>
<I>void push(T x)</I> &#151; puts the single value <I>x</I> at the end of the list.<P>
<I>void push(SPList&lt;T&gt; l)</I> &#151; puts all the elements in the list <I>l</I> at the end of the list.<P>
<I>T shift()</I> &#151; removes and returns the first element in the list.<P>
<I>int unshift(T x)</I> &#151; puts the single value <I>x </I>at the start of the list.<P>
<I>int unshift(SPList&lt;T&gt; l)</I> &#151; puts all the elements in the list <I>l</I> at the start of the list.<P>
<I>SPList&lt;T&gt; reverse()</I> &#151; returns a list that is in the reverse order.<P>
<I>SPList&lt;T&gt; splice(offset, len, SPList&lt;T&gt; l)</I> &#151; removes <I>len</I> elements from <I>offset</I> (0-based) and inserts all the elements in the list <I>l</I> at the same position<P>
<I>SPList&lt;T&gt; splice(offset, len)</I> &#151; removes <I>len</I> elements from <I>offset</I> (0-based).<P>
<I>SPList&lt;T&gt; splice(offset)</I> &#151; removes all the elements from <I>offset</I> (0-based).<P>
<I>SPList&lt;T&gt; sort()</I> &#151; returns a list that has been sorted according to the rules that <I>T::operator&lt;()</I> returns for the type <I>T</I>.<P>
<I>class SPStringList</I> &#151; everything <I>SPList</I> does and ...<P>
<I>int split(str [,pat] [,limit])</I> &#151; appends the results of splitting the string <I>str</I> to the list. If <I>pat</I> is specified then any string that matches the RE (Regular Expression) <I>pat</I> is considered a separator to split on; the default is white-space. If <I>limit</I> is specified then no more than that number of elements is generated. If <I>limit</I> is not specified, then empty entries are stripped from the end of the list. If the RE includes subexpressions then they are inserted into the list as well. If <I>pat</I> is equal to the string <I>"' '"</I> then a special case is done which matches <I>awk's</I> handling of whitespace. If <I>pat</I> is an empty string <I>""</I>, then all characters are split into the list.<P>
<I>SPString join([pat])</I> &#151; Returns the string that is the result of combining all the elements in the list, and separating them by <I>pat.</I> If <I>pat</I> is omitted then the elements are separated by a space.<P>
<I>int m(const char *exp, targ [,opts])</I> &#151; Appends to the list all the subexpression matches that occured when applying the regular expression <I>exp</I> to the string <I>targ</I>. The number of matches is returned. The first element generated is the entire matched string.<P>
<I>opts:</I> (a <I>const char *</I> with default <I>""</I>)<P>
<I>i</I> &#151; Forces case insensitive match.<P>
<I>SPStringList grep(const char *exp [,opts])</I> &#151; returns a list of all the elements that matched the regular expression <I>exp</I>.<P>
<I>opts:</I> (a <I>const char *</I> with default <I>""</I>)<P>
<I>i</I> &#151; Forces the search to be case insensitive.<P>
<I>class SPString</I> &#151; A Standard C null-terminated string may be used anywhere that a SPString can be used and vice-versa. Individual characters may be read with the <I>[]</I> operator.<P>
<I>int length()</I> &#151; returns the length of the string.<P>
<I>char chop()</I> &#151; removes and returns the last character in the string.<P>
<I>int index(SPString str [, offset])</I> &#151; returns the offset in the string that matches the string <I>str,</I> starting at position <I>offset</I> if specified, otherwise searches the entire string. Returns -1 if no match is found.<P>
<I>int rindex(SPString str [, offset])</I> &#151; returns the offset in the string that matches the string <I>str,</I> starting at the end of the string &#151; <I>offset</I> if specified, otherwise searches the entire string. Returns -1 if no match is found.<P>
<I>substring substr(offset [, len])</I> &#151; returns the substring within the string that starts at <I>offset</I> and is <I>len</I> characters, if <I>len</I> is omitted the rest of the string is returned. This may be used as an <I>lvalue,</I> in which case the characters are removed, and the RHS of the expression is inserted at the same postion.<P>
<I>SPStringList split([,pat] [,limit])</I>- same as <I>S-PStringList::split()</I> but returns a list of splits.<P>
<I>operator&lt; operator&gt; operator&lt;= operator&gt;= operator== operator!=</I> &#151; These operators do what you would expect.<P>
<I>operator+</I> &#151; returns the result of concatenating two or more strings.<P>
<I>operator+=</I> &#151; replaces the LHS of the expression with the concatenation of the LHS with the RHS.<P>
<I>int m(const char *exp [,opts])</I> &#151; returns <I>0</I> if the regular expression <I>exp</I> fails to match the string. Returns 1 if a match was made.<P>
<I>opts:</I> (a const char * with default "")<P>
<I>i</I> &#151; Forces case insensitive match.<P>
<I>int m(const Regexp&amp; exp)</I> &#151; Same as above but takes a precompiled regular expression.<P>
<I>int m(const char *exp, SPStringList&amp; l [,opts]) </I>&#151; Loads the list <I>l</I> with all subexpression matches of the regular expression <I>exp</I> with the string. Returns <I>0</I> if no matches were made. Returns the number of matches if any.<P>
<I>opts:</I> (a const char * with default <I>""</I>)<P>
<I>i</I> &#151; Forces case insensitive match.<P>
<I>int m(const Regexp&amp; exp, SPStringList&amp; l) </I>&#151; Same as above but takes a precompiled regular expression.<P>
<I>int tr(search, repl [,opts])</I> &#151; replaces all occurrences of characters in <I>search</I> with the equivalent character in <I>repl</I>. If <I>repl</I> is empty then just counts the characters.<P>
<I>opts:</I> (a const char *, default is <I>""</I>)<P>
<I>c</I> &#151; complements the <I>search</I> pattern. Replaces all characters that are not in <I>search</I>, with the last character specified in <I>repl</I>.<P>
<I>d</I> &#151; deletes characters in <I>search</I> that don't have an equivalent <I>repl</I>.<P>
<I>cd</I> &#151; deletes characters not in <I>search</I>.<P>
<I>s</I> &#151; compresses sequences of translated characters in resulting string.<P>
<I>int s(exp, repl [,opts])</I> &#151; substitute the first substring matched by <I>exp</I> with the string <I>repl. $&amp;</I> in <I>repl</I> will be replaced by the entire matching string, <I>$1 - $9</I> will be replaced by the respective subexpression match. <I>\$</I> or \\ will insert a <I>$</I> or \ respectively.<P>
<I>opts:</I> (a <I>const char *,</I> default is <I>""</I>)<P>
<I>g</I> &#151; causes all occurrences of <I>exp</I> in the string to be replaced by <I>repl</I>.<P>
<I>i</I> &#151; Forces case insensitive matching.<P>
<I>class Regexp</I> &#151; Henry Spencer's, regular expression package, OO-ized.<P>
<I>Regexp(exp [,opts])</I> &#151; Compiles a regular expression that can be passed to one of the <I>m()</I> functions.<P>
<I>opts:</I> (an <I>int</I> with default <I>0</I>)<P>
<I>Regexp::nocase</I> &#151; Forces case insensitive match.<P>
<I>int match (targ)</I> &#151; returns 1 if the compiled <I>RE</I> matches <I>targ</I> returns <I>0</I> if not.<P>
<I>int groups ()</I> &#151; returns 1 + the number of subexpression matches found in the last <I>match()</I>. If the previous <I>match()</I> succeeded then the whole match is included in the count (hence + 1).<P>
<I>Range getgroup(n)</I> &#151; returns the range of the <I>n</I>th sub-group.<I>n</I> = <I>0</I> is the range of the entire match.<P>
<I>SPStringList m(exp, targ [,opts])</I> &#151; returns a list of all the subexpression matches that occured when applying the regular expression <I>exp</I> to the string <I>targ.</I> element <I>0</I> of the list is the first subexpression, element <I>1</I> the next, etc.<P>
<I>opts:</I> (a <I>const char</I> * with default "")<P>
<I>i</I> &#151; Forces case insensitive match.<P>
<I>xin &gt;&gt; astring</I> &#151; Text from the stream <I>xin</I> is loaded into astring; the text is expected to be terminated by <I>\n</I>, which is removed from the stream, but not put into <I>astring.astring</I> is cleared first.<P>
<I>xin &gt;&gt; astringlist</I> &#151; Each Text line, as defined above, is loaded into an element of <I>astringlist</I>, which is reset first.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
