

<HTML>
<HEAD>

<TITLE>October 1993/Random Event Simulation for C Programmers</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Random Event Simulation for C Programmers<A name="02DD_00F4"><A name="02DD_00F4"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="02DD_0000"><A name="02DD_0000">Martin Scolnick</font></h3><hr><blockquote><P>
<P><i><A name="02DD_0000"><A name="02DD_0000">After 16 years as an experimental physicist, five as a computer design engineer, and six as a professional programmer, Martin Scolnick can be found managing the engineering group at Z-World Engineering, in Davis, CA 95616, 916-757-3793 or Compuserve 76662,3406.</i></P><P>
Many discrete probability functions, such as those associated with flipping a coin or rolling dice, can be modeled by a single process: picking balls from a set of urns. If each urn contains black and white balls, the odds of picking one of the two colors will depend on the ratio of black to white. For example, with a ratio of 2:1, you would expect to pick black balls twice as frequently as white ones, as long as you replaced the ball after each pick to maintain the ratio.<P>
Most computer languages include a pseudo-random number generator function, such as random(n), which returns a random integer in the range 0 to n-1. Since all of the numbers in this range are equally likely to occur, the distribution is called "uniform." You can use uniformly distributed random integers in the "picking from an urn" process to generate the same probability function as flipping a coin:<P>
1.     Place one black and one white ball in each of two urns.<P>
2.     Use a random number generator to obtain a 0 or 1.<P>
3.     If the generator returns a 0, pick at random (i.e. blindfolded) a ball from the urn labeled "head"; otherwise, pick a ball from the urn labeled "tail." In either case, return the ball to its respective urn.<P>
4.     If the ball is black accept the result, head or tail; otherwise return to step 2.<P>
This process may seem unnecessarily complex, considering that you could use random(2) to directly produce a 0 or a 1 with the equal probabilities that are required to simulate a normal coin flip. However, the advantage of the urn paradigm becomes apparent when you simulate a "loaded" coin by changing the ratio of black to white balls in either of the two urns.<P>
To simulate the rolling of a die, increase the number of urns to six and obtain a random number in the range 0 to 5 from the random number generator. To simulate a loaded die, change the ratio of black to white balls from 1:1 to something else in one or more of the urns.<P>
To generalize the algorithm to an arbitrary discrete probability function of n events, use n urns in step 1 and load them with black and white balls in whatever ratio the function requires. In step 2, generate an integer in the range 0 to n-1 and use it to select an urn from which a ball is picked at random. If it's black, accept the random number generator's output as an "event;" otherwise, return to step 2.<P>
<h4><FONT COLOR="#000080"><A name="02DD_00F5">An Example Implementation<A name="02DD_00F5"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="02DD_00F6"><I>SumNPicks<A name="02DD_00F6"></I></FONT></h4></P>
The function <I>SumNPicks</I> (<A href="list1.htm">Listing 1</a>)
 will return "events" at the statistical frequency implied by any of a wide range of "pick from an urn" models. A specific model is selected by specifications in the first three fields of a <I>RAND</I> structure (<A href="list2.htm">Listing 2</a>)
.<P>
The number of distinct objects, <I>nobjs,</I> refers to the two sides of a coin, or the six faces of a die, or the number of intervals in the domain partition of the normal distribution, depending on which model (probability function) is selected. The number of random picks, <I>npick,</I> refers to the number of flips or the number of dice, etc. When <I>npick</I> is <I>1</I>, the number of distinct events, <I>nbin,</I> will be the same as the number of distinct objects. When <I>npick &gt; 1, nbin</I> will equal the number of summing events that are possible when the objects are picked <I>npick</I> times (e.g., for two dice: <I>nobjs = 6; npick = 2; nbin = 11</I>). The label <I>nbin</I> refers to the number of bins (intervals) that are used for displaying statistical event data in a histogram. While many other kinds of events can be constructed from several picks, the present program is limited to events that can be generated by summing the results of picking objects and replacing them.<P>
To simplify some of the display routines, events are treated as indices. This implementation limits the field of events to positive integers and uses the ordinal value of an event to find the label that describes it. For example, in one simulation, <I>index = 0</I>, could mean the event was a "Head," but in another simulation it might mean that a dart hit the target at a point in the zeroth interval from the bullseye. The demonstration program finds the appropriate label by using the event as an index into the array selected by the pointer in the last field of the <I>RAND</I> structure. As a conceptual aid for distinguishing between these two uses of integers, as cardinal numbers and as event indices, the type <I>index</I> is defined in <A href="list2.htm">Listing 2</a>.
<P>
In simulations where the model requires units of length or voltage, generating labels from the indices returned by <I>SumNPicks</I> requires additional code. In <A href="list6.htm">Listing 6</a>,
 for example, an extra statement adds a random noise value to the input signal in <I>AddNoise</I>; in <I>RandWalk</I> (<A href="list8.htm">Listing 8</a>)
 <I>x</I> and <I>y</I> are assigned lengths. Note that these statements apply scaling factors as well as offsets (viz. "(<I>nbin</I>-1)" is an offset that determines which index corresponds to 0 units), so <I>index = 0</I> can mean "-0.1 volts," and<I> index = 6</I> can mean a random walk displacement of "0 microns."<P>
<h4><FONT COLOR="#000080"><A name="02DD_00F7">The Demonstration Program<A name="02DD_00F7"></FONT></h4></P>
The driver in <A href="list3.htm">Listing 3</a>
and <A href="list4.htm">Listing 4</a>
excercises three sample applications: a module which displays histograms, a module which simulates a random walk, and a module which simulates the effect of various filters on a "noisy" electronic signal. Each application module is invoked with each of the probability distribution models specified in the <I>tbl</I> array of <I>RAND</I> structures (initialized in <A href="list3.htm">Listing 3</a>)
. On each pass through the main loop, the driver copies one of these <I>RAND</I> structures into a local buffer, <I>xampl</I>. The demonstration program includes specifications for distributions that correspond to:<P>
<UL><li>a single coin toss</li>
<li>a single loaded coin toss</li>
<li>two coins tossed</li>
<li>one die thrown</li>
<li>two dice thrown</li>
<li>two loaded dice thrown</li>
<li>four dice thrown</li>
<li>the normal distribution</li>
<li>a uniform circular distribution</li></UL>
<h4><FONT COLOR="#000080"><A name="02DD_00F8">The Histogram Module<A name="02DD_00F8"></FONT></h4></P>
<I>MakeHistogram</I> (<A href="list5.htm">Listing 5</a>
and <A href="list6.htm">Listing 6</a>)
 uses the model specifications in <I>xampl</I> to generate simulated statistical data, and displays the associated frequency histogram.<P>
Note how many flips of an "honest" coin are required before the heads:tails ratio gets close to 50:50, and how long it takes for the normal distribution to shape up. The distribution shown in <A href="fig1.htm">Figure 1</a>,
 for example, represents over 5,000 trials. In the case of the loaded coin, heads are twice as likely to occur as tails, so the large-number statistics are expected to show 66.67 percent heads and 33.33 percent tails. In the loaded dice case, the <I>1</I> (<I>index</I> = 0) is twice as likely to occur as any of the other five numbers. The histogram for two loaded dice, therefore, shows a bias for all sums less than <I>8</I> (as can be seen in <A href="fig2.htm">Figure 2</a>)
 because these rely on combinations that include pairs with <I>1</I>, whereas sums of <I>8</I> or larger rely entirely on pairs that exclude <I>1</I>.<P>
<h4><FONT COLOR="#000080"><A name="02DD_00F9">Random Walk<A name="02DD_00F9"></FONT></h4></P>
This exercise (<A href="list7.htm">Listing 7</a>
and <A href="list8.htm">Listing 8</a>)
 demonstrates the use of computer generated random variables in simulating phenomenon such as Brownian motion, molecular dispersion, and diffusion. Here, the selected probability function is used two times, once to determine the x-component of a step and a second time for the y-component. (The simulation which uses the uniform circular probability model calls the probabiltity model only once, since the step length is fixed.) When the path intercepts a boundary, the simulation stops and displays the number of steps. Because steps of one pixel would obscure the geometric structure of the paths, <I>RandWalk</I> amplifies the steps by the scaling factor, <I>sf</I>.<P>
When the coin flip model is used, each step component has only two options, 1 unit, so the "walk" is constrained to diagonal paths, as shown in <A href="fig3.htm">Figure 3</a>.
 This also means that each step has the same length, namely <IMG SRC="equat1.gif"> units. On the other hand, when two dice are used, each step component has 11 possibilities, five different lengths in either the positive or negative direction and the possibility of a zero step, where no movement occurs.<P>
Of the sample probability models, the last one, "uniform circular," is probably most appropriate to a simulation of molecular dispersion. In this case (<A href="fig4.htm">Figure 4</a>)
 2<FONT FACE="Symbol">p</FONT> radians have been divided into 24 equal angles and the probability for picking any one of them is uniform. The fact that the size of each step is a constant may be acceptable if we equate it to the mean free path of a molecule in a gas. In any case, the choice of probability function depends on the objective of the simulation.<P>
The loaded coin model generates statistics that obey the binomial law. That is, if the coin is loaded for heads and if a head means a step toward a border, we can define such a step as a "success" in a "repeated Bernoulli trial." In this case, the binomial law gives the probability for obtaining <I>k</I> successes and <I>n-k</I> failures after <I>n</I> tries. Since the mean for this distribution is <I>np</I>, where <I>p</I> is the probability for success and <I>1-p</I> is the probability for failure, the expected number of steps to wander from the origin to a border, <I>D</I> steps away, is <I>n</I> = <I>D/(2p-1)</I>. In this program, each step in the loaded coin model has been scaled to 11 pixels and the origin has been placed in the center of a 400 x 400 pixel window, so <I>D</I> = <I>200/11</I> = <I>18</I> steps. As noted earlier, <I>p</I> = <I>0.667</I>, so we should expect a "molecule" to reach a border after <I>n</I> = <I>54</I> steps, on average. To verify this result as a reasonable estimate, run the program, say ten times, and compute the average of the number of steps that it took for the "molecule" to reach a border (a total "verification" would require an infinite number of samples). Note also that, because the coin is biased for "heads," the path almost always intercepts a border in the top left quadrant.<P>
<h4><FONT COLOR="#000080"><A name="02DD_00FA">Electronic Filters<A name="02DD_00FA"></FONT></h4></P>
<I>MakeScopeSignals</I> (<A href="list5.htm">Listing 5</a>
and <A href="list6.htm">Listing 6</a>)
 simulates the appearance of a noisy square wave on an oscilloscope screen and demonstrates the effects of three different digital filters on noise. The results in <A href="fig5.htm">Figure 5</a>
and <A href="fig6.htm">Figure 6</a>
show how different distributions can simulate different types of noise. The noise component of the "noisy signal" in <A href="fig5.htm">Figure 5</a>
is generated using a normal distribution. Since the domain of this distribution is arbitrarily partitioned into 25 intervals, there are 13 different amplitudes of noise (positive, negative and zero), with zero being the most likely. The noise in <A href="fig6.htm">Figure 6</a>,
 on the other hand, was generated by the single coin flip algorithm, so it has only two possibilities; it adds either a positive or a negative increment of constant magnitude to the signal.<P>
The square wave (the "signal") is a digitized representation of a continuous voltage wave form; it's a series of numbers that represents samples of a signal taken per unit time. The algorithms for generating random numbers are the same as in the random walk, except that instead of summing them to get a net distance from a fixed point, one random number is added to each number in the series to simulate noise.<P>
<h4>The Filters</FONT></h4></P>
In both cases, the resulting "noisy signal" is then processed by three filters: a "running average" filter, a simulated RC filter, and a differentiator. All three filters are implemented as weighted average computations.<P>
In general, a "weighted average" filter replaces the <I>i</I>th number in a series with the sum of the weighted values of itself and its neighbors. For example, we could replace the third number in the series, <I>8, 10, 9,</I> with<P>
<pre>(8*W1+10*W2+9*W3) / (W1+W2+W3)</pre>
where the <I>W</I>'s are referred to as "weights." When <I>W1=W2=W3,</I> the filter just replaces <I>10</I> with the average of <I>8, 10, 9</I>.<P>
If each number in a series is replaced with the average of itself and <I>n</I> of its neighbors (a "running average" filter), some of the high frequency noise will be smoothed out, especially if the average value of the noise is <I>0</I> and <I>n</I> is large. However, if <I>n</I> is too large, some of the useful signal components will also be lost. Using a geometric series for the values of the weights, simulates the effect of a "low-pass RC" filter of the kind that might be found in the bass control of a radio. The differentiator is an interesting hybrid of high-pass and low-pass filter; in effect, it differentiates data that have been smoothed by a running average filter. As the number of weights is reduced, however, it begins to perform more like a high (frequency) pass filter.<P>
The <I>Filter</I> routine is responsible for the convolution of data and weights. This single routine simulates all three filters, by applying the weighting schemes from the <I>filtr_wts</I> array (initialized in <A href="list3.htm">Listing 3</a>)
. The first two numbers in each of the <I>filtr_wts</I> arrays are the number of weights and the sum of the weights, respectively; the remaining numbers are the weights themselves. Pointers to this table, to a series of noisy data, and to a space for storing filtered data are passed to <I>Filter</I> in <A href="list6.htm">Listing 6</a>.
<P>
The first filter array results in a running average. Note (in <A href="fig5.htm">Figure 5</a>
and <A href="fig6.htm">Figure 6</a>)
 how a noisy square wave is transformed to a less noisy but somewhat trapezoidal wave form by this filter. By increasing the number of weights, the square wave will get smoother, but its slopes will become less steep.<P>
The second array represents a low-pass RC filter, as indicated by the geometric progression. This filter tends to round off the leading edge of a square wave and causes the trailing edge to decay exponentially. Increasing the number of weights will result in smoother data, but will increase the distortion at the leading and trailing edges.<P>
The third array represents a differentiator. In this filter, the first six weights are negative and the last six are positive. This sharp polar division is characteristic of differentiators. Because the center weight is zero and the magnitudes of the neighbors are symmetrically distributed (constant, in this case), when applied to a series of constant numbers, this filter will produce a constant zero output &#151; exactly what we want from a differentiator.<P>
<h4>Conclusion</FONT></h4></P>
The uniform output of the C function, <I>random(n)</I>, can be "shaped" into random integers with prescribed frequency distributions that have many applications. Clearly, this program can be expanded in a number of ways. For use as a statistics teaching aid, a variety of probability functions and <I>RAND</I> records can be added to the existing code and iterative loops can be used to compute the means and variances, etc. of simulated samples. The additional distributions would probably require a menu driven program. For use as an engineering tool, the <I>RAND</I> tables, the filter weight arrays, and real or simulated input data can be read from external files to test filter designs. If the program is modified to accept noise amplitude as a command line argument or as a menu option, users can control both the nature of the noise and the signal-to-noise ratio in their analysis. If the filtered data are also written to external files, they can be processed many times by the same or different filters. More elaborate versions of this program can be used in more complex programs. For example, radiation shielding requirements can be estimated by simulating the high energy particle scattering that results in a nuclear beam experiment.<P>
<h4>Sidebar: <a href="sidebar1.htm">"Probability Review"</a></h4>

<h4><a href="../../../source/1993/oct93/scolnick.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
