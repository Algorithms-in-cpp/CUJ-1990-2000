<HTML><head>
<title>July 1995/A C++ Class Generator/Sidebar</title></head>

<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h3 align="center"><FONT FACE="Garamond" COLOR="#000080">Design Issues Supported By CLASSGEN</FONT></h3><hr>
<BLOCKQUOTE>
As stated in the article, I intended that <I>CLASSGEN</I> function as a repository of design experience. One way <I>CLASSGEN</I> does this is by forcing you to decide whether or not to include certain features in your class. I list these features as follows:<P>
<h4>Copy Constructor and Assignment Operator</FONT></h4></P>
<I>CLASSGEN</I> urges you to make up your mind about the copy constructor and assignment operator issue. If you choose to define them, <I>CLASSGEN</I> will generate these functions' prototypes and empty bodies for you (with a ready-made test for assignment to self in <I>operator</I>=). If you choose "Default," <I>CLASSGEN</I> will let the compiler generate its shallow, memberwise copy functions. If you do not want these functions at all, <I>CLASSGEN</I> will generate two private prototypes and no body, so that either the compiler or the linker will complain if someone calls them. Scott Meyer's book, <I>Effective C</I>++ [1] contains a thorough discussion of the copy constructor and assignment operator.<P>
<h4>Inheritance</FONT></h4></P>
<I>CLASSGEN</I> expects you to decide from the very beginning whether your new class is meant to be derived somewhere down the line. If it is, check the "Virtual destructor" box in the user interface. Selecting a virtual destructor will ensure that the appropriate derived-class destructor gets called in polymorphic code. If your class is not inherited, do not ask <I>CLASSGEN</I> for a virtual destructor "just in case," especially if your class has no other virtual functions, unless you want all your objects to house a pointer to a useless vtable (again, see [1] for a thorough explanation). Oddly enough, the only difference between the two in generated source is the keyword <I>virtual</I> in the destructor's prototype. I decided to make this feature a part of <I>CLASSGEN</I> because I experienced hours of random general protection faults last time the keyword was missing.<P>
<h4>Class-Specific <B><I>new</I></B> Handler</FONT></h4></P>
Checking this option will cause <I>CLASSGEN</I> to add three lines of code to create a class-specific <I>new</I> handler. The <I>new</I> handler rings a <I>CLASS</I>-specific bell if memory allocation fails while attempting to create a new class instance. To set up the handler, the generated code calls standard function <I>set_new_handler</I>, which establishes a static member function <I>CLASS: :NoMemory</I> as the handler. After memory is successfully allocated, the old handler is restored. [1] shows a somewhat more complicated way of doing it.<P>
<h4>Instance Count</FONT></h4></P>
This is a feature that might prove useful in actual design (to build a singleton, for example), as well as in debug stages. If the instance count drops to zero in the class invariant, your destructor has been called one too many times. You might also want to display its value when out of memory.<P>
<h4>Emdedded CRC</FONT></h4></P>
I decided to throw in this firewall against wild pointers after hours of fighting with an obscure ISDN programming interface. Basically, the class invariant peforms a checksum at memory address <I>this</I>, over a length <I>sizeof</I>(*<I>this</I>), and blows the whistle if the result doesn't match the expected value. Obviously, you should call the private method for updating this value at the end of all your non-const member functions. You should also call the class invariant at the beginning of all member functions. Since <I>CLASSGEN</I> generates code for altering the CRC value in the destructor, this option will also protect against using references to already destroyed objects. As for uninitialized objects, it is highly unlikely that a garbage value matches the computed CRC of the surrounding garbage zone. Since this kind of check adds a heavy run-time overhead, it all recompiles to nothing when <I>NDEBUG</I> is defined. (You might want to do the same thing whenever you add code meant for debugging and/or profiling to the pattern files.)<P>
</BLOCKQUOTE>
</BODY>
</HTML>
