

<HTML>
<HEAD>

<TITLE>January 1995/We Have Mail</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<hr><h2 align="center"><font color="#800000">We Have Mail<A name="0036_001A"><A name="0036_001A"></font></h2><hr>
<BLOCKQUOTE>
<A name="0036_0000"><A name="0036_0000">Dear C/C++ Users Journal:<P>
I just bought the September 1994 issue of your magazine. On page 19, David Singleton has an article on Windows memory management. However, this article is so full of bugs as an article on this subject can possibly get. The first line of the article states that "It is generally recomended that programs developed to run under MS-Windows use the medium memory model." This is just plain wrong. The recomended memory model for Windows programs is large. Medium model was for real mode Windows.<P>
But probably the worst error is the article's emphasis on <I>GlobalLock</I> and <I>GlobalUnlock</I>. These functions are only needed for real mode Windows, and as we all know, real mode Windows disappeared along with Windows 3.0. Windows 3.1 can move memory at any time without invalidating pointers. This, of course, is due to its use of a Local Descriptor Table (LDT) to translate selector:offset to a logical address.<P>
In fact, Microsoft now recomends using <I>malloc/free</I> or <I>new/delete</I> (which maps to <I>malloc/free</I>) for memory allocations. Both Visual C++ and Borland C++, and probably the rest of the Windows C/C++ compilers, use a suballocation scheme in <I>malloc</I>, similar to the one presented in the article. But even though the article assumes real mode Windows, it actually requires protected mode to work. On page 25, <I>FarHeapBlock::GetHbFromHandle</I> is defined as follows:<P>
<pre>FP_FHB FarHeapBlock::GetHbFromHandle(HGLOBAL h)
{
   FP_FHB p fhb = (FP FHB) GlobalLock (h);
   ASSERT (p_fhb != NULL);
   GlobalUnlock (h);
   return p_fhb;
}</pre>
The <I>GlobalUnlock</I> call actually tells Windows that it's okay to move the block. The pointer returned from the function is therefore invalid! It can be used safely only in standard or enhanced mode, and in real mode only until the next <I>GetMessage or PeekMessage </I>call. I find it amazing that a magazine starts off its Windows Programming issue with such an outdated and erroneous article. The only thing I got out of it was the name of a magazine to stop buying, and the name of a consultant firm to avoid.<P>
Martin Larsson, author of several unknown utilities for DOS and Windows<br>
e-mail: larsson@cs.colorado.edu<P>
David Singleton replies:<P>
Dear Editor,<P>
Thank you for sending me a copy of Martin Larsson's letter. Interesting and provocative reading. I give my response below, interlaced with excerpts from Martin Larsson's original text [in <I>italics</I>]. In the interests of courtesy, I am copying this reply to Larsson. If he would like to engage in further dialog direct with me, I would be delighted to respond.<P>
<I>The recomended memory model for Windows programs is large. Medium model was for real mode Windows.</I><P>
I would ask Larsson to justify his statement that the recommended model for Windows Programming is large. My justifications for my statement are (in no particular order of importance):<P>
a. There are probably still some people out there using Windows 3.0. We do need to remember them.<P>
b. The medium memory model allows one to run more than one instance of a program. You cannot do this with the large model. (I will willingly concede that there may be occasions when it might be disastrous to allow more than one instance of a program to run.)<P>
c. The Visual C++ V1.5 AppWizard utility, when it builds a program framework, defaults to the medium memory model. It seems to me from this that Microsoft, themselves, endorse the use of the medium memory model as the preferred starting model.<P>
d. Medium memory models are generally smaller and faster because near pointers can be used to access the data in the local data segment.<P>
e. Finally, I would refer to Charles Petzold's book <I>Programming Windows 3.1</I>, published by Microsoft Press, Chapter 7, Page 285. His book is to all accounts something of an authority on Windows programming. Petzold says: "Windows programmers who require more than 64 KB of data in their programs might be feeling a little nervous at this point. They have a right to be because the compact and large models are not recommended for Windows programs. This does not mean they can't be used however."<P>
<I>But probably the worst error is the article's emphasis on </I>Global Lock and Global Unlock.<P>
Larsson has made a significant error in his statement concerning the use of <I>GlobalLock</I>. It is perfectly true that there is no longer the need to physically lock memory when using Windows 3.1. However, <I>GlobalLock</I> performs one essential additional function that Larsson seems to have forgotten. It translates the <I>HGLOBAL </I>returned by <I>GlobalAlloc</I> into a far pointer to the allocated memory. It is certainly Microsoft policy to use <I>GlobalLock</I> in conjunction with <I>GlobalAlloc</I>, as evidenced by the example code in Microsoft KnowledgeBase articles Q77226 and Q74197.<P>
<I>In fact, Microsoft now recomends using </I>malloc/free<I> or </I>new/delete<I> (which maps to </I>malloc/free<I>) for memory allocations.</I><P>
If one is using a large memory model or a medium memory model with less than 64 KB of data, then, of course, one should use <I>malloc/free</I> or <I>new/delete</I>. It is by far the easiest way of getting more memory in these cases. However, if one wishes to use a medium memory model and have more than 64 KB of data, then one must use the Windows global memory services, as discussed in the article.<P>
<I>But even though the article assumes real mode Windows, it actually requires protected mode to work.</I><P>
I regret that Larsson has again made a small error. I quote from the Microsoft <I>SDK Programmers Reference Manual</I>, Volume 2, concerning GlobalUnlock: "With movable or discardable memory, this function decrements the object's lock count. The object is completely unlocked and subject to moving or discarding <I>if the lock count is decreased to zero."</I><P>
The emphasis above is mine. The marked phrase is the key to answering Larsson's concern. Each <I>FarHeapBlock</I> holds references to the previous and next <I>FarHeapBlocks</I> in the chain of <I>FarHeapBlocks</I>. I decided to hold these references as <I>HGLOBALs</I>. To get the corresponding address, I needed to use <I>GlobalLock</I> with an equivalent <I>GlobalUnlock</I> (it is always necessary to use these as a pair) to get the corresponding address.<P>
This is what the function <I>FarHeapBlock:: GetHbFromHandle</I> does for me. On entry to this routine, I would expect the relevant global heap lock count to be 1, as the <I>HGLOBAL</I> points to a block that has already been allocated. The call to <I>GlobalLock</I> will increase the lock count to 2. The subsequent call to <I>GlobalUnlock</I> will return the lock count to 1. As the function never causes the lock count to go to zero (and hence unlock the block), Larsson's comment is invalid<P>
I look forward to seeing Martin Larsson's response to my points. I am prepared to stand by my article and I believe that the above responses have refuted all of his comments on the article.<P>
Best wishes,<P>
David Singleton<br>
100265,3625@compuserve.com<P>
Larsson replies:<P>
Here's my reply to David Singleton's comments.<P>
<I>There are probably still some people out there using Windows 3.0. We do need to remember them.</I><P>
So? The large model runs on Windows 3.0 too doesn't it? I will agree that Windows 3.0 has a bug (how can I not?) that pagelocks all but the first segment if you have multiple data segments. So, there can be no movement of the segments. Not good. However, with Windows 95 coming up, I don't think we should limit ourselves by bugs in Windows 3.0. It's as simple as saying, "The program runs on Windows 3.0 and greater. However, if you experience 'out of memory' errors on Windows 3.0, you might want to upgrade to Windows 3.1. Windows 3.0 has a bug that..." You get the idea.<P>
Remember, this <I>only</I> applies to programs with multiple writeable data segments. And they can't use the medium model anyway. Also, remember that Windows is a large model program. So when you use the medium model, you're in fact dealing with mixed-model programming. This is, and has always been, a real pain since you have to remember which pointers are far and which are near.<P>
<I>The medium memory model allows one to run more than one instance of a program. You cannot do this with the large model.</I><P>
This is simply not true. The limitation is that you cannot have more than one read-write segment, as long as all segments but one are read-only. Multiple instances works just fine in the large model (<I>Programming at large</I>, Dale Rogerson, Microsoft Developer Network Technology Group). MS-compilers from 8.0 and up (VC++ 1.0), combine your data into one segment if possible. This means that your large model program automaticaly can run multiple instances. Of course, Borland and Watcom always did this.<P>
<I>The Visual C++ V1.5 AppWizard utility, when it builds a program framework, defaults to the medium memory model. It seems to me from this that Microsoft, themselves, endorse the use of the medium memory model as the preferred starting model.</I><P>
Read, "The C/C++ Compiler Learus New Tricks," by Dale Rogerson, written Aug. 28, 1992, revised Jan. 27, 1993. The article is available on The Microsoft Developer Network. The conclusions is that Microsoft C/C++ version 7.0 introduces new programming practices that facilitate the development of applications for Windows version 3.1 in protected mode. Programmers can now:<P>
<UL><li>Use the large memory model. Large-model programs are compatible with the protected modes of Windows version 3.1 and can have multiple instances.</li>
<li>Use <I>_fmalloc</I>. With C/C++, <I>_fmalloc</I>, which is the large or model-independent version of <I>malloc</I>, performs subsegment allocation and conserves selector usage.</li></UL>
<I>Medium memory models are generally smaller and faster because near pointers can be used to access the data in the local data segment.</I><P>
<I>Microsoft Systems Journal</I>, 1993, Volume 8, Number 10, Questions &amp; Answers, C/C++, last question, summary: "The upshot is: if you have a good C++ compiler that supports Windows, don't fret over memory management. But do use the large model... Of course, you can always get the memory in the medium model if you really want, by declaring everything far, and allocating everything with <I>_fmalloc</I> of <I>farmalloc</I>, but then you have all sorts of problems in C++ trying to allocate objects with <I>new</I> so their constructors get invoked.<P>
Why subject yourself to such torture? Anyone who tells you that performance is slower in the large model is probably a frustrated assembly-language programmer, not to be trusted. It's true, of course, it is slower. But not much. Your users will probably never notice. If a particular section of your code is performance-critical, you can always use near pointers, or even rewrite it in assembly. The large model is simply the easiest way to get gobs of memory."<P>
Yes, this is on C++, but most of it applies to plain C also. The large model just makes life so much easier.<P>
<I>Finally, I would refer to Charles Petzold's book </I>Programming Windows 3.1<I>, published by Microsoft Press, Chapter 7, Page 285. His book is to all accounts something of an authority on Windows programming.</I><P>
I agree on one point, Petzold's book is a very good book on Windows programming. But, chapter 7 was not updated for 3.1. Therefore, it should not be accepted as <I>the</I> authority on Windows 3.1 memory management. I'm sorry, but Petzold's just plain wrong. Ask the guys on <I>comp. os.ms-windows.programmer.memory </I>what they think of Chapter 7 in Petzold's otherwise exellent book. You'll get the idea.<P>
<I>Larsson has made a significant error in his statement concerning the use of GlobalLock.</I><P>
I guess I wasn't clear enough. My point is that there's no reason for locking and unlocking memory all the time. Lock once, when you allocate, using <I>malloc, farmalloc, GlobalAllocPtr</I>, or <I>new</I>. Unlock once, when you free the memory using <I>free, farfree, GlobalFreePtr</I>, or <I>delete</I>. Now, there are exceptions, just as with everything in Windows. For instance, you can allocate memory in a dialog procedure and return it to 'the calling function. However, since <I>DialogBox</I> only returns an integer, you'll have to return a handle (16-bit). You could of course use a global or member data in C++. Or you could send a message to the parent of the dialog.<P>
<I>As the function never causes the lock count to go to zero (and hence unlock the block), Larsson's comment is invalid.</I><P>
So, what you're saying is that you call <I>GlobalLock</I> and <I>GlobalUnlock</I> totally unnecessary since you could just as well keep a copy of the pointer. Quite interesting when you're using the medium model to gain speed. And, you have memory locked all the time, quite contrary to what Petzold recommends. Of course, Petzold's wrong, memory <I>can</I> be locked for the whole duration of the program. But you seem to contradict yourself when you follow Petzold's advice on memory model, but not on when to lock and unlock the memory you allocate.<P>
<I>I am prepared to stand by my article and I believe that the above responses have refuted all of his comments on the article.</I><P>
Well, I think I've made my points clearer. All references are to Microsoft Developer Network CD #8.<P>
Martin Larsson<P>
Singleton replies:<P>
Dear Larsson,<P>
Thanks for your last message. As the messages seem to be getting rather long, I will not go repeating everything. I will just repeat any necessary salient points.<P>
<I>So? The large model runs on Windows 3.0 too doesn't it? I will agree that Windows 3.0 has a bug... You get the idea.</I><P>
Point noted, thanks<P>
<I>Remember, this only applies to programs with multiple writeable data segments. And, they can't use the medium model anyways.</I><P>
Agreed.<P>
<I>So when you use the medium model, you're in fact dealing with mixed-model programming. This is, and has always been, a real pain...</I><P>
Agreed. However, that is one nice thing about using MFC. Most of the time, one does not need to worry about near and far pointers, although there are, of course, occasions when one does need to remember which are which and that can, I agree, sometimes be a pain.<P>
<I>The limitation is that you cannot have more than one read-write segment, as long as all segments but one is read-only.</I><P>
Correction accepted. That is really what I meant to say. In my article I was, though, dealing with the case where one would want more than one segment's worth of read-write data (i.e., more than 64 KB of data) and, in this case, my assertion that one cannot have more than one instance of a program is correct. Thanks for the references to the two Microsoft articles and for your comments on Chapter 7 of Petzold's books. I shall add them to my data bank.<P>
<I>My point is that there's no reason for locking and unlocking memory all the time.</I><P>
I entirely agree with your comment. There is absolutely no need to lock and unlock memory all the time. You raised this comment with reference to my function <I>FarHeapBlock::GetHbFromHandle</I>. My reason for doing this is contained in the article, where I say, "I use doubly linked lists to keep track of individual <I>FarHeapBlocks</I>. Thus, a <I>FarHeapBlock </I>contains pointers both to the previous <I>FarHeapBlock</I> and to the next <I>FarHeapBlock</I>. In the case of <I>FarHeapBlocks</I>, I decided to store the <I>HGLOBAL</I> of the previous and next blocks, rather than a far pointer."<P>
Whenever I need to recover the actual address of a <I>FarHeapBlock</I>, I call <I>FarHeapBlock::GetHbFromHandle</I>, using <I>GlobalLock</I> and <I>GlobalUnlock</I> to do the necessary conversion. The fact that they set and release locks is, from this function's perspective, a side-effect. What I want is the <I>HGLOBAL</I> to <I>FP_FHB</I> conversion.<P>
The article then goes on to say, "With hindsight, I could have used far pointers instead. Indeed, this could probably give slightly more efficient code." I am sure you would say that I could delete 'probably' and 'slightly' from the above. With hindsight, I would agree with you.<P>
I will close by thanking you for this fascinating discussion. It is always good scientific and engineering practice to test one's arguments by open debate. I too use the large model when I consider it appropriate. However, I also use the method set out in my article, when that is appropriate.<P>
Best wishes,<P>
David Singleton<P>
<I>In fairness to David Singleton, I should report that we sat on his article for a number of months before publishing it, then failed to check whether all the information was still timely. We indulge in such antics less and less often, and we check our accepted submissions better all the time, but we &#151; and our authors &#151; will never get it perfect.</I><P>
<I>Windows, in particular, is a bottomless pit of complexity. The preceding discussion reminds me of numerous debates from the distant past over how best to perform various operations under various System/370 operating systems. Microsoft has reinvented IBM a quarter century later. I cross my fingers every time one of our authors describes one side of this latest elephant. They are more courageous than I am. &#151; pjp</I><P>
Bill,<P>
Re-October 1994 <I>C/C</I>++ <I>UJ:</I> yet another fine issue... I have mixed, mainly queasy, feelings over Bob Jervis's proposal for a (C++)--! It's true that C++ has grown like Topsy and even the experts are confused. (See, for example, the theological altercations in any issue of <I>The C++ Report</I>.) But surely all programming languages have had similar growing pains as we've struggled to gain familiarity with "arcane" (i.e., new) concepts and features. Take the C declaration syntax (please). And consider that after 20 years or so, we still see "not quite accurate" <I>CUJ</I> articles using or explaining C arrays-as-pointers. If one of Bob's motivations is to ease the compiler-writer's burden, forget it. Compiler-writers, <I>in rerum natura</I>, thrive on impossible challenges &#151; specification ambiguities being especially welcomed (and provably unavoidable from the lessons of Algol 68). Otherwise, pjp would be editing <I>The Machine-Language Users Journal</I>. My suspicion is that as the C community mulls and fights over Bob's "minimalist" OOPL, his (C++)-- will post-accrete "one damn good thing after another,"aping the agonizing stepwise refinement (some might call it unfinement) of Bjarne's original "C with Classes" (1979) into ANSI/ISO C++ (1994). The story is uniquely documented in <I>The Design &amp; Evolution of C++</I> (Bjarne Stroustrup, Addison-Wesley, 1994), which traces the pros and cons of each increment. Consider just one item not mentioned by Bob: the C++ "exposure" specifier <I>protected</I><I>.</I> This public/private "compromise" was added for members in Release 1.2 and for base classes in Release 2.1. For member functions, Bjarne still considers <I>protected</I> to be a "fine way of specifying operations for use in derived classes." However, <I>protected</I> data members are now frowned on, even by Mark Lipton who pushed for the change (ibid, p. 302). Will Bob exclude <I>protected</I><I> </I>completely as "inessential," or, learning from C++ experience, confine it to member functions. I smell a good twelve months argufying on this point alone. It seems that (C++)-- will never "catch up" since "All is Flux," especially C++ itself. PAX, etc.<P>
Stan Kelly-Bootle<br>
Contributing Editor,<br>
<I>UNIX Review</I> and <I>OS/2 Magazine</I><P>
PS: Re-your name: the Celtic diphthong <I>au </I>is usually pronounced <I>ow</I>, as in <I>plow</I>, not <I>aw</I>, as in <I>plaudit</I>. However, both sounds seem appropriate! BTW: Peter van Linden offers $1 for each error found in his <I>Expert C Programming</I>. I reported that he had spelled your name <I>Plaugher</I> on two occasions, but he only sent me <I>one</I> dollar!<P>
<I>Whew! It might have been easier refereeing the previous discussion on Windows programming than replying to a classic Kelly-Bootle missive. (C++)-- is a cute name, but an invalid expression, in Standard C at least. More important, not even Jervis is proposing making C a full-fledged OOPL. The idea is to crib a bit of prior art that has proven utility at low cost in complexity, not to invent yet another language on the fly as part of the standardization process.</I><P>
<I>As for my name, I'm told it originally hails from Alsace Lorraine. A slippery dipthong like au shifts neatly between French and German pronunciation, depending on who's in charge in a given year.</I><P>
Dear Sirs!<P>
My comments about the idea of the modifications to C mentioned in the article "All is Flux" (<I>CUJ</I>, October 1994 by B. Jervis): YES! YES! YES! YES! YES! YES! ... ad infinitum! The only problem with it: It may kill C++. Then again we (real everyday programmers) may need such extended C (maybe we should call C+-?) desparetely when C++ dies by itself under its own weight. C++ inflates at the rate approaching the rates of supernovas.<P>
Sure, it gives more and more employment for language commentators, critics, academic programming gurus, etc. (This is not an innuendo about PJP. Please believe me!). Anyone remember Algol 68? If we needed a language so big as the future C++ maybe we should settle for something already working and tested like Ada? C became so popular because it allowed people to program close enough to the performance levels of assembly language with benefits of the structure of a higher-level programming language. C++ became popular <I>only </I>because it is perceived as <I>an extension of C!</I><P>
This is of course my personal view, but then again I am being told from time to time that true OOP can happen only in languages like Smalltalk and so on. B. Jervis! Go on!<P>
Bogdan M. Baudis<P>
<I>Innuendo or no, I do get a certain job security from the ambitions of language designers. Still, I wish sometimes the job of explaining esoterica wasn't quite so hard. &#151;pjp</I><P>
C/C++ Users Journal<P>
This is the second of two letters. The first, which is enclosed behind this one, was waiting to be stuffed in its envelope when my copy of the October issue of the Journal arrived. Needless to say, I read Bob Jervis's article and your sidebar with great interest. Having done that, I feel that what I said in my first letter concerning ADTs versus OOPing, and C's capacity to support new dialects, still needs saying &#151; perhaps more than ever.<P>
If classes are added to C, that's fine. That is, it is if they don't get in the way of their ADT forebears. My concern is that although there are many instances where another level of sophistication is needed, anything which creates the impression that OOPing is <I>the</I> way could stifle the growth of C as a source of new programming ideas. Also, if the freedom to create and expand ADT libraries is legislated against by committee fiat, I, for one, will not use any compiler implementing that standard.<P>
I've studied more than a few articles over the years on how to OOP in C, including the one Colvin did in <I>CUJ</I><I> </I>last year. I've also "poured over" more than one book on the subject, and I have to say that I've yet to find any well-wrought discussion of the relationship between ADTs and classes as clone factories. The nail still protrudes!<P>
On a related point: In his Letter to the Editor in this October issue, someone named Marty says: "One of the best ways to become a better programmer is to read other people's code,..." This is a fairly common, often enunciated belief, but one which I find actually qualifies as a half-truth. Reading other people's code can also be one of the worst ways to learn. Not only are there many ways to write correct C, the ways that apear in print tend to perpetuate what might be called The-Old-Boys' version.<P>
A full-fledged discussion of C's several prevailing styles and the effect they have on program semantics ought to make an excellent subject for one of your columnist's columns. It ought also to fit-in nicely with your expressed intent to cover further discussion of C's ongoing development.<P>
Truly,<P>
Mark Rhyner<P>
Dear Mr. Plauger:<P>
I would like to suggest that a "read_only" data member access specification be added to the <I>public, protected</I>, and <I>private</I> access specifiers in the C++ standard.<P>
I find myself writing numerous <I>get_XXX </I>functions to allow users of my classes to access the private data in them. The data is declared private to localize the responsibility and maintain the integrity of the data, but I still wish the callers to be able to act on the data. The only other alternative I can think of is to make the data public, which is okay if the users are disciplined about not altering the data.<P>
Problems with <I>read_only</I> might arise if the data exposed is a pointer, but that is the way of C anyway. If you have any suggestions on how to deal with this issue in C++ as it stands, I would be very interested.<P>
On another subject, I would be very interested in reading a regular column in <I>The C/C++ Users Journal</I> on programming style. It could cover issues such as the above:<P>
<UL><li>When to derive a new class as opposed to when a class should contain another class</li>
<li>When should functions be declared virtual?</li>
<li>What are the relative merits of iostreams compared to <I>fprintf</I>?</li>
<li>What are the trade-offs among the possible design decisions?</li></UL>
Sincerely,<P>
David Rosenbush<P>
<I>I agree that read-only access to certain member objects could save some tedious writing. I also agree that style is an important topic. So far, we've kind of smeared responsibility for discussing issues of style among all our columnists. &#151; pjp</I><P>
</BLOCKQUOTE>
</BODY>
</HTML>
