

<HTML>
<HEAD>

<TITLE>January 1995/Stepping Up To C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjan.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Stepping Up To C++<A name="002C_0013"><A name="002C_0013"></font></h2><P>
<h3 align="center"><A name="002C_0000"><A name="002C_0000">C++ at CD Registration</h3><P>
<h3 align="center"><font color="#800000">Dan Saks</font></h3><hr><blockquote><P>
<P><i><A name="002C_0000"><A name="002C_0000">Dan Saks is the president of Saks &amp; Associates, which offers consulting and training in C++ and C. He is secretary of the ANSI and ISO C++ committees. Dan is coauthor of C++ Programming Guidelines, and codeveloper of the Plum Hall Validation Suite for C++ (both with Thomas Plum). You can reach him at 393 Leander Dr., Springfield OH, 45504<I>-</I>4906, by phone at (513)324<I>-</I>3601, or electronically at dsaks@wittenberg.edu.</i></P><P>
As P.J. Plauger recently reported in his "Editor's Forum," <I>CUJ</I>, September 1994, the draft C++ standard has reached a major milestone on its way to becoming a bona fide standard. This past July, the joint ANSI and ISO C++ standards committees voted to submit the latest draft for registration as a committee draft (CD). CD registration is the first of three ballots that a draft must pass before it becomes an international standard (IS).<P>
As Plauger explained, the significance of this stage (aside from simply showing progress) is that it's supposed to be the point at which all the key features of the language are in place. As such, this is probably a good time to look back and see how the language has changed over the past few years.<P>
<h4><FONT COLOR="#000080"><A name="002C_0014">Who's Standardizing What?<A name="002C_0014"></FONT></h4></P>
It's hard to talk about programming language standards without bandying about acronyms like ANSI and ISO, or arcane codenames like X3J16 or WG21. Although you clearly don't need to understand these terms to program competently in C++, I expect that many of you are at least a little interested in understanding the forces that shape your destiny.<P>
<A href="tab1.htm">Table 1</a>
contains a handy quick reference guide to standards organizations and committees affecting C and C++. You may find it helptul to refer to the table from time to time.<P>
ANSI (pronounced "AN-see") stands for the American National Standards Institute. ANSI is a trade association that sets standards for industrial products and processes. ANSI standards cover a wide assortment of products such as bar codes, bicycle helmets, heating and air conditioning equipment, and plywood. ANSI is not a US government agency and its standards are not in and of themselves binding by law. However, a government agency may adopt an ANSI standard for regulatory or procurement purposes, thus entwining that standard with laws.<P>
ANSI doesn't actually write standards; it establishes procedures for writing and approving standards, and then delegates most of the work to industry-specific standards committees. X3 is the ANSI-accredited committee that administers standards development for information processing systems (which includes programming languages). X3 operates out of the headquarters of CBEMA, the Computer and Business Equipment Manufacturer's Association. CBEMA (pronounced "see-BEE-ma") provides funding and staffing for X3's activities.<P>
X3 in turn establishes technical committees to develop specific standards. X3 has chartered, among others, X3J11 and X3J16 to develop the ANSI standards for C and C++, respectively. X3J16 started working in early 1990, and has been meeting three times a year ever since.<P>
ANSI has counterparts in other nations, such as AFNOR (France), BSI (UK), DIN (Germany), JTSC (Japan), SCC (Canada), and many others. (To the rest of the world, please pardon me for not listing your national standards body.) These national standards bodies are members of ISO ("I-so"), the International Organization for Standardization. As with its members, ISO doesn't write standards, but rather charters committees to establish standards according to ISO procedures. ISO standards are not laws, but they have become the basis for international treaties, and so should not be taken lightly.<P>
ISO works cooperatively with yet another standards group, IEC, the International Electrotechnical Commission. ISO and IEC formed a joint technical committee, JTC1, to standardize information technology. JTC1's subcommittee SC22 oversees the development of international programming language standards.<P>
The international counterpart of an ANSI technical subcommittee like X3J16 is called a "working group." WG14 and WG21 are the SC22 working groups responsible for the international C and c++ standards, respectively. (WG21's fully-qualified name is ISO/IEC JTC1/SC22/WG21.)<P>
WG21 has been meeting jointly with X3J16 since the summer of 1991. The joint committees are working to produce a single document that, if all goes well, will become both the ANSI and ISO standards for C++. I often refer to the joint committees as a singular entity (the "joint committee" with no "s") or as WG21+X3J16.<P>
<h4><FONT COLOR="#000080"><A name="002C_0015">Base Documents<A name="002C_0015"></FONT></h4></P>
Rather than write the C++ standard from scratch, X3J16 started by adopting the AT&amp;T C++ Product Reference Manual (the PRM) version 2.1 as the <I>base document,</I> that is, as the initial working draft. C++ programmers are not as familiar with the PRM as they are with the Annotated C++ Reference Manual (the ARM)<a href="#1">[1]</a>. The ARM is a textbook that includes a version of the PRM along with annotations and commentary that elaborate the language description, explain many language design decisions, and suggest implementation techniques. The ARM also includes chapters on templates and exceptions, which the PRM does not.<P>
Thus, strictly speaking, the ARM is not the base document. However, X3J16's first decisions eliminated most of the differences between the draft and the ARM (aside from the annotations and commentary). Therefore, for all practical purposes, the initial draft standard was based on the ARM, and so it's fair to call the ARM the base document.<P>
X3J16 selected the C standard as its second base document. Over the years, the committee has mined the C standard for passages describing parts of C that are supposed to be the same, or nearly the same, in C++. For example, the ARM does not include a grammar for the lexical tokens of C++ (constructs such as identifiers and literals). The C++ draft standard now incorporates the lexical grammar from the C standard. Similarly, the C++ draft's description of the preprocessor is now nearly identical to the one in the C standard. Nonetheless, the overall structure of the C++ draft still largely resembles that of the ARM.<P>
Occasionally, I receive requests for information about or copies of the "C++ 3.0 standard" or something similar. There is no such thing. I think such questions arise because before there was a draft standard, compiler vendors used to claim compatibility with numbered versions of AT&amp;T's C++ compiler.<P>
C++, like C, began at AT&amp;T Bell Labs. AT&amp;T started distributing a C++ compiler called <I>cfront</I> in the mid-1980s. For a few years, it was the only C++ compiler around. For several more years, cfront remained the de facto standard for C++ compilers. Vendors of the first non-AT&amp;T C++ compilers typically described the features their compilers supported by comparison with AT&amp;T's product. This practice continued through the release of cfront 3.0 in 1991, even after X3J16 had been at work for a couple of years. Comparisons with cfront 3.0 are now pass, but the confusion apparently still lingers.<P>
In short, there is not yet a C++ standard, but there is a draft C++ standard inching its way toward formal acceptance several years from now. That draft is based on, and still bears a strong resemblance to, the ARM, but it has also gone well beyond the ARM in many ways. What follows is a summary of the changes in the language wrought by standardization. But first...<P>
<h4><FONT COLOR="#000080"><A name="002C_0016">What About Libraries?<A name="002C_0016"></FONT></h4></P>
Except for mentioning a few header files and functions, the ARM does not describe any run-time library accompanying a C++ implementation. From the beginning, X3J16 agreed that any acceptable C++ language standard must include a library. The current C++ draft includes a fairly extensive library, including language support functions, iostreams, complex arithmetic, and an adaption of the Standard C library. The draft also contains a variety of data structures, such as strings, dynamic arrays, and assorted container classes, most of which are provided as templates.<P>
I shall focus my attentions on the language itself, and defer to my colleagues at <I>CUJ</I> in describing the C++ library. (See Chuck Allison's column, "Code Capsules: The Standard C++ Library," <I>CUJ</I>, December 1994.) You can find even greater detail on the library in P.J. Plauger's <I>CUJ</I> columns over the last year and well into the future, or in his most recent book <a href="#2">[2]</a>.<P>
<h4><FONT COLOR="#000080"><A name="002C_0017">Language Changes<A name="002C_0017"></FONT></h4></P>
The joint committee has made a lot of changes in the C++ language definition. Many of the changes are substantive; they change the syntactic structure and/or the semantic interpretation of the C++ language itself. Other changes are just editorial &#151; they are changes in the description of the C++ language, not in the C++ language itself. The following lists omit changes that I believe are purely editorial.<P>
To give you a better sense of the nature of the substantive changes, I've grouped them into four broad categories:<P>
<UL><li><I>major extensions</I> that dramatically increase the complexity of the language, and support alternative programming styles and paradigms</li>
<li><I>minor enhancements</I> that extend C++ in less dramatic ways</li>
<li><I>changes</I> that alter the meaning of existing features</li>
<li><I>clarifications</I> of existing features</li></UL>
This is not a hard-and-fast classification scheme, and my judgments about what goes where are admittedly subjective. But hey, it's my column.<P>
<h4><FONT COLOR="#000080"><A name="002C_0018">Major Extensions<A name="002C_0018"></FONT></h4></P>
The major extensions are:<P>
<UL><li>Templates</li>
<li>Exception handling</li>
<li>Run-time type information (including <I>dynamic_cast</I>)</li>
<li>Namespaces</li></UL>
Templates are a translation-time facility for writing generic functions and classes in terms of unspecified types. For example,<P>
<pre>template &lt;class T&gt;
void swap(T &amp;a, T &amp;b)
   {
   T t = a;
   a = b;
   b = t;
   }</pre>
defines a template for a function that will swap (exchange the values stored in) two objects of arbitrary type <I>T.</I> I described function templates in some detail in "Recent Extensions to C++," <I>CUJ,</I> June 1993. I devoted my entire column last month to template classes ("Designing Generic Container Classes, Part 6: Templates," <I>CUJ</I>, December 1994). You will find a lengthy discussion and numerous examples of templates in <a href="#3">[3]</a> and <a href="#4">[4]</a><P>
Exception handling is a facility for orderly recovery from exceptional (typically erroneous) events during program execution. C++ exception handlers can only handle synchronous events &#151; the kinds of events that can be expressed as conditional expressions (for use in <I>if</I> or <I>while</I> statements or in <I>assert</I> macro calls). Exception handlers cannot intercept asynchronous events, such as device interrupts or hardware faults, which are better handled as signals.<P>
C++ provides exception handling through additional flow structures and library functions. A <I>try-block</I> is a compound statement (a sequence of statements enclosed in brackets) followed by a sequence of one or more handlers, also known as <I>catch clauses</I><I>.</I> For example,<P>
<pre>try
   {
   // do something
   }
catch (const char *s)
   {
   // catch an error
   }</pre>
is a try-block. The handlers "catch" exceptions "thrown" by throw expressions executed in the compound statement or in functions called from within the compound statement, For example, executing<P>
<pre>throw "something happened";</pre>
throws an exception that will be caught by the catch clause above. The throw terminates every active function invoked from the try-block and transfers control to the catch clause. Presumably, the catch clause handles the exception somehow.<P>
For much more detail on exceptions see Chuck Allison's "Code Capsules: C++ Exceptions," <I>CUJ</I>, July 1994, as well as <a href="#3">[3]</a> and <a href="#4">[4]</a>.<P>
Run-time type information (RTTI) is a facility for querying the dynamic type of a polymorphic object. A polymorphic object is an object whose class has at least one virtual function. An expression that refers to a polymorphic object has both a static type and a dynamic type, which may be different. For example, given:<P>
<pre>class B
   {
public:
   virtual void f();
   ...
   };
class D: public B
   {
   ...
   };
B*pb = new D;</pre>
then <I>*pb</I> is a polymorphic object with static (declared) type <I>B</I> but dynamic (run-time) type <I>D.</I><P>
Using RTTI, you can query an object with a given static type to determine if it has a particular dynamic type. One form of query is an expression such as<P>
<pre>if (typeid(*pb) == typeid(D))
...</pre>
You can also try to convert <I>pb</I> to a <I>D</I> * using<P>
<pre>D *pd = dynamic_cast&lt;D *&gt;(pb);</pre>
which sets <I>pd</I> to 0 (a null pointer) if <I>pb</I> does not point to an object whose dynamic type is either <I>D</I> or a type derived from <I>D.</I><P>
For a little more detail on RTTI see Chuck Allison's "Code Capsules: Conversions and Casts," <I>CUJ,</I> September 1994. For much more detail, see <a href="#4">[4]</a>.<P>
Namespaces offer a mechanism for adding qualifiers to global names in the hope of reducing global name conflicts. Global name conflicts typically occur when a program attempts to use two different libraries that use the same global name but for different purposes. For example, <I>libA.h</I> might declare<P>
<pre>class status { ... };</pre>
but <I>libB.h</I> might declare<P>
<pre>enum status { ... };</pre>
A translation unit that tries to include both <I>libA.h</I> and <I>libB.h</I> will run up against compilation errors.<P>
Wrapping these global names in separate namespaces eliminates the conflicts. In <I>libA.h,</I> you write:<P>
<pre>namespace A
   {
   class status
   { ... };
   ...
   };</pre>
and in <I>libB.h</I> you write:<P>
<pre>namespace B
   {
   enum status { ... };
   ...
   };</pre>
A program that uses both libraries must refer to a status type by its explicitly-qualified name, i.e., as either <I>A::status</I> or <I>B::status.</I> If you would like the unqualified name <I>status</I> to mean <I>A::status</I> by default, you can write<P>
<pre>using namespace A;</pre>
Then you must still refer to <I>B::status</I> by its fully-qualified name. Writing both<P>
<pre>using namespace A;
using namespace B;</pre>
reintroduces the name conflict.<P>
Chuck Allison's "Code Capsules: Visibility in C++," <I>CUJ,</I> May 1994 has more discussion of namespaces. <a href="#4">[4]</a> has even more.<P>
<h4><FONT COLOR="#000080"><A name="002C_0019">Minor Enhancements<A name="002C_0019"></FONT></h4></P>
In addition to the major extensions, the draft C++ standard includes numerous minor enhancements:<P>
<UL><li>New keywords and digraphs as alternate ISO646-compliant spellings for their corresponding tokens</li>
<li>Operator overloading on enumerations</li>
<li>operator <I>new[]</I> and operator <I>delete[]</I></li>
<li>Relaxed restrictions on the return type of virtual functions</li>
<li><I>wchar_t</I> as a keyword representing a distinct type</li>
<li>A Boolean type, <I>bool</I></li>
<li>Declarations in conditional expressions</li>
<li>New cast notation</li>
<li>Qualified names in elaborated-type specifiers</li>
<li>Expressions of the form <I>a.::B::c and p</I><I>-</I><I>&gt;::B::c</I> (that is, with <I>::</I> after the . or -&gt;)</li>
<li>Conversion from <I>T</I> **to <I>const T *const *</I></li>
<li>Layout rules for POD-struct and POD-union (POD-struct means "plain old data structure")</li>
<li>Mutable class members</li>
<li>Compile-time member constants</li>
<li>Default return value (of 0) from <I>main</I></li>
<li>Empty initializer-clauses</li></UL>
I covered the first five of these minor enhancements in "Recent Extensions to C++," <I>CUJ,</I> June 1993. <a href="#4">[4]</a> covers some the others. I'll get around to covering all of them in an upcoming column.<P>
All of the extensions and enhancements have added a lot of keywords to C++. See <A href="tab2.htm">Table 2</a>
for the complete list of C++ keywords, as listed in the current draft standard.<P>
<h4><FONT COLOR="#000080"><A name="002C_001A">Changes in Meaning<A name="002C_001A"></FONT></h4></P>
The C++ draft also changes the behavior of numerous constructs from their previous behaviors specified by the ARM. Some changes simply prohibit features that were never intended to be, yet somehow slipped into some implementations. Other changes actually just change some constructs with explicitly-defined behavior to have different behavior. Roll with it.<P>
Here are the changes:<P>
<UL><li>Conditional statements introduce a new block scope.</li>
<li>Enumerations are no longer integral types.</li>
<li>The rules for class scopes have greater consistency.</li>
<li>Friend function definitions in local classes are prohibited.</li>
<li>Conversions between pointer to object type and pointer to function are prohibited.</li>
<li>Operator <I>op</I> is not a valid identifier name except when used as a function name.</li>
<li><I>cv-qualifiers</I> (<I>const</I> and <I>volatile</I>) are ignored when modifying parameter types in function types.</li>
<li>Parameter types that include pointer to array of unknown bound of <I>T</I> are prohibited.</li>
<li>The lifetime of a compiler-generated temporary object lasts to the end of the full-expression in which the temporary is created.</li>
<li>An enumerator may be accessed with a. or -) operators.</li>
<li>Omitting the type specifiers (and implying <I>int</I>) is (1) prohibited in declarations wherever Standard C prohibits it, as well as (2) prohibited in a <I>typedef</I> without a type-specifier (e.g. <I>typedef I;</I>), and (3) deprecated in all other contexts.</li>
<li>The scope of a declaration in a <I>for-init-statement</I> is restricted to the <I>for-statement</I>.</li>
<li>The left hand side of a . or -&gt; operator is always evaluated.</li>
<li>A derived class constructor may explicitly initialize an inherited virtual base.</li>
<li><I>T()</I> has a specified value for every type <I>T.</I></li>
<li>The point of declaration for an enumerator is immediately after its enumerator-definition.</li></UL>
<h4><FONT COLOR="#000080"><A name="002C_001B">Clarifications<A name="002C_001B"></FONT></h4></P>
The ARM left a lot unsaid. The committee has been trying to fill in the details. Here's the summary of most of the issues clarified so far:<P>
<UL><li>The name of an untagged class named in a <I>typedef</I> is the class name for linkage purposes only.</li>
<li>A function can be declared pure virtual in a derived class even if it's already defined in a base class.</li>
<li>A destructor can be declared pure virtual, but it must also be defined.</li>
<li><I>new T[0]</I> returns a unique pointer, thus implying that the allocated array may consume memory.</li>
<li>A pointer to a <I>T</I> member of a class cannot point to a <I>T &amp;</I> member.</li>
<li>Member bitfields cannot be declared <I>static.</I></li>
<li>A class may declare a static data member with an incomplete type.</li>
<li>Lookup for names in an out-of-line member function looks in base classes before looking in enclosing classes.</li>
<li>An aggregate initializer can only initialize an aggregate's non-static data members.</li>
<li>Constructors and destructors for volatile objects may be compiled with or without volatile semantics.</li>
<li>A C++ translator must look up the <I>T</I> in <I>x. T::m</I> (<I>or p</I><I>-</I><I>&gt;T::m</I>) as a type in two contexts &#151; (1) in the class scope of <I>x</I> (or <I>*p</I>), and (2) in the context of <I>x</I> &#151; but find <I>T</I> in only one.</li>
<li>For the purpose of type lookup, the class name <I>T</I> is also considered a nested class member of class <I>T</I>.</li>
<li>cv-qualifiers are not removed from function return types.</li>
<li>cv-qualifiers that appear in the type-modifier for an array of <I>T</I> are applied to the type <I>T</I> and not to the array type itself.</li>
<li>Pointers to members with reference or (possibly cv-qualified) <I>void</I> type are prohibited.</li>
<li>Redundant cv-qualifiers within a single declaration are prohibited.</li>
<li>References to (possibly cv-qualified) <I>void</I> are prohibited</li>
<li>Function parameters that include references to incomplete array types are prohibited.</li>
<li>Overload resolution does not consider functions as candidates if they cannot be called due to invalid reference initialization.</li>
<li>cv-qualifiers are significant in overload resolution.</li>
<li>Conversion function names may employ multiple pointers.</li>
<li>Expression evaluation only considers overloaded operators when at least one operand has user defined type.</li>
<li>cv-qualified reference types (e.g., <I>T &amp;const n</I>) are prohibited.</li>
<li>Static objects defined at file scope may be initialized at translation time (non-dynamically).</li></UL>
As you can see, we at <I>CUJ</I> have plenty to write about for years to come.<P>
<h4><FONT COLOR="#000080"><A name="002C_001C">Meeting Dates, Etc.<A name="002C_001C"></FONT></h4></P>
WG21+X3J16 will meet three times in 1995:<P>
<UL><li>March 5-10 in Austin, TX USA, hosted by Motorola</li>
<li>July 9-14 in the San Francisco Bay area, CA USA, hosted by Sun Microsystems</li>
<li>November 5-10 in Tokyo, Japan, hosted by ITSCJ</li></UL>
If you would like to participate in the standards process as a member of X3J16, contact the vice-chair:<P>
Jose'e Lajoie<br>
IBM Canada Laboratory<br>
844 Don Mills Rd.<br>
North York, Ontario M3C<br>
1V7 Canada<br>
(416)448-2734<br>
josee@vnet.ibm.com<P>
<h4>References</FONT></h4></P>
<a name="1"></a>[1]     Margaret A. Ellis and Bjarne Stroustrup. <I>The Annotated C++ Reference Manual</I> (Addison-Wesley, 1990).<P>
<a name="2"></a>[2]     P.J. Plauger. <I>The Draft Standard C++ Library</I> (Prentice-Hall, 1995).<P>
<a name="3"></a>[3]     Bjarne Stroustrup. <I>The C++ Programming Language</I>, 2nd. ed. (Addison-Wesley, 1991).<P>
<a name="4"></a>[4]     Bjarne Stroustrup. <I>The Design and Evolution of C++</I> (Addison-Wesley, 1994).<P>
</BLOCKQUOTE>
</BODY>
</HTML>
