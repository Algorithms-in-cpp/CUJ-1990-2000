<HTML><HEAD>
<TITLE>November 1995/Standard C/C++/Listing 1</TITLE></HEAD>

<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<h4><A NAME="heading1">Listing 1 <I>An implementation of the header </I>&lt;complex&gt;</A></h4>
<pre>// complex standard header
#ifndef _COMPLEX_
#define _COMPLEX_
#include &lt;cmath&gt;
#include &lt;istream&gt;
_STD_BEGIN
#define __STD_COMPLEX
       // TEMPLATE CLASS _Ctr
template&lt;class _T&gt; class _Ctr {
public:
   static _T _Cosh(_T _X, _T _Y)
       {return (::_Cosh((double)_X,
                     (double)_Y)); }
   static short _Exp(_T *_P, _T _Y,
                  short _E)
       {double _W = (double)*_P;
       short _Ans = :: _Exp(&amp;_W,
                        (double)_Y,
                        _E);
       *_P = (_T)_W;
       return (_Ans); }
   static _T _Infv(_T)
       {return (_Inf._D); }
   static bool _Isinf(_T _X)
       {double _W = (double)_X;
       return (_Dtest(&amp;_W) == _INF); }
   static bool _Isnan(_T _X)
       {double_W = (double)_X;
       return (_Dtest(&amp; _W) == _NAN); }
   static _T _Nanv(_T)
       {return (_Nan._D); }
   static _T _Sinh(_T _X, _T _Y)
       {return (::_Sinh((double)_X,
                     (double_Y)); }
   static _T atan2(_T _Y, _T _X)
       {return (::atan2((double) _Y,
                     (double _X)); }
   static _T cos(_T _X)
       {return (::cos((double)_X)); }
   static _T exp(_T _X)
       {return (::exp((double)_X)); }
   static _T ldexp(_T _R, int _E)
       {return (::ldexp((double)_R,
                     _E)); }
   static _T log(_T _X)
       {return (::log((double) _X)); }
   static _T pow(_T _X, _T _Y)
       {return (::pow((double)_X,
                   (double)_Y)); }
   static _T sin(_T _X)
       {return (::sin((double) _X)); }
   static _T sqrt(_T _X)
       {return (::sqrt((double)_X)); }
   };
       // CLASS_Ctr&lt;float&gt;
class _Ctr&lt;float&gt; {
public:
   typedef float _T;
   static _T _Cosh(_T _X, _T _Y)
       {return (_FCosh(_X, _Y)); }
   static short _Exp(_T*_P, _T _Y,
                  short _E)
       {return (_FExp(_P, _Y, _E)); }
   static _T _Infv(_T)
       {return (_FInf._F); }
   static bool _Isinf(_T _X)
       {return (_FDtest(&amp;_X) == _INF); }
   static bool _Isnan(_T _X)
       {return (_FDtest(&amp;_X) == _NAN); }
   static _T _Nanv(_T)
       {return (_FNan._F); }
   static _T _Sinh(_T _X, _T _Y)
       {return (_FSinh(_X, _Y)); }
   static _T atan2(_T _Y, _T _X)
       {return (atan2f(_Y, _X)); }
   static _T cos(_T _X)
       {return (cosf(_X)); }
   static _T exp(_T _X)
       {return (expf(_X)); }
   static _T ldexp(_T _R, int _E)
       {return (ldexpf(_R, _E)); }
   static _T log(_T _X)
       {return (logf(_X)); }
   static _T pow(_T _X, _T _Y)
       {return (powf(_X, _Y)); }
   static _T sin(_T _X)
       {return (sinf(_X)); }
   static _T sqrt(_T _X)
       {return (sqrtf(_X)); }
   };
       // CLASS _Ctr&lt;double&gt;
class _Ctr&lt;double&gt; {
public:
   typedef double _T;
   static _T _Cosh(_T _X, _T _Y)
       {return (::_Cosh(_X, _Y)); }
   static short _Exp(_T *_P, _T _Y,
                  short _E)
       {return (::_Exp(_P, _Y, _E)); }
   static _T _Infv(_T)
       {return (_Inf._D); }
   static bool _Isinf(_T _X)
       {return (_Dtest(&amp;_X) == _INF); }
   static bool _Isnan(_T _X)
       {return (_Dtest(&amp;_X) == _NAN); }
   static _T _Nanv(_T)
       {return (_Nan._D); }
   static _T _Sinh(_T _X, _T _Y)
       {return (::_Sinh(_X, _Y)); }
   static _T atan2(_T _Y, _T _X)
       {return (::atan2(_Y, _X)); }
   static _T cos(_T _X)
       {return (::cos(_X)); }
   static _T exp(_T _X)
       {return (::exp(_X)); }
   static _T ldexp(_T _R, int _E)
       {return (::ldexp(_R, _E)); }
   static _T log(_T _X)
       {return (::log(_X)); }
   static _T pow(_T _X, _T _Y)
       {return (::pow(_X, _Y)); }
   static _T sin(_T _X)
       {return (::sin(_X)); }
   static _T sqrt(_T _X)
       {return (::sqrt(_X)); }
   };
       // CLASS _Ctr&lt;long double&gt;
class _Ctr&lt;long double&gt; {
public:
   typedef long double _T;
   static _T _Cosh(_T _X, _T _Y)
       {return (_LCosh(_X, _Y)); }
   static short _Exp(_T *_P, _T _Y,
                  short _E)
       {return (_LExp(_P, _Y, _E)); }
   static _T _Infv(_T)
       {return (_LInf._L); }
   static bool _Isinf(_T _X)
       {return (_LDtest(&amp;_X) == _INF); }
   static bool _Isnan(_T _X)
       {return (_LDtest(&amp;_X)== _NAN); }
   static _T _Nanv(_T)
       {return (_LNan._L); }
   static _T _Sinh( _T _X, _T _Y)
       {return (_LSinh(_X, _Y)); }
   static _T atan2(_T _Y, _T _X)
       {return (atan2l(_Y, _X)); }
   static _T cos(_T _X)
       {return (cosl(_X)); }
   static _T exp(_T _X)
       {return (expl(_X)); }
   static _T ldexp(_T _R, int _E)
       {return (ldexpl(_R, _E)); }
   static _T log(_T _X)
       {return (logl(_X)); }
   static _T pow(_T _X, _T _Y)
       {return (powl(_X, _Y)); }
   static _T sin(_T _X)
       {return (sinl(_X)); }
   static _T sqrt(_T _X)
       {return (sqrtl(_X)); }
   };
       // TEMPLATE CLASS _Complex_base
template&lt;class _T&gt; class complex;
class complex&lt;float&gt;;
class complex&lt;double&gt;;
class complex&lt;long double&gt;;
template&lt;class _T&gt;
   class _Complex_base {
public:
   typedef _Complex_base&lt;_T&gt; _Myt;
   _Complex_base(const _T&amp; _R, const _T&amp; _I)
       : _Re(_R), _Im(_I) {}
#if _HAS_MEMBER_TEMPLATES
   template class&lt;U&gt;
       _Myt&amp; operator=(const complex&lt;_U&gt;&amp; _X)
       {_Re = (_T)_X.real();
       _Im = (_T)_X.imag();
       return (*this); }
   template&lt;class _U&gt;
       _Myt&amp; operator+=(const complex&lt;_U&gt;&amp; _X)
       {_Re += (_T)_X.real();
       _Im += (_T)_X.imag();
       return (*this); }
   template&lt;class _U&gt;
       _Myt&amp; operator-=(const complex&lt;_U&gt;&amp; _X)
       {_Re -= (_T)_X.real();
       _Im -= (_T)_X.imag();
       return (*this); }
   template&lt;class _U&gt;
       _Myt&amp; operator*=(const complex&lt;_U&gt;&amp; _X)
       {_T _Xre = (_T)_X.real();
       _T _Xim = (_T)_X.imag();
       _T _W = _Re *_Xre - _Im * _Xim;
       _Im = _Re * _Xim + _Im * _Xre;
       _Re = _W;
       return (*this); }
   template class&lt;U&gt;
       _Myt&amp; operator/=(const complex&lt;_U&gt;&amp; _X)
       {_T _Xre = (_T)_X.real();
       _T _Xim = (_T)_X.imag();
       if (_Ctr&lt;_T&gt;::_Isnan(_Xre) || _Ctr&lt;_T&gt;::_Isnan(_Xim))
          _Re = _Ctr&lt;_T&gt;::_Nanv(_Xre), _Im = _Re;
       else if ((_Xim &lt; 0 ? -_Xim : +_Xim)
          &lt; (_Xre &lt; 0 ? -_Xre : +_Xre))
          {_T _Wr = _Xim / _Xre;
          _T _Wd = _Xre + _Wr *_Xim;
          if (_Ctr&lt;_T&gt;:: _Isnan(_Wd) || _Wd == 0)
             _Re = _Ctr&lt;_T&gt;::_Nanv(_Xre), _Im = _Re;
          else
             {_T _W = (_Re + _Im * _Wr) / _Wd;
             _Im = (_Im - _Re * _Wr) / _Wd;
             _Re = _W; }}
       else if (_Xim == 0)
          _Re = _Ctr&lt;_T&gt;::_Nanv(_Xre), _Im = _Re;
       else
          {_T _Wr = _Xre / _Xim;
          _T _Wd = _Xim + _Wr * _Xre;
          if (_Ctr&lt;_T&gt;::_Isnan(_Wd) || _Wd == 0)
             _Re = _Ctr&lt;_T&gt;::_Nanv(_Xre), _Im = _Re;
          else
             {_T _W = (_Re * _Wr + _Im) / _Wd;
             _Im = (_Im * _Wr - _Re) / _Wd;
             _Re = _W; }}
       return (*this); }
#else
   _T real(_T _X)
       {return (_Re = _X); }
   _T imag(_T _X)
       {return (_Im = _X); }
#endif
   _T real() const
       {return (_Re); }
   _T imag() const
       {return (_Im); }
private:
   _T _Re, _Im;
   };
       // CLASS complex&lt;float&gt;
class complex&lt;float&gt; : public _Complex_base&lt;float&gt; {
public:
   typedef float _T;
   explicit complex(const complex&lt;double&gt;&amp;);
   explicit complex(const complex&lt;long double&gt;&amp;);
   complex(const _T&amp; _R = 0, const _T&amp; _I = 0)
       : _Complex_base&lt;_T&gt;(_R, _I) {}
   };
       // CLASS complex&lt;double&gt;
class complex&lt;double&gt; : public _Complex_base&lt;double&gt; {
public:
   typedef double _T;
   complex(const complex&lt;float&gt;&amp;);
   explicit complex(const complex&lt;long double&gt;&amp;);
   complex(const _T&amp; _R = 0, const _T&amp; _I = 0)
       : _Complex_base&lt;_T&gt;(_R, _I) {}
   };
       // CLASS complex&lt;long double&gt;
class complex&lt;long double) : public_Complex_base&lt;long double&gt; {
public:
   typedef long double _T;
   complex(const complex&lt;float&gt;&amp;);
   complex(const complex&lt;double&gt;&amp;);
   complex(const _T&amp; _R = 0, const _T&amp; _I = 0)
       : _Complex_base&lt;_T(_R, _I) {}
   };
       // CONSTRUCTORS FOR complex SPECIALIZATIONS
complex&lt;float&gt;::complex(const complex&lt;double&gt;&amp; _X)
   : _Complex_base&lt;float&gt;((_T)_X.real(), (_T)_X.imag()) {}
complex&lt;float&gt;::complex(const complex&lt;long double&gt;&amp; _X)
   : _Complex_base&lt;float&gt;((T)_X.real(), (_T)_X.imag()) {}
complex&lt;double&gt;::complex(const complex&lt;float&gt;&amp; _X)
   : _Complex_base&lt;double&gt;((_T)_X.real(), (_T)_X.imag()) {}
complex&lt;double&gt;::complex(const complex&lt;long double&gt;&amp; _X)
   : _Complex_base&lt;double&gt;((_T)_X.real(), (_T)_X.imag()) {}
complex&lt;long double&gt;::complex(const complex&lt;float&gt;&amp; _X)
   : _Complex_base&lt;long double&gt;((_T)_X.real(), (_T)_X.imag()) {}
complex&lt;long double&gt;::complex(const complex&lt;double&gt;&amp; _X)
   : _Complex_base&lt;long double&gt;((_T)_X.real(), (_T)_X.imag()) {}
       // TEMPLATE CLASS complex
template&lt;class _T&gt;
   class complex : public _Complex_base&lt;T&gt; {
public:
   complex(const _T&amp; _R = 0, const _T&amp; _I = 0)
       : _Complex_base&lt;_T&gt;(_R, _I) {}
#if _HAS_MEMBER_TEMPLATES
   template&lt;class _U&gt;
#else
   typedef _T _U;
#endif
       complex(const complex&lt;_U&gt;&amp; _X)
       : _Complex_base&lt;_T&gt;((_T)_X.real(), (_T)_X.imag()) {}
   };
#if !_HAS_MEMBER_TEMPLATES
       // TEMPLATE complex OPERATORS
template&lt;class _T, class _U&gt; inline
   complex&lt;_T&gt;&amp; operator=(complex&lt;_T&gt;&amp; _X, const complex&lt;_U&gt;&amp; _Y)
   {_X.real((_T)_X.real());
   _X.imag((_Tl_X.imag());
   return (_X); }
template&lt;class _T, class _U&gt; complex&lt;_T&gt;&amp; operator+=(
   complex&lt;_T&gt;&amp; _X,
   const complex&lt;_U&gt;&amp; _Y)
   {_X.real(_X.real() + (_T) _Y.real());
   _X.imag(_X.imag() + (_T)_Y.imag());
   return (_X); }
template&lt;class _T, class _U&gt; complex&lt;_T&gt;&amp; operator-=(
   complex&lt;_T&gt;&amp; _X,
   const complex&lt;_U&gt;&amp; _Y)
   {_X.real(_X.real() - (_T)_Y.real());
   _X.imag(_X.imag() - (_T)_Y.imag());
   return (_X); }
template&lt;class _T, class _U&gt; complex&lt;_T&gt;&amp; operator*=(
   complex&lt;_T&gt;&amp; _X,
   const complex&lt;_U&gt;&amp; _Y)
   {_T _Yre = (_T)_Y.real();
   _T _Yim = (_T)_Y.imag();
   _T _W = _X.real() * _Yre - _X.imag() * _Yim;
   _X.imag(_X.real() * _Yim + _X.imag() * _Yre);
   _X.real(_W);
   return (_X); }
template&lt;class _T, class _U&gt; complex&lt;_T&gt;&amp; operator/=(
   complex&lt;_T&gt;&amp; _X,
   const complex&lt;_U&gt;&amp; _Y)
   {_T _Yre = (_T)_Y.real();
   _T _Yim = (_T)_Y.imag();
   if (_Ctr&lt;_T&gt;::_Isnan(_Yre) || _Ctr&lt;_T&gt;::_Isnan(_Yim))
       _X.real(_Ctr&lt;_T&gt;::_Nanv(_Yre)), _X.imag(_X.real());
   else if ((_Yim &lt; 0 ? -_Yim : +_Yim)
       &lt; (_Yre &lt; 0 ? -_Yre : +_Yre))
       {_T _Wr = _Yim / _Yre;
       _T _Wd = _Yre +_Wr * _Yim;
       if (_Ctr&lt;_T&gt;::_Isnan(_Wd) || _Wd == 0)
          _X.real(_Ctr&lt;_T&gt;::_Nanv(_Yre)), _X.imag(_X.real());
       else
          {_T _W = (_X.real() + _X.imag() *_Wr) / _Wd;
          _X.imag((_X.imag() - _X.real() *_Wr) / _Wd);
          _X.real(_W); }}
   else if (_Yim == 0)
       _X.real(_Ctr&lt;_T&gt;::_Nanv(_Yre)), _X.imag(_X.real());
   else
       {_T _Wr = _Yre / _Yim;
       _T _Wd = _Yim + _Wr * _Yre;
       if (_Ctr&lt;_T&gt;::_Isnan(_Wd) || _Wd == 0)
          _X.real(_Ctr&lt;_T&gt;::_Nanv(_Yre)), _X.imag(_X.real());
       else
          {_T _W = (_X.real() * _Wr + _X.imag()) / _Wd;
          _X.imag((_X.imag( * _Wr - _X.real()) / _Wd);
          _X.real(_W); }}
   return (_X); }
#endif
       // TEMPLATE FUNCTION imag
template&lt;class _T&gt; inline
   _T imag(const complex&lt;_T&gt;&amp; _X)
   {return (_X.imag()); }
       // TEMPLATE FUNCTION real
template&lt;class _T&gt; inline
   _T real(const complex&lt;_T&gt;&amp; _X)
   {return {_X.real()); }
       // TEMPLATE FUNCTION _Fabs
template&lt;class _T&gt; inline
   _T _Fabs(const complex&lt;_T&gt;&amp; _X, int *_Pexp)
   {*_Pexp = 0;
   _T _A = real(_X);
   _T _B = imag(_X);
   if (_Ctr&lt;_T&gt;::_Isnan(_A))
       return (_A);
   else if (_Ctr&lt;_T&gt;::_Isnan(_B))
       return (_B);
   else
       {if (_A &lt; 0)
          _A = -_A;
       if (_B &lt; 0)
          _B = -_B;
       if (_A &lt;_B)
          {_T _W = _A;
          _A = _B, _B = _W; }
       if (_A == 0 || _Ctr&lt;_T&gt;::_Isinf(_A))
          return (_A);
       if (1 &lt;= _A)
          *_Pexp = 2, _A *= 0.25, _B *= 0.25;
       else
          *_Pexp = -2, _A *= 4, _B *= 4;
       _T _W = _A - _B;
       if (_W == _A);
          return (_A);
       else if (_B &lt;_W)
          {const _T _Q = _A / _B;
          return (_A + _B
             / (_Q + _Ctr&lt;_T&gt;::sqrt(_Q * _Q + 1))); }
       else
          {static const _T _R2 = 1.4142135623730950488L;
          static const _T _Xh = 2.4142L;
          static const _T _Xl = 0.0000135623730950488016887L;
          const _T _Q = _W / _B;
          const _T _R = (_Q + 2) *_Q;
          const _T _S = _R / (_R2 + _Ctr&lt;_T&gt;::sqrt(_R + 2))
             + _Xl + _Q + _Xh;
          return (_A + _B / _S); }}}
       // TEMPLATE FUNCTION operator+
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator+(const complex&lt;_T&gt;&amp; _L,
       const complex&lt;_T&gt;&amp; _R)
   {return (complex&lt;_T&gt;(_L) += _R); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator+(const complex&lt;_T&gt;&amp; _L, const _T&amp; _R)
   {complex&lt;_T&gt; _W(_L);
   _W.real(_W.real() + _R);
   return (_W); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator+(const _T&amp; _L, const complex&lt;_T&gt;&amp; _R)
   {return (complex&lt;_T&gt;(_L) += R); }
       // TEMPLATE FUNCTION operator-
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator-(const complex&lt;_T&gt;&amp; _L,
       const complex&lt;_T&gt;&amp; _R)
   {return (complex&lt;_T&gt;(_L) -= _R); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator-(const complex&lt;_T&gt;&amp; _L, const _T&amp; _R)
   {complex&lt;_T&gt; _W(_L);
   _W.real(_W.real() - _R);
   return (_W); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator-(const _T&amp; _L, const complex&lt;_T&gt;&amp; _R)
   {return (complex&lt;_T&gt;(_L) -= _R); }
       // TEMPLATE FUNCTION operator*
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator*(const complex&lt;_T&gt;&amp; _L,
       const complex&lt;_T&gt;&amp; _R)
   {return (complex&lt;_T&gt;(_L) *= _R); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator*(const complex&lt;_T&gt;&amp; _L, const _T&amp; _R)
   {complex&lt;_T&gt;_W(_L);
   _W.real(_W.real() * _R);
   _W.imag(_W.imag() * _R);
   return (_W); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator*(const _T&amp; _L, const complex&lt;_T&gt;&amp; _R)
   {return (complex&lt;_T&gt;(_L) *= _R); }
       // TEMPLATE FUNCTION operator/
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator/(const complex&lt;_T&gt;&amp; _L,
       const complex&lt;_T&gt;&amp; _R)
   {return (complex&lt;_T&gt;(_L) /= R); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator/(const complex&lt;_T&gt;&amp; _L, const _T&amp; _R)
   {complex&lt;_T&gt;_W(_L);
   _W.real(_W.real() / _R);
   _W.imag(_W.imag() / _R);
   return (_W); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator/(const _T&amp; _L, const complex&lt;_T&gt;&amp; _R)
   {return (complex&lt;_T&gt;(_L) /= _R); }
       // TEMPLATE FUNCTION UNARY operator+
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator+(const complex&lt;_T&gt;&amp; _L)
   {return (complex&lt;_T&gt;(_L)); }
       // TEMPLATE FUNCTION UNARY operator-
template&lt;class _T&gt; inline
   complex&lt;_T&gt; operator-(const complex&lt;_T&gt;&amp; _L)
   {return (complex&lt;_T&gt;(-real(_L), -imag(_L))); }
       // TEMPLATE FUNCTION operator==
template&lt;class _T&gt; inline
   bool operator==(const complex&lt;_T&gt;&amp; _L, const complex&lt;_T&gt;&amp; _R)
   {return (real(_L) == real(_R) &amp;&amp; imag(_L) == imag(_R)); }
template&lt;class _T&gt; inline
   bool operator==(const complex&lt;_T&gt;&amp; _L, const _T&amp; _R)
   {return (real(_L) == _R &amp;&amp; imag(_L) == 0); }
template&lt;class _T&gt; inline
   bool operator==(const _T&amp; _L, const complex&lt;_T&gt;&amp; _R)
   {return (_L == real(_R) &amp;&amp; 0 == imag(_R)); }
       // TEMPLATE FUNCTION operator!=
//template&lt;class _T&gt; inline
//    bool operator!=(const complex&lt;_T&gt;&amp; _L, const complex&lt;_T&gt;&amp; _R)
//    {return (!(_L == _R)); }
template&lt;class _T&gt; inline
   bool operator!=(const complex&lt;_T&gt;&amp; _L, const _T&amp; _R)
   {return (!(_L == _R)); }
template&lt;class _T&gt; inline
   bool operator!=(const _T&amp; _L, const complex&lt;_T&gt;&amp; _R)
   {return (!(_L == _R)); }
       // TEMPLATE FUNCTION operator&gt;
template&lt;class _T&gt; inline
   istream&amp; operator&gt;(istream&amp; _I, complex&lt;_T&gt;&amp; _X)
   {char _Ch;
   long double _Re, _Im;
   if (_I &gt; _Ch &amp;&amp; Ch != '(')
       _I.putback(_Ch), _I &gt; _Re, _Im = 0;
   else if (_I &gt; _Re &gt; _Ch &amp;&amp; _Ch != ',')
       if (_Ch == ')')
          _Im = 0;
       else
          _I.putback(_Ch), _I.setstate(ios_base::failbit);
       else if (_I &gt;_Im &gt; _Ch &amp;&amp; _Ch != ')')
          _I.putback(_Ch), _I.setstate(ios_base::failbit);
   if (!_I.fail())
       _X = complex&lt;_T&gt;((_T)_Re, (_T)_Im);
   return (_I); }
       // TEMPLATE FUNCTION operator&lt;&lt;
template&lt;class _T&gt; inline
   ostream&amp; operator&lt;&lt;(ostream&amp; _0, const complex&lt;_T&gt;&amp; _X)
   {return (_0 &lt;&lt; '(' &lt;&lt; real(_X) &lt;&lt; ',' &lt;&lt; imag(_X) &lt;&lt; ')'); }
       // TEMPLATE FUNCTION abs
template&lt;class _T&gt; inline
   _T abs(const complex&lt;_T&gt;&amp; _X)
   {int _Xexp;
   _T _Rho = _Fabs(_X, &amp; _Xexp);
   return (_Xexp == 0 ? _Rho : _Ctr&lt;_T&gt;::ldexp(_Rho, _Xexp)); }
       // TEMPLATE FUNCTION arg
template&lt;class _T&gt; inline
   _T arg(const complex&lt;_T&gt;&amp; _X)
   {return (_Ctr&lt;_T&gt;::atan2(imag(_X), real(_X))); }
       // TEMPLATE FUNCTION conjg
template&lt;class _T&gt; inline
   complex&lt;_T&gt; conj(const complex&lt;_T&gt;&amp; _X)
   {return (complex&lt;_T&gt;(real(_X), -imag(_X))); }
       // TEMPLATE FUNCTION cos
template&lt;class _T&gt; inline
   complex&lt;_T&gt; cos(const complex&lt;_T&gt;&amp; _X)
   {return (complex&lt;_T&gt;(
       _Ctr&lt;_T&gt;::_Cosh(imag(_X), _Ctr&lt;_T&gt;::cos(real(_X))),
       -_Ctr&lt;_T&gt;::_Sinh(imag(_X), _Ctr&lt;_T&gt;::sin(real(_X))))); }
       // TEMPLATE FUNCTION cosh
template&lt;class _T&gt; inline
   complex&lt;_T&gt; cosh(const complex&lt;_T&gt;&amp; _X)
   {return (complex&lt;_T&gt;(
       _Ctr&lt;_T&gt;::_Cosh(real(_X), Ctr&lt;_T&gt;::cos(imag(_X))),
       _Ctr&lt;_T&gt;::_Sinh(real(_X), _Ctr&lt;_T&gt;::sin(imag(_X))))); }
       // TEMPLATE FUNCTION exp
template&lt;class _T&gt; inline
   complex&lt;_T&gt; exp(const complex&lt;_T&gt;&amp; _X)
   {_T _Re(real(_X)), _Im(real(_X));
   _Ctr&lt;_T&gt;::_Exp(&amp;_Re, _Ctr&lt;_T&gt;::cos(imag(_X)), 0);
   _Ctr&lt;_T&gt;::_Exp(&amp;_Im, _Ctr&lt;_T&gt;::sin{imag(_X)), 0);
   return (complex&lt;_T&gt;(_Re, _Im)); }
       // TEMPLATE FUNCTION log
template&lt;class _T&gt; inline
   complex&lt;_T&gt; log(const complex&lt;_T&gt;&amp; _X)
   {int _Xexp;
   _T _Rho = _Fabs(_X, &amp; _Xexp);
   if (_Ctr&lt;_T&gt;::_Isnan(_Rho))
       return (complex&lt;_T&gt;(_Rho, _Rho));
   else
       {static const _T _Cm = 22713.0 / 32768.0;
       static const _T _Cl = 1.428606820309417232e-6L;
       _T _Xn = _Xexp;
       complex&lt;_T&gt; _W(_Rho == 0 ? - _Ctr&lt;_T&gt;::_Infv(_Rho)
          : _Ctr&lt;_T&gt;::_Isinf(_Rho) ? _Rho
          : _Ctr&lt;_T&gt;::log(_Rho) + _Xn * _Cl + _Xn *_Cm,
             _Ctr&lt;_T&gt;::atan2(imag(_X), real(_X)));
       return (_W); }}
       // TEMPLATE FUNCTION norm
template&lt;class _T&gt; inline
   _T norm(const complex&lt;_T&gt;&amp; _X)
   {return (real(_X) * real(_X) + imag(_X) * imag(_X)); }
       // TEMPLATE FUNCTION polar
template&lt;class _T&gt; inline
   complex&lt;_T&gt; polar(const _T&amp; _Rho, const _T&amp; _Theta)
   {return (complex&lt;_T&gt;(_Rho * _Ctr&lt;_T&gt;::cos(_Theta),
       _Rho * _Ctr&lt;_T&gt;::sin(_Theta))); }
       // TEMPLATE FUNCTION pow
template&lt;class _T&gt; inline
   complex&lt;_T&gt; pow(const complex&lt;_T&gt;&amp; _X, const complex&lt;_T&gt;&amp; _Y)
   {return (imag(_Y) == 0 ? pow(_X, real(_Y))
       : imag(_X) == 0 ? complex&lt;_T&gt;(pow(real(_X), _Y))
       : exp(_Y * log(_X))); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; pow(const complex&lt;_T&gt;&amp; _X, const _T&amp; _Y)
   {return (imag(_X) == 0 ? complex&lt;_T&gt;(
       _Ctr&lt;_T&gt;::pow(real(_X), _Y))
       : exp(_Y * log(_X))); }
template&lt;class _T&gt; inline
   complex&lt;_T&gt; pow(const complex&lt;_T&gt;&amp; _X, int _Y)
   {if (imag(_X)== 0)
       return (complex&lt;_T&gt;(pow(real(_X), _Y)));
   else
       return (_Pow_int(complex&lt;_T&gt;(_X), _Y)); }
template&lt;class _T&gt; inline
   complex&lt;_T) pow(const _T&amp; _X, const complex&lt;_T&gt;&amp; _Y)
   {return (imag(_Y)== 0
       ? complex&lt;_T&gt;(_Ctr&lt;_T&gt;::pow(_X, real(_Y)))
       : exp(_Y * _Ctr&lt;_T&gt;::log(_X))); }
       // TEMPLATE FUNCTION sin
template&lt;class _T&gt; inline
   complex&lt;_T&gt; sin(const complex&lt;_T&gt;&amp; _X)
   {return (complex&lt;_T&gt;(
       _Ctr&lt;_T&gt;::_Cosh(imag(_X), _Ctr&lt;_T&gt;::sin(real(_X))),
       _Ctr&lt;_T&gt;::_Sinh(imag(_X), _Ctr&lt;_T&gt;::cos(real(_X))))); }
       // TEMPLATE FUNCTION sinh
template&lt;class _T&gt; inline
   complex&lt;_T&gt; sinh(const complex&lt;_T&gt;&amp; _X)
   {return (complex&lt;_T&gt;(
       _Ctr&lt;_T&gt;::_Sinh(real(_X), _Ctr&lt;_T&gt;::cos(imag(_X))),
       _Ctr&lt;_T&gt;::_Cosh(real(_X), _Ctr&lt;_T)::sin(imag(_X))))); }
       // TEMPLATE FUNCTION sqrt
template&lt;class _T&gt; inline
   complex&lt;_T) sqrt(const complex&lt;_T&gt;&amp; _X)
   {int _Xexp;
   _T _Rho = _Fabs(_X, &amp;_Xexp);
   if (_Xexp == 0)
       return (complex&lt;_T&gt;(_Rho, _Rho));
   else
       {_T _Remag = _Ctr&lt;_T&gt;::ldexp(real(_X) &lt; 0
          ? - real(_X) : real(_X), -_Xexp);
       _Rho = _Ctr&lt;_T&gt;::ldexp(_Ctr&lt;_T&gt;::sqrt(
          2 * (_Remag + _Rho)), _Xexp / 2 - 1);
       if (0 &lt;= real(_X))
          return (complex&lt;_T&gt;(_Rho, imag(_X) / (2 *_Rho)));
       else if (imag(_X) &lt; 0)
          return (complex&lt;_T&gt;(-imag(_X) / (2 * _Rho), -_Rho));
       else
          return (complex&lt;_T&gt;(imag(_X) / (2 * _Rho), _Rho)); }}
_STD_END
#endif /* _COMPLEX_ */
//End of File</pre>

</BODY>
</HTML>
