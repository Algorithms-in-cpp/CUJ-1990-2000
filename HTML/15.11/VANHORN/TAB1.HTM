



<HTML><HEAD>

<TITLE>November 1997/Rolling Your Own Input Iterators/Table 1</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<h4>Table 1:	Input Iterator Requirements</h4>
<p>In the following:<br>
<LI> X is an input iterator type</LI>
<LI>  T is the value type for X.</LI>
<LI>  a and b are values of type X.</LI>
<LI>  r is a value of type X&amp;.</LI>
<LI>  t is a value of type T.</LI>
<LI>  u, tmp, and m are identifiers.</LI><br>
A type X satisfies the requirements of an input iterator for value type T if
the following expressions are valid:</p>
<pre>
<b>operation       type              semantics, pre/post-condition</b>
1. X u(a);	X	          post: u is a copy of a
                                  A destructor is assumed to be
                                  present and accessible.
2. u = a;       X (?)             result: u
		                  post: u is a copy of a
3. a == b       converts to bool  == is an equivalence relation over its
                                  domain
4. a != b       converts to bool  bool(a==b) != bool(a!=b) if (a, b) is
                                  in the domain of ==.
5. *a           T (?)             pre: a is dereferenceable
                                  If (a, b) is in the domain of ==,
                                  and a==b, then *a is equivalent to *b.
6. a-&gt;m                           pre: (*a).m is well-defined
                                  Equivalent to (*a).m
7. ++r          X&amp;                pre: r is dereferenceable
                                  post: either r is dereferenceable
                                  or r is past-the-end.
                                  post: any copies of r's previous
                                  value are no longer required either
                                  to be dereferenceable or in the domain of ==.
8. (void)r++                      equivalent to (void)++r
9. *r++         T                 { T tmp = *r; ++r; return tmp; }
</pre>
</body></html>
