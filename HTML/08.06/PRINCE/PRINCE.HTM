


<HTML>
<HEAD>

<TITLE>June 1990/Generating Source For <float.h></TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Generating Source For &lt;float.h&gt;<A name="0155_00B7"><A name="0155_00B7"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0155_0000"><A name="0155_0000">Dr. Timothy Prince</font></h3><hr><blockquote><P>
<P><i><A name="0155_0000"><A name="0155_0000">Timothy Prince has worked 25 years in aerodynamic design and computational analysis. He first wrote software in BASIC in 1967 on a GE225 with KSR32 terminals. His first renovation of old FORTRAN came shortly thereafter, leading to more such projects, including seminars on adapting code to modern architectures. He received a B.A. in physics from Harvard and a Ph.D. in mechanical engineering from the University of Cincinnati. He can be contacted at 39 Harbor Hill, Grosse Pointe Farms, MI 48236.</i></P><P>
The standard for ANSI C defines several header files which are not supported under many current compilers. Most of these header files may be created by reference to the library documentation of a given compiler and a good reference on ANSI C.<P>
Two header files contain most of the definitions of the size of the arithmetic types supported by an ANSI C compiler. The integer types are described in &lt;<I>limits.h</I>&gt;, and the appropriate parameters may be looked up in the documentation of most systems. Floating point types are described in <I>&lt;float.h&gt;</I>. On BSD systems, similar territory is covered by &lt;<I>values.h</I>&gt;. Since this concept may be new to many C programmers, I will describe a C program which may be run to create &lt;<I>float.h</I>&gt; without depending on non-standard headers such as &lt;<I>values.h</I>&gt;, and some of the reasons why one might wish to use such a file.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Although the ANSI standard permits all manner of expressions in &lt;<I>float.h</I>&gt;, its utility is not severely compromised by restricting the values to constants. Additionally, if &lt;<I>float.h</I>&gt; values are constants, then in many cases they can be acted upon by integer comparisons and can be used to control conditional compilation. Technically, some of the example macros shown are non-portable.</FONT></FONT></FONT></FONT><P>
The ANSI committee didn't restrict &lt;<I>float.h</I>&gt; parameters to <I>#if</I> expressions. This allows the environment to change at runtime. For example, if the rounding mode could be changed by a function call, then <I>FLT_ROUNDS</I> would become a runtime function rather than a function only of the compiler options. Or, the committee may have meant to remove some of the architecture dependence from &lt;<I>float.h</I>&gt;, making it independent of the target hardware. It seems to me that such independence defeats the purpose of header files. An example similar to the unsatisfactory behavior permitted by ANSI C occurs in the BSD &lt;<I>values.h</I>&gt;, where <I>DSIGNIF</I> is defined in terms of <I>sizeof(double)</I>, preventing the preprocessor from using <I>DSIGNIF</I> to control conditional compilation.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
In my view, a compiler should be able to select appropriate header files, rather than having the header file select constants from a library which the compiler has chosen according to the options in effect. If we have a portable program which can put these parameters into the header file in a form which the preprocessor can use, we can overcome these restrictions.<P>
<h4><FONT COLOR="#000080"><A name="0155_00B8">Relationship To Floating Point Standards<A name="0155_00B8"></FONT></h4></P>
Two IEEE draft floating point standards prescribe the system behaviors which are described in &lt;<I>float.h</I>&gt;. These are P754, for 32/64-bit floating point, and P854, for any width floating point. One might expect to be able to write &lt;<I>float.h</I>&gt; directly from the P754 standard. In practice, not only are there variations in whether <I>long double</I> differs from <I>double</I>, but also in whether the implementors choose to apply IEEE rounding in <I>long double</I> or <I>double</I> precision. The Cray, DEC, and IBM traditions, predating the IEEE standards activity, also dictate certain shortcuts which increase speed at the cost of accuracy. Fortunately, there are ways to test the arithmetic by running C code on the target system, so that <I>float.h</I> may be created without depending on the style of C support.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0155_00B9">Computing &lt;float.h&gt; Parameters<A name="0155_00B9"></FONT></h4></P>
The first characteristic to be determined is the radix, or base, for floating point arithmetic. IEEE P754 requires base two, with P854 permitting also base 10. Only with these bases is there a reasonable degree of associativity in computational arithmetic, so that the expression .<I>5</I>*(<I>x</I>+<I>y</I>) evaluates the same as <I>x</I>*.<I>5</I>+<I>y</I>*.<I>5</I> for all values of <I>x</I> and <I>y</I> between 2*<I>DBL_MIN</I> and .<I>5</I>*<I>DBL_MAX</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
IBM-compatible mainframes, which use base 16 arithmetic, are the most common environment which uses a non-IEEE radix. Early versions of Aztec C used a radix of 256 so that normalizations could be performed by byte string moves, leading to a waste of up to a full byte out of each number.<P>
The test code exploits the properties of floating point arithmetic to determine the limiting parameters needed in &lt;<I>float.h</I>&gt;. The radix is found by determining the smallest power of <I>2</I> which is not affected by adding <I>1</I> (due to the limitations of the precision). This is a large integer, such as 2<SUP>53</SUP> for IEEE P754 <I>double</I>. Then the next floating point value is greater by the radix.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0155_00BA">Accuracy<A name="0155_00BA"></FONT></h4></P>
The <I>float.h</I> parameters <I>DBL_EPSILON</I>,<I> FLT_EPSILON</I>,<I> LDBL_EPSILON</I> are the difference between <I>1</I> and the next larger value of <I>double</I>,<I> float</I>, and <I>long double</I>. Corresponding parameters <I>DBL_DIGITS</I> etc., give the approximate equivalent number of significant digits. An example of the use of these would be conditional compilation to select the data type which should provide a required level of accuracy on various systems. The code to find these numbers resembles the code used to find the radix.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Since <I>long double</I> is not supported by many compilers, the type <I>register double</I> is assumed to be equivalent for non-ANSI compilers. The code presented here has been tested successfully on a variety of systems, all of which satisfy the requirement that all <I>register doubles</I> within a loop remain in <I>long double</I> precision. <I>Long double</I> generally is not supported in <I>log()</I>, <I>atof()</I>, and <I>printf()</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0155_00BB">Rounding<A name="0155_00BB"></FONT></h4></P>
ANSI C provides for a parameter specifying the type of rounding behavior, defined as whether rounding is performed in addition operations. The implicit assumption that this behavior does not depend on data type is not strictly true. For instance, <I>double</I> arithmetic on 8087 and 68881 systems may be rounded first to 64 bits and then to 53 bits precision, causing slight errors. Certain older systems may have better rounding in <I>float</I> precision than <I>double</I> or <I>register double</I>. By performing these tests in <I>long double</I>, we can use <I>"float.h"</I> as a guide to wringing the last bit of accuracy out of <I>long double</I> arithmetic. Performing intermediate steps in higher precision than the final destination will provide maximum accuracy in other cases.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
There is no apparent concern in the ANSI C standard for the distinction between IEEE-style rounding, where numbers are rounded to the nearest even when they fall exactly on a rounding threshold, and DEC-style rounding, where the threshold numbers are rounded away from zero. Likewise, ANSI C does not care, as the IEEE standard does, whether one's or two's complement is used for floating point. Unlike &lt;<I>limits.h</I>&gt;, &lt;<I>float.h</I>&gt; does not tell whether the range of negative numbers may be larger than the range of positive numbers. To my knowledge, the most serious practical implication of ignoring these points in &lt;<I>float.h</I>&gt; is the inability to detect certain obsolete machines which switch from <I>FLT_ROUNDS</I> == <I>0</I> behavior for positive and small negative values to <I>FLT_ROUNDS </I>==<I> 3</I> for larger negative numbers.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
You will notice, by examining the C code, that the rounding test expressions could be simplified to a point where they will indicate that rounding is not performed. Aside from the test for <I>subgrd</I>, which certain K&amp;R compilers may change to the point where it cannot be passed, known compilers are close enough to ANSI C that this should not be a problem. We are interested in how the system executes a C program, so it is immaterial whether the compiler or the hardware cause incorrect rounding.</FONT></FONT><P>
The addition and subtraction tests generate the expressions<P>
<pre>1 + .5*(1+LDBL_EPSILON),
1 + .5*(1-LDBL_EPSILON),
1 - .5*(1+LDBL_EPSILON)/FLT_RADIX,
1 - .5*(1-LDBL_EPSILON)/FLT_RADIX,</pre>
and check to see how they are rounded. These tests cannot be passed unless the arithmetic is carried out exactly before rounding (as in the case of <I>float</I> arithmetic carried out in <I>double</I> precision) or a "sticky" bit is used to record the loss of bits shifted out. Similar tests with the <I>_EPSILON</I> removed could be used to distinguish IEEE from DEC-style rounding.</FONT></FONT></FONT></FONT></FONT></FONT><P>
Tests have been added to determine whether multiplication and division are rounded in a manner similar to addition. These tests check only whether the largest possible fraction of <I>_EPSILON</I> is lost in rounding each side of <I>1</I>.</FONT></FONT></FONT></FONT><P>
Many compilers choose to convert the vector by scalar division operation to an inversion outside the loop with multiplications inside, gaining speed at the cost of accuracy. The compiler may even be set up so that it passes the IEEE conformance tests which do not exercise vector operations.<P>
Similar tests are available for <I>sqrt()</I>, but have not been included here because conditional compilations are not likely to be based on the correctness of <I>sqrt()</I>.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0155_00BC">Range<A name="0155_00BC"></FONT></h4></P>
Most systems have different ranges for various floating point types, with (perhaps total) loss of accuracy when numbers exceed the range. It may also be useful to know what range of exponent values as well as how much accuracy is possible when setting up format strings for <I>printf()</I>.</FONT></FONT><P>
To test for the values of <I>DBL_MIN.. </I><I>et al</I>, we start with (<I>1</I>+<I>DBL_EPSILON...</I>) and divide repeatedly by <I>FLT_RADIX</I> until a loss of accuracy occurs which prevents us from recovering the previous value by multiplying by <I>FLT_RADIX</I>. This sequence of operations finds the "minimum normalized value" for each data type, which is the smallest value for which the characteristics <I>DBL_DIGITS</I>... are valid. On some systems, this value is the smallest non-zero number available. If there is gradual underflow, the smallest non-zero number will be <I>_EPSILON</I> times this size. If these partially underflowed numbers are supported, as the IEEE standard demands, they may not (as on the 8087) be allowed as a divisor, so portable programs will not rely on them. In order to avoid complaints from <I>log()</I> when it gets a very small argument, we calculate the logarithm for the <I>long double</I> case from the loop count. Thus we need not depend on availability of <I>logl()</I>. The extra runtime taken by this slow and simple code on a 68881 is insignificant for code which is to be run only a few times per compile.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
To find <I>DBL_MAX</I>... we try powers of <I>FLT_RADIX</I> until we get an overflow, indicated by reaching a value which does not increase when multiplied again by <I>FLT_RADIX</I>. We must be prepared for the program to abort, since that is the way DEC works. If the code keeps running, we go on and do the same for all the data types. On modern systems, there is a special bit pattern obtained at overflow, which <I>printf()</I> displays as <I>"Inf"</I>(inity). The code will detect the <I>Inf</I> result because it will not change as we try to back down to smaller magnitudes. Previous values are saved so that <I>DBL_MAX</I> may be displayed as the number obtained before <I>Inf</I> is obtained twice. The computations use negative numbers because some older systems used two's complement for floating point as well as for integers. On such systems the maximum negative number could be exactly a power of the radix, with the maximum positive number (which we are searching for) being slightly less.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0155_00BD">Accuracy Of Conversion To And From Decimal<A name="0155_00BD"></FONT></h4></P>
Compilers may have trouble digesting the <I>MAX</I> and <I>MIN</I> decimal values if they happen to convert to binary values outside the range. The IEEE standards specify ability to convert within <I>.47 _EPSILON</I>, but this is possible only when the <I>printf()</I> and <I>scanf()</I> functions use extended precision. For example, the IEEE-specified ability to convert to within <I>.47 DBL_EPSILON</I> is implemented in the 8087 by the use of <I>long double</I>, so that <I>double</I> conversions should be accurate. Although <I>long double</I> has over 19 significant digits, only 17 or 18 digits will be converted correctly to decimal. The number 17 complies with the IEEE standard, and the correct conversion of integers to 18 digits complies with COBOL compiler standards. On a machine which implements <I>long double</I> as the same as <I>double</I>, as many significant digits may be lost in <I>printf()</I> as there are in the exponent. The IEEE standard makes no demands on the ability to convert <I>long double</I> to decimal, so C libraries cannot be expected to support it without casting to <I>double</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Several of the <I>atof()</I> or <I>scanf()</I> functions I have tried were inadequate, so one is included in the code. The results written into <I>float.h</I> are adjusted away from the limits according to the amount of error found when nearby numbers are formatted by <I>sprintf()</I> and checked by <I>atof()</I>. The code, of course, trusts the compiler to use an adequate scheme for reading the constants from &lt;<I>float.h</I>&gt;! The difficulty of precisely converting constants may be another reason for the ANSI committee's caution against expecting portable constants in &lt;<I>float.h</I>&gt;. The standard allows for &lt;<I>float.h</I>&gt; constants to be in hexadecimal or other non-standard form, so that compilers may read them without error.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0155_00BE">Conclusion<A name="0155_00BE"></FONT></h4></P>
The ANSI C header file &lt;<I>float.h</I>&gt; may be obtained by running the test code on the target system (see <A href="list3.htm">Listing 3</a>
and <A href="list4.htm">Listing 4</a>
for sample output). The floating point arithmetic characteristics which we might wish to test when performing a conditional compilation may be pretested and summarized in &lt;<I>float.h</I>&gt; so that code may be written to work to best advantage on a variety of architectures. This is a good way to explain the use of roundabout expressions which are needed to overcome numerical difficulties.</FONT></FONT></FONT></FONT><P>
<h4>References</FONT></h4></P>
Cody, W. J. et al. "A Proposed Radix- and Word-length-independent Standard for Floating-point Arithmetic," <I>IEEE MICRO</I> reprint, 1984. This reference sets out the P854 draft standard, with some explanations.<P>
Stevenson, David et al. "A Proposed Standard for Binary Floating-Point Arithmetic," <I>IEEE COMPUTER</I> reprint, 1981.<P>
Plauger, P.J., Brodie, J. <I>Standard C</I>, Microsoft Press 1989. This reference explains the reasons for the P754 standard.<P>
<h4>Coding For Accuracy</FONT></h4></P>
Here is an example of how accuracy might be preserved for non-IEEE radix while allowing normal systems to use fast code:<P>
<pre>#include &lt;float.h&gt;

#if FLT_RADIX != 2 &amp;&amp; FLT_RADIX != 10
   y= ((b&gt;=0)==(c&gt;=0))? a*b+a*c : a*(b+c);
#else
   y = a*(b+c);
#endif</pre>
Of course, such code is more desirable when <I>b</I> and <I>c</I> are known to be of the same sign, so that the runtime conditional may be eliminated. Such attempts to retain the accuracy which would be lost by non-standard arithmetic, cost more time than is gained by faster hardware.<P>
A textbook case in which the effects of inaccurate division may be eliminated by careful coding is in the final calculation of a rational approximation for <I>exp()</I> (see <A href="list1.htm">Listing 1</a>)
.</FONT></FONT><P>
The <I>odds</I> term is known to be much smaller than the <I>evens</I> term, so the inaccuracy in division is buried by performing the addition of .<I>5 or 1</I> last when addition is known to be more accurate. On non-pipelined systems, the second alternative may be as fast as the first.</FONT></FONT><P>
<h4>Exploiting Range Information</FONT></h4></P>
This example shows how to use range parameters to determine whether the usual DEC and IBM style heroic measures need be taken when calculating the hypotenuse of a triangle:<P>
<pre>float x,y;
double tmp1,tmp2;
#if DBL_MAX_10_EXP &gt; 99 || DBL_MAX_10_EXP &gt; FLT_MAX_10_EXP
   hyp= sqrt (x*(double)x+y*(double)y);
#else
   hyp= ((tmp1=fabs(x))&gt;(tmp2=fabs(y)))?
      tmp1*sqrt((y/x)*(y/x)+1):
      tmp2*sqrt((x/y)*(x/y)+1);
#endif</pre>

You don't want to have your code abort in the middle of a three hour job because of an unrecoverable overflow or divide by zero, but you also want to avoid writing code which spends 20 percent of its CPU time calculating the hypotenuse. The IEEE precision extensions preclude this problem, but, with conditional compilation, we can still run the conservative method on the machines which require it.<P>
<P>

<A href="list2.htm">Listing 2</A>

<h4><a href="../../../source/1990/jun90/prince.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
