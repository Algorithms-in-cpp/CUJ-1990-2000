


<HTML>
<HEAD>

<TITLE>June 1990/A Date Object In C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">A Date Object In C++<A name="014A_00B1"><A name="014A_00B1"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="014A_0000"><A name="014A_0000">David Clark</font></h3><hr><blockquote><P>
<P><i><A name="014A_0000"><A name="014A_0000">The author has ten years programming experience and is a senior research scientist in the advanced technology group of Miles Diagnostics, a manufacturer of medical diagnostics instruments and reagents.</i></P><P>
It is something of a paradox that time is so difficult to define and yet we can measure its passage with more precision than any other physical quantity. One method to mark places in time is to assign dates to particular days. Western civilization keeps track of those dates by referring to calendars, specifically the Gregorian calendar, which was adopted in 1582.<P>
This article describes a date object implemented in C++, which simplifies date manipulation.<P>
<h4><FONT COLOR="#000080"><A name="014A_00B2">Calendars And Julian Dates<A name="014A_00B2"></FONT></h4></P>
Different cultures create different types of calendars. As far as I know, all are derived from attempts to measure the passage of the seasons. The Julian <I>calendar</I>, not to be confused with a Julian <I>date</I>, was one method adopted by the Romans.<P>
The term "Julian date" takes a lot of abuse. Though a Julian date has a very precise meaning in astronomy, we will relax that meaning here somewhat. In general terms, a Julian date is simply an integer representing a particular day in history. Many computer programs use something like a Julian date, assigning numbers to dates. However, many of these programs assign different numbers to the same date. I will use the same numbering system that astronomers use.<P>
One final point about Julian dates: in astronomy, Julian dates change at noon instead of midnight. However, the program I describe interprets date changes as occurring at midnight.<P>
<h4><FONT COLOR="#000080"><A name="014A_00B3">Implementation<A name="014A_00B3"></FONT></h4></P>
The files DATES.HPP, DATES.CPP and DATETEST.CPP in <A href="list1.htm">Listing 1</a>
to <A href="list3.htm">Listing 3</a>
show an implementation of a date object called <I>DateObject</I>. I compiled and tested the object with Zortech C++ v1.07 under MS-DOS 3.30.</FONT></FONT><P>
The header file DATES.HPP (<A href="list1.htm">Listing 1</a>)
 contains the declaration of the <I>DateObject</I> type, and several useful constants. DATES.CPP, shown in <A href="list2.htm">Listing 2</a>,
 contains most of the details of the implementation. <A href="list3.htm">Listing 3</a>,
 DATETEST.CPP, is a simple demonstration program illustrating some of the ways that <I>DateObjects</I> may be used.</FONT></FONT></FONT></FONT><P>
<I>DateObjects</I> can represent dates ranging from 1 January 4,700 BC to 31 December 25,000 AD. Though the limits are somewhat arbitrary, this range is adequate for my own uses. The boundaries are due to the implementation of the internal calculations which convert from day, month and year to a Julian date, and vice versa. The calculations will overflow the <I>int</I> used to represent the year if the range is exceeded by a large amount. The range could probably be extended by representing the year as a <I>long int,</I> but I have not bothered to try it.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00B4">Data<A name="014A_00B4"></FONT></h4></P>
The data associated with a <I>DateObject</I> consists of six fields listed at the top of the <I>DateObject</I> class declaration (<A href="list1.htm">Listing 1</a>)
. <I>Julian</I> is a <I>long int</I> representing the Julian date. The value <I>BADDATE, #defined</I> above the declaration of the <I>DateObject</I>, represents an invalid date.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>DateFormatPtr</I> field contains a pointer to a dynamically allocated character string. The string acts as a template that describes how a particular <I>DateObject</I> should be converted to a printable string.</FONT></FONT></FONT></FONT><P>
The <I>Day, Month, Year</I> and <I>DayOfWeek</I> fields represent what their names imply. The <I>Year</I> field takes on negative values to represent years B.C. These fields are somewhat redundant in that all of the information they contain can be calculated from the Julian date. I have included these fields for my own convenience, based on the untested assumption that some operations on <I>DateObjects</I> are faster if the information is kept at hand rather than recalculated. If storage space is a more pressing concern for you, these fields could probably be removed with little effort or performance degradation.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00B5">Internal Functions<A name="014A_00B5"></FONT></h4></P>
In addition to the public methods associated with a <I>DateObject</I>, DATES.CPP (<A href="list2.htm">Listing 2</a>)
 contains functions which are used only within the <I>DateObject</I> code. The function <I>IsLeap()</I> returns a non-zero value if the year passed to it is a leap year and returns zero otherwise.</FONT></FONT></FONT></FONT></FONT></FONT><P>
Checking for a leap year is not just a matter of determining if the year is evenly divisible by four. Leap years occur in the calendar because the time it takes the Earth to orbit the sun is not an integral number of days. It is almost 365.25 days &#151; almost, but not quite. Over a period of 100 years, the small errors accumulate, growing to almost one extra day. So, years evenly divisible by 100 are not leap years, unless they are divisible by 400 (which corrects for even smaller errors). By the same token, there is a special rule for years evenly divisible by 4000. Beyond that, my program does not care. For example, the year 2000 is a multiple of four, which would normally be a leap year. However, it is also a multiple of 100, which is not normally a leap year. However, it is also a multiple of 400, which means it is a leap year.<P>
<I>DaysInMonth()</I> returns the number of days in a particular month in a particular year. If the month is February, the function <I>IsLeap()</I> is called to determine if it is in a leap year. If so, 29 is returned. If the month is not February or the year is not a leap year, the number of days in the month is looked up in the array <I>MonthDays</I> and returned.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The function <I>CheckForValidDate()</I> determines if the <I>Day</I>, <I>Month</I> and <I>Year</I> passed to it represent a valid date. Besides checking that <I>Year</I> is within the limits of <I>MINYEAR</I> and <I>MAXYEAR</I>, the function checks that <I>Month</I> is valid and that <I>Day</I> is valid for the <I>Month</I> and <I>Year.</I></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The small function <I>JulianToDayOfWeek()</I> calculates the day of the week from the Julian date passed as its argument.</FONT></FONT><P>
The functions <I>DMYtoJulian()</I> and <I>JulianToDMY()</I> convert days, months and years to Julian dates and vice versa. These functions were taken almost directly from <I>Numerical Recipes in C</I> by Press, Flannery, Teukolsky and Vettering, pp. 10-13. Note that these functions take into consideration the ten-day gap that occurred in October of 1582 when converting from the Julian to the Gregorian calendar. I believe these functions are the only ones which make any direct or indirect calls to the floating point library. If recovering the memory used by the floating point calculations is important, these routines could probably be converted to all integer (or probably <I>long</I> <I>int</I>) operations.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00B6">Constructors<A name="014A_00B6"></FONT></h4></P>
Four constructors for <I>DateObject</I>s are declared in <A href="list1.htm">Listing 1</a>
and defined in <A href="list2.htm">Listing 2</a>.
 The constructor used depends on how the instance of a <I>DateObject</I> is declared. Instances declared without initializers are simply set to the current date.</FONT></FONT></FONT></FONT><P>
The first constructor in the <A href="list2.htm">Listing 2</a>
obtains the current date by calling DOS interrupt <I>33 (21H)</I>, service <I>42 (2AH).</I> The date is then copied to the correct fields of the <I>DateObject.</I> No checks for an illegal date are performed since it is assumed that MS-DOS always returns a legal date. A copy of the default format string is allocated, if possible, by calling the standard library function <I>strdup().</I> The <I>DateFormatPtr</I> field points to that copy. If a copy of the format string cannot be allocated, the <I>Julian</I> field is assigned the value <I>BADDATE</I> to indicate that the <I>DateObject</I> is invalid.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The second constructor in <A href="list2.htm">Listing 2</a>
is a "copy initializer". It takes as its single argument the address of another <I>DateObject</I> and copies the data from its argument into its own data fields. Copy initializers are not used so much by the programmer as by the compiler &#151; when a <I>DateObject</I> is a pass-by-value argument to a function or when a <I>DateObject</I> is returned from a function, for example.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The last two constructors accept initializers for the day, month and year. One uses a default format string pointed to by the <I>static</I> variable <I>CurrentDateFormat</I> (defined near the top of <A href="list2.htm">Listing 2</a>)
, while the other accepts a format string as one of the initializers. Both of these constructors call the member function <I>ChangeDate()</I> to copy data from the initializers to the new instance. These constructors check that the requested date is legal. Dates like 31 February 1980 will not be accepted. If the initializers would result in an illegal date, the <I>Julian</I> field is assigned the value <I>BADDATE</I> to indicate that the <I>DateObject</I> does not contain valid data.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
All of the constructors allocate the format string from dynamic memory by calling the standard library routine <I>strdup()</I>. If the allocation fails, <I>strdup()</I> returns a <I>NULL</I> pointer and the <I>Julian</I> field is set to <I>BADDATE.</I></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00B7"><I>Destructor</I><A name="014A_00B7"></FONT></h4></P>
The destructor for a <I>DateObject</I> simply releases the memory containing the format string, pointed to by <I>DateFormatPtr</I>, with a call to <I>free()</I>. <I>NULL</I> pointers are allowed since <I>free()</I> will accept a <I>NULL</I> argument without harm.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00B8">Access Functions<A name="014A_00B8"></FONT></h4></P>
The group of access functions, <I>GetDay()</I>, <I>GetMonth()</I>, <I>GetYear()</I>, <I>GetDayofWeek()</I>, <I>GetFormat()</I>, and <I>GetJulian()</I>, examine the internal contents of a <I>DateObject</I>. Note that <I>GetFormat()</I> returns a pointer to a copy of the format string, not to the format string itself, insuring that the format string cannot be altered by anything other than <I>DateObject</I> methods and forcing the programmer to <I>free</I> the unneeded copies.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00B9">Overloaded Operators<A name="014A_00B9"></FONT></h4></P>
One of the nice features of C++ is operator overloading, the ability to define new actions for existing operators. Operator overloading allows you to do date arithmetic and comparison with the same operators you use with "normal" operands.<P>
Because <I>DateObjects</I> contain the Julian date, logical comparison operations are easy. The overloaded comparison operators are implemented inline in <A href="list1.htm">Listing 1</a>
and simply perform the relevant comparison on the <I>Julian</I> fields.</FONT></FONT></FONT></FONT><P>
The assignment operator copies most of the data from the rvalue, which is passed by reference, into the lvalue <I>(this)</I>. A call to <I>strdup()</I> dynamically allocates and copies a new format string. The object containing the newly copied data is returned.</FONT></FONT></FONT></FONT><P>
It seems to me that date arithmetic is somewhat analogous to pointer arithmetic in C. It makes no sense to multiply or divide dates, but some addition and subtraction operations seem intuitive. For example, it makes sense to add integral quantities to a date to yield a new date. However, just as with pointers, it does not make sense to add two dates together. What is the meaning of "4 July 1776 + 20 July 1969" anyway? This addition should also be commutative (i.e. integer + Date == Date + integer).<P>
Subtraction with <I>DateObject</I> operands can take two forms. When one <I>DateObject is</I> subtracted from another, the result is an integral value representing the number of days between the two dates. In contrast to addition, subtraction is not commutative. It seems logical to subtract a number of days from a date but not to subtract a date from a number of days, i.e. "3L - 26 January 1986" has no meaning that I can see.</FONT></FONT></FONT></FONT><P>
The simplest overloaded operator is the subtraction operator used when one <I>DateObject</I> is subtracted from another. This operator is implemented as an inline <I>friend</I> operator, declared near the bottom of <A href="list1.htm">Listing 1</a>.
 The operator simply subtracts the <I>Julian</I> field of the second <I>DateObject</I> from the <I>Julian</I> field of the first and returns the difference. The returned value represents the number of days by which the two dates differ.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The subtraction operator is also overloaded in the case where a <I>long</I> is subtracted from a <I>DateObject</I>. This operation returns a <I>DateObject</I> whose value preceeds the <I>DateObject</I> argument by the number of days represented by the <I>long</I>. For example, 20 July 1969 - 3L would yield 17 July 1969.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The binary addition operator, +, has been overloaded by two methods: adding a <I>DateObject</I> to a <I>long</I>, and adding a <I>long</I> to a <I>DateObject</I>. Both methods yield a new date which corresponds to the date operand plus a number of days equal to the <I>long</I> operand. For example, 20 July 1969 + -3L yields 17 July 1969. The methods specify a <I>long</I> <I>int</I> as one of the arguments, but an <I>int</I> may be used in an expression since the compiler will promote the <I>int</I> to a <I>long</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The first overloaded operator for addition in <A href="list2.htm">Listing 2</a>
is really the foundation for most of the other overloaded arithmetic operators, and is implemented as a <I>friend</I> operator. It first adds the <I>long</I> argument to the <I>Julian</I> field of the <I>DateObject</I> argument. The operator function checks that the result is within the range <I>MINDATE</I> to <I>MAXDATE</I>. If so, the <I>Day</I>, <I>Month</I>, <I>Year</I> and <I>DayOfWeek</I> fields are calculated. The operator function initializes the <I>DateFormatPtr</I> field to point to a copy of the date format string of the <I>DateObject</I> argument.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The remainder of overloaded arithmetic operators, -, ++, -, += and -=, with the exception of the <I>friend</I> subtraction operator, are all implemented as variations of addition.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00BA">Formatting<A name="014A_00BA"></FONT></h4></P>
While using Microsoft's Excel spreadsheet, I found one of the most attractive features to be the user-definable formats that could be assigned to cells. From that inspiration, I built a simple format interpreter into the <I>DateObject</I>. The member function <I>DateToString()</I> dynamically allocates a string and fills it with a printable representation of a <I>DateObject</I>. The format of the string is controlled by the formatting instructions pointed to by <I>DateFormatPtr</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Basically, the interpreter recognizes four special characters and several combinations thereof. These control the format for the day, month and year. The characters are <I>d</I> for the day, <I>m</I> for the month, <I>y</I> for the year, and \ as an escape prefix. The number of special characters encountered determines the exact formatting.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<UL><li><I>     d</I> The day of the month, usually from 1 to 31.</FONT></li>
<li><I>     dd</I> The day of the month including a leading zero if needed, such as <I>07.</I></FONT></FONT></li>
<li><I>     ddd</I> A three letter abbreviation for the day of the week, e.g. "Sun" or "Wed".</FONT></li>
<li><I>     dddd</I> The day of the week fully spelled. These run from "Sunday" to "Saturday".</FONT></li>
<li><I>     m</I> The number of the month from <I>1</I> to <I>12.</I></FONT></FONT></FONT></FONT></li>
<li><I>     mm</I> The number of the month with a leading zero for months earlier than October, such as <I>09.</I></FONT></FONT></li>
<li><I>     mmm</I> A three letter abbreviation for the name of the month.</FONT></li>
<li><I>     mmmm</I> The full name of the month, "April" for example.</FONT></li>
<li><I>     yy</I> A two digit abbreviation for the year. For example, 1953 would be formatted as <I>53.</I></FONT></FONT></li>
<li><I>     yyy</I> Formatted as a signed integer from -<I>4700</I> to <I>25000.</I></FONT></FONT></FONT></FONT></li>
<li><I>     yyyy</I> An unsigned integer value representing the year, followed by "AD" for years greater than zero or "BC" for years less than zero.</FONT></li>
<li>\ Used as an escape character so that any of the letters above can be used as letters in a date format.</li></UL>
The current format is stored in the string pointed to by <I>CurrentDateFormat</I> and by default is <I>m-dd-yyy</I>. MS-DOS uses this same format to display file and system dates.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00BB">Format Examples<A name="014A_00BB"></FONT></h4></P>
If a <I>DateObject</I> contained the date 24 July 1995, <A href="table1.htm">Table 1</a>
shows how the date would be formatted with several different format strings.</FONT></FONT><P>
In the first example, the date is in the default format, just as MS-DOS would display it. In the second example, the order of the day and month have been reversed and the numeric month has been replaced by an alphabetic abbreviation. In the third example, the <I>d</I> character is used in two places: first to format the day of the week, then to generate the day of the month. Notice the comma after the <I>dddd</I>. Any text that is not recognized as a special character is simply placed in the output string unchanged. The next two examples cause only the year and the day of the week, respectively, to be placed in the string. The last example shows that arbitrary text can be placed in the format string and passed through to the output string. Notice that the <I>d</I> in "date" must be preceeded by a \ or it will be replaced by the day of the month instead.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>ChangeFormat()</I> changes the string used to format a <I>DateObject</I>. The function attempts to dynamically allocate a copy of its argument, the new format string. If successful, the old format string is released, and a pointer to the new string is installed in <I>DateFormatPtr</I> field. If the new format string cannot be allocated, no changes are made.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The function <I>ChangeDefaultDateFormat()</I> is not a <I>DateObject</I> method. It changes the default format string attached to <I>DateObjects</I> when they are instantiated without an initializer for the format. The format string used for these initializations is pointed to by the <I>static</I> variable <I>CurrentDateFormat</I> in <A href="list2.htm">Listing 2</a>.
 <I>ChangeDefaultFormat()</I> copies its argument to the heap and points <I>CurrentDateFormat</I> to the copy. The first call to <I>ChangeDefaultDateFormat()</I> sets the bookkeeping variable <I>OnHeap</I> to a nonzero value. Subsequent calls to <I>ChangeDefaultDateFormat()</I> will free the old string on the heap.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00BC">Miscellaneous<A name="014A_00BC"></FONT></h4></P>
The function <I>ChangeDate()</I> changes the date of a <I>DateObject</I>. The function first checks that its arguments represent a valid date. If not, zero is returned. If the requested change is valid, a new Julian date is calculated, and the new data is copied into the <I>DateObject</I>. <I>ChangeDate()</I> does not alter the date format string, though <I>ChangeFormat()</I> can be used for that purpose. For a valid new date, the function returns <I>1</I>. Note that two of the constructors are actually implemented with calls to <I>ChangeDate()</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The function <I>ValidDate()</I> determines whether a <I>DateObject</I> contains valid data by checking whether the <I>Julian</I> field has been set to <I>BADDATE</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00BD">Demonstration Program<A name="014A_00BD"></FONT></h4></P>
The program in <A href="list3.htm">Listing 3</a>
demonstrates how a <I>DateObject</I> might be used. Although output is accomplished by means of the stream operators, these operators are not necessary to use <I>DateObjects</I>. <A href="list4.htm">Listing 4</a>
shows the output produced by the program when the system date is set to 7 April 1993.</FONT></FONT></FONT></FONT><P>
The program begins by declaring five variables of type <I>DateObject</I>. The first three are assigned specific dates and formats. Since the last two variables are not explicitly initialized, when the program starts they are set to the current system date using the default format.</FONT></FONT><P>
The variables <I>d1</I> and <I>d2</I> are set to the earliest and latest dates respectively that a <I>DateObject</I> can hold, with the difference between the two assigned to <I>Diff</I> and displayed in a single statement. The value of <I>Diff</I> is thus the largest <I>long</I> operand that may be used in an arithmetic operation on <I>DateObjects</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The variable <I>d3</I> is initialized to 23 May 1968, which has the nice, round Julian date 2,440,000. The second group of statements checks whether or not the variable is assigned the Julian date we know it must have.</FONT></FONT><P>
The next three groups of statements in <A href="list3.htm">Listing 3</a>
illustrate more date arithmetic. The first group causes an overflow while the second group results in an underflow. In both cases, the result of the expression is a bad date. The third group does not cause overflow and returns a valid date, which is displayed.<P>
The final group of statements in the example first displays the date contained in <I>d4</I>, which was initialized to the system date using the default format. Next the format is changed by a call to <I>ChangeFormat</I>. The new format will cause <I>DateToString()</I> to return a string containing only the week day. Next, <I>DateObjects</I> are used in a <I>for</I> statement, being preincremented, postincremented and compared. Note that <I>d5</I> is never explicitly initialized. It has the same initial value as <I>d4</I> since <I>d5</I> was initialized to the system date by default. When the <I>for</I> statement is executed, the five days of the week following the system date are displayed.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The example does not exercise all of the capabilities of the <I>DateObject</I>, but does give you some idea of their flexibility.</FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="014A_00BE">Conclusion<A name="014A_00BE"></FONT></h4></P>
There are a number of additions and improvements that could be made to the <I>DateObject</I>. An obvious addition would be to overload the stream operators, &lt;&lt; and &gt;&gt;, to accept dates. The input operator would be somewhat more difficult because of the variety of formats in which dates can be written as strings.</FONT></FONT><P>
Reading and writing dates to binary files can be accomplished simply by storing the <I>Julian</I> field and the format string. All of the other information can be reconstructed. Additional conversion methods might include functions to convert between <I>DateObjects</I> and MS-DOS file dates.</FONT></FONT></FONT></FONT><P>
As implemented, the <I>DateObject</I> does not implement many of the powerful features of object-oriented programming (no inheritance or polymorphism for example). However, it is easy to imagine a <I>DateObject</I> as a descendant of a more general <I>Time</I> class. In addition to the Gregorian calendar, it should be possible to create sibling classes for date objects based on the Chinese, Hebrew, Moslem or Aztec calendars, all descending from an abstract <I>Date</I> class.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>

<h4><a href="../../../source/1990/jun90/clark.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
