


<HTML>
<HEAD>

<TITLE>June 1990/An Applied File I/O Tutorial: Text-Based Disk Routines</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocjun.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">An Applied File I/O Tutorial: Text-Based Disk Routines<A name="0153_00B5"><A name="0153_00B5"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="0153_0000"><A name="0153_0000">Leor Zolman</font></h3><hr><blockquote><P>
<P><i><A name="0153_0000"><A name="0153_0000">After spending the first half of his life in Hollywood, CA and the second in Boston, MA (where he happily discovered Thai restaurants), Leor Zolman now resides directly between those two cities in beautiful Lawrence, KS, where he has a tremendously enjoyable time hacking DOS and Xenix systems for CUJ (but really misses Thai restaurants.)</i></P><P>
In the first two installments of this tutorial series, I presented the framework, user-interface and record-editing portions of a small, special-purpose database program. Now we arrive, finally, at the central point of the tutorial: the storage and retreival of database records to and from the mass storage device.<P>
<h4><FONT COLOR="#000080"><A name="0153_00B6">Text Or Binary?<A name="0153_00B6"></FONT></h4></P>
The fundamental design of the <I>read_db()</I> and <I>write_db()</I> functions depend on whether we store the data as human-readable, ASCII text or as a straight (raw) binary image. If efficiency is a major concern, then binary mode is the right choice: the data will take up less space on disk, and require the minimum amount of format translation during input and output operations. To make the routines easier to debug, however, the ASCII format is often more appropriate: storing the data in human-readable form allows for convenient visual inspections (using <I>type</I> or any text editor) after the data has been written to disk.</FONT></FONT></FONT></FONT></FONT></FONT><P>
Other considerations need also be taken into account when deciding upon a disk format. Will there ever be a need for the data to be read in by other applications, such as spreadsheets or fullblown database management systems? If so, the text format is probably the better choice.<P>
Depending on which of these two approaches is chosen, a different set of standard library functions will be required. For the ASCII approach, the line-oriented formatted I/O functions <I>fprintf()</I> and <I>fscanf()</I> will do all the work. The binary approach will rely on the byte-oriented functions <I>fread()</I> and <I>fwrite()</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0153_00B7">The Interface<A name="0153_00B7"></FONT></h4></P>
Both versions of <I>read_db()</I> and <I>write_db()</I> interface with their calling routine (the <I>main</I> function) via the same set of external data:</FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>RECS</I>: the array of pointers to data records. The actual array name is <I>recs</I>, with <I>RECS</I> being a defined synonym for <I>recs</I>. This synonym will ease a future transition to dynamic array allocation.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>n_recs</I>: the number of records currently stored in <I>RECS</I>.</FONT></FONT></FONT></FONT><P>
The only additional piece of information specified by the caller is the file name to be used for the operation.<P>
<I>write_db()</I> does not return any value; either the data is written correctly, or the error is diagnosed within <I>write_db()</I> and the program aborts through a call to the <I>error()</I> function. See the Exercises section at the end of this article for more on <I>write_db()</I> error recovery.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>read_db()</I> returns the number of records loaded.</FONT></FONT><P>
For convenience, the header file for this mini-database system is reproduced in <A href="list1.htm">Listing 1</a>.
<P>
<h4><FONT COLOR="#000080"><A name="0153_00B8">The <B><I>read_db()</I></B> Function<A name="0153_00B8"></FONT></FONT></FONT></h4></P>
<A href="list2.htm">Listing 2</a>
shows the <I>read_db()</I> and <I>write_db()</I> functions written to work with ASCII data files.</FONT></FONT></FONT></FONT><P>
<I>read_db()</I> begins by defining several control variables, along with a set of temporary variables for containing record field values in transition from disk to memory array storage.</FONT></FONT><P>
The control variables are:<P>
<I>fp</I>: the file pointer for buffered input</FONT></FONT><P>
<I>rec_no</I>: the number of records read in so far</FONT></FONT><P>
<I>rp</I>: a temporary record buffer pointer</FONT></FONT><P>
<I>nitems</I>: the number of items read in each line of input</FONT></FONT><P>
<I>read_db()</I> starts out by setting the <I>max_recs</I> variable to the maximum number of records that can be handled by the system (line 31). Since the <I>recs</I> array is defined statically to contain <I>MAX_RECS</I> elements, the value of <I>max_recs</I> will never change in this version; we'll make better use of <I>max_recs</I> later when adding dynamic array allocation to the system.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
To open the input file, the <I>fopen ()</I> library function is called with a mode of <I>"r"</I> to specify text mode. <I>NULL</I> (0) is returned if the file cannot be opened.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The text format chosen for the data consists of a single line of ASCII text (terminated by newlines) per record, with whitespace (one space character) between each field of a record and no other whitespace permitted.<P>
The main read loop (lines 39-68) opens with a call to the <I>fscanf</I> function. The format specification contains one format conversion specifier of the appropriate type for each field of the record, and the remaining parameters are the locally-defined temporary variables. Because the parameters to the <I>scanf</I> family of input functions must all be pointers, the &amp; operator must be used on the scalar parameters in order to generate pointers to those objects. The character array parameters (<I>last</I> and <I>first</I>) do not need the &amp; operator applied to them, because array names used alone are equivalent to pointers to their first elements.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>fscanf</I> returns a value telling how many items were actually matched from the input, and we assign that value to the variable <I>nitems</I>. If the value was <I>EOF</I>, then a normal end-of-file has been reached and we fall out of the loop, close the file, and return with the total number of records loaded (<I>rec_no</I>, initialized to zero at the top of the function.)</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
If <I>nitems</I> ends up with any value other than 7, then something unexpected was encountered in the input; a warning message is printed and the reading loop is exited.</FONT></FONT><P>
Having avoided all the possible error conditions from the <I>fscanf()</I> call, we are ready to deal with a valid record's worth of new data. The first step is to get some memory in which to store the data; the <I>alloc_rec()</I> function (<A href="list3.htm">Listing 3</a>,
 reproduced from the <I>MDBUTIL.C</I> listing shown in the April '90 issue) does this for us. <I>alloc_rec()</I> returns either a valid pointer to the needed block of memory, or <I>NULL</I> if the memory could not be allocated. This return value is assigned to the<I> rp</I> variable.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Using the <I>rp</I> pointer, each field value is copied into the memory block obtained from <I>alloc_rec</I>. Then the address of this memory block is installed in the <I>RECS</I> array and the record counter <I>rec_no</I> is incremented (line 67) for the next loop iteration.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>write_db()</I> function is set up much like <I>read_db()</I>. Since the <I>fprintf()</I> function takes values, not pointers, for its list of parameters to write, there is no need for &amp; operators (in fact, using them would cause incorrect results.) The return value from <I>fprintf()</I> is checked only for a single negative error flag, in accordance with <I>fprintf()</I>'s definition.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The only additional feature of interest in <I>write_db()</I> is the use of a temporary file for writing the output text. This practice insures against losing both the results from the current session <I>and</I> the previously stored database data file in the event of a catastrophic failure during the output writing process. Only if the temporary file is written without incident, is the previous version of the file erased and the temporary file renamed. To be especially safe, a check is performed on the return value of the <I>rename()</I> call (line 110-116) in case the new filename is not accepted; in this case, the user is given the opportunity to enter other names until the <I>rename()</I> call succeeds.</FONT></FONT></FONT></FONT></FONT></FONT><P>
Next time, I'll show how to implement the <I>read_db()</I> and <I>write_db()</I> functions using raw binary images instead of ASCII data.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0153_00B9">Exercises<A name="0153_00B9"></FONT></h4></P>
1. The %<I>s</I> format conversions used to read in the first and last name fields effectively prevent those fields from being able to contain space characters. What if a two-part first or last name needs to be represented, or a middle name? A way to extend the system to allow strings with embedded spaces would be useful, and this can be accomplished by changing the text format to require a delimiter character between each field item. A special form of format conversion may be used in place of "%<I>s</I>" to read such variable-legth string fields: if the delimiter character chosen were the vertical bar, for example, then a <I>scanf</I> call to read a single line containing a variable-legth string (terminated by a vertical bar character) followed by an integer would look like:</FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>scanf("%[^<FONT FACE="Symbol" SIZE=2>|</FONT>] <FONT FACE="Symbol" SIZE=2>|</FONT>%d\n", string, &amp;i);</pre>
The sub-sequence %<I>[</I>^<FONT FACE="Symbol" SIZE=2>|</FONT><I>]</I> tells <I>scanf</I> to match all characters up to but <I>not</I> including the first <FONT FACE="Symbol" SIZE=2>|</FONT> character encountered. The final <FONT FACE="Symbol" SIZE=2>|</FONT> in the format sequence says to then skip the <FONT FACE="Symbol" SIZE=2>|</FONT> character in the input stream.<P>
Modify the mini-database to allow spaces within the first name and last name fields, using this technique.<P>
2. As written, if an error occurs during the main loop of a <I>write_db()</I> call it is possible to lose all data modified in the current session. Modify the program to recover gracefully from a file output error, so that the user has a chance to try again on, say, a different drive. Note that <I>write_db()</I> is currently called from both the <I>SAVE</I> and <I>QUIT</I> main menu options.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>

<h4><a href="../../../source/1990/jun90/zolman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
