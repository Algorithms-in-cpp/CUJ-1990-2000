

<HTML>
<HEAD>

<TITLE>March 1995/Code Capsules</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmar.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Code Capsules<A name="006A_003D"><A name="006A_003D"></font></h2><P>
<h3 align="center"><A name="006A_0000"><A name="006A_0000">The Standard C Library, Part 3</h3><P>
<h3 align="center"><font color="#800000">Chuck Allison</font></h3><hr><blockquote><P>
<P><i><A name="006A_0000"><A name="006A_0000">Chuck Allison is a regular columnist with <I></I>CUJ<I></I> and a Senior Software Engineer in the Information and Communication Systems Department of the Church of Jesus Christ of Latter Day Saints in Salt Lake City. He has a B.S. and M.S. in mathematics, has been programming since 1975, and has been teaching and developing in C since 1984. His current interest is object-oriented technology and education. He is a member of X3J16, the ANSI C++ Standards Committee. Chuck can be reached on the Internet at <I></I>72640.1507@compuserve. com<I></I>.</i></P><P>
This month I conclude this series on the Standard C Library by exploring the headers in Group III (see <A href="tab1.htm">Table 1</a>, <a href="tab2.htm">Table 2</a>, 
and <A href="tab3.htm">Table 3</a>)
.<P>
<h4><FONT COLOR="#000080"><A name="006A_003E">Group III: For the "Complete" C Programmer<A name="006A_003E"></FONT></h4></P>
<h4><FONT COLOR="#000080"><A name="006A_003F">&lt;<B><I>float.h</I></B>&gt;<A name="006A_003F"></FONT></h4></P>
Perhaps nothing varies so widely across different computer environments as floating-point number systems. Some platforms require special hardware to make native floating-point instructions available. Others provide floating-point capability through software, and MS-DOS compilers must support both implementations.<P>
A floating-point number system is a collection of numbers that can be expressed in scientific notation, with a fixed number of digits. To be precise, it is the finite set of numbers of the form <I>&plusmn;0.d<SUB>1</SUB>d<SUB>2</SUB>...d<SUB>p</SUB> x <FONT FACE="Symbol" SIZE=2>b</FONT><SUP>e</SUP></I>, where <I>m <U>&lt;</U> e <U>&lt;</U> M</I>. The parameters <I><FONT FACE="Symbol" SIZE=2>b</FONT>, p, m</I>, and <I>M</I> represent the <I>radix, precision, minimum exponent</I>, and <I>maximum exponent</I>, respectively. The header &lt;<I>float.h</I>&gt; provides manifest constants for these and other important floating-point parameters (see <A href="tab4.htm">Table 4</a>;
 also see the sidebar, <a href="sidebar1.htm">"Floating-Point Number Systems"</a>). As <A href="tab4.htm">Table 4</a>
illustrates, each implementation must support three potentially separate number systems, one each for <I>float, double</I>, and <I>long double</I> numbers.<P>
<h4><FONT COLOR="#000080"><A name="006A_0040">&lt;<B><I>math.h</I></B>&gt;<A name="006A_0040"></FONT></h4></P>
Although C is not used widely in scientific programming, it provides a full-featured set of mathematical functions (see <A href="tab6.htm">Table 6</a>)
. Most of these functions have the standard names used in mathematics, so if you know what they are, you know how to use them. A few deserve special mention, however. As the program in <A href="list4.htm">Listing 4</a>
illustrates, the <I>fmod</I> function computes the remainder of dividing its first argument by its second. The answer to <I>fmod(1234.56, 90.1234</I><I>)</I> is 62.9558 because<P>
<pre>1234.56 - (13 * 90.1234) == 62.9558</pre>
The function <I>modf</I> stores the integer part of its first argument at the address given by its second argument, and returns the fractional part. <I>frexp</I> splits a floating-point number as given by its first argument into two parts, mantissa and base-2 exponent. In <A href="list4.htm">Listing 4</a>,
 <I>frexp</I> computes a normalized fraction <I>w</I> and an integer <I>p</I> such that its first argument, y, is equivalent to<P>
<pre><I>w</I> x 2<I><SUP>p</SUP></I></pre>
<I>frexp'</I>s inverse, <I>ldexp</I>, returns a floating-point number given mantissa <I>w</I> and exponent <I>p</I>.<P>
The floor of a number is itself if that number is an integer; otherwise the floor of a number is the next adjacent integer to the "left" on the number line, so the following relationships are valid:<P>
<pre>    floor(90.1234) == 90
    floor(-90.1234) == -91</pre>
The ceiling of a number is the next integer to the right, so<P>
<pre>    ceil(90.1234) == 91
    ceil(-90.1234) == -90</pre>
The calculator program in <A href="list5.htm">Listing 5</a>
illustrates a number of &lt;<I>math.h</I>&gt; functions.<P>
<h4><FONT COLOR="#000080"><A name="006A_0041">&lt;<B><I>errno.h</I></B>&gt;<A name="006A_0041"></FONT></h4></P>
<I>&lt;errno.h&gt;</I> implements a simple error reporting facility. It defines a global integer, <I>errno</I>, to hold certain error codes that are generated by a number of library functions. The C Standard requires vendors to provide only two codes, <I>EDOM</I> and <I>ERANGE</I> (see <A href="tab7.htm">Table 7</a>)
. <I>EDOM</I> indicates a <I>domain error</I>, which usually means that you passed bad arguments to the function. For example, the <I>sqrt</I> function in &lt;<I>math. h</I>&gt; complains if you ask for the square root of a negative number. Math functions can set <I>errno</I> to <I>ERANGE</I> to indicate a <I>range error</I>, which mean that a calculation on valid arguments would result in an arithmetic overflow or underflow. Most of the mathematical functions in the standard library use <I>errno</I> to report such errors. As the calculator in <A href="list5.htm">Listing 5</a>
illustrates, you should set <I>errno</I> to zero before invoking any function that uses this facility, and then check it immediately after the function returns. The function <I>perror</I> prints its string argument followed by a colon, followed by a string representation of the last error recorded in <I>errno. perror(s)</I> is equivalent to the expression:<P>
<pre>    printf("%s: %s\n",s,strerror(errno));</pre>
<I>strerror</I>, defined in <I>&lt;string.h&gt;</I>, returns implementation-defined text that corresponds to <I>errno</I>.<P>
The following functions from other standard library headers also set <I>errno</I> upon failure: <I>strod, strtol, strtoul, fgetpos, fsetpos</I>, and <I>signal</I>. The C Standard allows an implementation to provide error codes of its own, beyond <I>EDOM</I> and <I>ERANGE</I>, and to use the <I>errno</I> facility with other functions, but such use is of course non-portable.<P>
<h4><FONT COLOR="#000080"><A name="006A_0042">&lt;<B><I>locale.h</I></B>&gt;<A name="006A_0042"></FONT></h4></P>
A locale in Standard C is a collection of preferences for the processing and display of information that is sensitive to culture, language, or national origin, such as date and monetary formats. The Standard recognizes five categories of locale-specific information, named by macros in &lt;<I>locale.h</I>&gt; (see <A href="tab8.htm">Table 8</a>)
. Each of these categories can be set to a different locale (e.g., "american", or "italian"). For want of a better term, I call the collection of settings for all five categories the <I>locale profile</I>.<P>
Standard C specifies two functions that deal with locales directly:<P>
<pre>    struct lconv *localeconv(void);
    char *setlocale(int category, char *locale);</pre>
The members of the <I>lconv</I> structure appear in <A href="list6.htm">Listing 6</a>.
 <I>localeconv</I> returns a static <I>lconv</I> object containing current settings for <I>LC_MONETARY</I> and <I>LC_NUMERIC</I>, and <I>setlocale</I> changes the locale for the given category to that specified in its second argument. You can set all categories to the given locale by specifying a category of <I>LC_ALL</I> (see <A href="list7.htm">Listing 7</a>)
. If locale is <I>NULL, setlocale</I> returns the current locale string for the category. All implementations must support the minimalist "C" locale, and a native locale named by the empty string (which may be the same as the "C" locale). Unfortunately, few U.S. vendors provide any additional locale support.<P>
<h4><FONT COLOR="#000080"><A name="006A_0043">&lt;<B><I>setjmp.h</I></B>&gt;<A name="006A_0043"></FONT></h4></P>
When you encounter an exceptional condition deep within a set of nested function calls, you need a "super goto" that branches to a safe point higher up in the function call stack. That's what the <I>setjmp/longjmp</I> mechanism is for. You mark that safe return point with <I>setjmp</I>, and branch to it with <I>longjmp</I>. Here's the syntax:<P>
<pre>   #include &lt;setjmp.h&gt;

   jmp_buf recover;

   main()
   {

      volatile int i = 0;
      for(;;)
      {
         if (setjmp(recover) != 0)
         {
            /* Recover from error in f() */
         }

         /* Get deeply nested... */
      }
      return 0;
   }

   . . .

   void f()
   {
      /* Do some risky stuff */

      if (&lt;things go crazy&gt;)
         longjmp(recover,1);

      /* else carry on */
   }</pre>
A <I>jmp_buf</I> (jump buffer) is an array that holds the system information necessary to restore execution at the <I>setjmp</I> point. For obvious reasons, a jump buffer must typically be global. When you call <I>setjmp</I>, the system stores the <I>calling environment</I> parameters, such as the contents of the stack and instruction pointer registers, in <I>recover. setjmp</I> always returns a zero when called directly. A call to <I>longjmp</I> restores the calling environment, so execution continues back at the <I>setjmp</I> call point, with one difference: it appears as if <I>setjmp</I> has returned the second argument from the <I>longjmp</I> call, in this case a 1. (One small quirk: if you give <I>longjmp</I> a second argument of zero, it returns a 1 anyway. Zero is the only argument with this behavior.) Since a <I>longjmp</I> performs an alternate return from a function, it interrupts the normal flow of a program, so you should use it only to handle unusual conditions.<P>
When <I>longjmp</I> is called, the function containing the <I>setjmp</I> target must still be active (i.e., must not yet have returned to its own caller), otherwise the calling environment will no longer be valid. And of course, it is a bad idea to have more than one <I>setjmp</I> target with the same <I>jmp_buf</I> variable. Since calling environments typically involve registers, and since a compiler is free to store automatic variables in registers, you have no idea if an automatic object will have the correct value when you return from a <I>longjmp.</I> To get around this problem, you should declare automatics in any function containing a <I>setjmp</I> with the <I>volatile</I> qualifier, which guarantees that the inner workings of <I>longjmp</I> will leave them undisturbed. For a more detailed example of the <I>setjmp/longjmp</I> mechanism, see <A href="list9.htm">Listing 9</a>
in "Code Capsules, File Processing, Part 2," <I>CUJ</I>, June 1993.<P>
<h4><FONT COLOR="#000080"><A name="006A_0044">&lt;<B><I>signal.h</I></B>&gt;<A name="006A_0044"></FONT></h4></P>
A <I>signal</I> occurs when an unusual event interrupts the normal execution of a program, such as a divide-by-zero error or when the user presses an attention key, such as Control-C or DEL. The header &lt;<I>signal. h&gt;</I> defines six "standard signals," shown in <A href="tab9.htm">Table 9</a>.
 These signals originated on the PDP architecture under UNIX, so some of them may not apply to your environment. An implementation may also define other signals, or may ignore signals altogether, so signal handling is inherently non-portable.<P>
Signals come in two flavors: <I>synchronous</I> and <I>asynchronous</I>. A synchronous signal is one that your program raises, such as dividing by zero, overflowing during a floating-point operation, or issuing a call to the <I>abort</I> function. You can also raise a signal explicitly with a call to <I>raise</I>, for example:<P>
<pre>    raise(SIGABRT);</pre>
An asynchronous signal occurs as a result of events that your program can't foresee, such as a user pressing the attention key.<P>
The default response to most signals is usually to abort the program, but you can either arrange for signals to be ignored or provide your own custom <I>signal handlers</I>. The following statement from <A href="list8.htm">Listing 8</A><P>
<pre>    signal(SIGINT,SIG_IGN);</pre>
tells the environment to ignore any keyboard interrupt requests (Control-C on my machine). The keyboard input process still echoes the ^C token on the display, but it does not pass control to the default signal-handling logic that terminates the program. The statement<P>
<pre>    signal(SIGINT,SIG_DFL)</pre>
restores the default behavior, so you can halt the program from the keyboard.<P>
For more on signal handling, see Listing 11 - Listing 13 in the Code Capsule "Control Structures," in the June 1994 issue of <I>CUJ.</I><P>
<h4><FONT COLOR="#000080"><A name="006A_0045">&lt;<B><I>stdarg.h</I></B>&gt;<A name="006A_0045"></FONT></h4></P>
This header provides a facility for defining functions with variable-length argument lists, like <I>printf</I>'s (see <A href="tab10.htm">Table 10</a>)
. <I>printf'</I>s function prototype in your compiler's <I>stdio.h</I> should look something like<P>
<pre>    int printf(const char *, ...);</pre>
The ellipsis tells the compiler to allow zero or more arguments of any type to follow the first argument in a call to <I>printf</I>. For <I>printf</I> to behave correctly, the arguments that follow the format string must match the types of the corresponding edit descriptors in the format string. If there are fewer arguments than the format string expects, the result is undefined. If there are more arguments, they are ignored. The bottom line is that when you use the ellipsis in a function prototype you are telling the compiler not to type-check your optional arguments because you think you know what you're doing &#151; so be sure that you do.<P>
The program in <A href="list9.htm">Listing 9</a>
shows how to use the <I>va_list</I> mechanism to find the largest integer in a variable-length argument list. For more on <I>&lt;stdarg.h&gt;</I>, see the Code Capsule, "Variable-length Argument Lists" in the Feb. 1994 issue of <I>CUJ.</I><P>
<h4><FONT COLOR="#000080"><A name="006A_0046">Conclusion<A name="006A_0046"></FONT></h4></P>
In this three-part series I have attempted to convey the overall flavor of the Standard C library, especially in the functionality it provides. It is foolish to waste time reinventing this functionality. Although I have classified the library into three groups of decreasing priority, my priorities may not match yours. If you make your living programming in C or C++, you will do well to master the entire library. Enough said.<P>

<h4><a href="../../../source/1995/mar95/allison.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
