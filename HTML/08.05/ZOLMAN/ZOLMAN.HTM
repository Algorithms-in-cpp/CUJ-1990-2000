


<HTML>
<HEAD>

<TITLE>May 1990/An Applied File I/O Tutorial: The Mini-Database System</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">An Applied File I/O Tutorial: The Mini-Database System<A name="010F_0093"><A name="010F_0093"></font></h2>
<h3 align="center"><font color="#800000">Leor Zolman</font></h3><hr>
<BLOCKQUOTE>
<P><i><A name="010F_0000"><A name="010F_0000">Leor Zolman wrote "BDS C", the first C compiler designed exclusively for personal computers. Since then he has designed and taught programming workshops and has also been involved in personal growth workshops as both participant and staff member. He still doesn't hold any degrees. His latest incarnation is as a CUJ staff member.</i></P><P>
Last month I began this series on a special-purpose small database system by presenting the global data structures and <I>main</I> program. While my main goal is to present an applied example of the design interdependencies between data structures and disk I/O techniques, there is still one major component of the system to tackle before sinking our teeth into the actual file I/O code: the data-entry and editing module.</FONT></FONT><P>
The entire listing this month is <I>MDBEDIT.C</I> <A href="list1.htm">(Listing 1)</A>, the record editing module. It consists primarily of the function <I>edit_db()</I>, most of which is a large switch statement to handle all the available editing options. <I>edit_db()</I> is called twice from the main program: to edit a database (via the <I>EDIT</I> main menu command) and to begin editing a newly created database (after the <I>CREATE</I> command has been issued).</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>edit_db()</I> maintains an internal state variable, <I>cur_rec,</I> identifying the currently selected record. Upon entry to <I>edit_db()</I>, <I>cur_rec</I> is set to zero (the number of the first record of the file). For coding convenience, the variable <I>rp</I> (a pointer to structures of type <I>record</I>) holds a pointer to the <I>cur_rec</I>'th element of the <I>RECS</I> array; this allows any expression of the form</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>RECS [cur_rec] -&gt;member</pre>
to be written more simply as<P>
<pre>rp-&gt;member</pre>
provided, of course, <I>rp</I> is updated to reflect any changes made to the value of <I>cur_rec.</I></FONT></FONT></FONT><P>
The global variable <I>n_recs</I> (declared externally in header file <I>mdb.h</I>) is also vital to the record editing process: whenever a record is added or purged from the database, the value of <I>n_recs</I> is adjusted accordingly. <I>n_recs</I> always reflects the total number of records, both active and inactive, currently stored in the database.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="010F_0094">Record Management<A name="010F_0094"></FONT></h4></P>
To simplify the task of inserting and deleting records, I've selected a simple scheme for record management: each record is either "active" or "inactive", as reflected by the value of the <I>active</I> flag associated with the record. When a new record is created, its <I>active</I> flag is set to <I>TRUE</I> (1). To delete a record, the <I>DELETE</I> command merely changes the record's <I>active</I> flag to <I>FALSE</I> (0). The (now inactive) record's other data remains intact, however, until the <I>FIX</I> command is used at some later time to release the storage of all inactive records en masse.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The commands for perusing data records sequentially &#151; <I>NEXT</I> and <I>PREVIOUS</I> &#151; both ignore inactive records. The <I>LIST</I> command, however, lists all records in the database, both active and inactive. To access an inactive record, the <I>SELECT</I> command may be used to address the record directly via the record number shown by the <I>LIST</I> command. Once an inactive record has been <I>SELECT</I>ed, the <I>UNDELETE</I> command may be used to make the record active once again, if desired.<P>
Inactive records only "stay around" until the next time the <I>FIX</I> command is invoked. Each time <I>FIX</I> is run, the storage for all deleted records is freed and the record pointers are compacted and sorted.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="010F_0095">The User Interface And Main Editing Loop<A name="010F_0095"></FONT></h4></P>
A menu structure, similar to the one shown last month for the main menu, controls the option menu for <I>edit_db()</I>. The record editing options I chose to implement under this menu are rudimentary to any sort of data-retreival system and, for brevity's sake, are operationally limited to a line-oriented interface.</FONT></FONT><P>
Upon entry to <I>edit_db()</I>, <I>cur_rec</I> is initialized to the first record of the database and an infinite loop is begun. For each iteration of the loop, <I>rp</I> is set to point to the new current record's data, and the values of all fields in the current record are displayed on the console output. If there are currently no records in the database (determined by checking the value of <I>n_recs</I> for <I>0</I>), then the current record display sequence is skipped.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Next, the menu is displayed and the user selects from the list of editing options. The options are:<P>
<h4><FONT COLOR="#000080"><A name="010F_0096">LIST_RECS<A name="010F_0096"></FONT></h4></P>
This option displays a "short form" listing of all records in the database. For each record, the record number (equal to the record pointer's subscript number in the <I>RECS</I> array) and name fields are always listed. If the value of the variable <I>active</I> for the current record is false (indicating that the record is inactive), then the message "(deleted)" is also displayed. Records are displayed in their physical order in the <I>RECS</I> array; this will correspond to the order of entry until the first time the <I>FIX</I> option is invoked (see below.)</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="010F_0097">NEXT, PREVIOUS<A name="010F_0097"></FONT></h4></P>
These two options select the next or previous active record (in physical sequence) to be the "current" record by adjusting the value of <I>cur_rec</I> as required. Before adjusting <I>cur_rec</I>, however, we check that we're not sending its value out of bounds, by iterating the variable <I>i</I> forward or backward through the records. If an active record is encountered, then <I>cur_rec</I> is set accordingly; if, however, the end-of-file (or beginning-of-file) is reached, then a message to that effect is displayed and <I>cur_rec</I> remains unchanged.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="010F_0098">NEW<A name="010F_0098"></FONT></h4></P>
Creates a new record. If we have reached maximum record capacity, then an error message is displayed and the option is aborted. The <I>alloc_rec()</I> function returns a pointer to storage for the new record; if the return value is <I>NULL</I>, then memory could not be allocated and the option is aborted.</FONT></FONT></FONT></FONT><P>
Once storage is acquired, <I>cur_rec</I> is set to the old value of <I>n_recs</I> (the record count) and <I>n_recs</I> is incremented to reflect the new number of records (line 125). After this operation, <I>cur_rec</I> is the subscript of the slot in <I>RECS</I> that will hold the new record pointer. Next, <I>rp</I> is copied into the new slot (line 126) and the element <I>active</I> is made <I>TRUE</I> (line 127). In lines 129 though 134, all data elements of the new record are initialized to "empty" values and control falls through to the next case, <I>MODIFY</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="010F_0099">MODIFY<A name="010F_0099"></FONT></h4></P>
This section is a quick-and-simple editing sequence for the data elements of the current record. For each element in sequence, the following is performed:<P>
<UL><li>The record description and current value is displayed.</li>
<li>A line of input text is read from the console.</li>
<li>If the line is empty (i.e., if the Return key was pressed immediately), then the original value of the element is left intact.</li>
<li>Otherwise, the value of the element is overwritten with the value of the input (converted to the appropriate data type).</li></UL>
In a "real" application additional input validations would occur at this point. For example, to limit the <I>gender</I> field to only the values <I>M</I> or <I>F</I>, you could change the <I>if</I> sequence in lines 154 and 155 to:</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>while (strlen(gets(buf)) &gt; 0 /* if not empty line */
{
    char c = toupper(*buf);
    if (!(c == 'M' || c == 'F')) /* if not legal */
    {
        printf("Please enter 'M' or 'F': ");
        continue; /* ask again */
    }
    rp-&gt;gender = c; /* assign the value */
    break; /* exit the loop */
}</pre>
<h4><FONT COLOR="#000080"><A name="010F_009A">DELETE<A name="010F_009A"></FONT></h4></P>
Deleting a record is simply a matter of setting the <I>active</I> flag to <I>0</I>. If the flag is already <I>0</I>, we display a message to that effect. Otherwise, we make the user confirm the deletion by typing a '<I>y</I>'.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="010F_009B">UNDELETE<A name="010F_009B"></FONT></h4></P>
This option restores a "deleted" record by setting its <I>active</I> flag back to <I>1</I>. If the record was active in the first place, a message is issued.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="010F_009C">SELECT:<A name="010F_009C"></FONT></h4></P>
Used in conjunction with the LIST option, this option can directly select any record in the database. <I>SELECT</I> asks for a record number and checks to make sure the value is within bounds. If the record number is valid, it is assigned to <I>cur_rec.</I> Since we wish to allow both active and inactive records to be selected, there are no further validity checks necessary.</FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="010F_009D">FIX<A name="010F_009D"></FONT></h4></P>
The FIX options serves a dual purpose: first, to purge all inactive (deleted) records from the database; second, to sort the remaining records. The <I>fix_db()</I> function does the work, and herein lies the only tricky code in this installment.</FONT></FONT><P>
To purge deleted records, a single pass is made over the database records using two indices. The first index, the loop variable <I>i</I>, iterates over the entire array of record pointers (that is, all <I>n_recs</I> records). The second index, <I>new_n_recs</I>, is incremented only for active records; when an inactive record is encountered, <I>new_n__recs</I> is not incremented, and the pointer to the inactive record's data is passed to the <I>free()</I> function to deallocate the storage.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
At the start of each iteration through the loop, record <I>i</I> is copied into position <I>new_n_recs</I> (line 222), and then <I>new_n_recs</I> is adjusted as described. The result is that the memory used by all inactive records is de-allocated, and the positions in the <I>RECS</I> array formerly occupied by inactive record pointers are filled in with active pointers.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
After the purge loop completes, a single call to the <I>qsort()</I> library function sorts the remaining records. <I>qsort()</I> is a wonderfully versatile function, but the interface can be a bit confusing. In this case, we wish to sort the pointers in the <I>RECS</I> array by the <I>last</I> field; we first set up the call to <I>qsort()</I> and then set up a comparison function that <I>qsort()</I> uses to determine the relationship between two pointers.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<I>qsort()</I> takes four parameters: a pointer to an array of data items to be sorted, the number of items in the array, the size of each item, and a pointer to a user-supplied function (to be called by <I>qsort()</I> directly) that accepts two pointers to the data array elements as parameters, compares the two data items specified by the pointers, and returns (to <I>qsort()</I> one of several pre-defined values indicating the relative ordering of those two data items.</FONT></FONT></FONT></FONT></FONT></FONT><P>
Since we are sorting the pointers in the <I>RECS</I> array, we pass <I>RECS</I> as the first parameter. The number of items in the array is <I>new_n_recs</I> (as a result of the purge loop just completed.) As we are sorting pointers, we pass the expression</FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>sizeof(struct record *)</pre>
as the data item size (by using the <I>sizeof</I> operator instead of hard-wiring in a constant value such as two for this parameter, we insure portability of this code among different memory models or processor families.) For the final parameter, we supply the name of a comparison function named <I>compar()</I>.</FONT></FONT></FONT></FONT><P>
The comparison function, as described above, must be designed to accept parameters that are pointers to the data type being sorted. Since the data we are sorting have type "pointer to structure", the parameters to the comparison function must be of type "pointer to pointer to structure." For a return value, the comparison function must return either zero (if the data items are equivalent, using whatever arbitrary ordering rules we wish to apply), a negative value (if the first item is "less than" the second by those same rules), or a positive value (if the first item is "greater than" the second.) The function header (line 242) reflects these specifications.<P>
Notice that a prototype for the <I>compar()</I> function is given (line 214) so that the identifier <I>compar</I> is recognized as a function having the proper characteristics when <I>fix_db()</I> calls <I>qsort()</I> (line 230). Alternatively, the entire definition of <I>compar()</I> could have been placed where the prototype is now located, eliminating any need for the separate prototype. I prefer to list functions in top-down order, however, so the prototype becommes necessary.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The body of the <I>compar()</I> function compares the element <I>last</I> (a string representing the last name of the person described in the record) from both records using the <I>strcmp()</I> standard library function. <I>strcmp()</I> is ideally suited for use with <I>qsort()</I>, because its return value is defined exactly as specified for the <I>qsort()</I> comparison function. The tricky part of <I>compar()</I> is remembering to de-reference the "structure pointer pointer" parameters in order to use them as simple "structure pointers" (line 245.) Note the need for parentheses around the indirection sub-expression of each parameter to <I>strcmp()</I>; without the parentheses, the selection operator (-&gt;) would take precedence over the indirection operator (*) and draw a compiler error.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="010F_009E">As For The File I/O...<A name="010F_009E"></FONT></h4></P>
Between this and last month's listings, the system is now complete except for the <I>read_db()</I> and <I>write_db()</I> functions. Before the next installment, you may wish to key in the system as presented so far (inserting a pair of dummy functions in lieu of the real <I>read_db()</I> and <I>write_db())</I> and play around a bit with entering, deleting and editing records in order to get a feel for the system's operation.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
I'll devote future installments to showing some different approaches to implement <I>read_db()</I> and <I>write_db()</I>. As a challenging exercise, see if you can come up with a scheme for implementing these functions on your own. Would you save the data on disk in the form of ASCII text or binary data? Which library functions would you use in each case? What would be the advantages of ASCII over binary, or vice versa?</FONT></FONT></FONT></FONT><P>
For a smaller-scale exercise, see if you can develop a replacement for the <I>do_menu()</I> function that has a slicker user interface. For example, you might include the ability to specify commands by a highlighted letter within the text of the command, as well as by a sequential number. Part of the menu specification would then have to include information about which letter to highlight &#151; perhaps by including a "magic" character in the menu item text that flags the subsequent character as special. Or, you may choose to adapt a windowing menu routine from some general C library function package.<P>

<h4><a href="../../../source/1990/may90/zolman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
