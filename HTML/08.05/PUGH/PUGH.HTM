


<HTML>
<HEAD>

<TITLE>May 1990/Questions & Answers</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">Questions &amp; Answers<A name="0119_009D"><A name="0119_009D"></font></h2><P>
<h3 align="center"><A name="0119_0000"><A name="0119_0000">Converting Files, Info On X_Windows</h3><P>
<h3 align="center"><font color="#800000">Ken Pugh</font></h3><hr><blockquote><P>
<P><i><A name="0119_0000"><A name="0119_0000">Kenneth Pugh, a principal in Pugh-Killeen Associates teaches C language courses for corporations. He is the author of C Language for Programmers and All On C, and is a member on ANSI C Committee. He also does custom C programming for communications, graphics, and image databases. His address is 4201 University Dr., Suite 102, Durham, NC 27707.</i></P><P>
<P><i>You may fax questions for Ken to (919) 493-4390. When you hear the answering message, press the * button on your telephone. Ken also receives email at kpugh@dukeac.ac. duke. edu (Internet) or dukeac!kpugh (UUCP).</i></P><P>
<B>Q</B><P>
Recently I had reason to write a short C program to convert a series of large BASIC files into another format.<P>
Everything was fine except where the BASIC program had stored numbers as single or double precision floating point numbers. Microsoft C did not read in and convert these numbers correctly.<P>
Am I correct in assuming that BASIC stores floating point numbers in a different format than C does? If so what is a routine which will do conversion between the formats?<P>
Finnbarr P. Murphy  Cork, Ireland<P>
<B>A</B><P>
Perhaps a reader can tell us what internal representation BASIC uses for floating point numbers.<P>
Your question raises an important issue for anyone who is trying to move data between environments &#151; whether the environmental differences be hardware, operating system, or (as in this case) development language.<P>
The only sure path to data compatibility is to use ASCII characters for the numeric values (i. e. text format). (There is a possibility that the lowest order bit of floating point values may differ, but this is usually not a significant issue.)<P>
You could write a BASIC program to dump the binary files in ASCII. A C program would then read the ASCII files and convert the data back to internal format. The data file is typically written in quote and command delimited format. For each record, the field values are printed out as:<P>
<pre>value1, value2, value3 . . .     (Newline)</pre>
The Newline may be composed of either a single newline or a combination of carriage return/linefeed. If a comma appears in a value, then the value is enclosed in quotes. For example:<P>
<pre>This is a field,
"This is a comma, field",
333.45, 666.9 (Newline)</pre>
This format is easy to generate in BASIC, but a little more difficult to parse in C. Because <I>scanf</I> stops reading string input at a white space, it is easier to read the entire string in with <I>fgets()</I> and then use the <I>strpbrk()</I> or <I>strcspn()</I> functions to break it into its parts.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
I know of only one binary floating point format that is guaranteed to be compatible among machines &#151; the IEEE standard. Most compilers do not support this relatively new standard, and the 80-bit long format is typically used only with compatible co-processors.<P>
<B>Q</B><P>
I have a question about how the <I>va_arg</I> macros in Standard C include file <I>&lt;stdarg.h&gt;</I> are intended to be implemented and/or used. I have not seen this topic raised anywhere in the Standard C references I have, though I have not seen the actual text of the standard.</FONT></FONT></FONT></FONT><P>
To pose the question, consider the following as a possible implementation intended for use in a 68000 environment:<P>
<pre>typedef int * va_list;

#define va_start (arg_ptr, first_param) \
 (arg_ptr= (va_list) (&amp;first_param+1))
#define va_arg(arg_ptr,type) \
 (* (((type*) (arg_ptr= (va_list) ((type*) arg_ptr) +1))-1))
#define va_end(arg_ptr) (arg_ptr=NULL)</pre>
The tortuous expression for <I>va_arg</I> is used because the typecasted pointer is not an 1value. (At least, that is what my compiler tells me if I try to use *<I>((type</I>*<I>)arg_ptr)++)</I>.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The problem appears when this definition is used with narrow types. For example, if a <I>float</I> value is passed, it will be widened to <I>double</I> when stored on the stack. The compiler is smart enough to recognize this fact for declared parameters, but the expression generated by the above <I>va_arg</I> macro would not.</FONT></FONT></FONT></FONT></FONT></FONT><P>
The two solutions that I can see are: some kind of test for narrow types inside the macro; and restricting the use of <I>va_arg</I> to non-narrow types. The only way I can see to implement the first solution is to string-ize the type and generate code to test whether a narrow type is being used and handle it separately. This seems like a very undesirable solution. On the other hand, I have seen no mention of the restriction specified in the alternative. What am I missing?</FONT></FONT><P>
Jeff Newmiller<br>
Davis, CA<P>
<B>A</B><P>
I'm glad I don't come across those expressions too often in my programming. I haven't actually seen anyone use the variable argument macros in writing their own functions. They are useful for writing the standard <I>printf</I> and <I>scanf</I> family of functions in C, rather than in assembler.</FONT></FONT></FONT></FONT><P>
The answer to your question lies in the standard. It reads "The <I>va_arg</I> macro expands to an expression that has the type and value of the next argument in the call..... if type is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined."</FONT></FONT><P>
It would appear that solution #2 is your only choice.<P>
If all types are integral multiples of the size of an integer, you can simplify your expression for <I>va_arg</I> by adding the <I>sizeof(type) / sizeof(va_list)</I> to <I>arg_ptr.</I> If not, then the expression will have to stay as it is.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="0119_009E">Reader Requests<A name="0119_009E"></FONT></h4></P>
I have a customer in Florida using a VAX running VMS 5.0-2. I would like to write programs here in PA on MS-DOS and only transmit a finished product to the end user.<P>
To relieve the cost of telephone connect time, I would like to compile on my MS-DOS machine. I have heard of cross compilers from VMS to DOS. Have you heard of one that goes MS-DOS to VMS? Any answer would be appreciated.<P>
Paul Hetherington<br>
Levittown, PA<P>
<B>Q</B><P>
Is X-Windows available for the IBM-PC? Rumours claim that MIT freely distribute the C-source. It this true? And in case how may I obtain a copy?<P>
Thanks for a splendid magazine, it is highly appreciated.<P>
Sincerely,<P>
Einar Valen<br>
Ristangen<br>
Haugland<br>
5265 Y. Arna<br>
Norway<P>
<B>A</B><P>
I asked fellow CUJ columnist Sydney Weinstein to respond. Here is his answer.<P>
The X Windowing system is split into two sections. The client that wants to display information and the server that displays the output the client generates. These two processes are connected by TCP-IP sockets. For IBM PCs there are several commercial X Server packages that reside on top of underlying TCP-IP networking packages. These packages are just ports of the MIT X distribution with changes necessary for the PC, and with varying amounts of optimization of the resulting server. Some of the commercial products run directly on the PC, some run on top of Microsoft Windows. Many vendors at UniForum 1990 in Washington, D.C. displayed MS-DOS X Servers. Of course, the commercial packages are just executable binaries.<P>
If you wish to adapt your own X server from the sample X server and the sources provided from the X Consortium at MIT, order the X source tapes. These tapes include the complete code of the X system and many contributed programs, toolsets, and window managers. On January 4th, 1990, the MIT X Consortium announced Release 4 of the X Window System, Version 11. Quoting from their own release notice:<P>
"The software in this release is not in the public domain, but is freely available without restrictions. No license is required and there are no royalties; vendors are actively encouraged to base products upon this software... a set of four 1600bpi tapes in UNIX tar format plus printed versions of the major manuals and a copy of the new Gettys, Newman, and Scheifler book <I>X Window System: C Library and Protocol Reference</I> are available from the MIT Software Center."<P>
In North America, the manuals and books are priced at $125 (for tapes too, add $275). Abroad, the manuals and books go for $175 (for tapes, add $325). Prices include shipping.<P>
To order, please send a letter and a check payable to MIT in US currency for the appropriate amount to:<P>
MIT Software Distribution Center<br>
Technology Licensing Office<br>
Room E32-300<br>
77 Massachusetts Avenue<br>
Cambridge, MA 02139<P>
<h4><FONT COLOR="#000080"><A name="0119_009F">Announcing The Great Name / Obscure Code Contest<A name="0119_009F"></FONT></h4></P>
As announced in the previous column, this contest has begun.<P>
Send examples of the worst names or abbreviations that you have seen in other people's programs (or even your own). Include both the name and a description of what it is supposed to represent. The best (or worst) examples will be published here, with credit for your submission. The name of the programmer who actually wrote the code in which the name is used will not be mentioned without his or her express permission.<P>
For starters, here are some abbreviations that have appeared in various journals.<P>
<pre>cls, dfthlp(), q_bsy(),
revdot(), hpel, strlwr(),
do_esq(), dld_char</pre>
Can you determine the full name for the variable or function? These variables were found in programs from the following general application areas:<P>
<pre>cls/* Window and File */
dfthlp() /* Windowing */
q_bsy()/* Queues */
revdot() /* Graphics */
hpel/* Graphics */
strlwr() /* General package */
do_esq() /* Communications */
dld_char /* Communications */</pre>
ANSI C allows 32 characters for variable names; most linkers allow the same limit. What longer names would you choose?<P>
</BLOCKQUOTE>
</BODY>
</HTML>
