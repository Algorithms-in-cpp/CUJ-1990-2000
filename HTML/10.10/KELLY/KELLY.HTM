


<HTML>
<HEAD>

<TITLE>October 1992/The Evolution of a Binary Tree in Turbo C</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">The Evolution of a Binary Tree in Turbo C<A name="022E_0100"><A name="022E_0100"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="022E_0000"><A name="022E_0000">Michael Kelly</font></h3><hr><blockquote><P>
<P><i><A name="022E_0000"><A name="022E_0000">Michael Kelly is a free-lance Writer/Programmer who uses the languages C, C++, Pascal, 80x86 Assembler, and English. He can be reached via M&amp;T Online as mkelly.</i></P><P>
The introductory texts on abstract data types that I have seen contain examples of trees that tend to fall into two categories. The first, a "bare-bones" recursive implementation, is easily understood but practically useless. The second, the "balanced" variety, promises quick look-ups but can be very confusing to follow, because it contains left and right, single and double rotations, node splitting and joining, and more. I have found it useful, when trying to learn from pointer-based C code, to experiment with the simple implementation, add enhancements incrementally, and repeat the cycle. This article discusses how to apply that process to the binary tree abstract data type.<P>
<h4><FONT COLOR="#000080"><A name="022E_0101">Binary Tree Test Program<A name="022E_0101"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
is a minimal binary tree test program useful for debugger single-stepping. The <I>node</I> structure type defines a node in the tree. This minimal tree node consists of a left node pointer, a right node pointer, and a character key. A recursive tree insertion routine, (<I>tree_insert</I>) compares keys and moves left if the new node has a lesser key, right if the new node has a greater key, and returns if the keys are equal (no duplicate keys in this scenario). Note that for this insertion function to work, the node returned from the outermost call must be stored as the tree anchor, and the left and right node pointers relinked all the way back through the calling chain.<P>
The function <I>tree_trace</I> uses recursion to traverse the tree in order and display the sorted character keys. The variable <I>tree_root</I> stores the first insertion to anchor the tree, then after a few insertions are made in a loop, <I>tree_trace</I> is called to display the keys.<P>
<h4><FONT COLOR="#000080"><A name="022E_0102">Adding Enhancements<A name="022E_0102"></FONT></h4></P>
<A href="list2.htm">Listing 2</a>
illustrates some enhancements that provide the binary tree with practical utility. The first modification is to the tree node structure so that data you might need to manipulate can be stored. The keys now consist of strings. To insert nodes into the tree efficiently, the <I>tree_insert</I> function has been replaced with a non-recursive, or iterative, implementation.<P>
On the first call to <I>tree_insert</I>, the root of the tree is <I>NULL</I>, so the program does not enter the <I>while</I> loop. The program simply allocates memory with <I>calloc</I>, so that the left and right node pointers are automatically set to zero (<I>NULL</I> in Turbo C), the root of the tree is stored, and the key string is copied and <I>NULL</I>-terminated. On subsequent calls the program does enter the <I>while</I> loop.<P>
C does not have a string data type so a comparison function must be used instead of the relational operators to compare the key strings. The Standard C library provides the <I>strcmp</I> function, which returns an integer result. The result will be zero if the strings are equal, less than zero if the left string is less than the right string, and greater than zero if the right string is greater. Branching is done based on the key comparisons until either a duplicate key or an empty "leaf" node is found. Once at an empty leaf, the program allocates memory and a jump is made to common code for copying the key.<P>
The code that copies a duplicate key over identical data in the case of equal keys seems redundant. However, this loop configuration lends itself to the next modification in which the data to be copied will contain, but may not be identical to, the key.<P>
The tree traversal function is modified to print a string instead of a character. The tree functions could now be applied (at our peril, for error recovery has yet to be considered) to a string sorting utility. In this test stub, a few keys, one of which is a duplicate, are inserted and displayed, to demonstrate that duplicates all map to one node in this tree.<P>
<h4><FONT COLOR="#000080"><A name="022E_0103">Expanding and Adding Functions<A name="022E_0103"></FONT></h4></P>
With the program in <A href="list3.htm">Listing 3</a>
not only are functions expanded in their generality, but additional routines begin to be introduced to perform operations appropriate to binary trees. Trees are noted more for efficiently finding data that has already been ordered than for doing the ordering.<P>
The <I>tree_find</I> function uses an iterative process to search the tree for an item matching the specified key. <I>tree_find</I> returns <I>NULL</I> on failure and a pointer to the node containing the item on success. Note that <I>tree_find</I>, as well as the new incarnations of routines from previous listings, treat the data as an amorphous blob. To make the routines more generally useful and thus reusable, the task of molding the data into a recognizable form should be left to the function that wishes to use it, so the tree functions will no longer make assumptions about the structure of the data. This requires that the functional interfaces be defined so as to be able to accomodate data of unknown type.<P>
This improved reusability exacts a performance penalty, since the tree functions must now depend on the users of the data, or client modules, to provide the means to compare two data items, determine the size of an item, and display an item. Pointers to functions are used in the tree-function interfaces in a manner similar to <I>qsort</I> in the Standard C library to access the necessary client-supplied code.<P>
The arguments to the <I>tree_insert</I> function are now a pointer to the root node pointer (so the root can be set from -inside the function), an untyped pointer to the data, the size of the data, and a pointer to a function that compares two data items and returns an integer result modeled after the <I>strcmp</I> function.<P>
The <I>tree_trace</I> function uses a global function pointer, <I>report</I>, and a global variable of enumerated type, <I>t_order</I>, to minimize the stack space eaten up by the function arguments when it calls itself. The variable <I>t_order</I> specifies the tree traversal order that <I>tree_trace</I> will use &#151; <I>pre order</I> (root, then left subtree, then right subtree), <I>in order</I> (left subtree, then root, then right subtree), and <I>post order</I> (left subtree, then right subtree, then root). The <I>report</I> function pointer is used to call a reporting or displaying function with an untyped pointer to the data (<I>void *info</I>) as its sole argument.<P>
The function <I>tree_free</I> traverses the tree in post order to free tree memory in a "last allocated, first freed" fashion.<P>
<h4><FONT COLOR="#000080"><A name="022E_0104">Deleting Nodes<A name="022E_0104"></FONT></h4></P>
Now you can build binary trees containing items of unknown type, search for a matching item, display the items, and free the memory for the entire tree. What happens if you need to extract an item from the tree, freeing memory for the node and leaving the remainder of the tree in a usable state? With the current definition of a node you can delete the node, but there is no easy way to link up the node's children. Another modification to the node structure type will simplify the solution.<P>
In <A href="list4.htm">listing 4</a>
a <I>parent</I> pointer is added to each node to bridge the gap created by the deleted node. An enumerated type <I>tree_child</I> describes the type of node in the process of being deleted. If the node you want to delete is the root node, and has children, the root of the entire tree will be changed so you must pass the address of the new root back to the caller. A <I>tree_child</I> value of <I>NOT_CHILD</I> is a node that is not a child node (the root of the tree), <I>LEFT_CHILD</I> is a left node and <I>RIGHT_CHILD</I> is a right node. These designations are temporary and only used by the deletion function <I>tree_delete</I>. If none of these condition applies, then an error must have occurred linking the nodes so the error code of <I>LINK_ERROR</I> is stored in the global error indicator <I>t_error</I>. In this case, the abstract data type should be considered corrupted and drastic action should be triggered.<P>
Since C passes parameters by value, changes to <I>this_node</I> made inside the <I>tree_delete</I> function will disappear when the function goes out of scope. However if <I>this_node</I> is a right child and we change it indirectly by assigning <I>this_node</I> to <I>temp</I> and a value to <I>temp-&gt;parent-&gt;right</I>, this change will be effective external to the function. This method seems less error prone than using node pointer pointers (**<I>this_node</I>) and makes the source a little easier to follow.<P>
The code for deleting a node that has both left and right children may look a little confusing. In English, the program appends the entire left subtree of the node to be deleted to the left-most extremity of its right subtree. The program then redirects the parent pointer of the left subtree to the node from which the left subtree now dangles. Then the program copies the parent pointer for the node to be deleted to its right child, spanning the "hole" that will be made by deleting the node. Now the target node can be deleted without disrupting the tree structure. If the deleted node was the root of the tree, <I>this_node</I> has the new root and is returned, otherwise <I>root</I> is returned to the caller.<P>
Of course, now that the node data type has been modified, the functions that use it should be checked for side-effects. The <I>tree_insert</I> function must now link the parent pointers as it adds items to the tree. When memory for a new left or right child node is allocated, the parent pointer of that child of <I>this_node</I> must be set to <I>this_node</I> before <I>this_node</I> is given that child's address. In the case of a duplicate key, the parent pointer remains intact.<P>
<h4><FONT COLOR="#000080"><A name="022E_0105">Summary<A name="022E_0105"></FONT></h4></P>
This binary tree, though generic, is still fairly simple. No question of balance has yet been posed. If the tree is built from ordered data, it degenerates into a linked list, with every search beginning at the head of the list. In this particular implementation, advantage could be made of the fact that new data having a key already in the tree is handled by assigning the data to the node whose key is already in the tree. For instance, if you wished to build the tree from a disk file of ordered records, you could take a random sample of the records, sort it, use the center record for the root, rewind the file and simply process the input sequentially. In this way you could reduce the likelihood of the tree becoming a linear list. More complex insertion and deletion techniques are required to insure tree balance. One type of binary tree that guarantees near balance (meaning that the left subtree and right subtree of each node in the tree differ in the number of children by at most one node) is the AVL Tree.<P>
<h4><FONT COLOR="#000080"><A name="022E_0106">Suggested Reading<A name="022E_0106"></FONT></h4></P>
Sedgewick, Robert. 1988. <I>Algorithms</I>. Addison-Wesley: Reading, MA.<P>
Weiskamp, Keith, Namir Shammas, and Ron Pronk. 1989. <I>Turbo Algorithms, A Programmer's Reference</I>. Wiley: New York.<P>

<h4><a href="../../../source/1992/oct92/kelly.zip">Get Article Source Code</a></h4>

</BODY>
</HTML>
