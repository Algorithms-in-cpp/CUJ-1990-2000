<HTML>
     
     <HEAD>
<TITLE>December 1998/What's New in Standard C++?</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">What's New in Standard C++?</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Chuck Allison</FONT></H3>

<BLOCKQUOTE>

<p>Standard C++ is finally real, after nine years in the making. Chuck supplies a quick guided tour of the end result.</p>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<p><I>It's official!</I> On July 20, 1998, all 20 ISO national bodies involved in the work of standardizing the C++ programming language approved the document the committee had created and maintained since 1990. This may not seem like a big deal to the casual observer, but I shudder to contemplate the cost of producing that dense, almost 800-page document.</p>
<p>When I joined the committee in March 1991, one year after the technical work had begun, the goal was to hurry up and "get this thing done," which at the time meant, "add templates and exceptions to the language, tighten up IOStreams, and maybe add a string class." Were we na&iuml;ve or what? There was such demand for more robust support of object-oriented programming, containers, and programming in the large that by 1994 we had also added run-time type identification, the Standard Template Library, and namespaces, some of which represented more invention than the standardization of existing practice. The committee needed the next three years just to work the bugs out. The result is an incredibly powerful and elegant, if not sometimes overwhelming, programming language.</p>
<p>In this article I summarize what has changed since AT&amp;T's C++ V2.0, which is what most of us were using before the standards committee went to work. To keep things orderly, I follow (most of) a traditional outline:</p>
<UL><LI>Something Old &#151; deprecated features and what has changed in existing features</LI>
    <LI>Something New &#151; features that have been added to the language without much precedent from other languages, such as Run-time Type Identification (RTTI), covariant return types, and new-style casts</LI>
    <LI>Something Borrowed &#151; includes type <B>bool</B>, templates, exceptions, and namespaces, since they were patterned after features found in other languages.</LI></UL>

<p>In a future article I'll discuss some of the newer features of the Standard C++ library [something blue? &#151; pjp].</p>
<p>Keep in mind that compilers still do not support all language features (they're only implementers, after all :-). For this article, I'm using version 2.39 of the Edison Design Group (EDG) demo compiler for Windows NT with the Dinkum C++ Library (V2.2), which I believe is the most up-to-date combination available. (Only one of the following examples, template-template arguments, fails to compile. Your mileage may vary).</p>

<h4><FONT COLOR="#000080">Something Old</FONT></H4>

<p>If you've been using C++ for a while, you need to be aware of changes to certain language features. Theoretically, you may need to recompile some of your code, but most compilers will likely provide a legacy mode to compile existing code. Notable changes follow.</p>

<h4><FONT COLOR="#000080">Banning implicit int in declarations</FONT></H4>

<p>If you've ever let your eyes pore over vintage C code, you've probably seen a large number of holes where the <B>int</B> keyword should have appeared. That's because C infers <B>int</B> as a type name in many instances (as a favor to lazy Unix hackers, I suppose :-). The following declarations are now invalid in C++ (and will be in C9X also):</p>

<pre>
const n = 7;
void f(const n) {.....}
g() {.....}
</pre>

<p>If you want a program that works with a conforming compiler, you need to explicitly use the <B>int</B> keyword in each of these contexts, as in:</p>

<pre>
const int n = 7;
void f(const int n) {.....}
int g() {.....}
</pre>

<p>A noticeable consequence of this change is that you must also explicitly declare <B>main</B> as a function returning <B>int</B>, in one of the following ways:</p>

<pre>
int main() {.....}
int main(int argc, char* argv[])
{.....}
</pre>

<p>You don't have to explicitly return a value from <B>main</B>, however. If you don't, it's the same as if you had returned a zero.</p>

<h4><FONT COLOR="#000080">Default behavior of operator new</FONT></H4>

<p>Instead of returning a null pointer, <B>operator new</B> now throws an exception when a dynamic memory allocation request fails, as the following snippet illustrates:</p>

<pre>
#include &lt;new&gt;

int main()
{
    int* p;
    try {
        p = new int[1000000L];
    }
    catch (std::bad_alloc&amp;) {
        // memory failure
    }
}
</pre>

<p>The <B>bad_alloc</B> exception class is defined in the header <B>&lt;new&gt;</B> as a member of namespace <B>std</B>, which contains most of the declarations in the Standard C++ library. (More about namespaces later.)</p>
<p>There is a special version of <B>operator new</B> for those times when you want to revert to the traditional null-return behavior, which goes like this:</p>

<pre>
#include &lt;new&gt;
     
int main()
{
    int* p =
        new (std::nothrow) int[1000000L];
    if (!p)
        ..... // failed
}
</pre>

<h4><FONT COLOR="#000080">Scope of for -init declarations</FONT></H4>

<p>Most C++ programmers are probably accustomed to declaring loop index variables in the init-part of a <B>for</B> loop, such as:</p>

<pre>
for (int i = 0; i &lt; n; ++i)
{.....}
int j = i;   // error!
</pre>

<p>What is less well known, most likely because compilers haven't supported it, is that the scope of the variable <B>i</B> above is the body of the loop only.</p>

<h4><FONT COLOR="#000080">Static const initializers</FONT></H4>

<p>This change to the language won't require re-compilation, but offers a valuable convenience. You can now initialize static const data members within the class definition itself. Not only is this a boon to readability, but it lets you use such variables in subsequent member declarations, like array dimensions, replacing the ubiquitous enum hack:</p>

<pre>
class Foo
{
    static const int MAXOBJS = 100;
    static const int numObjs = 0;
    static Foo objects[MAXOBJS];
};
const int Foo::numObjs;
const int Foo::MAXOBJS;
Foo Foo::objects[MAXOBJS];
</pre>

<p>As this code illustrates, you still have to define the space outside the class definition, and you mustn't repeat the initialization there.</p>

<h4><FONT COLOR="#000080">Deprecated Features</FONT></H4>

<p>A deprecated or obsolescent language feature is one that may disappear due to future standards work. What this really means is that the feature is either no longer needed, or is undesirable for one reason or another. The 1989 standard for C, for example, marked old-style function definitions (i.e., without prototyping) as obsolescent. I wouldn't be surprised if the C9X committee votes to drop them from the language this time. The newly approved C++ Standard has made the following language features obsolescent:</p>

<h4><FONT COLOR="#000080">Invoking Standard C headers with a .h suffix</FONT></H4>

<p>We traditionally think of headers as files, but a compiler is free to make a header's declarations available in any manner it chooses. To encourage this point of view, the C++ standards committee voted rather early to drop the .h suffix for C++ headers. This means that you should write:</p>

<pre>
#include &lt;iostream&gt;
</pre>

<p>instead of:</p>

<pre>
#include &lt;iostream.h&gt;
</pre>

<p>although most compilers will allow both. When namespaces were added to the language, the committee decided to wrap most C++ and all Standard C library declarations in the namespace <B>std</B>, and to rename the C headers by prepending a "c" and dropping the . h suffix. This means that the preferred method of getting at C library features is the same for using C++ library elements. For example:</p>

<pre>
#include &lt;cstdio&gt;
int main()
{
    std::printf("hello, world\n");
}
</pre>

<p>Thinking that this might be too much of a culture shock, the committee decided to deprecate instead of disallow altogether the traditional .h header. For now, if you say:</p>

<pre>
#include &lt;stdio.h&gt;
</pre>

<p>it's as if you had written:</p>

<pre>
#include &lt;cstdio&gt;
</pre>

<p>followed by a using declaration for each identifier defined in the header (so you don't have to use the <B>std::</B> prefix).</p>

<h4><FONT COLOR="#000080">Old-style casts</FONT></H4>

<p>Old C-style casts are dangerous and ugly, but sometimes a programmer's got to do what a programmer's got to do. Unfortunately, programmers occasionally do the wrong thing. The new-style C++ casts are superior to C-style casts because they:</p>

<UL><LI>explicitly advertise the type of cast being performed</LI>
    <LI>disallow any type of conversion other than the one requested, and</LI>
    <LI>stand out in code inspections because of their noticeable syntax</LI></UL>

<p>For example, the expression:</p>

<pre>
p = reinterpret_cast&lt;char*&gt; (0x00f0c10a)
</pre>

<p>is much more likely to draw a reader's attention than:</p>

<pre>
p = (char*)(0x00f0c10a)
</pre>

<p>Furthermore, using <B>static_cast</B> here instead of <B>reinterpret_cast</B> would fail, since the former converts only between related types. For now, old-style casts are only deprecated, since otherwise too much existing code would break, but watch out! Five years from now they're probably going away.</p>

<h4><FONT COLOR="#000080">Static declarations at file scope</FONT></H4>

<p>The old-fashioned way of making an identifier private to its translation unit is to declare it static at file scope:</p>

<pre>
static void f() {.....}
</pre>

<p>The modern way to organize identifiers is inside namespaces. Anything you declare at file scope is part of the "global namespace," which is visible across compilation units. If you want to hide identifiers declared outside of any block from other compilation units, you should place them in the <I>unnamed namespace</I>, as follows:</p>

<pre>
namespace
{       // has no name
    void f() {.....}
};
</pre>

<p>Each unnamed namespace in a compilation unit behaves as if it has a name unique to that compilation unit, so there is no possibility that you can access its identifiers from any other file. Since there is no name for this namespace, there is no way to define a function outside of the namespace body, as you typically do with the scope resolution operator for member functions and functions in named namespaces.</p>

<h4><FONT COLOR="#000080">Access declarations</FONT></H4>

<p>When using less than public inheritance, the access of inherited members decays to the level of the inheritance used, if applicable. For example, in the following code excerpt, without the access declaration <B>B::f</B> in the public section of <B>D</B>, <B>f</B> would not be accessible to clients of <B>D</B> objects.</p>

<pre>
class B
{
public:
    void f();
};

// private inheritance makes f
// private in D, hence inaccessible
// to D's clients
class D : private B
{
public:
    B::f; // old-style access declaration
};
</pre>

<p>Old-style access declarations are now deprecated in favor of using declarations, which were introduced with namespaces. In the case of class <B>D</B> above, you should instead write:</p>

<pre>
class D : private B
{
public:
    using B::f;
};
</pre>

<h4><FONT COLOR="#000080">&lt;strstream.h&gt; classes</FONT></H4>

<p>The classes in &lt;strstream.h&gt; are C++ equivalents of the functionality provided by the Standard C library functions <B>sscanf</B> and <B>sprintf</B>, which support in-core formatting of C-style strings. In old C++, you would do something like the following to build a null-terminated string via output operations:</p>

<pre>
#include &lt;iostream.h&gt;
#include &lt;strstream.h&gt;

main()
{
    ostrstream os;
    os &lt;&lt; "A number: " &lt;&lt; 7 &lt;&lt; ends;
    char* s = os.str();
    cout &lt;&lt; s &lt;&lt; endl;
    os.rdbuf()-&gt;freeze(0);
}
</pre>

<p>The resulting output is:</p>

<pre>
A number: 7
</pre>

<p>The <B>str</B> member function yields a <B>char*</B> that points to the dynamically constructed array of characters. You can insert the <B>ends</B> manipulator to get a terminating null. Since it uses the heap to build the string, the object <B>os</B> leaves you responsible for deleting the memory when you're through, unless you give ownership back to <B>os</B> via the <B>strstreambuf::freeze</B> member function. There is also an <B>istrstream</B> class for doing stream input on a <B>char</B> array.</p>
<p>Standard C++ has deprecated the use of these classes, and, like the rest of the library, they now reside in the <B>std</B> namespace in the appropriately named header &lt;strstream&gt;. If you want to do things the Right Way, however, you will now use the <B>ostringstream</B> and <B>istringstream</B> classes defined in &lt;sstream&gt;, which work on instances of <B>std::string</B>, instead of arrays of characters, as the following example illustrates:</p>

<pre>
#include &lt;iostream&gt;
#include &lt;sstream&gt;

main()
{
    std::ostringstream os;
    // no ends
    os &lt;&lt; "A number: " &lt;&lt; 7;  
    std::string s = os.str();
    std::cout &lt;&lt; s &lt;&lt; std::endl;
    // no freeze(0)
}
</pre>

<p>You don't need the <B>ends</B> manipulator because C++ strings don't need terminating nulls. Since the <B>str</B> function gives you a pointer to a copy of the string, <B>ostringstream</B> maintains ownership of any heap memory it uses, rendering a "freeze" unnecessary.</p>

<h4><FONT COLOR="#000080">Something New</FONT></H4>

<p>The following features have been manufactured "out of whole cloth" during the last five years.</p>

<h4><FONT COLOR="#000080">Explicit constructors</FONT></H4>

<p>Single-argument constructors routinely provide implicit conversions from one type to another. For example, mathematical classes such as <B>Complex</B> typically have a constructor with the signature <B>Complex(double)</B>, as well as global functions for arithmetic operations, such as <B>Complex operator+(const Complex&amp;, const Complex&amp;)</B>. With these definitions in place, you can write mathematical expressions like you would by hand, such as:</p>

<pre>
Complex c1(1, 2);
Complex c2 = c1 + 1;  // c1 + (1, 0)
</pre>

<p>The compiler implicitly converts the literal <B>1</B> to <B>Complex(1.0)</B> to accommodate <B>operator+(const Complex&amp;, const Complex&amp;)</B>. To give the programmer control over when implicit conversions apply, Standard C++ provides the <B>explicit</B> keyword. An explicit constructor is never used for implicit conversions. If you define the single-argument constructor above like this:</p>

<pre>
explicit Complex(double);
</pre>

<p>then the addition operation in the initialization of <B>c2</B> above fails. And in case you're wondering, no, you can't use <B>explicit</B> with conversion operators, although it would make sense to do so.</p>

<h4><FONT COLOR="#000080">Mutable data members</FONT></H4>

<p>It is widely accepted that the constness of member functions should always be determined from a client perspective, but sometimes you want to update some hidden data members the user knows nothing about during an apparently const operation. Traditionally, you would "cast away" the constness of the <B>this</B> pointer to gain access to those data members. For example, the lookup method in the <B>List</B> class below uses the <B>const_cast</B> operator to gain access to the cache:</p>

<pre>
class List
{
    void* cache;
public:
    bool lookup(void* p) const
    {
        // Do lookup, then cache
        // pointer for next time
        const_cast&lt;List*&gt;(this)-&gt; cache = .....;
    }
};
</pre>

<p>Although you may have other reasons for casting away const, this particular situation occurs so frequently that C++ now allows you to declare data members <B>mutable</B>, so you can modify them directly in a const member function:</p>

<pre>
class List
{
    mutable void* cache;
public:
    bool lookup(void* p) const
    {
        // Do lookup, then cache
        // pointer for next time
        cache = .....;
    }
};
</pre>

<h4><FONT COLOR="#000080">Covariant returns</FONT></H4>

<p>A long-standing C++ rule requires that a member function that overrides a virtual function must have not only the same signature but also the same return value as the base class member function. In the following code, for example, <B>A::f</B> and <B>B::f</B> both return a pointer to an object of class <B>X</B>:</p>

<pre>
class X {};

class A
{
public:
    virtual X* f() {return new X;}
};

class B : public A
{
public:
    virtual X* f() {return new X;}
};
</pre>

<p>In real-world object models, however, it is quite common for <B>B::f</B> to want to return a pointer to an object derived from X. Standard C++ allows such covariant returns, so you can modify the code as follows:</p>

<pre>
class Y : public X {};

class B : public A
{
public:
    virtual Y* f() {return new Y;}
};
</pre>

<h4><FONT COLOR="#000080">New-style casts</FONT></H4>

<p>As I indicated earlier, C-style casts have long been a source of controversy as well as bugs. Since they represent a work-around to normal language behavior, they should be used sparingly, and should be easy to spot in code. To this end, the committee invented new-style casts, which come in four flavors: <B>static_cast</B>, <B>dynamic_cast</B>, <B>reinterpret_cast</B>, and <B>const_cast</B>.</p>
<p><B>static_cast</B> is for converting between related types, such as numeric types, as in:</p>

<pre>
double x;
// truncate x
int i = static_cast&lt;int&gt;(x);
</pre>

<p>You can also use <B>static_cast</B> to downcast from a pointer to base to a pointer to a derived object:</p>

<pre>
X* px = new Y; // Y derives from X, as in 3 above
Y* py = static_cast&lt;Y*&gt;(px);
</pre>

<p>This particular use of <B>static_cast</B> is safe only when you know at compile time that <B>px</B> actually points to a <B>Y</B> object. If you don't, you can use <B>dynamic_cast</B> to find out for sure:</p>

<pre>
Y* py = dynamic_cast&lt;Y*&gt;(px);
if (py)
    .....  // actually points to a Y
else
    .....  // doesn't point to a Y
</pre>

<p><B>dynamic_cast</B> works only for polymorphic types (classes that have a virtual function) and built-in types. You can also use <B>dynamic_cast</B> for casting reference types, in which case the cast throws a <B>bad_cast</B> exception if the referent isn't what you expected. You'll find the definition for <B>bad_cast</B> in the header &lt;typeinfo&gt;. I showed examples of the other two casts earlier in this article.</p>

<h4><FONT COLOR="#000080">Run-time type identification (RTTI)</FONT></H4>

<p><B>dynamic_cast</B> is part of RTTI, the C++ mechanism that lets you query the dynamic type of an object through a pointer or reference. There is also a <B>typeid</B> operator that yields an object of class <B>typeinfo</B>, which has limited information about an object's dynamic type. The following example shows how to get the name of an object's dynamic type:</p>

<pre>
#include &lt;typeinfo&gt;

main()
{
  D d;
  B* bp = &amp;d;
    
  cout &lt;&lt; typeid(d).name() &lt;&lt; endl;
  cout &lt;&lt; typeid(bp).name() &lt;&lt; endl;
  cout &lt;&lt; typeid(*bp).name() &lt;&lt; endl;
  cout &lt;&lt; (typeid(d) == typeid(*bp))
       &lt;&lt; endl;
}
</pre>

<p>This example should yield output something like:</p>

<pre>
D
B *
D
1
</pre>

<p>Needless to say, you shouldn't use RTTI very often in typical applications. Unless you're writing a utility that needs to specifically query an object's dynamic type, such as a debugger, polymorphism via virtual functions should meet your dynamic binding needs.</p>

<h4><FONT COLOR="#000080">Something Borrowed</FONT></H4>

<p>It may seem strange to label the major new features of Standard C++ "borrowed," but one must give credit where it is due. The following table lists these features and the languages that inspired them.</p>

<pre>
Feature     Borrowed From

type bool   Pascal and many others
namespaces  Lisp/CLOS, Modula 2, Ada
exceptions  Lisp, ML
templates   Ada, Clu
</pre>

<p>A <B>bool</B> variable holds the result of a Boolean expression. C++ also provides the Boolean literals <B>true</B> and <B>false</B>, should you need them. When used in an integer expression, <B>true</B> becomes 1 and <B>false</B> becomes zero, so you can use them as array indices if you want. There is even an output stream flag, <B>boolalpha</B>, that causes a stream such as <B>cout</B> to print the string literals <B>"true"</B> and <B>"false"</B> instead of 1 and 0 for corresponding Boolean values. The following example illustrates all these features:</p>

<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// test an int's parity
bool odd(int n)
{
    return n%2 == 1;
}

string parity[] = {"even", "odd"};

int main()
{
    int n = 7;
    cout.setf(ios::boolalpha);
    cout &lt;&lt; "n odd? " &lt;&lt; odd(n)
         &lt;&lt; endl;
    cout &lt;&lt; "parity of n-1 == "
         &lt;&lt; parity[odd(n-1)] &lt;&lt; endl;
}
</pre>

<p>This produces the output:</p>

<pre>
n odd? true
parity of n-1 == even
</pre>

<h4><FONT COLOR="#000080">Namespaces</FONT></H4>

<p>C++ lets you partition your declarations into namespaces &#151; to package them together, so to speak. It's essentially the C++ equivalent of modules in Modula-2, or packages in Ada, Common Lisp, and Java. The main reason for namespaces is to manage "programming in the large" by minimizing name conflicts that might occur when using multiple libraries in a program. Library vendors have traditionally invented strange looking names for global identifiers to uniquely identify them. Often this has involved some prefix related to the name of the company or particular library product. Most of Rogue Wave's library functions, for example, begin with the characters <B>RW</B>. With namespaces, you don't worry about name conflicts (other than the names of namespaces themselves) because declarations remain hidden within a namespace until you ask for them. To define a namespace, you use the <B>namespace</B> keyword, like this:</p>

<pre>
namespace MyNamespace
{   // namespace begins here
    void f();
    // more declarations .....
};      // namespace ends here
</pre>

<p>The full name of the function <B>f</B> above is <B>MyNamespace::f</B>, similar to a class member. If you refer to <B>f</B> with its fully qualified name, therefore, there is no chance for a conflict with any other function named <B>f</B>. If <B>MyNamespace::f</B> is the only function named <B>f</B> that you will be using in a given scope, then you can say so with a <I>using declaration</I>, and then just use <B>f</B> unadorned thereafter to save keystrokes, as in:</p>

<pre>
using MyNamespace::f;
f();  // calls MyNamespace::f
</pre>

<p>If you're confident that none of the names in <B>MyNamespace</B> conflict with other names in your program, you can import all of the names with a single <I>using directive</I>:</p>

<pre>
using namespace MyNamespace;
</pre>

<p>A using directive in essence "unlocks" an entire namespace, so that all of its names are considered when the compiler seeks to match a use of an identifier with its original declaration. You encounter a problem only when you use a name that is declared in more than one place &#151; its mere presence in multiple namespaces is not a liability, as is the case with traditional link libraries. It is generally bad practice, however, to put using directives in a header file, since any translation unit that includes a directive will unlock the associated namespace, thus defeating the purpose of having namespaces. The same logic applies to individual using declarations, as well (only on a smaller scale, since you're exposing identifiers only one by one). The rule of thumb, therefore, is to use only fully qualified references to namespace members in your own header files.</p>
<p>Declarations for the same namespace can occur in different header files. The complete namespace is the union of the declarations included in a translation unit. This is how the standard namespace <B>std</B> is defined. Each standard header wraps its declarations in the definition:</p>

<pre>
namespace std {.....};
</pre>

<p>but there is only one namespace <B>std</B>.</p>

<p>If you don't like typing out long namespace names, you can define an alias, like this:</p>

<pre>
namespace my = MyNamespace;
</pre>

<p>You can thereafter refer to namespace members with the alias, e.g., <B>my::f()</B>. This becomes a cheap versioning tool as well, since you can precede code that assumes a particular namespace name (like <B>my</B> above) with an alias declaration that you can change at will.</p>

<h4><FONT COLOR="#000080">Exceptions</FONT></H4>

<p>C++ exceptions support runtime error handling in a robust manner. Exceptions behave somewhat like the <B>setjmp/longjmp</B> mechanism of Standard C, only they are much safer and more flexible. To throw an exception, you use the <B>throw</B> keyword:</p>

<pre>
if (&lt;something bad happens&gt;)
    throw MyException("hit the fan");
</pre>

<p>To handle this exception, there must be a try block with an associated catch clause that can catch a <B>MyException</B> object, somewhere back up the thread of execution. For example:</p>

<pre>
try
{
    f();
}
catch (MyException&amp; x)
{
    cout &lt;&lt; x.what() &lt;&lt; endl;
}
</pre>

<p>The Standard C++ library defines several exception classes for the objects it throws. Much has been written on exceptions, so to save space here I'll just refer you to my two-article series, "Error Handling in C++," <I>CUJ,</I> November-December 1997, or to chapter 13 of my book, <I>C &amp; C++ Code Capsules</I> (Prentice-Hall, 1998), which derives from those articles.</p>

<h4><FONT COLOR="#000080">Templates</FONT></H4>

<p>The crowning piece of work of the C++ standards committee is most assuredly the template mechanism. What started out as merely a formalism for generating type-parameterized code has become a programming paradigm in its own right. As proof, just consider the power, flexibility, and popularity of the Standard Template Library. Mike Vilot, past chair of the committee's library group, once called STL "templates on steroids." STL has generated a subculture of its own, and has even spilled over into Java as JGL (the "Java Generic Library"), which was developed by ObjectSpace, one of the first vendors of STL.</p>
<p>Templates come in two varieties: class and function templates. Both occur throughout the Standard C++ library. In fact, the Standard C++ library is almost 100% templates. For example, the <B>string</B> class is really an instantiation of the <B>basic_string</B> template for <B>char</B> string elements. <B>cout</B> is an object of type <B>ostream</B>, which in turn is an instantiation of the template class <B>basic_ostream</B>, for <B>char</B> stream elements. How about <B>complex</B>? Yep, it's a template, with specializations for <B>float</B>, <B>double</B>, and <B>long double</B> right out of the box. The only notable library components I can think of off the top of my head that aren't templates are the basic library support functions, such as <B>set_terminate</B> and the various overloads of <B>operator new</B> and <B>operator delete</B>.</p>
<p>Class templates seem to have evolved from the need to build code once for a container and then adapt it for use on different types of contained objects. Imagine a container of integers, such as the following (substitute <B>stack</B> or <B>set</B> or some other favorite container in place of <B>Container</B>):</p>

<pre>
class Container
{
    int *data; // uses an array
    int n;     // #elements
public:
    Container();
    void insert(int);
    void remove(int);
    bool contains(int) const;
    int* first();
    int* next();
};
</pre>

<p>The logic of the member functions is the same whether a <B>Container</B> holds <B>int</B> elements or <B>float</B>, or objects of any user-defined type. To capture that fact, templates let us make the type of the contained object a parameter:</p>

<pre>
template&lt;class T&gt;
class Container
{
    T *data;   // use an array
    int n;     // #elements
public:
    Container();
    void insert(const T&amp;);
    void remove(const T&amp;);
    bool contains(const T&amp;) const;
    T* first();
    T* next();
};
</pre>

<p>When you need a <B>Container</B> of integers, you specialize the template by specifying the actual type for its parameter, as follows:</p>

<pre>
Container&lt;int&gt; c;
</pre>

<p>whereupon the compiler generates the appropriate code from the template.</p>

<p>Function templates behave differently, in that the compiler deduces the type of the template parameter(s) from the arguments to the function call. For example, given the template:</p>

<pre>
template&lt;class T&gt;
void swap(T&amp; x, T&amp; y)
{
    T temp = x;
    x = y;
    y = temp;
}
</pre>

<p>the call <B>swap(i, j)</B>, where <B>i</B> and <B>j</B> both have type <B>int</B>, will cause code for the <B>int</B> version of <B>swap</B> to be generated automatically at compile time. Compilers have supported basic class and function templates for some time now.</p>
<p>That's the easy explanation of templates. In the rest of this section I summarize features that have evolved over the years that make templates the sophisticated tool for generic programming that they have become.</p>

<h4><FONT COLOR="#000080">Non-type parameters</FONT></H4>

<p>Template parameters don't have to be types. They can also be compile-time constants, such as an integer for array limits. For example, if you know an upper bound for the number of elements a container in your application will hold, then you can store the elements more efficiently inside the container object, as follows:</p>

<pre>
template&lt;class T, size_t N&gt;
class Container
{
    T data[N]; // the elements
    int n;
public:
    Container();
    void insert(const T&amp;);
    void remove(const T&amp;);
    bool contains(const T&amp;) const;
    T* first();
    T* next();
};
</pre>

<p>The declaration:</p>

<pre>
Container&lt;int, 100&gt; c;
</pre>

<p>defines the data array for <B>c</B> to occupy 100 words within the object.</p>

<h4><FONT COLOR="#000080">Default arguments</FONT></H4>

<p>You can provide default values for both type and non-type template parameters. For example, if you change the template parameter specification for <B>Container</B> above to:</p>

<pre>
template&lt;class T, size_t N = 100&gt;
class Container {.....}
</pre>

<p>then the declaration:</p>
<pre>
Container&lt;int&gt; c;
</pre>

<p>fixes the capacity of <B>c</B> at 100, as in the previous example. For a type parameter example, consider the <B>set</B> container type in the Standard C++ library. The declaration:</p>

<pre>
set&lt;int&gt; s1;
</pre>

<p>causes s1 to store its elements in ascending numerical order because the <B>set</B> template is defined as:</p>

<pre>
template&lt;class T, class Compare = less&lt;T&gt;, .....&gt;
class set {.....};
</pre>

<p>The construction of a <B>set</B> object involves the creation of a function object of type <B>Compare</B>, which is of type <B>less&lt;T&gt;</B> by default. The container uses this function object to compare elements by pairs to maintain proper ordering for the set. To store elements in descending order, you can provide a different function object class, like this:</p>

<pre>
set&lt; int, greater&lt;int&gt; &gt; s2;
</pre>

<p>The specification of <B>Compare</B> shows that you can use a template parameter (<B>T</B> in this case) to define subsequent parameters in the same template definition (<B>less&lt;T&gt;</B>).</p>

<h4><FONT COLOR="#000080">Member templates</FONT></H4>

<p>You can define a template as a class member function, for example</p>

<pre>
class A
{
    template&lt;class T&gt; void f(const T&amp; t);
    // .....
};
</pre>

<p>This is especially useful for implicit conversions between related template classes. As I mentioned earlier, the Standard C++ library defines a <B>complex</B> template class, with three specializations for the types <B>float</B>, <B>double</B>, and <B>long double</B>. To allow conversions between these various precisions, the following member template is defined:</p>

<pre>
template&lt;class T&gt;
class complex
{
public:
    template&lt;class X&gt; complex(const complex&lt;X&gt;&amp;);
    // .....
};
</pre>

<p>To define the function body outside the class definition, you have to mention both template parameters, as follows:</p>

<pre>
// Definition:
template&lt;class T1&gt;
    template&lt;class T2&gt;
    complex&lt;T1&gt;::complex(const complex&lt;T2&gt;&amp; c)
    {.....};
</pre>

<p>The member constructor template above is used in the construction of <B>c2</B> below:</p>

<pre>
// Usage:
complex&lt;float&gt; c1;
complex&lt;double&gt; c2(c1); // uses template ctor
</pre>

<h4><FONT COLOR="#000080">Explicit instantiation</FONT></H4>

<p>A C++ compiler decides which template code to generate by the objects you declare and the functions you call. When calling a function template, however, the arguments must match the template definition exactly. To illustrate, suppose you write a template to find the maximum of two integers:</p>

<pre>
template&lt;class T&gt;
T max(const T&amp; t1, const T&amp; t2)
{
    return t1 &gt; t2 ? t1 : t2;
}
</pre>

<p>In the following function call the template will not apply:</p>

<pre>
int i = 1;
double x = 2.0;
cout &lt;&lt; max(i,x); // error
</pre>

<p>The reason this fails is because the template expects the arguments to be the same type. You can instruct the compiler to generate the <B>double</B> version ahead of time, however, in which case the standard conversion from <B>int</B> to <B>double</B> can be used to favor this keyword. To do this, just declare a version of the function with the <B>template</B> keyword, as in:</p>

<pre>
template double max(double, double);
</pre>

<p>This explicit instantiation brings the <B>double</B> version of <B>max</B> into existence as if you had coded it yourself. You can explicitly instantiate template classes as well.</p>

<h4><FONT COLOR="#000080">Explicit specification of template functions</FONT></H4>

<p>It is possible to define a function template that does not necessarily use all of its template parameters in its arguments. The following example, while not terribly useful, illustrates the point:</p>

<pre>
template&lt;class T&gt;
T* build()
{
    return new T;
}
. ....
int* ip = build&lt;int&gt;();
</pre>

<p>Since there is no way to deduce the type of <B>ip</B> from the call to <B>build</B>, you need a way to specify it explicitly. A more useful example, which almost made its way into the Standard C++ library but didn't for lack of time, is <B>implicit_cast</B>, a function template that looks like a new-style cast:</p>

<pre>
template&lt;class To, class From&gt;
To implicit_cast(const From&amp; f)
{
    return f;
}
. ....
int i = 1;
double x = implicit_cast&lt;double&gt;(i);    // int deduced
char* p = implicit_cast&lt;char*&gt;(i);      // conversion error
</pre>

<p>This pseudo-operator allows you to force an implicit conversion. I know that sounds strange, but <B>implicit_cast</B> succeeds only if an implicit conversion naturally exists between the two types involved, which sometimes is just what you want. The only way to introduce the target type is with the explicit specification syntax, which is by coincidence the same as the new-style cast syntax. (New-style casts are bona fide operators, though, and not templates).</p>

<h4><FONT COLOR="#000080">Explicit specialization</FONT></H4>

<p>You may sometimes want to override the code-generation mechanism for special cases. Consider a function much like <B>strcmp</B> that compares objects:</p>

<pre>
// A Comparison function template
template&lt;class T&gt;
int comp(const T&amp; t1, const T&amp; t2)
{
    return (t1 &lt; t2) ? -1 : (t1 == t2) ? 0 : 1;
}
</pre>

<p>This works fine for value-oriented types that support <B>operator&lt;</B> and <B>operator==</B>, but certainly not for pointer types like <B>char*</B>. You can specialize this template for <B>const char*</B> to compare null-terminated strings instead of the pointers themselves, as follows:</p>

<pre>
// A char* specialization:
template&lt;&gt;
int comp&lt;const char*&gt;(const char*&amp; t1, const char*&amp; t2)
{
    return strcmp(t1,t2);
}
</pre>

<p>The <B>template&lt;&gt;</B> prefix signifies that the code that follows is a full specialization of a previously defined template. Since in this case the compiler could deduce that <B>T</B> is <B>const char*</B>, you could omit the <B>&lt;const char*&gt;</B> specification after the function name. For that matter, in this example you could ignore template syntax altogether and just define a function named <B>comp</B> that takes <B>const char*</B> arguments, since the compiler considers ordinary functions before templates to match a function call. But it is a good idea to do it like I did here, so the reader knows that it overrides a template. And of course you must use the template syntax when the function's return type is a template argument, or if you are specializing a class template.</p>

<h4><FONT COLOR="#000080">Partial specialization</FONT></H4>

<p>For class templates with multiple arguments, you can choose to specialize only some of those arguments. You can easily spot such partial specializations by the occurrence of type specifications both in the template prefix and immediately after the class name. To illustrate, consider the following primary template with two type parameters:</p>

<pre>
template&lt;class T, class U&gt;
class A
{
public:
    A() {cout &lt;&lt; "primary template\n";}
};
</pre>

<p>The following partial specialization overrides the primary template when <B>T</B> is a pointer type.</p>

<pre>
template&lt;class T, class U&gt;
class A&lt;T*, U&gt;
{
public:
    A() {cout &lt;&lt; "&lt;T*, U&gt; specialization\n";}
};
</pre>

<p>The next one applies when the types of the template arguments are the same.</p>

<pre>
template&lt;class T&gt;
class A&lt;T, T&gt;
{
public:
    A() {cout &lt;&lt; "&lt;T, T&gt; specialization\n";}
};
</pre>

<p>The following specializes the case where <B>T</B> is <B>int</B>.</p>

<pre>
template&lt;class U&gt;
class A&lt;int, T&gt;
{
public:
    A() {cout &lt;&lt; "&lt;int, U&gt; specialization\n";}
};
</pre>

<p>The following test program verifies the above statements:</p>

<pre>
int main()
{
    A&lt;char, int&gt; a1;
    A&lt;char*, int&gt; a2;
    A&lt;float, float&gt; a3;
    A&lt;int, float&gt; a4;
}
</pre>

<p>It should produce the output:</p>

<pre>
primary template
&lt;T*, U&gt; specialization
&lt;T, T&gt; specialization
&lt;int, U&gt; specialization
</pre>

<p>Partial specialization comes in handy when you want to avoid the code bloat that sometimes results with templates. As you know, the compiler generates separate code for each type you specialize a class template for. For example, the declarations <B>Container&lt;int&gt;</B>, <B>Container&lt;float&gt;</B>, and <B>Container&lt;Foo&gt;</B>, generate three distinct class definitions. Using partial specialization you can arrange for all pointer types to share a common implementation. First, fully specialize on <B>void*</B>:</p>

<pre>
// The Primary Template:
template&lt;class T&gt;
class Container {.....};

// Full Specialization:
template&lt;&gt;
class Container&lt;void*&gt; {.....};
</pre>

<p>Then, partially specialize on <B>T*</B>, as follows:</p>

<pre>
// Partial Specialization:
template&lt;class T&gt;
class Container&lt;T*&gt; : private Container&lt;void*&gt;
{.....};
</pre>

<p>The <B>T*</B> specialization uses the <B>void*</B> implementation, casting <B>T* to and from void*</B> as needed. Whenever you specialize <B>Container</B> for a pointer type other than <B>void*</B>, the <B>T*</B> specialization is used, so you don't have a different instantiation for each pointer type.</p>

<h4><FONT COLOR="#000080">Template-template arguments</FONT></H4>

<p>No, I'm not stuttering :-). You can actually use another template as a template argument. The following should suffice as an illustration:</p>

<pre>
template&lt;class T, template&lt;class U&gt; class Container&gt;
class SomethingBig
{
    Container&lt;T&gt; c;
    .....
};
</pre>

<p>In addition to whatever else it may do, <B>SomethingBig</B> allows you to arbitrarily specify a container type with its associated contained type, and it builds the container in its implementation. You actually pass the container template as an argument, like this:</p>

<pre>
SomethingBig&lt;int, vector&gt; sb_vec_int
SomethingBig&lt;Foo, map&gt; sb_map_Foo;
</pre>

<p>Since the formal parameter <B>U</B> is not actually used, you can omit it, just like you can omit the names of formal parameters in C++ function definitions:</p>

<pre>
template&lt;class T, template&lt;class&gt; class Container&gt;
class SomethingBig {.....};
</pre>

<h4><FONT COLOR="#000080">typename</FONT></H4>

<p>There are some obscure instances in template definitions that can really confuse a compiler (and you thought you were confused! :-). For example, the expression <B>T::U</B> inside a template definition with a type parameter named <B>T</B> could represent either a typedef member or a static data member of type <B>T</B>, and compilers aren't sufficiently clairvoyant to distinguish between the two. The <B>typename</B> keyword cues the compiler that the following token is a type, as the following definition of <B>Baz</B> illustrates:</p>

<pre>
template&lt;class T&gt;
class Baz {
    typename T::U x;
};
</pre>

<p>You can also use <B>typename</B> in place of the <B>class</B> keyword in specification of template parameters:</p>

<pre>
template&lt;typename T&gt;
    .....
</pre>

<h4><FONT COLOR="#000080">Conclusion</FONT></H4>

<p>As you can see, C++ has evolved significantly since its early days at AT&amp;T Bell Labs. Some things have changed in the name of type safety, and other features have been added to support more sophisticated programming techniques. A lot has been said about the language over the years. One particular programming language has been marketed in large part as a supposedly simpler alternative to C++.</p>
<p>Is C++ complex? When taken as a whole, perhaps. Is it worth the effort to master? I think so, although you can use it effectively without "mastering" it. In any case, perhaps the most important thing that could be said at this point is that C++ is stable. It is widely used, and now it has an ISO/ANSI standard.</p>
<p>The future looks bright for C++.</p>

<p><i>Chuck Allison is Consulting Editor and a former columnist with </I>CUJ<I>. He is the owner of Fresh Sources, a company specializing in object-oriented software development, training, and mentoring. He has been a contributing member of J16, the C++ Standards Committee, since 1991, and is the author of </I>C and C++ Code Capsules: A Guide for Practitioners<I>, Prentice-Hall, 1998. You can email Chuck at <B>cda@freshsouces.com</B>.</i></p>

</BLOCKQUOTE>
</BODY>
</HTML>
