

<HTML>
<HEAD>

<TITLE>September 1994/Using Windows Memory Management Services</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocsep.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Windows Programming</FONT></H2>

<hr><h2 align="center"><font color="#800000">Using Windows Memory Management Services<A name="016D_00BF"><A name="016D_00BF"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="016D_0000"><A name="016D_0000">David Singleton</font></h3><hr><blockquote><P>
<P><i><A name="016D_0000"><A name="016D_0000">David Singleton is a Director and Principal Consultant with Singleton Systems Ltd, an independent computer systems consulting company. He has a BA in Physics and an MSc in Computer Science. He can be contacted at his home and business address &#151; 30 The Albany, Sunset Avenue, Woodford Green, Essex, IG8 OTJ, England. His telephone number is +44-81-505-7996. He can also be contacted at CompuServe address 100265,3625.</i></P><P>
<h4><FONT COLOR="#000080"><A name="016D_00C0">Introduction<A name="016D_00C0"></FONT></h4></P>
It is generally recommended that programs developed to run under MS-Windows use the medium memory model. However, use of the medium memory model normally confines the user to a single, 64 KB data segment. Windows provides services to allow programs to request additional space from its global heap. This article demonstrates a C++ class, <I>MemoryObject</I>, that hides the details of managing the Windows global heap from the applications programmer.<P>
Windows recognizes that you might want to use one of the smaller memory models, but that you might need more than 64 KB of data space. For this reason, the Windows global memory services allow a user to request (and return) data segments from global memory. Programs must address these segments with a full <I>segment:offset</I> address, i.e., with a far pointer. I use the following main Windows global memory services:<P>
<UL><li><I>GlobalAlloc</I> &#151; Allocates memory from the global heap. This function returns a handle (i.e., a pointer to an entry in an internal Windows table) for the object.</li>
<li><I>GlobalFree</I> &#151; Frees a global memory object. For every call to <I>GlobalAlloc</I>, a program must ultimately make a corresponding call to <I>GlobalFree</I>.</li>
<li><I>GlobalLock</I> &#151; Locks a global memory object and returns a far pointer to it. In Windows 3.1, running in enhanced mode, this function's most important use is to convert a handle to global memory object to a far pointer. Programs must allocate memory with <I>GlobalAlloc</I> before they can <I>GlobalLock</I> the memory.</li>
<li><I>GlobalSize</I> &#151; Returns the size of a global memory object.</li>
<li><I>GlobalUnlock</I> &#151; Unlocks a global memory object. For every call to <I>GlobalLock,</I> a program must make a corresponding call to <I>GlobalUnlock</I>.</li></UL>
<a href="#1">Reference 1</a> gives full details of all the Windows global memory services. <a href="#2">Reference 2</a> provides invaluable background material.<P>
<h4><FONT COLOR="#000080"><A name="016D_00C1">Design Approach<A name="016D_00C1"></FONT></h4></P>
While it is not difficult to use the Windows global memory services, programmers must follow a few rules, as noted above. Further, there is a practical limit on the number of segments that can exist at any one time. (<a href="#3">Reference 3</a> gives some indication of this number, but it largely depends on Windows internals with which I am unfamiliar.) So, it is not a good idea to request lots of small chunks of global memory from Windows. Instead, my approach is to request a few larger chunks and manage the internal allocation of these myself. I have therefore implemented a set of C++ classes to manage the allocation and deallocation of Windows global memory.<P>
Managing the allocation/deallocation process proved to be the most difficult part of my class design. A program may allocate or deallocate individual blocks in any conceivable order. So my classes must allocate the correct amount of memory, without too much overhead, and return a block in such a way that it can be reallocated if needed. I've also designed the classes to provide some diagnostic capabilities that can be used to trace memory leakage within user programs.<P>
Taking all of the above into account, I've come up with two main classes to manage the allocation/deallocation of Windows global memory: <I>FarHeapBlock</I><I>,</I> and <I>MemoryObject</I>.<P>
<h4><FONT COLOR="#000080"><A name="016D_00C2">Class <B><I>FarHeapBlock</I><A name="016D_00C2"></B></FONT></h4></P>
This class manages the allocation/deallocation of large memory blocks from the Windows global memory area. For this application, I've arbitrarily defined a large block as 4,096 bytes. You can use a larger or smaller block size if you wish. Although the Windows global memory allocation functions allow you to request a block of up to about 16 MB, my implementation restricts the maximum block size to 64 KB, as it assumes that the block should fit within a single 16-bit segment.<P>
I use doubly-linked lists to keep track of individual <I>FarHeapBlocks</I>. Thus, a <I>FarHeapBlock</I> contains pointers both to the previous <I>FarHeapBlock</I> and to the next <I>FarHeapBlock</I>. In the case of <I>FarHeapBlocks</I>, I also decided to store the <I>HGLOBAL</I> of the previous and next blocks, rather than a far pointer. With hindsight, I could have used far pointers instead. Indeed, this would probably make for slightly more efficient code.<P>
<A href="list1.htm">Listing 1</a>
and <A href="list2.htm">Listing 2</a>
show the <I>FarHeapBlock</I> class. Most of the code is in the two operator functions <I>new</I> and <I>delete.new</I> requests a block of global memory from Windows and chains it into the list of existing <I>FarHeapBlocks. new</I> also checks that the request for memory has succeeded. If not, it raises an error. <I>delete</I> unlinks a <I>FarHeapBlock</I> from the list of <I>FarHeapBlocks</I> and returns the memory block to Windows. <I>GetHbFromHandle</I> converts a Windows <I>HGLOBAL</I> handle to a far memory pointer.<P>
(Users of the Microsoft Foundation Class (MFC) library may see something familiar in the way that I move through a list of <I>FarHeapBlocks.</I> This is deliberate, after all, why change a good thing! I have defined a type <I>FHB_POSITION</I>, which gives the current position in the list of <I>FarHeapBlocks.</I> I use functions <I>GetHeadPosition, GetAt, GetNext</I>, and <I>IsEmpty</I> to iterate through the list of <I>FarHeapBlocks. GetCount</I> returns a count of the number of <I>FarHeapBlocks</I> that are currently in existence. These functions operate in the same manner as their synonyms in MFC.)<P>
<I>FarHeapBlock</I> manages the allocation/deallocation of memory from the Windows global memory area; <I>MemoryObject</I> manages allocation/deallocation of memory from a <I>FarHeapBlock</I>. To <I>FarHeapBlock,</I> any block of memory, whether allocated or free, is just another <I>MemoryObject. FarHeapBlock</I> therefore requires the four <I>MemoryObject</I> pointers <I>free_list, end_free_list, in_use_list</I>, and <I>end_in_use list</I>. These pointers delineate the start and end of the free and allocated chains of <I>MemoryObjects</I> within a <I>FarHeapBlock</I>.<P>
At this point, we must leave the realms of standard C++ and move into some Microsoft-specific features. All of the above pointers are declared as type <I>MemoryObject BASED_VOID *. BASED_VOID</I> is in turn defined as __<I>based (void)</I>. To fully specify a pointer to an object, a program running on a 80x86 platform must specify both a segment and an offset &#151; but the __<I>based (void</I>) type of pointer specifies only the offset value. To complete the pointer, Microsoft supplies a further extension, the <I>:&gt;</I> operator. This operator enables a program to combine a segment with an offset to form a complete pointer. Using a __<I>based (void)</I> pointer reduces the overhead of each pointer to two bytes, while preserving the functionality of a far (four-byte) pointer.<P>
The <I>FarHeapBlock</I> class supports the <I>MemoryObject</I> class. <I>MemoryObject</I> is the class through which you will typically access global memory; under normal circumstances you will not need to worry about <I>FarHeapBlock</I>.<P>
<h4><FONT COLOR="#000080"><A name="016D_00C3">Class <B><I>MemoryObject<A name="016D_00C3"></B></I></FONT></h4></P>
A MemoryObject is essentially a header for a block of memory; without the associated memory block, a <I>MemoryObject</I> is of little use! <A href="list3.htm">Listing 3</a>
and <A href="list4.htm">Listing 4</a>
show a significant portion of the MemoryObject class. (The full class source code is provided on this month's code disk.)<P>
Like the <I>FarHeapBlock</I>, each <I>MemoryObject</I> contains a number of special data fields. A particular <I>MemoryObject</I> will always be referenced in some <I>FarHeapBlock</I>'s in-use or free list. Therefore, each MemoryObject holds pointers to the next and previous <I>MemoryObjects</I> in whichever list it resides. <I>mo_block_size</I> indicates the size of each <I>MemoryObject</I>. (<I>sizeof</I> (<I>MemoryObject</I>) + the amount of data space requested by the user.) A <I>MemoryObject</I> must know how big it is so that it knows how much space to return to the free list. When deleting a <I>MemoryObject,</I> a program must know what <I>FarHeapBlock</I> it is stored in so that the MemoryObject can be transferred from the <I>FarHeapBlock's</I> in-use list to its free list. Therefore, each <I>MemoryObject</I> keeps a record of its associated <I>FarHeapBlock</I> in <I>my_heap_block</I>.<P>
As in <I>FarHeapBlock</I>, most of the code for <I>MemoryObject</I> is found in the two operator functions <I>new</I> and <I>delete</I>, C++ gives the programmer the ability to override these operator functions to considerable benefit. MFC already redefines the global <I>new</I> and <I>delete</I> operator functions for memory tracking purposes. I use MFC whenever I am developing codes, so I decided not to redefine these operators at a global level. Instead, I've implemented class-specific <I>new</I> and <I>delete</I> operators for the <I>MemoryObject</I> class. This approach does impose one restriction on the use of classes derived from <I>MemoryObject</I>: users should not create arrays of such classes, as they would be created using the global <I>new</I> operator rather than the class-specific version.<P>
I define three versions of <I>MemoryObject::operator new</I>:<P>
<UL><li><I>operator new (size_t size</I>) &#151; This is the standard redefinition of <I>new</I> for the class. Classes derived from <I>MemoryObject</I> will use this version by default.</li>
<li><I>operator new (size_t, size_t size</I>) &#151; This version takes an additional parameter that allows direct control of the <I>MemoryObject's</I> size. This version of <I>new</I> is used only within the <I>MemoryObject</I> class itself and is therefore declared as <I>private</I>.</li>
<li><I>operator new (size_t size, const char FAR * FileName, int Line</I>) &#151; I developed this version to assist in debugging and detecting memory leaks. It draws on ideas presented in MFC. This version takes two additional parameters, which indicate the program file and line number in the file from which <I>new</I> was called.</li></UL>
I have also defined functions <I>AllocateBlock</I> and <I>ReturnBlock</I> so that users can request arbitrary blocks of global memory, managed as <I>MemoryObjects</I>, without always having to define derived versions of the <I>MemoryObject</I> class. These two functions work in a very similar way to the standard C++ functions <I>malloc</I> and <I>free</I>.<P>
<h4><FONT COLOR="#000080"><A name="016D_00C4">Debug Support<A name="016D_00C4"></FONT></h4></P>
I have built debug support into the <I>MemoryObject</I> class. My code defines additional <I>MemoryObject</I> data items when I compile the code with debugging turned on. These objects are as follows:<P>
<UL><li><I>flags</I> indicates whether or not a block of memory has been allocated. My program checks this object upon allocation and deallocation, to ensure that it is as expected.</li>
<li><I>validity_tag</I> is a four-byte field that my program checks against an expected value whenever a <I>MemoryObject</I> is deleted. This check ensures that the user has not done anything odd, resulting in an attempt to delete an invalid <I>MemoryObject</I>.</li>
<li><I>Lno</I> and <I>Fname</I> hold the line number and (pointer to) filename of the program that called the <I>MemoryObject's new</I> operator. When a program calls the <I>new</I> operator with the line number and filename as placement parameters, <I>new</I> keeps a record of these parameters in <I>Lno</I> and <I>Fname,</I> respectively. Subsequently, a call to <I>DumpAllObjects</I> will cause the program to list, on its standard debugging output, all of the <I>MemoryObjects</I> that currently remain allocated. This feature is invaluable for tracing memory leaks. The sample program (on the code disk) shows the preferred method for declaring the filename.</li></UL>
I define a macro <I>MO_DEBUG_NEW</I> that can replace calls to <I>MemoryObject's new</I> operator. <I>MO_DEBUG_NEW</I> selects the correct version of <I>new,</I> depending on whether or not the code is being compiled for debugging. You can, if you wish, go one stage further. Include the following definition in your code, whenever you wish to invoke <I>MO_DEBUG_NEW</I>, but want your code to look like standard code:<P>
<pre>#define new MO_DEBUG_NEW</pre>
You can then use <I>new</I> as usual throughout the rest of your code. You should use this technique with great care in whatever file also makes calls to non-<I>MemoryObject</I> versions of <I>new,</I> (e.g. the global operator <I>new).</I> I believe that it will work without problem, but I have not tested it exhaustively. (I issue this warning because MFC uses an almost identical technique and defines an equivalent macro <I>DEBUG_NEW.)</I><P>
At the end of a program I can call <I>MemoryHeapIsEmpty</I> to see whether I have had any memory leakage. If it returns <I>FALSE,</I> I can then call <I>DumpAllObjects</I> to get a list of the <I>MemoryObjects</I> that have not been correctly deleted together with the program details of where they were allocated.<P>
The class's constructor and destructor both assist with validity checking during debugging, to trap errors before they get too far. The constructor sets an allocation flag and a validity tag. The destructor checks the validity tag and marks the block as unallocated.<P>
I have also developed <I>MemoryObject::PrintHeapReport</I> to record the status of the current <I>MemoryObject</I> and <I>FarHeapBlock</I> internal structures to a file. This has proven invaluable during development. (Strictly speaking, I should have developed a separate <I>FarHeapBlock::PrintHeapReports</I> function to report on <I>FarHeapBlock</I> internals, but it was just as easy to develop the function as I have done.)<P>
<h4><FONT COLOR="#000080"><A name="016D_00C5">Final Remarks<A name="016D_00C5"></FONT></h4></P>
In this article I've presented but one of possibly many ways to access Windows global memory. When I designed these classes I wanted not only to exploit the power of C++, but to tap the wealth of resources to be found in an application framework &#151; in this case, MFC. Thus I hoped to avoid reinventing too many wheels. I believe that I have demonstrated what a little careful class design, combined with a little judicious borrowing, can do.<P>
<h4>References</FONT></h4></P>
<a name="1"></a>1.     <I>Windows SDK Programmer's Reference</I>, Volume 2, Functions. Microsoft.<P>
<a name="2"></a>2.     <I>Programming Windows 3.1</I>, Third Edition, Charles Petzold, Microsoft Press 1992.<P>
<a name="3"></a>3.     <I>i486 Microprocessor Programmer's Reference Manual</I>, Intel 1990.<P>
<h4><FONT COLOR="#000080"><A name="016D_00C6">Additional Reading<A name="016D_00C6"></FONT></h4></P>
1.     <I>Visual C++ Programming Techniques Manual</I>, Microsoft.<P>
2.     "cout and cerr for Windows," David Singleton, <I>The C Users Journal</I>, Vol. 11 No. 9, September 1993.<P>

<h4><a href="../../../source/1994/sep94/single.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
