

<HTML>
<HEAD>

<TITLE>May 1994/CUG Product Focus</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Columns</FONT></H2>

<hr><h2 align="center"><font color="#800000">CUG Product Focus<A name="0104_007F"><A name="0104_007F"></font></h2><P>
<h3 align="center"><A name="0104_0000"><A name="0104_0000">MINED: A Powerful Multi-platform Text Editor</h3><P>
<h3 align="center"><font color="#800000">Victor R. Volkman</font></h3><hr><blockquote><P>
<P><i><A name="0104_0000"><A name="0104_0000">Victor R. Volkman received a BS in Computer Science from Michigan Technological University. He has been a frequent contributor to The C Users Journal since 1987. He is currently employed as Senior Analyst at H.C.I.A. of Ann Arbor, Michigan. He can be reached by dial-in at the HAL 9000 BBS (313) 663-4173 or by Usenet mail to sysop@ha19k.com.</i></P><P>
This article is abstracted from original documentation by Thomas Wolff, <I>wolff@inf.fu-berlin.de,</I> Freie Universitt Berlin, Institut fr Informatik, D-14195 Berlin, Germany, expressly for Reprint in <I>The C Users Journal.</I><P>
The MINED editor, originally by Michiel Huisjes and extensively modified by Achim Mller and Thomas Wolff, is a powerful multi-platform text editor. MINED runs on most UNIX platforms as well as MS-DOS and DEC VAX-11/VMS. MINED uses <I>TERMCAP</I> under UNIX and can edit text in any 8-bit character set. One of its more interesting features is full regular expression pattern matching for search and replace operations. This abstract provides some notes on implementing MINED. MINED is available from the CUG Library as volume #399.<P>
MINED is a screen editor designed for the <I>MINIX</I> operating system <I>(MINix + EDitor = MINED).</I> MINED is designed for files smaller than 50K and it tends to be quite fast. When MINED starts up, it reads the entire file into memory, thus minimizing disk access. (Only a few save, write, and copy commands require access to the disks.)<P>
Like Emacs and Jove, MINED is a modeless editor. Each character has its own entry in a 256-entry pointer-to-function array. When you type a character, MINED calls the corresponding function. Printable characters are connected with a function which inserts that character at the current location in the file. Other characters invoke other functions.<P>
The display consists of <I>SCREENMAX</I> + 1 lines and <I>XMAX</I> + 1 characters. When a line becomes larger than <I>XBREAK</I> characters, the line is either shifted <I>SHIFT_SIZE</I> characters to the left (which means that the first <I>SHIFT_SIZE </I>characters are not printed) or the end of the line is marked with the <I>SHIFT_MARK</I> character and the rest of the line is not printed. A line can never exceed <I>MAX_CHARS</I> characters. MINED will try to keep the cursor on the same line and same (relative) x-coordinate unless you alter the text. If you scroll up or down, the cursor attempts to stay in the same position with respect to the text. If the cursor position leaves the field of view, the cursor will move to the nearest visible line.<P>
Every character on the line is available for editing including the <I>linefeed</I> at the end of the line. When the <I>linefeed</I> is deleted, the current line and the next line are joined. The last character of the file (which is always a<I> linefeed</I>) can never be deleted.<P>
The bottom line (as indicated by <I>YMAX</I> + 1) is used as a status line during editing. This line is usually blank, but sometimes contains a request for information MINED needs during editing. Commands and requests on this line are displayed in reverse video.<P>
The terminal modes have changed completely since the last version. All signals like <I>start/stop, interrupt</I> etc. are unset. The only signal that remains set is the <I>quit</I> signal. The <I>quit</I> signal (^\) is the general abort signal for MINED. Typing a ^\ during searching or when MINED is asking for filenames, etc. will abort the function and MINED will return to the main loop.<P>
Sending a quit signal during the main loop will abort the session (after confirmation). If the file has been modified, MINED will ask if you want to save the file. If there isn't enough space left on the disk for a save, MINED will give an error message and continue.<P>
MINED attempts to mimimize the number of system calls. (This also tends to make it run fast.) I/O is done in <I>SCREEN_SIZE reads/writes</I> and accumulated output is flushed at the end of each character.<P>
<h4><FONT COLOR="#000080"><A name="0104_0080">Regular Expressions<A name="0104_0080"></FONT></h4></P>
MINED has a built-in regular expression matcher for search and replace routines. This allows for very efficient "wildcard" search requests. A regular expression can contain any number of normal characters and also these special characters:<P>
1.     A. ("dot," indicates matching any character)<P>
2.     A ^ (matching the begin of a line)<P>
3.     A $ (as the last character of the pattern) matching the end of a line<P>
4.     A \&lt;character&gt; matching &lt;character&gt;<P>
5.     A number of characters enclosed in [] pairs (matching any of the enclosed characters). You can indicate a list of characters with a hyphen. For example, [a-z] matches any letter of the alphabet. If the first character after the [ is a ^ then MINED will match anything but the characters in the set.<P>
Putting \ in front of any of the special characters negates its special meaning. Therefore a \ must be represented by \\.<P>
6.     * means that MINED will match a sequence of zero or more occurrences of the previous expression.<P>
MINED performs regular expression searches in two phases. In the first phase the expression is compiled into a more comprehensible form. In the second phase the actual matching is performed. For more details see "Search and Replace Routines" below.<P>
<h4><FONT COLOR="#000080"><A name="0104_0081">MINED Data Structures<A name="0104_0081"></FONT></h4></P>
In MINED, the whole data file is kept in a double-linked list of lines. The <I>LINE</I> structure looks like this:<P>
<pre>typedef struct Line {
   struct Line * next;
   struct Line *prev;
   char * text;
   unsigned char shift_count;
} LINE;</pre>
Each line entry contains a pointer to the next line, a pointer to the previous line and a pointer to the text of that line. A special field called <I>shift_count</I> contains the number of shifts (in units of <I>SHIFT_SIZE)</I> performed on that line. The total size of the structure is seven bytes per line so a file consisting of 1,000 empty lines will waste a lot of memory. A <I>LINE</I> structure is allocated for each line in the file. After that, MINED determines the number of characters in a line and allocates sufficient space to store them (including a <I>linefeed</I> and a <I>'\0').</I> The resulting address is assigned to the text field in the structure.<P>
A special structure is allocated and its address is assigned to the variable <I>header</I> as well as the variable <I>tail.</I> The text field of this structure is set to <I>NIL_PTR.</I> The <I>tail-&gt;prev</I> of this structure points to the last line of the file and the <I>header-&gt;next</I> to the first line. Other <I>LINE</I> * variables are <I>top_line</I> and <I>bot_line</I>, which point to the first line and last line on the screen respectively.<P>
Two other variables are also important. First, the <I>LINE * cur_line</I>, which points to the <I>LINE</I> currently in use and the <I>char * cur_text,</I> which points to the character at which the cursor stands.<P>
Whenever an ASCII character is typed, a new line is built with this character inserted. Then the old data space (pointed to by <I>cur_line-&gt;text)</I> is freed and space for the new line is allocated and assigned to <I>cur_line-&gt;text.</I><P>
Two global variables called<I> x </I>and <I>y</I> represent the <I>x</I> and <I>y</I>-coordinates of the cursor. The global variable <I>nlines</I> contains the number of lines in the file. <I>Last_y</I> indicates the maximum y coordinate of the screen (which is usually <I>SCREENMAX</I>).<P>
You must initialize a few strings by hand before compiling MINED. These string are <I>enter_string,</I> which is printed upon entering MINED, <I>rev_video</I> (turn on reverse video), <I>normal_video</I>, <I>rev_scroll</I> (perform a reverse scroll) and <I>pos_string. pos_string</I> positions the cursor. The <I>#define X_PLUS</I> and <I>Y_PLUS</I> contain the characters that MINED will add to the coordinates x and y (both starting at 0) to finish cursor positioning.<P>
<h4><FONT COLOR="#000080"><A name="0104_0082">Starting Up<A name="0104_0082"></FONT></h4></P>
You can call MINED with or without a filename argument. If you specify a filename, the function <I>load_file</I> checks if the file exists, if it can be read, and if it is writable (setting the <I>writable</I> flag accordingly). If the file can be read, <I>load_file</I> reads a line from the file and stores this line into a structure by calling <I>install_line</I> and <I>line_insert. line_insert</I> installs the line into the double linked list. <I>loadfile</I> then reads another line and repeats the process until it reaches the end of the file.<P>
Lines are read by the function <I>get_line,</I> which buffers the reading in blocks of <I>SCREEN_SIZE.</I> <I>load_file</I> also initializes the<I> LINE *</I> variables described above.<P>
<h4><FONT COLOR="#000080"><A name="0104_0083">Moving Around<A name="0104_0083"></FONT></h4></P>
MINED has several commands for moving through the file. You can move up (UP), down (DN), left (LF), and right (RT) with the arrow keys. Moving one line below the screen scrolls the screen one line up. Moving one line above the screen scrolls the screen one line down. The functions <I>forward_scroll</I> and <I>reverse_scroll</I> scroll the screen.<P>
There are several other move functions: begin of line <I>(BL)</I>, end of line <I>(EL)</I>, top of screen <I>(HIGH)</I>, bottom of screen <I>(LOW)</I>, top of file <I>(HO),</I> end of file <I>(EF)</I>, scroll one page down <I>(PD), </I>scroll one page up<I> (PU),</I> scroll one line down <I>(SD)</I>, scroll one line up <I>(SU)</I>, and move to a certain line number <I>(GOTO).</I><P>
Two functions called <I>MN</I> and <I>MP</I> move one word forward or backward. A word is a number of non-blanks seperated by a space, a tab, or a linefeed.<P>
<h4><FONT COLOR="#000080"><A name="0104_0084">Modifying Text<A name="0104_0084"></FONT></h4></P>
The modifying commands are built around the two functions, <I>insert</I> and <I>delete. insert</I> must be told where to insert the text. It doesn't make any difference whether this text contains linefeeds or not. <I>delete</I> must be given a pointer to the start line, a pointer to where deleting should start on that line, and the same information about the end position. The last character of the file will never be deleted. <I>delete</I> will make the necessary changes to the screen after deleting, but <I>insert</I> won't.<P>
The functions for modifying text are: insert one char <I>(S)</I>, insert a file <I>(file_insert(fd))</I>, insert a linefeed and put cursor back to end of line <I>(LIB),</I> delete character under the cursor <I>(DCC),</I> delete before cursor (even linefeed) <I>(DPC),</I> delete next word <I>(DNW)</I>, delete previous word <I>(DPW)</I>, and delete to end of line (if the cursor is at a linefeed delete line) <I>(DLN).</I><P>
<h4><FONT COLOR="#000080"><A name="0104_0085">Yanking<A name="0104_0085"></FONT></h4></P>
MINED provides a few utilities for yanking pieces of text. The function <I>MA</I> marks the current position in the file. This is done by setting <I>LINE</I> <I>*</I> <I>mark_line</I> and <I>char *</I> <I>mark_text</I> to the current position. Yanking of text can occur in either of two modes. The first mode just copies the text from the mark to the current position (or visa versa) into a buffer <I>(YA)</I> and the second also deletes the text <I>(DT).</I> Both functions call the function <I>set_up (YA</I> with the delete flag on; <I>DT</I> with it <I>off</I>). <I>set_up</I> checks if the marked position is still valid (by using <I>check_mark</I> and <I>legal</I>), then calls the function <I>yank,</I> sending <I>yank</I> the start and end positions in the file. <I>yank</I> copies the text into a <I>scratch_file</I> as indicated by the variable <I>yank_file.</I> At the end of copying, <I>yank</I> will (if necessary) delete the text. A global flag called <I>yank_status</I> keeps track of the buffer (or file) status. <I>yank_status</I> is initialized to <I>NOT_VALID</I> and set to <I>EMPTY</I> (by <I>set_up</I>) or <I>VALID</I> (by <I>yank</I>). Several things can be done with the buffer. It can be inserted somewhere else in the file <I>(PT)</I> or it can be copied into another file <I>(WB)</I>.<P>
<h4><FONT COLOR="#000080"><A name="0104_0086">Search and Replace Routines<A name="0104_0086"></FONT></h4></P>
The string search and replace routines use regular expresions (see above). For any expression, the function <I>compile</I> is called with the expression as an argument. <I>compile</I> returns a pointer to a structure that looks like this:<P>
<pre>typedef struct regex {
   union {
      char * err_mess;
      int * expression;
   } result;
   char status;
   char * start_ptr;
   char * end_ptr;
} REGEX;</pre>
If something goes wrong during compiling (e.g. an invalid expression), the function <I>reg_error</I> is called, which sets the status field to <I>REG_ERROR</I> and the <I>err_mess</I> field to the error message. If the match must be anchored at the beginning of the line (or end of line), the status field is set to <I>BEGIN_LINE</I> (or <I>END_LINE</I>). If none of these special cases apply, the field is set to 0 and the function <I>finished</I> is called. <I>finished</I> allocates space to hold the compiled expression and copies this expression into the expression field of the union <I>(bcopy).</I> Matching is performed with the routines <I>match</I> and <I>line_check. Match</I> takes as argument the <I>REGEX</I> <I>*</I> program, a pointer to the start position on the current line, and a flag indicating forward or reverse search. <I>match</I> checks the whole file until a match is found. If match is found it returns a pointer to the line in which the match was found. Otherwise it returns a <I>NIL_LINE.</I> <I>Line_check</I> takes the same arguments, but return either <I>MATCH</I> or <I>NO_MATCH.</I><P>
During checking, the <I>start_ptr</I> and <I>end_ptr</I> fields of the <I>REGEX</I> structure are assigned to the start and end of the match. Both functions try to find a match by walking through the line character by character. For each possibility, the function <I>check_string</I> is called with the <I>REGEX *</I> program and the string as arguments. <I>check_string</I> starts walking through the expression until either the end of the expression or the end of the string is reached. Whenever <I>check_string</I> encounters a <I>*</I>, the position of the string is marked, the maximum number of matches are performed, and the function <I>star</I> is called to find the longest possible match. <I>star</I> takes as arguments the <I>REGEX</I> program, the current position of the string, the marked position, and the current position of the expression. <I>star</I> walks from the current position of the string back to the marked position, and calls <I>string_check</I> in order to find a match. (<I>star</I> returns <I>MATCH</I> or <I>NO_MATCH,</I> just as <I>string_check</I> does.)<P>
Searching is now easy. Both search routines (forward search <I>(SF)</I> and backward search <I>(SR))</I> call <I>search</I> with an appropriate message and a flag indicating forward or reverse search. <I>search</I> will get an expression from the user by calling <I>get_expression.</I> <I>get_expression</I> returns a pointer to a <I>REGEX</I> structure (or to <I>NIL_REG</I> if it encounters an error) and prompts for the expression. If no expression is given, the previous expression is used. After that, <I>search</I> will call <I>match,</I> and if a match is found, we can move to that place in the file by the functions <I>find_x</I> and <I>find_y</I>, which will find and display the match on the screen. Replacement can occur in either of two ways. A global replace <I>(GR)</I> or a line replace <I>(LR).</I> Both functions call <I>change</I> with a message and a flag indicating global or line replacement. <I>change</I> will prompt for the expression and for a replacement string. Every <I>&amp;</I> in the replacement string means "substitute the search string." (You can escape this special meaning of <I>&amp;</I> by preceding it with \. See "Regular Expressions," above.) When a match is found, the function <I>substitute</I> will perform the substitution.<P>
<h4><FONT COLOR="#000080"><A name="0104_0087">Miscellaneous Commands<A name="0104_0087"></FONT></h4></P>
Here are some other important commands: redraw the screen <I>(RD)</I>, fork a shell <I>(SH)</I>, print file status <I>(FS)</I>, write file to disc <I>(WT)</I>, insert a file at current position <I>(IF),</I> leave editor <I>(XT)</I>, and visit another file <I>(VI).</I> The last two functions will check if the file has been modified. If it has, they will ask if you want to save the file by calling <I>ask_save.</I><P>
The function <I>REPT</I> will repeat a command n times. It will prompt for the number. (You can abort the loop by sending the ^\ signal.)<P>
<h4><FONT COLOR="#000080"><A name="0104_0088">Utility Functions<A name="0104_0088"></FONT></h4></P>
MINED has several functions for internal use. The allocation routines <I>alloc(bytes)</I> and <I>newline</I> will return a pointer to free data space. If there is no more memory available, the function <I>panic</I> is called.<P>
The only signal that can be sent to MINED is the <I>SIGQUIT</I> signal. This signal functions as a general abort command. MINED will abort if the signal is given during the main loop. The function <I>abort_mined</I> causes MINED to abort.<P>
<I>panic</I> takes an error message as an argument. It will print the message and the error number set by the kernel <I>(errno),</I> then ask if the file must be saved. It resets the terminal (<I>raw_mode</I>) and exits.<P>
MINED string handling routines include <I>copy_string(to, from), length_of(string)</I>, and <I>build_string(buffer, format, arg1, arg2, ... ). build_string</I> takes a description of the string from the format field and puts the result in the buffer. The functions <I>status_line(string1, string2), error(string1, string2), clear_status</I>, and <I>bottom_line</I> all print information on the status line.<P>
<I>Get_string(message, buffer)</I> reads a string and <I>getchar</I> reads one character from the terminal.<P>
<I>Num_out((long) number</I>) prints the argument <I>number</I> into an 11-digit field without leading zeros. It returns a pointer to the resulting string. <I>File_status</I> prints all file information on the status line. <I>Set_cursor(x, y)</I> prints the string that will position the cursor at coordinates x and y.<P>
MINED has four output functions: <I>writeline(fd, string), clear_buffer, write_char(fd, c)</I>, and <I>flush_buffer(fd).</I> Normally MINED writes to file descriptor <I>STD_OUT</I> (the terminal). It provides three functions for this purpose: <I>string_print(string)</I>, <I>putchar(c)</I> and <I>flush.</I> All these functions use the global I/O buffer <I>screen</I> and the global index <I>out_count.</I> Thus, I/O is buffered, so that reads or writes can be done in blocks of <I>SCREEN_SIZE</I> size.<P>
The following functions handle internal line maintenance. The function <I>proceed(start_line, count).</I> returns the <I>count</I>th line after <I>start_line.</I> If <I>count</I> is negative, the <I>count</I>th line before the <I>start_line</I> is returned. If a header or tail is encountered then the header or tail will be returned. <I>Display(x, y, start_line</I>, <I>count)</I> displays count lines starting at coordinates (x, y) and beginning at <I>start_line.</I> If a header or tail is encountered, empty lines are displayed instead. The function <I>reset(head_line, ny)</I> resets <I>top_line</I>, <I>last_y</I>, <I>bot_line</I>, <I>cur_line</I>, and y-coordinate. This is not a neat way to do the line maintenance, but it saves a lot of code. It is usually used in combination with <I>display.</I><P>
<I>Put_line(line, offset, clear_line)</I>, prints a line (skipping characters according to the <I>line-&gt;shift_size</I> field) until <I>XBREAK - offset</I> characters are printed or a '\<I>n</I>' is encountered. If <I>clear_line</I> is <I>TRUE</I>, spaces are printed until <I>XBREAK - offset</I> characters. <I>Line_print(line)</I> is a <I>#define</I> from <I>put_line(line, 0, TRUE).</I> Moving is done with the functions <I>move_to(x, y)</I>, <I>move_addres(address)</I>, and <I>move(x, address, y).</I><P>
<h4><FONT COLOR="#000080"><A name="0104_0089">Platform Notes<A name="0104_0089"></FONT></h4></P>
To compile MINED on UNIX, try <I>make</I> with the makefile provided in the package. Depending on your system, you may have to change the screen handling method by selecting <I>SCREEN = -DSGTTY</I> instead of <I>SCREEN = -DTERMIO</I> in the makefile. If neither works, you should try the <I>curses</I> variant. This is the last choice for two reasons: <I>curses</I> screen output is clumsier than direct terminal control, and many UNIX curses implementations still obstruct the use of 8-bit character sets. (The <I>curses</I> option was built in for a quick port to VMS, where it is automatically selected.)<P>
On some systems, you may have to define the <I>sysV</I> variable (see makefile). Optimization can be turned on or off in makefile for generation/development.<P>
On VMS, just compile the source files and link them with an extra library using the script <I>linkmined.com.</I><P>
On MSDOS, you may have the files in their UNIX form (i.e. with <I>linefeed</I>-only newlines) so you will have to change the newlines of all text files (except <I>mined. hlp</I> which is already dedicated) to an MSDOS compatible form. You can temporarily use the enclosed executable, <I>mined.exe</I>, to edit the MINED source and makefiles prior to compiling a customized version. (In some cases, you may choose not to compile MINED at all and can simply use the executable as is.) Configuration files for Turbo C are included. The <I>COMPACT</I> memory model should be used to allow the largest possible file size.<P>
</BLOCKQUOTE>
</BODY>
</HTML>
