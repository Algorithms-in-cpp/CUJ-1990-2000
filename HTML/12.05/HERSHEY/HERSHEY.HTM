

<HTML>
<HEAD>

<TITLE>May 1994/Archimedes C-51 Hosted on an IBM-PC Compatible</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   User Reports</FONT></H2>

<hr><h2 align="center"><font color="#800000">Archimedes C-51 Hosted on an IBM-PC Compatible<A name="00F8_0073"><A name="00F8_0073"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="00F8_0000"><A name="00F8_0000">Comments by Charles Hershey</font></h3><hr><blockquote><P>
<P><i><A name="00F8_0000"><A name="00F8_0000">Charles Hershey received his Bachelor of Science degree in Electrical Engineering and Physics from the California Institute of Technology in Pasadena. He has been writing software professionally for over ten years in such areas as image and data analysis, embedded systems, and robotic control. He currently works as an independent software/electronics consultant. He can be reached at 13539 Wyandotte St., Van Nuys, CA 91405 or via the Internet at hershey@alumni.caltech.edu.</i></P><P>
A cross-compiler is a useful tool that allows embedded systems programs to be developed on a computer other than the target embedded system. The host computer typically provides facilities for software development (editors, hard-disk storage, etc.) unavailable on the target system. This article reports the experience of the author using the Archimedes C-51 8051 compiler hosted on an IBM-PC compatible computer.<P>
<h4><FONT COLOR="#000080"><A name="00F8_0074">Running the Compiler<A name="00F8_0074"></FONT></h4></P>
The 8051 C cross-compiler, known as C-51 version 4.23H, comes with a compiler, linker, assembler, and librarian. The compiler and linker require 1MB of extended memory. Because the linker and compiler are run from the command line, the user will probably wish to automate project management using a <I>make</I> utility, which the package does not include. I use Borland C++ for native DR-DOS programming, and the <I>make</I> utility included with that performs quite well. However one caution is in order: both Borland's standard <I>make</I> utility and the Archimedes compiler use extended memory, and they do not graciously cooperate in its use. Therefore, the programmer must use the real mode version of the Borland make utility, <I>maker. exe</I>.<P>
The linker requires that it be informed of every code and data segment used in the program. In meeting this requirement, the programmer can also specify where each segment is to be placed, and in what order. Because this information can occupy many lines, it is communicated to the linker through a linker control file, which also permits specifying other linker options. Sample linker control files are included with the C-51 compiler to get the user started. I had to make only minor modifications to one of these to get my program running on my target system.<P>
<h4><FONT COLOR="#000080"><A name="00F8_0075">Using the 8051's Features<A name="00F8_0075"></FONT></h4></P>
From here on, when I refer to the 8051 microcontroller, I will actually mean the 8051 family of microcontrollers. Produced by various manufacturers, these controllers all share a common general architecture, with variations in type and size of available memory and in their assortment of special registers.<P>
To let the user take advantage of these different memory features, C-51 permits the use of special data types and qualifiers. In particular, Archimedes introduces a special <I>sfr</I> data type to denote a byte-wide register within the Special Function Register (SFR) region of internal memory (see the sidebar, <a href="sidebar1.htm">"8051 Memory Organization"</a>). Because an <I>sfr</I> data type denotes a specific register, it has a fixed location that must be specified in its definition. An example of this is:<P>
<pre>sfr P0 = 0x80;</pre>
This statement tells the compiler that the identifier <I>P0</I> will be used to access the SFR at location <I>0x80</I> in internal memory. Archimedes Software supplies a header file which defines many standard 8051 SFRs. The user may also define new SFR variables that correspond to additional registers in a particular variant of the 8051.<P>
<h4><FONT COLOR="#000080"><A name="00F8_0076">Bit Addressing<A name="00F8_0076"></FONT></h4></P>
C-51 uses the keyword <I>bit</I> to denote a variable that can be stored in one of 256 single-bit locations. This keyword enables the programmer to use a tight, fast Boolean variable that will not hog precious internal data registers. General purpose bit variables are completely relocatable. The compiler specifies the storage needed, and the bits' locations are determined at link time. In addition, C-51 provides access to special-purpose bit variables that are mapped into sixteen of the special function registers. This is done with the following syntax:<P>
<pre>sfr_name. bit_number</pre>
For example:<P>
<pre>P0.5 = 0;</pre>
will clear bit <I>5</I> in special function register <I>P0</I> with a single instruction.<P>
<h4><FONT COLOR="#000080"><A name="00F8_0077">Specifying Memory Types<A name="00F8_0077"></FONT></h4></P>
C-51 also offers the choice of keywords or #pragmas to specify whether a particular variable should be placed in internal or external data memory or in the code segment. The freedom to choose the location of individual variables permits the user to optimize the resulting code.<P>
As well as letting the programmer specify the type of storage for individual variables, C-51 offers several memory models which determine the default form of storage for different types of data, including a model that supports banked code memory. The user specifies the desired memory on the compiler command line.<P>
<h4><FONT COLOR="#000080"><A name="00F8_0078">The Stack and Function Calls<A name="00F8_0078"></FONT></h4></P>
The 8051 instruction set is designed to use the internal register array as a stack. C-51 uses the stack to store intermediate results used by library routines and to save the contents of registers used by interrupt service routines. By default, C-51 also uses the stack to store the return addresses in function calls. These return addresses use three bytes per function call.<P>
In programs with heavily nested functions it is not difficult to run out of internal stack space. To avoid running out of space, C-51 permits the user to specify that all function call return addresses be stored in external memory. However, using this option often produces slower, larger code.<P>
Normally, C compilers will also store function local variables on the stack. In large programs this practice also can easily consume the limited internal stack space. The 8051 has no built-in facilities for a stack located in external data RAM, so while a compiler could implement such a stack, doing so would result in code that was unnecessarily large and slow. To avoid these problems, Archimedes decided to allocate fixed memory locations for local variables. This technique is similar in effect to declaring all local variables to be of storage class <I>static</I>, except that the Archimedes linker performs an additional optimization. The linker builds the entire function call tree and determines what functions can and cannot be active at the same time. Rather than wasting valuable memory space, the linker may map local variables that cannot be active at the same time into the same memory locations. This process can produce code that is actually tighter on RAM usage than the equivalent hand-optimized assembly is likely to be. (Few people will actually lay out the entire function tree of a complex assembly program and determine down to the last byte which variables can be overlaid in the same memory locations. At least, not unless they have to.)<P>
This optimization does, however, create problems for two features common in C programs, recursion and reentrancy. Recursion is the process of a function calling itself, directly or indirectly. In a recursive call, two or more copies of the function's local variables will be active at the same time. If these copies are located in the same memory locations, corruption of data values will likely occur. The Archimedes linker solves this problem by detecting recursive function calls and implementing a stack just for the local variables of those functions. Again, this results in bigger, slower code, but the alternative is to implement an external stack for all functions. Archimedes lets the user pay for the overhead of this general purpose stack only when and where it is needed.<P>
A similar problem arises with reentrancy. An example of a reentrant function call ocurs when an interrupt service routine (ISR) calls a function which is itself currently executing. Thus, after this function has been called (entered) the first time, and before it returns, the function is called again (reentered) in service of an interrupt. As with recursion, if the function's local variables have the same locations for separate function invocations, data corruption will likely occur. Archimedes C-51 currently does not support reentrant functions. [Archimedes informs us that they plan to release C-51 version 5.0 in the second quarter of this year. Version 5.0 will support reentrancy and will allow declaration of functions with a new <I>reentrant</I> keyword. &#151; mb] As a result, an ISR should not call a function that <I>could</I> be executing when that ISR's interrupt occurs. For that matter, it's a good idea to avoid calling any function from within an ISR, if that function is also called by non-ISR code.<P>
<h4><FONT COLOR="#000080"><A name="00F8_0079">Interrupt Service<A name="00F8_0079"></FONT></h4></P>
When an interrupt occurs in the 8051, the 8051 transfers control to the code located at an address retrieved from the interrupt vector table (IVT). Each interrupt source will cause the processor to look for its ISR address at different locations in the IVT. The IVT is located in code memory starting at memory location <I>0x0003</I>.<P>
Other than writing the ISR code, using an ISR requires two steps: placing the address of the routine in the IVT, and making provisions for saving and restoring registers used by the routine. To enable writing and using an ISR, C-51 provides the keyword <I>interrupt</I>, used to declare a routine that services an interrupt. When this keyword is used, the compiler will place the routine's address in the designated IVT location, and cause any registers used by the routine to be automatically saved on entry and restored on exit. In addition, inclusion of the optional keyword <I>using</I> causes the program to switch to one of four register banks (0-3) internal to the 8051 upon entry to the ISR. Switching register banks obviates the need to save and restore any banked registers used by the ISR. Here's a sample ISR definition that includes the keyword <I>using</I>:<P>
<pre>interrupt [0x0B] using
        [1] void my_isr(void)
{
    /* Service interrupt using register bank 1 */
}</pre>
The function in this example will be called whenever the Timer 0 interrupt (to be explained later) occurs. The Timer 0 interrupt causes the 8051 to vector to address 0x0B in the interrupt vector table.<P>
<h4><FONT COLOR="#000080"><A name="00F8_007A">Limitations and Workarounds<A name="00F8_007A"></FONT></h4></P>
Archimedes C-51 does have some limitations that can be frustrating. For one thing, C-51 delays until run time some calculations that could be performed at compile time. For example, the following code simply stores the high-order byte of an integer in one-byte sized variable, and the low-order byte in another:<P>
<pre>int x;
char lo,hi;

/* MSB is stored in lower memory */
hi = ((char*)(&amp;x))[0];
lo = ((char*)(&amp;x))[1];</pre>
Ideally, this syntax would simply result in the code necessary to move a single byte from one location to another. (The fancy pointer and array notation simply tells the compiler which byte to access.) Unfortunately, even though the source address is completely specified at compile/link time, the compiler determines this address at run time and calls a run-time library function to do the job.<P>
Fortunately, an equivalent construct yields the desired result. Writing<P>
<pre>*( ((char*)(&amp;x)) + 1)</pre>
in place of<P>
<pre>((char*)(&amp;x))[1]</pre>
makes the compiler perform the address calculation at compile time and create the code expected.<P>
Another limitation, as mentioned previously, is C-51's lack of support for reentrant functions. This limitation effectively discourages programmers from calling <I>any</I> function in an ISR if that function appears elsewhere in the program, even if careful analysis might reveal that the function was not in danger of being interrupted (and who wants to do that kind of analysis?) Another alternative is to implement a pseudo-stack for reentrant functions' local variables, and to suffer the penalty of slow, klunky code. Whatever you choose to do, at least the Archimedes linker is kind enough to warn you of any functions which are called in two separate function trees (such as from main and your ISR) so that you don't have to worry about finding all possible conflicts yourself.<P>
A third limitation that has caused me a lot of frustration is that C-51 limits macros to 256 bytes in length. Sometimes when writing repetitive code that must run quickly (such as within an ISR that performs the same operations on several sets of similar variables), I would like to write the code only once, without incurring the overhead of a function call. A macro is the natural choice &#151; unless it runs over 256 characters long. You can get around this length limitation by running the macro and the calls to it through a C preprocessor. One such preprocessor comes with Borland C++, <I>CPP.EXE.</I> This technique does the job, but you still must break up the resulting C source code into individual lines, because C-51 also has a line length limit of 256 characters.<P>
<h4><FONT COLOR="#000080"><A name="00F8_007B">A Simple Program<A name="00F8_007B"></FONT></h4></P>
<A href="list1.htm">Listing 1</a>
contains a simple program which illustrates some of the features of the C-51 compiler (<A href="list2.htm">Listing 2</a>
shows a link control file, and <A href="list3.htm">Listing 3</a>
is a makefile). This program does three important things: It performs basic serial I/O, it demonstrates the use of an ISR under timer control, and it demonstrates the use of a dedicated bit variable in an SFR to toggle one of the microcontroller's external pins.<P>
I chose to implement these features because they represent the first hurdles to writing software for an 8051 in an embedded system. If the programmer does not have a simulator or emulator, embedded systems programming presents a unique challenge in that the programmer cannot simply use <I>printfs</I> to figure out what the program is doing. Thus, it is extremely helpful to have an alternative system for telling the outside world what is going on inside the microcontroller. Two methods for communicating such information are presented here: working character I/O, and changing the state of an output pin which can be monitored with a test instrument such as an oscilloscope. Toggling an output pin also provides timing information. If you note the time between state transitions on the pin, you can empirically determine how long the ISR takes to execute. (This is particularly useful if you want to verify that the ISR is not using too much time.)<P>
<h4><FONT COLOR="#000080"><A name="00F8_007C">Timer Control<A name="00F8_007C"></FONT></h4></P>
The 8051 has two built-in timers, Timer 0 and Timer 1. Timer 1 doubles as a baud-rate generator and is used as such in the example program. Timer 0 can operate in any one of four programmable modes. This program uses Mode 1, which causes Timer 0 to take a 16-bit value loaded into SFRs TL0 and TH0. Timer 0's counter will count up at 1/12 the frequency of the 8051's clock oscillator. When the counter reaches <I>0xffff</I>, the next count rolls the counter over to <I>0x0000</I> and generates an interrupt when Timer 0 interrupts are enabled. The counter will continue to count up from zero unless new values are loaded into TL0 and TH0.<P>
The values I chose for this example assume a system clock rate of 15Mhz. This combination produces an interrupt from Timer 0 once every millisecond (approximately), and a baud rate of 9600 from Timer 2. The 8051 does not reload Timer 0's count value automatically so the program must load it explicitly. The program does not compensate for the time that it takes to respond to the interrupt and reload the counter.<P>
<h4><FONT COLOR="#000080"><A name="00F8_007D">A Walk Through the Source Code<A name="00F8_007D"></FONT></h4></P>
At the top of <A href="list1.htm">Listing 1</a>,
 you will find the line<P>
<pre>#pragma language=extended</pre>
This line tells the ANSI C compiler that it can now accept non-ANSI extensions such as the <I>interrupt, data</I>, and <I>bit</I> keywords. The first variable definition,<P>
<pre>data int millisecond_counter;</pre>
defines an integer in internal RAM. The ISR increments this variable, so I assigned it to internal RAM for speed considerations. The bit <I>first_time</I> is the only other variable defined in this program. (I use <I>first_time</I> to overcome a quirk of the serial port electronics.) All other variables are actually registers defined in the header file <I>I051.h</I> included with the compiler. <I>TR0, TR1, RI, TI, ET0</I>, and <I>EA</I> are SFR bits which have special meanings. For example, setting <I>EA</I> to 1 or 0 enables or disables interrupts on the processor. <I>TH0, TL0, SBUF, TH1, TMOD</I>, and <I>SCON</I> are byte-wide SFRs.<P>
The body of the ISR does three things: it toggles bit 7 of I/O port P1 on and off, reloads the count value in Timer 0, and increments <I>millisecond_counter</I>. This last variable is not used for anything, but could be used in a program for timing information.<P>
The next two functions read and write characters from the serial port buffer <I>SBUF</I>. The function <I>setup</I> sets up the two internal timers, enables them and enables the Timer 0 interrupt which will call the ISR. <I>main</I> calls <I>setup</I> and enters an infinite loop which will continuously echo characters received over the serial port.<P>
<h4><FONT COLOR="#000080"><A name="00F8_007E">Conclusion<A name="00F8_007E"></FONT></h4></P>
The 8051 microcontroller and its variants have some unique features, including an interesting memory organization. One natural concern for someone familiar with the 8051 architecture is that using a high-level language will prevent the user from taking advantage of these features and will instead produce code that can use only those properties found in a genetic microprocessor model. This is not the case with Archimedes C-51. The compiler itself makes efficient use of the memory organization, and in addition makes other special features available through high-level constructs. Thus it is possible to write tight code tailored to the 8051 without resorting to assembly language, and after all, that's what C is all about.<P>
<h4>Product Information</FONT></h4></P>
Products mentioned in this article:<P>
Archimedes' C-8051 for DOS (version 4.23H)<br>
Archimedes Software, Inc.<br>
2159 Union Street<br>
San Francisco, CA 94123<br>
(415) 567-4010<P>
Borland C++ (version 3.0)<br>
Borland International, Inc.<br>
1800 Green Hills Road<br>
P.O. Box 660001<br>
Scotts Valley, CA 95067-0001<P>

<h4><a href="../../../source/1994/may94/hershey.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
