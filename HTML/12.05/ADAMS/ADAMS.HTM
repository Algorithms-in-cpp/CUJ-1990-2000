

<HTML>
<HEAD>

<TITLE>May 1994/Temporary Object Management through Dual Classes</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocmay.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Object-Oriented Programming</FONT></H2>

<hr><h2 align="center"><font color="#800000">Temporary Object Management through Dual Classes<A name="00E5_006D"><A name="00E5_006D"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="00E5_0000"><A name="00E5_0000">Robert M. Adams</font></h3><hr><blockquote><P>
<P><i><A name="00E5_0000"><A name="00E5_0000">Robert M. Adams is an independent consultant specializing in defense applications. He lives in Dallas, Texas, and can be reached on CompuServe at 71214,1553 or on Internet at robert.adams@chrysalis.org.</i></P><P>
<h4><FONT COLOR="#000080"><A name="00E5_006E">Introduction<A name="00E5_006E"></FONT></h4></P>
A problem that frequently occurs in C++ is excessive copying of objects as they are passed around within a program. For example, consider a typical vector class. Whenever a vector object appears on both sides of an equal sign, the program copies the vector from the source object to the destination. When a function returns an object in an assignment statement, there are two copy operations. The second copy operation occurs because C++ creates an intermediate, temporary object as functions and overloaded operators pass complicated objects from source to destination. The C++ program first copies the source object to the temporary object, then copies the temporary object to the destination.<P>
It's unfortunate that operations like the preceding carry such a performance penalty. The vector class exemplifies a group of objects that are potentially quite useful, and seemingly made for overloaded operators and all the other formal goodies that C++ provides. C++ seems especially appropriate for a vector or matrix class since it allows the outward form of vector and matrix expressions to follow the standard notation adopted many years ago in mathematical circles, or at least to approximate it, as FORTRAN does for scalar arithmetic operations.<P>
So, I have looked for ways to provide general vector and matrix capability without invoking the inefficiencies of C++ copy operations. Here is what I would like to find in a vector and matrix class library:<P>
1.     Linear algebraic formula conversions<P>
2.     Minimization of unnecessary copy operations and other overhead<P>
3.     No requirement of programmer awareness of deeper structures in library classes (e.g. multiple access, reference counters, etc.)<P>
In this article, I present a technique for passing complicated objects using efficient copy constructors, through the use of dual classes. Other techniques will accomplish the same results, though they have certain disadvantages. Therefore, I briefly describe these techniques as well. I begin by describing the way C++ normally handles complicated objects in function returns and overloaded operators. I then show some feasible alternatives and, finally, I present my temporary object management technique.<P>
<h4><FONT COLOR="#000080"><A name="00E5_006F">How C++ Returns Complicated Objects<A name="00E5_006F"></FONT></h4></P>
Consider <A href="list1.htm">Listing 1</a>,
 defining the <I>Vector</I> function <I>unit</I>, which receives a reference to a <I>Vector v</I>. After construction of the return parameter, the meat of the function follows. To find a unit vector in the same direction as <I>v, unit</I> divides each element of <I>v</I> by the length of <I>v</I>:<P>
<IMG SRC="equat1.gif"><P>
where <I>v</I><I>i</I> are the components of <I>v</I>. It is very easy to evaluate this function using <I>for</I> loops and the overloaded <I>()</I> operator to access the elements of <I>u</I> and <I>v</I>.<P>
<I>unit</I> then returns the resulting vector <I>u</I>. At this point, things begin to get a little complicated. <I>u</I> is local to the function; therefore, it must be gone when the function ceases to execute. But <I>u</I> contains the result needed by the calling program. To pass <I>u</I> to <I>unit</I>'s caller, C++ creates an object, unnamed and invisible, within the scope of the calling program to receive the return parameter of the function. C++ uses the return object class's copy constructor to create this invisible object, with <I>Vector u</I> as the source of the copy. Then the <I>u</I> is destroyed, along with everything else that was local to the function <I>unit</I>, and control makes its way back to the caller. All of these operations are in accordance with the current standard <a href="#1">[1]</a>.<P>
The calling program may use the function value to perform an assignment or to fill new storage allocated for a vector definition, as in the statement<P>
<pre>Vector x = unit(y);</pre>
In either case, C++ again invokes the copy constructor to copy the invisible <I>Vector</I> object to the destination. The program never uses the invisible <I>Vector</I> object again and this object is ultimately destroyed. The process I have just described accounts for the two copy operations that occur when C++ returns complicated objects from functions.<P>
If these copy operations involved only a few bytes, the issue would be trivial, merely some more exercise for the fast copy routine. But a vector can have any (reasonable) length, so the copy operations can eat up processor power in a hurry if the vectors are big.<P>
<h4><FONT COLOR="#000080"><A name="00E5_0070">Alternative Vector Designs<A name="00E5_0070"></FONT></h4></P>
One way to prevent excessive copying is to avoid <I>Vector</I> function returns entirely by providing the object to be returned in the parameter list, as in:<P>
<pre>void unit (const Vector&amp; v, Vector&amp; u);</pre>
I would call this the retrograde approach, why use C++ to write this kind of statement? The resulting code has lost its formula-like appearance. Moreover, this form doesn't allow the use of overloaded operators.<P>
Another approach to the problem, reference counting, is illustrated by a commercially available linear systems package which I will call Q&amp; (not its real name).<P>
The Q&amp; package defines a variety of vector and matrix classes, having in common that their constructors allocate the Vector Element Space (or VES, the space that holds the vector or matrix data) and their destructors deallocate the VES. Q&amp; does not copy the VES in these classes' copy constructors or in the assignment operators. Instead, Q&amp; writes the pointer to the source VES into the new <I>Vector</I> and maintains a count of references with the VES itself (which therefore has a structure of its own). Thus, several <I>Vectors</I> can exist simultaneously, all pointing to one VES and, by definition, all having the same value. When a Vector is constructed requiring a new VES, Q&amp; allocates the VES and sets the reference count to one. Any time another <I>Vector</I> is constructed that points to an existing VES, the constructor increments the count of references. When a Vector is destroyed, the destructor decrements the count of references, and if the count is zero, Q&amp; releases the VES. <A href="list2.htm">Listing 2</a>
illustrates the general idea. (This listing only outlines the technique &#151; it does not represent actual code from the Q&amp; library, which I consider to be very refined and safe.)<P>
Reference counting reduces unnecessary copy operations, but imposes its own difficulties. One difficulty is that when a <I>Vector</I> component changes in one instance, the <I>Vector</I>'s value changes for all instances that reference the same VES. Multiple references to a common VES do not often create a problem, but to stay out of trouble the programmer must be aware of the common VES and must have access to a "deep-copy" function that can create a <I>Vector</I> copy with a unique VES when required.<P>
The reference counting mechanism also entails overhead for additional pointer fetches, required for every initial access to the VES.<P>
One writer <a href="#2">[2]</a> proposes that the language designers should be: eliminate copy constructor invocation on function return by allocating memory for the function's <I>return</I> parameter within the scope of the calling program. This plan provides the advantage of invisibility (what most people call transparency), but is complicated by the possibility of multiple, different <I>return</I> statements. I wouldn't be surprised if this method introduced other nasty complications, but whatever its implications, it's not available as a C++ feature today.<P>
<h4><FONT COLOR="#000080"><A name="00E5_0071">A New Way<A name="00E5_0071"></FONT></h4></P>
I have developed an object-passing technique that uses efficient copy constructors. While I can't prevent invocation of the copy constructor upon return from a function, I can modify this constructor so that instead of <I>copying</I> the contents of the source object's VES to the temporary invisible object, the constructor passes the temporary object a pointer to the source object's VES. A second crucial step in my technique is to set the source object's VES pointer to null, thereby preventing the source object's destructor from releasing the VES's memory upon function return. I call this two-step process "seizing the VES."<P>
Seizing the VES is similar to reference counting in that no copying of <I>Vector</I> components takes place, but it's different because it maintains no explicit data field indicating when the VES may be destroyed. Eliminating the reference count scheme simplifies the copy constructor and the <I>Vector</I> class, but the class design is not complete because I've yet to solve another nagging problem: a function return is not the only action that will invoke the copy constructor. It would be inappropriate for the copy constructor to seize the VES in the following statement, where <I>t</I> is a previously defined <I>Vector</I>:<P>
<pre>Vector x = t;</pre>
I need some indication of when it is appropriate for the destination object to seize the VES from the source object. I could provide a flag as member data for the <I>Vector</I> class, which would indicate whether or not the VES could be seized. Besides its inelegance, this plan introduces two difficulties, that of setting and testing the flag. A better method for managing the seizure of the VES makes use of knowledge built-in to the structure of the program.<P>
<h4><FONT COLOR="#000080"><A name="00E5_0072">Dual Classes<A name="00E5_0072"></FONT></h4></P>
To communicate the seizability of the VES, I've invented a second class of <I>Vectors</I> called <I>TempVector,</I> having the property that their VES can be seized in the copy construction and the assignment operation. The <I>TempVector</I> object has exactly the same member data and many of the same constructors and other member functions as the <I>Vector</I> object, but has a limited lifetime, appearing only in certain contexts. <I>TempVector's</I> sole purpose is to be the type for the return objects in <I>Vector</I> functions and overloaded operators.<P>
Consider <A href="list3.htm">Listing 3</a>.
 The first class defined is the <I>Vector</I> class with dynamic VES and suitable operators and friend functions. The second class given is <I>TempVector</I>. While it contains many of the same member data and functions, it differs in certain details from the <I>Vector</I> class. In particular, the <I>TempVector</I> copy constructor simply transfers the pointer to the VES from the source <I>TempVector</I> to the destination <I>TempVector,</I> replacing the pointer value in the source <I>TempVector</I> with a null. (This is what is meant by "seizing" the VES.) Now, note that in both class definitions the Vector addition <I>operator +</I> returns a <I>TempVector.</I> In a <I>Vector</I> addition, the compiler first invokes the <I>TempVector</I> copy constructor to seize the VES as it is returned from the addition operator. In an assignment operation involving a function return, the compiler invokes the form of assignment that seizes the VES from the <I>TempVector</I> and gives it to the object on the left side of the equal sign. In effect, those occasions of temporary object use are identified by the assignment of a different type to temporary objects.<P>
<h4><FONT COLOR="#000080"><A name="00E5_0073">An Example<A name="00E5_0073"></FONT></h4></P>
Consider the following example, involving the sum of two existing <I>Vectors</I> with the result to be placed in a third:<P>
<pre>t = u + v;</pre>
The compiler can recognize that the right side is a temporary result, that is, that the right side result is a <I>TempVector</I>. Invoking the correct overloaded assignment operator causes the entire command to be carried out with no unnecessary copy operations. The order of operations are as follows (see <A href="fig1.htm">Figure 1</a>)
:<P>
1.     Upon invocation of the <I>+</I> operation, <I>operator+</I> compares the lengths of the vectors for equality (an error is returned for non-conformal addition).<P>
2.     <I>operator+</I> constructs a <I>TempVector</I> with VES of the appropriate size.<P>
3.     <I>operator+</I> performs <I>Vector</I> addition and stores the result in the <I>TempVector</I> <I>VES</I>.<P>
4.     <I>operator+</I> returns the <I>TempVector</I>.<P>
5.     The <I>TempVector</I> copy constructor is invoked to construct an unnamed, invisible <I>TempVector</I> in the calling program scope.<P>
6.     The <I>TempVector</I> copy constructor seizes the VES from the <I>operator+</I> return parameter <I>TempVector</I>, by placing a pointer to the VES in the <I>TempVector</I> being constructed, and setting the VES reference in the return parameter <I>TempVector</I> to NULL so that the VES will not be released.<P>
7.     The return <I>TempVector</I> in the <I>operator+</I> scope is destroyed along with all the other local variables; the destructor finds no VES to release.<P>
8.     Control returns to the calling program.<P>
9.     The Vector assignment operator is invoked for Vector <I>t</I> with the invisible <I>TempVector</I> as a parameter, also releasing the VES currently owned by <I>t</I>, if any.<P>
10.     The assignment operator seizes the VES from the invisible <I>TempVector</I> by placing a pointer to it in the Vector <I>t</I>, and setting the VES reference in the <I>TempVector</I> to null so that the VES will not be released.<P>
11.     Control is returned to the calling program; the invisible <I>TempVector</I> is destructed; the invisible <I>TempVector'</I>s destructor finds no VES to release.<P>
12.     The next instruction is executed.<P>
My scheme imitates the above scenario in all possible <I>Vector</I> expressions. Note that <I>TempVector</I> is the only class that can have its VES seized. The copy constructor for <I>Vector</I> always allocates a new VES and copies the source VES to it. Also, in forming the classes this way, I have accounted for the difference in processing required for<P>
<pre>Vector t = u + v;</pre>
and<P>
<pre>Vector t = u;</pre>
In the former, the Vector <I>t</I> receives the VES from the <I>TempVector</I> produced by the Vector addition operator. In the latter, the Vector <I>t</I> receives a new VES copied from the VES that belongs to and remains with the Vector <I>u</I>.<P>
<h4><FONT COLOR="#000080"><A name="00E5_0074">Dual Class Performance<A name="00E5_0074"></FONT></h4></P>
In an informal comparison of the methods outlined in <A href="list2.htm">Listing 2</a>
and <A href="list3.htm">Listing 3</a>,
 I repeatedly summed (100,000 repititions) a set of vectors 12 <I>doubles</I> in length with the result unitized:<P>
<pre>c = unit (a + b);</pre>
I used Borland C++ 3.1 on a 33 MHz 486. The results in seconds were:<P>
<pre>Dynamic VES with reference counting     22.14
Dynamic VES with dual classes           17.67</pre>
The dual class method held a 25% time advantage over the reference counting method. While this informal benchmark is hardly an exhaustive test of the idea, it strongly suggests that I'm on the right track.<P>
<h4><FONT COLOR="#000080"><A name="00E5_0075">Drawbacks and Restrictions<A name="00E5_0075"></FONT></h4></P>
There are certain inherent drawbacks to the system proposed here. For one thing, the number of operator functions proliferates by a factor of approximately four, because I must allow for the possibility in a binary operator that one, the other, both, or neither of the operands may be a <I>TempVector</I>. This proliferation does not pose a problem except in increase of the library debugging effort and in bulkier libraries. Also note that the constructors for <I>TempVector</I> are private, so the user cannot take advantage of the dual class scheme, without making those functions <I>friends</I> (at least) of the <I>Vector</I> and <I>TempVector</I> classes, and thus requiring their obedience to the interior rules of the library.<P>
One interior rule stipulates that when a <I>TempVector</I> is defined in the function to serve as a return parameter, the <I>TempVector</I> must never be used in such a way that it loses its VES. That is, a <I>TempVector</I> must never stand alone on the right-hand side of an <I>operator</I> = (assignment). Also, a <I>TempVector</I> should never be used in a global or <I>static</I> definition. Other than that, the <I>TempVector</I> and <I>Vector</I> structures may be used freely. If the programmer feels comfortable enough with these restrictions, he can make the <I>TempVector</I> constructors public and use them throughout his code as function return parameters.<P>
<h4><FONT COLOR="#000080"><A name="00E5_0076">Conclusion<A name="00E5_0076"></FONT></h4></P>
The dual class of temporary objects have the special property that the VES they may own can be seized by a successor operation, such as copy construction following function return or the assignment operation. This feature is designed to reduce the overhead of unnecessary copy operations. In concert with other measures to reduce the cost of computation, the dual <I>Vector</I> classes can be made the basis for a complete library of vector and matrix functions and operators having very low operating cost. Moreover, the principles exemplified by the <I>TempVector</I> and <I>Vector</I> classes can be extended to the <I>Matrix</I> class, the <I>String</I> class, and any other class containing a large, variable-length data structure of reasonable homogeneity.<P>
<a name="1"></a>1.     1.Ellis, M., Stroustrup, B., <I>The Annotated C</I>++<I> Reference Manual</I>, Addison-Wesley, Reading Ma, 1990, pp. 300-303.<P>
<a name="2"></a>2.     2.Wilkinson, Nancy M., "C++ Return Value Optimization," <I>C</I>++ <I>Journal</I>, vol. 2, no. 1, 1992, pp. 47-51.<P>

<h4><a href="../../../source/1994/may94/adams.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
