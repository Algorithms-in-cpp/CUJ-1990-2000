<HTML>   
     <HEAD>
<TITLE>October 2000/An Improved Variant Type Based on Member Templates</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tococt.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Objects and Components</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">An Improved Variant Type Based on Member Templates</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Fernando Cacciola</FONT></H3>

<BLOCKQUOTE>
<p>C has generic pointers and varying length argument lists for flexibility. C++ has templates for even more flexibility, and better type safety in the bargain.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<p>This article presents class <B>variant_t</B>, which encapsulates a mechanism to hold values of arbitrary types. If the types used to initialize <B>variant_t</B> variables have full copy semantics, this <B>variant_t</B> can be stored in an array, returned from a function, and contained in any standard collection. As an example use of the <B>variant_t</B>, I present a class <B>ArgumentList</B>. It is a container adaptor to a <B>vector&lt;variant_t&gt;</B> that provides an interface akin to a list of arguments to a function.</p>

<H4><FONT COLOR="#000080">Developing a variant_t</FONT></H4>

<p>A preliminary definition for <B>variant_t</B> could be the following <B>struct</B>:</p>

<pre>
struct variant_t
{  
   variant_t (const void * value)
   : data ( value ) {}
   const void* data;
};
</pre>

</p>It would be used as follows:</p>

<pre>
variant_t array [2];
int n0 = 3;
double f0 = 3.14;
array[0] = variant_t((const void*)&amp;n);
array[1] = variant_t((const void*)&amp;f);
int n1 = *(const int*)(array[0].data);
double f1 = 
   *(const double*)(array[1].data);
</pre>

<p>One of the problems with this design is that it forces the user to explicitly cast to and from the <B>variant_t</B> object. A recent addition to the language, member templates, permits a more flexible design.</p>

<H4><FONT COLOR="#000080">Version 0</FONT></H4>

<p><a href="list1.htm">Listing 1</a> shows the definition of <B>variant0_t</B>. The constructor for <B>variant0_t</B> is a member template function:</p>

<pre>
template&lt;typename T&gt;
variant0_t(const T&amp; v){...}
</pre>

<p>A member template function is a member function that is instantiated (generated by the compiler) for a particular type when a call using this type is first seen by the translator. In the case of <B>variant0_t</B>, the compiler will generate a constructor according to the particular type of the argument. For example, the expression <B>variant0_t(3)</B> will generate a constructor that takes a <B>const int &amp;</B> as an argument and produce a call to that constructor. Similarly, <B>variant0_t</B> has a generic conversion operator:</p>

<pre>
template&lt;typename T&gt;
operator T () const {...}
</pre>

<p>The compiler will try to generate code to convert from <B>variant0_t</B> to any type by instantiating this conversion operator for the particular return type. For example, the expression <B>int n = variant0_t(3)</B> will call an <B>operator int</B> (instantiated by the compiler) to provide an <B>int</B> that can be used to initialize <B>n</B>.</p>
<p>The following snippet shows how <B>variant0_t</B> can be used.</p>

<pre>
variant0_t array [2];
int n0 = 3;
double f0 = 3.14;
array[0] = n0;
array[1] = f0;
int n1 = array[0];
double f1 = array[1];
</pre>

<p>The conversion code uses <B>reinterpret_cast&lt;&gt;</B> to cast back the void pointer. I will add type checking to this cast later.</p>
<p>A problem with <B>variant0_t</B> is that it holds a pointer to the original value. If the original value goes out of scope, then <B>variant0_t</B> points to an invalid object. The solution is to hold a copy of the original value.</p>

<H4><FONT COLOR="#000080">Version 1</FONT></H4>

<p><a href="list2.htm">Listing 2</a> shows <B>variant1_t</B>. It maintains a copy of the value it is initialized with in a separate memory block. Using <B>variant1_t</B>, the following operations are valid:</p>

<pre>
int* a0 = new int(3);
variant1_t v ( *a0 );
delete a0;
int a1 = v;  // a1 = 3
</pre>

<p>A problem with this new version is that it assumes that <B>T</B> can be safely copied as a bitwise copy operation.</p>

<H4><FONT COLOR="#000080">Version 2</FONT></H4>

<p><a href="list3.htm">Listing 3</a> shows <B>variant2_t</B>. It is a considerable improvement over the last variant, so I'll explain it step by step.</p>
<p>Consider the following template:</p>

<pre>
template&lt;typename T&gt;
struct Impl
{
   Impl (T v) : data (v) {}
   T data;
};
</pre>

<p>This template can be used to safely obtain and store a copy of a given variable of an arbitrary type. Since it uses the type's copy constructor, the copy is guaranteed to be appropriate, as long as the copy constructor is properly defined. The next snippet extends <B>Impl&lt;&gt;</B> in a way that makes it particularly useful for our purposes:</p>

<pre>
struct ImplBase
{
   virtual ~ImplBase() {}
};
   
template&lt;typename T&gt;
struct Impl : ImplBase
{
   Impl (T v) : data (v) {}
   T data;
};
</pre>

<p>The big difference here is that <B>Impl&lt;T&gt;</B> is a class derived from <B>ImplBase</B>, which has a virtual destructor. Any instance of <B>Impl&lt;T&gt;</B> is a polymorphic type; that is, a pointer to an object of this type can be converted to a pointer to the base type, and vice versa. For instance, given a pointer to <B>ImplBase</B>, it is possible to safely cast it to <B>Impl&lt;T&gt;</B> using <B>dynamic_cast&lt;&gt;</B>. It is possible to cast a pointer to <B>Impl&lt;T&gt;</B> back to <B>ImplBase</B> using an implicit cast, since this is an upcast. This inheritance relationship enables arbitrary types to be stored in arrays and containers (via pointers), in a way that complements the <B>variant_t</B>.</p>
<p>Consider the following example:</p>

<pre>
ImplBase* array[2];
array[0] = new Impl&lt;int&gt;(3);
array[1] = new Impl&lt;double&gt;(3.14);
int n1 = (dynamic_cast&lt;Impl&lt;int&gt;*&gt;(array[0]))-&gt;data;
double f1 = (dynamic_cast&lt;Impl&lt;double&gt;*&gt;(array[1]))-&gt;data;
delete array[0];
delete array[1];
</pre>

<p>The above code implements an array of polymorphic types that holds values of types <B>int</B> and <B>double</B>. The expression</p>

<pre>
new Impl&lt;int&gt;(n0)
</pre>

<p>generates the type <B>Impl&lt;int&gt;</B> with the following important properties:</p>
<p>1)  It contains a data member of type <B>int</B>.</p>
<p>2)  This data member has been safely initialized as a copy of the <B>int</B> variable <B>n0</B>. Both the data member and the original variable are exactly of the same type so this initialization is type safe.</p>
<p>3)  It is polymorphic, which means that it can safely be converted to and from <B>BaseImpl *</B>.</p>
<p>4)  <B>BaseImpl</B> has a virtual destructor, so an <B>Impl&lt;int&gt; *</B> can be safely deleted from a <B>BaseImpl *</B>.</p>
<p>5)  This type is uniquely bound to the type <B>int</B>. Different instances of <B>Impl&lt;&gt;</B> instantiated for different types will have similar properties, which will guarantee type-safe and copy-safe operations while maintaining polymorphic behavior.</p>
<p>The expression:</p>

<pre>
int n1 = (dynamic_cast&lt;Impl&lt;int&gt;*&gt;(array[0]))-&gt;data
</pre>

<p>is type-safe because the dynamic cast will fail if <B>array[0]</B> is not an instance of <B>Impl&lt;int&gt; *</B>. Therefore, if the dynamic cast succeeds, <B>-&gt;data</B> is guaranteed to be of type <B>int</B>. Furthermore, because <B>Impl&lt;&gt;</B> is a polymorphic type, this dynamic cast is guaranteed to succeed when the result type matches the type of the <B>n1</B>.</p>
<p><B>variant2_t</B> (<a href="list3.htm">Listing 3</a>) is the combination of <B>variant1_t</B> and <B>Impl&lt;&gt;</B>. An additional method in <B>variant_t</B> encapsulates the casting operation shown above; <B>CastFromBase</B> enforces type checking by throwing an exception if the dynamic cast fails.</p>

<H4><FONT COLOR="#000080">Dealing with Shared Representation</FONT></H4>

<p>Since <B>variant2_t</B> holds a pointer to a value in a separate object, it creates a new problem.</p>
<p>Consider the following code:</p>

<pre>
variant_t foo() {return 3;}
</pre>

<p>The return statement is functionally equivalent to:</p>

<pre>
variant_t result ;
int _unnamed_int(3);
variant_t _unnamed_var_t(_unnamed_int); // temporary
result = _unamed_var_t;
</pre>

<p>As you can see, a temporary <B>variant_t</B> object is constructed and copied into the <B>result</B> object (which is constructed on the caller side and passed as a hidden parameter so the return statement can assign to it). This temporary holds a pointer to an instance of <B>Impl&lt;int&gt;</B> through its <B>ImplBase</B> pointer. This same instance is stored in <B>result</B>. But, when the temporary goes out of scope, this instance is deleted and <B>result</B> holds a pointer to an invalid object.</p>
<p>There are three basic solutions to this problem: "copy on copy," unique ownership, and reference counting.</p>
<p>By "copy on copy," I mean that every time the <B>variant_t</B> is initialized or copied, it makes a copy of the underlying value. I will not discuss this solution here, since it is relatively inefficient, but I provide an implementation on the <I>CUJ</I> website (<B>www.cuj.com/code</B>).</p>
<p>The unique ownership idiom mandates that only one instance of a (smart) pointer can point to a given object. <B>std::auto_ptr&lt;&gt;</B> is an example of this kind of smart pointer. Whenever a given instance of <B>auto_ptr&lt;&gt;</B> is copied, it passes a pointer to the owned object to the copy. In this manner, <B>auto_ptr&lt;&gt;</B> hands off ownership to the copy and relinquishes ownership for itself.</p>
<p>As an alternative, reference counting is the idiom for collaborative shared ownership. The reference counting idiom allows any number of smart pointers to own the same object without the risk of containing "dangling" pointers (i.e., pointers to deleted objects). Each smart pointer is guaranteed to contain a valid pointer because the jointly owned object can be destroyed only when all smart pointers to it have relinquished ownership.</p>
<p>There are two major drawbacks to reference counting:</p>
<p>1)  The most straightforward implementations of the idiom require that additional data and operations be placed in the contained object. In this case, any class that will be reference counted must be slightly modified. (However, see <a href="#ref1">[1]</a> for an implementation that does not impose such requirements.)</p>
<p>2)  Circular references might cause unpredictable behavior.</p>
<p>Unique ownership is a flexible and safe approach to providing smart pointer behavior <I>in general</I>; that's why <B>auto_ptr&lt;&gt;</B> uses this scheme. However, this scheme is unsuitable for general collections (including arrays and the standard containers), because general collections make extensive use of copying, possibly leading to situations where unowned objects are referenced. For this reason, I've chosen to implement <B>variant_t</B> as a reference counted object.</p>

<H4><FONT COLOR="#000080">The Final Version</FONT></H4>

<p><a href="list4.htm">Listing 4</a> shows the complete code for the final <B>variant_t</B> type. It is functionally equivalent to <B>variant2_t</B>, except for the reference counting over <B>Impl&lt;&gt;</B>.</p>
<p>This final implementation of <B>variant_t</B> also includes a member template <B>is_type()</B>, with two overloaded versions. You can use <B>is_type</B> to test if <B>variant_t</B> holds a value of of some type <B>T</B>. The first version takes no argument and must be used as in:</p>

<pre>
v.is_type&lt;MyClass&gt;();
</pre>

<p>The second version takes a single argument and must be used as in:</p>

<pre>
v.is_type(MyObject);
</pre>

<p>where <B>MyObject</B> is of the type being tested for. I thought about adding a method of the form:</p>

<pre>
string type_name() const {return typeid(*data).name();}
</pre>

<p>but this method would return strings such as <B>"variant_t::Impl&lt;int&gt;"</B>, revealing implementation details. Extracting <B>"int"</B> from the string above cannot be done portably because the exact string returned by <B>typeid::name</B> is compiler specific. So I just decided to leave this feature out.</p>
<p><a href="list5.htm">Listing 5</a> shows a test program that demonstrates various uses of <B>variant_t</B>.</p>

<H4><FONT COLOR="#000080">An Argument List Example</FONT></H4>

<p>This example shows how to use a <B>variant_t</B> to create variable argument list. I think of an argument list as a collection with the following properties:</p>

<UL><LI>   The list has a fixed size.
<LI>   Elements are be added (or pushed) to the list before any of them are accessed.
<LI>   Elements cannot be inserted in the middle of the list.
<LI>   Elements cannot be removed from the list.
<LI>   Elements can be randomly accessed.</UL>

<p>I consider these properties to closely resemble the functioning of a formal parameter list to function.</p>
<p>With a properly defined <B>variant_t</B> class, designing the <B>ArgumentList</B> class is just a matter of determining its interface and the container it will use. Based on the above properties, I present class <B>ArgumentList</B>, shown in <a href="list6.htm">Listing 6</a>. It is implemented in terms of a <B>vector</B> of <B>variant_t</B>.</p>
<p>Elements can be pushed on the back of the list. Just as you can with a <B>variant_t</B>, you can push elements directly to the list without explicit casting. You can use <B>operator[]</B> or the <B>at</B> method to access individual elements in the list, but you need to know the positions (indexes) of the specific arguments you are accessing. You cannot query the list about which type is at a given position.</p>
<p><a href="list7.htm">Listing 7</a> shows a test program that demonstrates various uses of the <B>ArgumentList</B> class.</p>

<H4><FONT COLOR="#000080">A Possible Extension</FONT></H4>

<p>You will notice that this design of <B>variant_t</B> allows you to retrieve only a copy (or <B>const</B> reference) of the value. If you want to permit the user to modify the values held in a <B>variant_t</B>, you will need to add a copy-on-write mechanism. Beware, however: you must not add a method or operator that provides access to the value via reference or pointer to non-<B>const</B>. That will violate the basic assumption behind any copy-on-write mechanism, which is that only the class itself is allowed to modify the data.</p>

<H4><FONT COLOR="#000080">Conclusion</FONT></H4>

<p>The type <B>variant_t</B> is a special class with the ability to hold values of arbitrary types. <B>variant_t</B> itself is just a reference counted envelope for objects derived from <B>variant_t::ImplBase</B>. <B>ImplBase</B> forms a template-based polymorphic hierarchy, whose leaves are classes generated by the compiler according to the specific type of the value held by <B>variant_t</B>. These leaves are responsible for holding the copies of the values in a copy-safe and type-safe manner.</p>

<H4><FONT COLOR="#000080">Reference</FONT></H4>

<p><a name="ref1">[1]</a>  Vladimir Batov. <a href="../../18.06/batov/batov.htm">"Safe and Economical Reference Counting in C++,"</a> <I>C/C++ Users Journal</I>, June 2000. </p>

<p><i><B>Fernando Cacciola</B> has been programming since 1984 and programming in C++ since 1990. He studied Biochemistry at John. F. Kennedy University. For the past five years, he has been developing computational geometry algorithms.</i></p>

<h4><a href="../../../source/2000/oct00/cacciola.zip">Get Article Source Code</a></h4>

</blockquote></body></html>
