


<HTML>
<HEAD>

<TITLE>February 1991/Skip Lists</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocfeb.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Algorithms</FONT></H2>

<hr><h2 align="center"><font color="#800000">Skip Lists<A name="004D_0029"><A name="004D_0029"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="004D_0000"><A name="004D_0000">Frederick Hegeman</font></h3><hr><blockquote><P>
<P><i><A name="004D_0000"><A name="004D_0000">Frederick Hegeman is an amateur programmer and computer language hobbyist. He can be reached at P.O. Box 2368, Rapid City, SD 57709, telephone (605) 343-7014.</i></P><P>
Maintaining some sort of ordered list must surely be one of the most common problems in programming. An ordered list can be a symbol table, a data dictionary or the distribution of periodic readings from some instrument. Maintaining an ordered list is also one of the most commonly studied, analyzed, refined, and seemingly well understood problems.<P>
That's why running across a completely novel approach is a bit unnerving, like finding a clam with legs. William Pugh's article, "Skip Lists: A Probabilistic Alternative To Balanced Trees," in <I>CACM</I> (June 1990), presented a novel data structure with characteristics intermediate between those of simple linear linked lists and perfectly balanced binary trees. I know a clam with legs when I see one.<P>
<h4><FONT COLOR="#000080"><A name="004D_002A">Skip Lists<A name="004D_002A"></FONT></h4></P>
Skip lists are linked lists with extra pointers that leapfrog, or skip over, intermediate nodes during search procedures. Because the extra pointers are assigned by consulting a random number generator, search times are independent of the ordering of the data input during list construction. <A href="fig1.htm">Figure 1</a>
diagrams a skip list that might be built by the test program with a command line of<P>
<pre>sltest 7 4 2 n x</pre>
If you start searching along the pointer chain marked level one, you are obviously searching along a simple one-way linked list, with a <I>NIL</I> pointer marking the end of the list. Each key along the chain is examined in turn. If the key compares less than the searchkey, you look at the next node. If it compares equal, you have found the desired node. If it compares greater than, the key you are searching for is not in the list. If you reach the <I>NIL</I> pointer, the key is not in the list.<P>
The strategy for searching the skip list is similar. Find the highest level pointer in the list header and follow the pointer chain. If you reach a <I>NIL</I> pointer, decrease the level one step. If the level drops to zero, the key is not in the list; otherwise, continue along the new chain. If you reach a node with a greater key, you've gone too far and have to drop down one more level. If the level drops to zero, the key is not in the list; otherwise, continue along that chain.<P>
Pugh provides a great deal of analysis. I've taken a more informal approach. First, I build a skip list, and then I take a kind of snapshot of the way it looks and behaves.<P>
<h4><FONT COLOR="#000080"><A name="004D_002B">Contents Of <B><I>skiplist.h<A name="004D_002B"></B></I></FONT></h4></P>
<A href="list1.htm">Listing 1</a>,
 <I>skiplist.h</I>, describes the node structure used to build the lists. In order to build the largest possible list, <I>sizeof(NODE)</I> has been kept artificially small, by omitting any data members. If you want to use skip lists in any real application, you will have to declare a member to hold or point to data. The structure is indifferent as to where you put the data member(s), as long as the dynamically sized array <I>pointers</I> is the last member of the structure.<P>
<A href="list1.htm">Listing 1</a>
also defines several important constants, such as the name of the comparison function <I>COMPARE</I>. As written, the functions depend on a <I>COMPARE</I> function that conforms to the <I>strcmp()/memcmp()</I> model (returning negative, zero, or positive). Integers are used as the keys in the test program, both to avoid using memory for storing character strings and to keep comparison times to the minimum.<P>
<h4><FONT COLOR="#000080"><A name="004D_002C">Skip List Routines<A name="004D_002C"></FONT></h4></P>
<A href="list2.htm">Listing 2</a>,
 <I>skiplist.c</I>, contains the actual list maintenance routines. <I>search()</I> works exactly as above, returning a pointer to the desired node if successful, <I>NIL</I> if not. <I>insert()</I> and <I>delete()</I> are only slightly more complicated, needing to preserve the integrity of the pointer chains. In either case, we begin by recording all pointers that pass the indicated key. <I>insert()</I> returns immediately whenever the key is already in the list. <I>delete()</I> records that pointer also. The number of comparisons performed in this step is limited by the maximum node level currently in the list. In the case of <I>delete()</I>, one additional comparison is necessary to determine if the node actually exists. After fetching a new list node or deleting an existing one, the code reconstructs pointer chains in a loop governed by the level of the affected node.<P>
The list always begins with a pseudo-member, or header, with space for <I>MAXLEVEL</I> pointers and provision for recording the current level of the list. <I>newlist()</I> ensures that you have a header node large enough to hold the maximum number of pointers that may be allotted. The call to <I>calloc()</I> will initialize each potential pointer to <I>NIL</I>. The initial level is set to one, which is the minimum. <I>newnode()</I> gets memory for a dynamically sized node and initializes the key member of the structure.<P>
<I>randomlevel()</I> returns an integer from <I>1</I> through <I>MAXLEVEL</I>, based on the numbers chosen for <I>DMAX (MAXLEVEL)</I> and <I>NMAX (PARTITION)</I>. The ratio <I>NMAX/DMAX</I> determines the distribution of node levels through the list. For example, if <I>DMAX</I> is <I>4</I> and <I>NMAX</I> is <I>2</I>, the function <I>slrandom()</I> is called repeatedly with <I>4</I> as its argument, incrementing the local variable <I>newlevel</I> so long as the returned value is <I>0</I> or <I>1</I>. Note that the entire series of consecutive values less than <I>NMAX</I> is consumed. The length of the series determines the level. Given a random number generator with reasonable performance, the distribution will approach the programmer specified ideal where approximately one-half of all nodes will have only one pointer, one-fourth will have two pointers, one-eighth will have three, and only one-sixteenth of all nodes will have the maximum number.<P>
<h4><FONT COLOR="#000080"><A name="004D_002D">Random Number Routines<A name="004D_002D"></FONT></h4></P>
The pseudo-random number routines are in <A href="list3.htm">Listing 3</a>,
 <I>slrandom.c</I>. The functions <I>slrand()</I> and <I>slsrand()</I> and the constant <I>SL_RAND_MAX</I> mimic their ANSI standard library counterparts in <I>&lt;stdlib.h&gt;</I>. They are based on code published by the ANSI committee, using <I>longs</I> rather than <I>unsigned longs</I> to accommodate compilers that do not recognize <I>unsigned long ints</I>. I included them so you could reproduce results across compilers and machines. When you're tired of the test program, use the standard functions. The function <I>slrandom()</I> scales a pseudo-random number returned from the standard function to fit within a specified range. Your compiler libraries may already have something similar. <I>slrandom()</I> provides a good distribution of values within a range &#151; other schemes may not.<P>
<h4><FONT COLOR="#000080"><A name="004D_002E">Test Routines<A name="004D_002E"></FONT></h4></P>
<A href="list4.htm">Listing 4</a>,
 <I>sltest.c,</I> contains the code for a simple test program to build and examine some skip lists. Five parameters are entered on the command line as unsigned integers &#151; the size of the list to build, the value of <I>MAXLEVEL</I>, the value of <I>PARTITION</I>, a seed for the pseudo-random number generator, and a flag to choose between random insertion of keys or an ordered insertion. None of these routines is very interesting on its own. A skip list of the indicated size, or of the largest size allowed by memory, is built as requested. Certain calculations are handled most easily by lookup tables, so the maximum size you can request is limited to 32,767, which will probably exceed the size of any list you can actually build in memory. Once the list is built, each element known to be in the list is searched for in its turn. I use the number of comparisons performed during a search as the measure of the length of the search path. This information is collected, organized, and output to <I>stdout</I> as shown in <A href="fig4.htm">Figure 4</a>.
<P>
<h4><FONT COLOR="#000080"><A name="004D_002F">Skip Lists<A name="004D_002F"></FONT></h4></P>
When you look at <A href="fig4.htm">Figure 4</a>,
 start with the line "pointers per level." No node has more than seven pointers, far fewer than the maximum allowed. About three-fourths of all nodes have only one pointer. The number of nodes with two pointers is approximately one-fourth the number at level one. Likewise with levels three and four. A little calculation shows that 4,050 pointers (not counting 16 pointers in the header) are sufficient to maintain a skip list of 3,000 entries &#151; 1.35 pointers per node. If trees always require two pointers per node, the savings is 1,950 pointers &#151; most probably 3,900 or 7,800 bytes. In general, the average number of pointers per node will be 1<I>/((MAXLEVEL </I>--<I> PARTITION)/MAX-LEVEL)</I>, a constant figure independent of the length of the list. The expected figure here would be 1.33 pointers per node. Unless the list is very short, you can make a reasonably close calculation of memory requirements even though you can't predict the structure of the list.<P>
The line "comparisons per search" is less interesting in isolation than when changing the command line parameters. Note, however, that you would have built a degenerate tree with the same input sequence.<P>
The simple graph is scaled so that the display will fit on a 24-line screen. Here, it shows a nice distribution of results about the mean. Very short lists can have distributors that are bi- or tri-modal, or even discontinuous. The random number routines simply don't cycle long enough to display any "random" behavior. The graph of comparisons over a reasonably long list sometimes starts looking less than bell-shaped. That tells you that one of the command line parameters needs to be adjusted to get better search properties.<P>
I consider a tree to be perfect when it requires the minimum number of comparisons to find each node in the tree. This situation occurs when each level of the tree, except, perhaps, the last level, is full. A degenerate tree is the same as a linked list. The figures for either are easily calculated and presented for comparison.<P>
<h4><FONT COLOR="#000080"><A name="004D_0030">Using <B><I>sltest</I><A name="004D_0030"></B></FONT></h4></P>
Twiddling the knobs can illustrate a number of things. First, varying only the random number seed and the flag parameter should demonstrate that a skip list of any reasonable length is indifferent to the order in which it was built. Once you're satisfied that this it true, you will find that processes go a little faster by always requesting in-order insertion.<P>
Second, the effect of varying the random number seed decreases as the size of the list increases. Building a series of short lists can seem chaotic, but only because the sequence of numbers generated never becomes long enough to become truly random.<P>
Third, varying the size of the list while keeping the other parameters constant might show some seemingly paradoxical behavior &#151; the mean number of comparisons goes down as the size of the list increases. It's only temporary. In general, the mean increases as the size of the list increases, but not always continuously. A strategic node is inserted, randomly of course, and many search paths are favorably affected. The list grows longer, and the mean begins to increase again. Pugh demonstrates that searching a skip list is <I>0(log N)</I> &#151; as in searching a balanced tree. Intuitively, the cost of searching the list increases very slowly relative to the size of the list.<P>
This is the case if <I>MAXLEVEL</I> and <I>PARTITION</I> are in the proper proportions &#151; both to each other and to the size of the list. A little doodling around should demonstrate that a ratio greater than one-half makes no sense at all. One-half works well but uses an average of two pointers per node. Pugh suggests the ratio one-fourth. Empirically, one-fourth seems an ideal balance between performance and memory usage, but why this should be a magic number is beyond my understanding.<P>
Tweaking the values for <I>MAXLEVEL</I> while maintaining the same ratio to <I>PARTITION</I> is less informative than it might appear. It is interesting to watch performance degrade as list size grows and/or <I>MAXLEVEL</I> decreases. Think of the distribution of pointers per node. If the distribution was exactly in our chosen ratio, we could determine the level where the expected number falls to one or below. Take a list of 32,768 elements. If the ratio were one-half, the level would be 15. If the ratio were one-fourth, the level would be nine. As <I>MAXLEVEL</I> starts to drop below expected levels, pointers begin to accumulate at the highest level, and search times increase. You might not have noticed how few nodes have been allotted at levels higher than strictly necessary, although I tried to hint at it previously. I would suggest that maintaining the ratio is more important than saving a few bytes allotted in the header, a few more that might or might not be needlessly allocated in one or two rogue nodes, and a negligible bit of stack space on insertion or deletion. A level of 16 will safely accommodate at least 65,536 nodes &#151; I would think <I>very</I> hard about what kind of memory space that would require &#151; and leaves more room for adjusting <I>PARTITION</I>, where you can preserve serious amounts of memory.<P>
Varying the value of PARTITION over a constant sized MAXLEVEL has another important effect that might not be readily apparent. That ratio, together with list size and random chance, has a bearing on the maximum comparisons per search. It seems obvious that the maximum should appear to increase as the size of the list increases. Changing the random number seed should cause the maximum to vary as different lists are built. Changing the ratio should affect the maximum as more or less leapfrogging gets done at higher levels. It might not be so obvious that as the ratio grows away from one-half, the maximum path length grows increasingly sensitive to changes in the random number seed, or chance. At the limit of one-sixteenth, the variations can be striking.<P>
Chance is the wildcard that I have been deliberately ignoring. There is always the chance that you might build a degenerate structure like one of those in the <A HREF="sidebar1.htm">sidebar</A>. You might as well get the worrying out of your system by using my random number routines and running<P>
<pre>sltest 16 3 1 35 1</pre>
You may never see such a situation again. Why this should be so might be illustrated by going through the previous paragraph in reverse.<P>
As the ratio approaches one-half, the volatility of the maximum search path lessens. If <I>MAXLEVEL</I> was chosen intelligently, or allowed to default, the maximum search path in any list may vary but should remain within a comfortable multiple of the mean. This conforms to Pugh's probabilistic analysis. Instinctively, also, as the mean increases very slowly in comparison to increases in list size, any constant multiple of the mean is also increasing very slowly. At the same time, the observed maximum is becoming relatively less sensitive to the random number seed. It is behaving rather nicely as a multiple of the mean, and as a multiple of what we might guess to be the mean of the means, so to speak, of all the lists of that size that are being built. The result is a crude demonstration that the behavior is becoming more regular as the size of the list increases.<P>
This seems to me one of the most profound properties of skip lists. The probability of worst-case behavior decreases exactly as the consequences of such behavior become more severe. And, inversely, the probability of poor behavior is greatest exactly at that stage when dealing with it means the least. Build a list of 16 elements &#151; the size of the list is limited; the random numbers don't look so random; the algorithms construct a degenerate list; it might take 16 comparisons to find a member of the list. So what? Build a list of 3,000 elements and the chances can be less than one in one hundred million that it might take, not 3,000 comparisons, but as many as 80 or 90 comparisons. It will not be likely to ever take 3,000.<P>
<h4><FONT COLOR="#000080"><A name="004D_0031">Conclusions<A name="004D_0031"></FONT></h4></P>
The common choice for managing ordered lists of any real size has usually been binary trees. Binary trees are sensitive to the randomness of the keys from which they are built, so various schemes for building balanced trees have been developed to keep search times from getting out of hand. Search can be much faster, but insertion and deletion are much slower. How much slower? Baer and Schwab suggest that the number of searches per node should be at least three before you consider AVL trees over random trees. They also found that AVL trees perform better than other balancing algorithms if only insertions and searches are performed.<P>
Now take as input some arbitrary text, break it down into individual words, record each distinct word, keep a count of how often each word appears in the input, then output the list of words in alphabetical order, together with each word's count of appearances. Sound familiar? Think of what could go wrong. Do you really need, or want, to use AVL trees?<P>
Skip lists are simple and straightforward to implement. In-order traversal is an iterative procedure that operates in constant space, unlike recursive procedures applied to tree structures, which can corrupt the stack when the list is large or highly unbalanced. Insertion and deletion procedures are faster than those for AVL trees. Skip lists are space efficient and can yield good search performance using an average of 1.33 pointers per node. Although skip lists have terrible worst-case search performance, no predictable input sequence will create a degenerate structure, and no random sequence of insertions and deletions will create such a degenerate structure with any significant degree of probability. Performance is sensitive to the size of the list, the number of pointers allowed per node, and the fraction used to determine when a node is allotted an extra pointer. These, however, are subject to tuning by the programmer.<P>
I cannot recommend Pugh's approach too highly because skip lists have so many desirable properties.<P>
<h4><FONT COLOR="#000080"><A name="004D_0032">Bibliography<A name="004D_0032"></FONT></h4></P>
Pugh, William. "Skip Lists: A Probabilistic Alternative to Balanced Trees." <I>Communications Of The ACM</I>. XXXIII, 6, June 1990, Pp. 668-676.<P>
Baer, J.-L. and Schwab, B. "A Comparison of Tree-Balancing Algorithms." <I>Communications Of The ACM</I>. XX, 5, May 1977, Pp. 322- 330.<P>
Knuth, Donald E. <I>The Art Of Computer Programming: Vol. I, Fundamental Algorithms</I>. Reading, MA, Addison-Wesley, 1968. Knuth goes deeply into lists and trees, though not, of course, skip lists.<P>

<h4><a href="../../../source/1991/feb91/hegeman.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
