


<HTML>
<HEAD>

<TITLE>August 1990/Pricing A Meal: An Object-Oriented Example In C++</TITLE></HEAD>
<body bgcolor="#ffffff">
<H2><A HREF="../tocaug.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<hr><h2 align="center"><font color="#800000">Pricing A Meal: An Object-Oriented Example In C++<A name="01B9_00F5"><A name="01B9_00F5"></font></h2><P>
<h3 align="center"><font color="#800000"><A name="01B9_0000"><A name="01B9_0000">Charles Havener</font></h3><hr><blockquote><P>
<P><i><A name="01B9_0000"><A name="01B9_0000">Charlie Havener is a senior principal engineer at GenRad Inc., where he specializes in test languages for automatic printed cirucuit board test equipment. He is also a C++ instructor in the Northeastern University State-of-the-Art Program. Charlie has masters degrees in electrical engineering from Cornell University and in computer science from Boston University. He may be contacted at (508) 369-4400 extension 3302.</i></P><P>
The essence of Object-Oriented Programming (OOP) is that it can often provide a model of the problem domain in software. OOP's direct modeling ability simplifies design and provides a solid framework on which to graft the features that end-users inevitably demand for software products. Naturally, implementing object-oriented designs (OODs) is much easier in a language that directly supports the three primary characteristics of OOP: inheritance, dynamic binding, and data abstraction. This article focuses on these characteristics in three stages, each a short listing, while implementing a program to price a meal. Only a little knowledge of C+ + is assumed.<P>
Suppose a cafeteria has just installed a new PC-based cash register system, and the cafeteria manager has chosen us to create the software. Initially, the system needs only to price the meals, but eventually must also provide weight conscious customers with the calories in the meal, and do inventory control. The system must be flexible since the cafeteria often changes prices and sometimes offers global discounts, on all desserts for example.<P>
Suppose also that our team chooses to develop the system in C++. C++ not only supports OOP via the three main characteristics &#151; inheritance, dynamic binding, and data abstraction &#151; but also allows the programmers to overload operators, such as +, and create user-defined data types such as <I>complex</I>, or <I>String</I>. However, object-oriented modeling problems do not require overloaded operators.</FONT></FONT></FONT></FONT><P>
An object-oriented design begins by defining the objects in the problem domain. In the cafeteria domain, an obvious object is the meal itself. The meal is composed of other objects, an <I>Appetizer</I><I>, </I>an<I> </I><I>Entree</I><I>, </I>and a<I> </I><I>Dessert</I>. To facilitate the "structuring" of objects, C++ supports two kinds of inheritance: the <I>isA</I><I>, </I><I>kindOf</I>, or subtype inheritance via the class derivation mechanism; and the <I>partOf</I> or composition inheritance via "layering" objects, one inside another.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<A href="list1.htm">Listing 1</a>
contains our first prototype. (The code should work with any C++ 2.0 compiler, including Zortech C++ for PCs. Copy the Zortech <I>stream.hpp</I> to <I>stream.h</I> and <I>string.h</I> to <I>strings.h</I> to maximize portability of code to other compilers). The objects are represented by classes, which are like C<I> </I><I>structs</I> that can also contain functions. The <I>Meal</I> class contains three pieces of data, <I>a</I>,<I> </I><I>e</I>, and <I>d</I> that represent the three parts of the meal. An integer data member in the <I>Dessert</I> class remembers the particular kind of dessert when the <I>Dessert</I> object is instantiated. The same mechanism is used for <I>Appetizer</I><I> </I>and<I> </I><I>Entree</I>. The naming convention used by most C++ programmers requires that the first letter of a class name be capitalized.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>main()</I> function shows how to create and price the meal.</FONT></FONT><P>
<pre>Meal m(Melon,Fish,Jello);</pre>
declares <I>m</I> to be of type <I>Meal</I>. A member function of the class which has the same name as the class is called a <I>constructor</I>. The compiler invokes the constructor implicitly when the program declares an object of the class type. The <I>Meal </I>constructor is passed the enumerated data types, <I>Melon</I> etc., for the parts of the meal. A strongly-typed language like C++ provides protection against inadvertent, though not devious, coding mistakes. For example, you cannot assign an integer (except zero) to a pointer variable. You cannot invoke <I>Meal x(0,1,2)</I> because the integers are not the same type as the new types we declared, i.e., <I>ENTREE, DESSERT, </I>and<I> APPETIZER</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The constructor for <I>Meal</I> passes the data along to the constructors for the <I>Appetizer</I>, <I>Entree</I>, and <I>Dessert</I> objects via the weird syntax of the member initialization list</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>: a(aval), e(eval), d(dval)</pre>
The actual body of the <I>Meal</I> constructor does nothing { }. The old style <I>printf</I> (which is not type safe) prints the meal cost.</FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>m.cost();</pre>
invokes the cost function on the object <I>m</I>. In other words, <I>m.cost()</I> sends the cost message to object <I>m</I>. In all of the listings, the function bodies that are defined within the class declaration are expanded inline wherever they are used. Inline functions should be small. They are usually used just for private data access.</FONT></FONT></FONT></FONT></FONT></FONT><P>
At this point, a little thought shows that we must implement a <I>case </I>statement in each <I>Class</I> to properly compute the cost. That is, depending on the kind of dessert ordered, the total cost will be different. The <I>cost()</I> function in the <I>Meal</I> class simply invokes the others, i.e., <I>a.cost()+ e.cost() + d.cost()</I> to obtain the total cost. The little red flag should go up! This is not a good OOD. Whenever you would use a <I>case </I>statement in the class implementation, something is probably wrong. As my OOP instructor often said, "narrow and deep, narrow and deep". The class hierarchy is not deep enough. We need more objects, one for each kind of <I>Appetizer</I>, etc.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="01B9_00F6">A Second Implementation<A name="01B9_00F6"></FONT></h4></P>
<A href="list2.htm">Listing 2</a>
shows a much improved implementation. <A href="diag1.htm">Diagram 1</a>
shows the class hierarchy. The <I>Appetizer, Entree</I> and <I>Dessert</I> classes have been made into <I>abstract</I> classes, i.e., ones that are not meant to be instantiated, just inherited from. The <I>isA</I> or <I>kindOf</I> inheritance is shown as a tree with abstract classes as dashed boxes. To avoid arguments about which way the arrows should point on the lines, I just leave them off. The <I>partOf</I> inheritance is effectively portrayed by drawing the boxes for the class objects inside the <I>Meal</I> object box.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
To prevent overcrowding the name space, I add _<I>obj</I> to the publicly derived subclasses so that the enumerated names (<I>Fish</I><I>, </I><I>Jello</I>, etc.) can stay the same. (If the derivation were <I>private</I>, the derived classes would not be considered a <I>kind &#151; Of</I> the base class. Private derivations are used when the goal is merely code reuse.)</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Another major change in the second implementation is that the <I>Meal</I> object contains pointers to the component parts, rather than containing the component parts themselves. In general, using pointers makes the dynamic binding of functions at runtime in C++ work best. Note that you use the component parts in <I>main()</I> the same as before, even though the underlying implementation has been changed radically. The <I>Meal</I> constructor no longer passes data back to embedded object constructors via the <I>member init</I> list. Instead, the <I>new</I> operator creates the constituent part objects. The <I>new</I> operator allocates space for the object, much like C's<I> </I><I>malloc()</I> function. However, <I>new</I> is type safe and automatically invokes the constructor, if any, for a new object. Constructors ensure that new data objects are initialized properly. In this example, the objects don't contain data so nothing requires explicit initialization.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The <I>Meal</I> class also has a destructor now, <I><SUP>~</I></SUP><I>Meal()</I>. The destructor cleans up the space allocated by the <I>new</I> operator when the meal object goes out of scope. In this example <I><SUP>~</I></SUP><I>Meal()</I> is invoked when the program returns from <I>main()</I>.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<h4><FONT COLOR="#000080"><A name="01B9_00F7">Runtime Binding<A name="01B9_00F7"></FONT></h4></P>
An abstract class serves as a central location for common data or functions used by the classes derived from it. If in the abstract base class we declare <I>cost()</I> as virtual, the compiler arranges for runtime binding to occur whenever that function is invoked on a pointer to the base class. For example, if <I>p</I> is a pointer to <I>dessert</I><I>, </I>then<I> </I><I>p-&gt;cost()</I> will access the correct dessert cost function. In other words, if you have</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
<pre>p = new Pie_obj;</pre>
then <I>p-&gt;cost()</I> will be <I>1.50</I>. If the derived class omits the <I>cost()</I> function, then the base class <I>cost()</I> function is used.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Each class with virtual functions actually contains a pointer to a table of function pointers. When we write <I>p-&gt;cost()</I>, the compiler generates something like <I>p-&gt;vtbl[1]</I>. Since every derived class has its own <I>vtbl</I> (virtual table), the correct function is invoked (see <A href="diag2.htm">Diagram 2</a>)
. A function that is virtual in the base class is always virtual, even if the derived classes leave off the <I>virtual</I> keyword.</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
A strongly typed language like C++ generally doesn't let you assign a pointer of one type to a pointer of another type. For public class derivations there is an important exception: you may assign to a variable declared to be a pointer to a base type, a pointer to any type that was publicly derived from that base type.<P>
Unlike many OOP languages, C++ ensures at compile time that if you invoke the <I>cost()</I> function on a dessert object, that function will exist. If you don't redeclare the function in a derived class, then the base class <I>stopper</I> function is invoked. Is there a better way? Yes, pure abstract classes.</FONT></FONT></FONT></FONT><P>
<A href="list3.htm">Listing 3</a>
shows the final prototype. C++ 2.0 allows <I>virtual</I><I> </I>function declarations to be followed by = <I>0</I>;. This somewhat strange syntax means every derived class must implement the function or again define it as pure virtual. The compiler checks the declarations and issues an error message if this is not so. The compiler check ensures that we don't inadvertently leave out the <I>cost()</I> function.</FONT></FONT></FONT></FONT><P>
This third version adds some new features. This week all desserts are 25% off except for <I>Pies.</I> By adding a <I>virtual discount()</I> function to the <I>Dessert</I> abstract class we automatically, via inheritance, apply it to all derived desserts. The <I>Meal</I> class's <I>cost</I> function was changed to multiply the dessert cost (<I>d-&gt;cost()</I>) by the discount (<I>d</I><I>-&gt;discount ()</I>).</FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
Since pies are the only desserts that have no discount, a <I>discount()</I> multiplier of <I>1.0</I> is placed in the <I>Pie_obj</I> class. Every object has a <I>text()</I> function to print information about itself. The <I>Meal::print()</I> member function in <A href="list3.htm">Listing 3</a>
uses the standard stream I/O, which is type safe, instead of <I>print f()</I>. In general, using <I>cout</I>, <I>cin</I> and <I>cerr</I> via the overloaded insertion &lt;&lt; and extraction &gt;&gt; operators is safer than <I>printf()</I> and you can easily overload the operators for new class types you create; <I>printf()</I> only knows about built-in types like <I>double</I> and <I>char </I>*. However, overloading operators is material for another article. <I>[Ed. note: see David Clark's "A Date Object In C++" in the June 1990</I> C Users Journal <I>for an example of operator overloading.]</I></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><P>
The final design is clean and elegant. The class framework models the real world problem domain directly. Adding calorie information would be much like cost. The class hierarchy actually needs to be deepened further to represent different kinds of cakes and pies. Instead of an item's cost residing in the object, the <I>cost()</I> member function could access a database to fetch the most recent price increase. This short example demonstrates just some of what OOP (and C++ in particular) has to offer.</FONT></FONT><P>

<h4><a href="../../../source/1990/aug90/havener.zip">Get Article Source Code</a></h4>

</BLOCKQUOTE>
</BODY>
</HTML>
